% -*- texinfo -*- vim: ft=texinfo noautoindent nocindent nosmartindent
% =========================================================================
%
% @(#) $Id: SPG2.texi,v 0.9.2.12 2006/10/21 10:31:30 brian Exp $
%
% =========================================================================
%
% Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
% Copyright (C) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2006/10/21 10:31:30 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename SPG2.info
@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide
@settitle @value{MANUAL_TITLE}

@dircategory STREAMS
@direntry
* SPG2: (SPG2).			STREAMS Programmer's Guide (Take 2)
@end direntry

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}.

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this guide
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed guide).

@end ignore
Permission is granted to copy and distribute modified versions of this guide
under the conditions for verbatim copying, provided the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this guide into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE STREAMS Programmer's Guide

@ignore
@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@end ignore
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2005  OpenSS7 Corporation <@uref{http://www.openss7.com/}> @*
Copyright @copyright{} 1997-2000  Brian F. G. Bidulock <@email{bidulock@@openss7.org}> @*
All Rights Reserved. @*

@noindent
Published by OpenSS7 Corporation @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
This is texinfo edition @value{PACKAGE_RELEASE} of the @value{MANUAL_TITLE}
documentation, and is consistent with @value{PACKAGE_NAME} @value{PACKAGE_VERSION}.
This guide was developed under the @uref{http://www.openss7.org/, OpenSS7
Project} and was funded in part by
@uref{http://www.openss7.com/, OpenSS7 Corporation}.

@noindent
Permission is granted to make and distribute verbatim copies of this guide
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission is granted to copy and distribute modified versions of this guide
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

@noindent
Permission is granted to copy and distribute translations of this guide into
another language, under the same conditions as for modified versions.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Ed. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Ed.  @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Manpage index
@defcodeindex mp

@c Concatenate indices
@syncodeindex fn cp
@syncodeindex vr cp
@synindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp
@synindex mp cp

@include texi/macros.texi
@include texi/versions.texi

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@unnumbered About This Guide
This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of @cite{The
@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
release @value{PACKAGE_RELEASE} of the @value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Acknowledgements::
* Preface::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* Messages::
* Polling::
* Modules and Drivers::
* Modules::
* Drivers::
* Multiplexing::
* Pipes and FIFOs::
* Terminal Subsystem::
* Synchronization::
* Reference::
* Conformance::
* Portability::
* Data Structures::
* Message Types::
* Utilities::
* Debugging::
* Configuration::
* Administration::
* Examples::
* Copying::
* Glossary::
* Index::

 --- The Detailed Node Listing ---

Acknowledgements

* Sponsors::			Sponsors
* Contributors::		Contributors

Preface
Introduction

* Background::			STREAMS Background
* What is STREAMS?::		STREAMS Description
* Basic Streams Operations::	STREAMS Basic Operations
* Components::			STREAMS Components
* Multiplexing of Streams::	STREAMS Multiplexing
* Benefits of STREAMS::		STREAMS Benefits

Overview

* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems

Mechanism

* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction

Processing

* Procedures::			STREAMS Put and Service Procedures
* Asynchronous Example::	STREAMS Asynchronous Stream Example

Messages

* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers

Polling

* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal

Modules and Drivers

* Environment::			STREAMS Module and Driver Environment
* Input-Output Control::	STREAMS Input and Output Control
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines

Modules

* Module::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines

Drivers

* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* spec File System::		Avoiding Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering

* Driver::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines

Multiplexing

* Multiplexors::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexor Connect and Disconnect Lower Stream
* Multiplexor Construction Example::
				STREAMS Multiplexor Construction Example
* Multiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexor Persistent Links
* Multiplexing Driver Design Guidelines::
				STREAMS Multiplexing Driver Design Guidelines

Pipes and FIFOs

* Pipes and FIFOs::		STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs

Terminal Subsystem

* Terminal Subsystem::		STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem

Synchronization

* MT Configuration::		MP STREAMS MT Configuration
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks

* STREAMS Framework Integrity::
* MP Message Ordering::
* MP-UNSAFE Modules::
* MP Put and Service Procedures::
* MP Timeout and Buffer Callbacks::
* MP Open and Close Procedures::
* MP Module Unloading::
* MP Locking::
* MP Asynchronous Callbacks::
* Stream Integrity::

Reference

* Files::			STREAMS Files
* Modules::			STREAMS Modules
* Drivers::			STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions

Conformance

* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX Compatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
* LiS Compatibility::		LiS 2.18.4 Compatibility

Portability

* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* LiS Portability::		Porting from LiS 2.18.4

Data Structures

* Stream Structures::
* Queue Structures::
* Message Structures::
* Input Output Control Structures::
* Link Structures::
* Options Structures::

Message Types

* Message Type::
* Ordinary Messages::
* High Priority Messages::

Utilities

Debugging

Configuration

Administration

* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System

Examples

* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example

Copying

* GNU General Public License::		GPL
* GNU Free Documentation License::	FDL

Glossary

Index

@end menu

@c --------------------------------------------------------------------------
@c --------------------------------------------------------------------------

@node Acknowledgements
@unnumbered Acknowledgements
@cindex credits

@include texi/funding.texi

@unnumberedsec Authors

The authors of the @cite{OpenSS7 @value{PACKAGE_TITLE}} package include:

@multitable @columnfractions .05 .95
@item @tab @minus{} @email{bidulock@@openss7.org, Brian Bidulock}
@end multitable

@unnumberedsec Maintainer

The maintainer of the @cite{OpenSS7 @value{PACKAGE_TITLE}} package is:

@multitable @columnfractions .05 .95
@item @tab @minus{} @email{bidulock@@openss7.org, Brian Bidulock}
@end multitable

Please send bug reports to @email{@value{PACKAGE_BUGREPORT}} using the @file{send-pr} script
included in the package, only after reading the @file{BUGS} file in the release, or @xref{Problem
Reports}.

@node Preface
@unnumbered Preface

@section Document Information
@cindex document information

@subsection Notice
@cindex document notice
@cindex licensing

This package is released and distributed under the @cite{GNU General Public License} (@pxref{GNU
General Public License}).  Please note, however, that there are different licensing terms for the
manual pages and some of the documentation (derived from OpenGroup@footnote{Formerly X/Open and UNIX
International.} publications and other sources).  Consult the permission notices contained in the
documentation for more information.

This document, is released under the @cite{GNU Free Documentation License} (@pxref{GNU Free
Documentation License}) with all sections invariant.

@subsection Abstract
@cindex document abstract

This document provides a @cite{@value{MANUAL_TYPE}} for @cite{@value{PACKAGE_TITLE}}.

@subsection Objective
@cindex document objective

The objective of this document is to provide a guide for the @dfn{STREAMS} programmer when
developing @dfn{STREAMS} modules, drivers and application programs for @cite{@value{PACKAGE_TITLE}}.

This guide provides information to developers on the use of the @dfn{STREAMS} mechanism at user and
kernel levels.

@dfn{STREAMS} was incorporated in UNIX System V Release 3 to augment the character input/output
(I/O) mechanism and to support development of communication services.

@dfn{STREAMS} provides developers with integral functions, a set of utility routines, and facilities
that expedite software design and implementation.

@subsection Intent
@cindex document intent

The intent of this document is to act as an introductory guide to the @dfn{STREAMS} programmer.  It
is intended to be read alone and is not intended to replace or supplement the
@cite{@value{PACKAGE_TITLE}} manual pages.  For a reference for writing code, the manual pages
(see @manref{STREAMS(9)}) provide a better reference to the programmer.
Although this describes the features of the @cite{@value{PACKAGE_TITLE}} package,
@uref{http://www.openss7.com/,OpenSS7 Corporation} is under no obligation to provide any software,
system or feature listed herein.

@subsection Audience
@cindex document audience

This document is intended for a highly technical audience.  The reader should already be familiar
with @cite{Linux} kernel programming, the @cite{Linux} file system, character devices, driver input
and output, interrupts, software interrupt handling, scheduling, process contexts, multiprocessor
locks, etc.

The guide is intended for network and systems programmers, who use the @dfn{STREAMS} mechanism at
user and kernel levels for @cite{Linux} and @cite{UNIX} system communication services.

Readers of the guide are expected to possess prior knowledge of the @cite{Linux} and @cite{UNIX}
system, programming, networking, and data communication.

@subsection Revisions
@cindex document revisions

Take care that you are working with a current version of this document: you will not be notified of
updates.  To ensure that you are working with a current version, contact the
@uref{mailto:bidulock@@openss7.org,Author}, or check @uref{http://www.openss7.org/,The OpenSS7
Project} website for a current version.

A current version of this document is normally distributed with the @cite{@value{PACKAGE_TITLE}}
package.

@subsubsection Version Control

@smallexample

$Log: SPG2.texi,v $
Revision 0.9.2.12  2006/10/21 10:31:30  brian
- updated LiS release number

Revision 0.9.2.11  2006/09/18 01:06:55  brian
- updated manuals and release texi docs

Revision 0.9.2.10  2006/08/28 10:46:57  brian
- correction

Revision 0.9.2.9  2006/08/27 12:26:58  brian
- finalizing auto release files

Revision 0.9.2.8  2006/08/26 09:18:15  brian
- better release file generation

Revision 0.9.2.7  2006/08/22 12:36:49  brian
- udpates to documentation, tweaks to Stream head

Revision 0.9.2.6  2005/11/20 22:20:18  brian
- still working up documentation

Revision 0.9.2.5  2005/11/17 10:52:33  brian
- working up take 2

Revision 0.9.2.4  2005/11/17 01:59:26  brian
- more workup of take 2

Revision 0.9.2.3  2005/11/16 10:30:39  brian
- still working up take 2

Revision 0.9.2.2  2005/11/16 03:20:03  brian
- working up take 2

Revision 0.9.2.1  2005/11/15 12:05:09  brian
- second run at SPG

Revision 0.9.2.45  2005/11/14 23:27:06  brian
- more workup

Revision 0.9.2.44  2005/11/14 11:19:49  brian
- working up manual

Revision 0.9.2.43  2005/11/14 04:43:55  brian
- updating manual

Revision 0.9.2.42  2005/11/13 23:04:01  brian
- starting cleanup of SPG

Revision 0.9.2.41  2005/10/07 09:34:00  brian
- more testing and corrections

Revision 0.9.2.40  2005/09/26 10:56:41  brian
- doc updates

Revision 0.9.2.39  2005/09/20 12:53:07  brian
- more doc updates, corrected QFULL handling

Revision 0.9.2.38  2005/09/18 07:38:35  brian
- more doc updates

Revision 0.9.2.37  2005/09/17 11:52:08  brian
- documentation updates

Revision 0.9.2.36  2005/09/17 08:20:57  brian
- more doc updates

Revision 0.9.2.35  2005/09/17 00:46:12  brian
- document updates

Revision 0.9.2.34  2005/09/16 03:06:02  brian
- added glossary

Revision 0.9.2.33  2005/09/15 13:02:52  brian
- added new graphics and updates

@end smallexample

@subsubsection ISO 9000 Compliance

Only the @TeX{}, texinfo, or roff source for this document is controlled.  An opaque (printed,
postscript or portable document format) version of this document is an @strong{UNCONTROLLED
VERSION}.

@subsection Disclaimer
@cindex document disclaimer

@noindent
@cite{OpenSS7 Corporation} disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights.  In
no event shall @cite{OpenSS7 Corporation} be liable for any direct, indirect, special or
consequential damages or any damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising out of or in connection with
any use of this document or the performance or implementation of the contents thereof.

@noindent
@cite{OpenSS7 Corporation} reserves the right to revise this software and documentation for any
reason, including but not limited to, conformity with standards promulgated by various agencies,
utilization of advances in the state of the technical arts, or the reflection of changes in the
design of any techniques, or procedures embodied, described, or referred to herein.  @cite{OpenSS7
Corporation} is under no obligation to provide any feature listed herein.

@subsubsection U.S. Government Restricted Rights

If you are licensing this Software on behalf of the U.S. Government ("Government"), the following
provisions apply to you.  If the Software is supplied by the Department of Defense ("DoD"), it is
classified as "Commercial Computer Software" under paragraph 252.227-7014 of the DoD Supplement to
the Federal Acquisition Regulations ("DFARS") (or any successor regulations) and the Government is
acquiring only the license rights granted herein (the license rights customarily provided to
non-Government users).  If the Software is supplied to any unit or agency of the Government other
than DoD, it is classified as "Restricted Computer Software" and the Government's rights in the
Software are defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR") (or any
successor regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to
the FAR (or any successor regulations).

@section Organization
@cindex organization

This guide has several chapters, each discussing a unique topic.  @ref{Introduction},
@ref{Overview}, @ref{Mechanism} and @ref{Processing} contain introductory information and can be
ignored by those already familiar with @dfn{STREAMS} concepts and facilities.

This document is organized as follows:

@ifnottex
@menu
  Acknowledgements::
  Preface::
* Introduction::
* Overview::
* Mechanism::
* Processing::
* Messages::
* Polling::
* Modules and Drivers::
* Modules::
* Drivers::
* Multiplexing::
* Pipes and FIFOs::
* Terminal Subsystem::
* Synchronization::
* Reference::
* Conformance::
* Portability::
* Data Structures::
* Message Types::
* Utilities::
* Debugging::
* Configuration::
* Administration::
* Examples::
* Copying::
* Glossary::
* Index::
@end menu
@end ifnottex
@iftex
@table @emph
@item @ref{Preface}
Describes the organization and purpose of the guide.  It also defines an intended audience and an
expected background of the users of the guide.
@item @ref{Introduction}
An introduction to @dfn{STREAMS} and the @cite{@value{PACKAGE_TITLE}} package.
@dfn{STREAMS} Fundamentals.  Presents an overview and the benefits of @dfn{STREAMS}.
@item @ref{Overview}
A brief overview of @dfn{STREAMS}.
@item @ref{Mechanism}
A description of the @dfn{STREAMS} framework.  Describes the basic operations for constructing,
using, and dismantling Streams.  These operations are performed using
@manpage{open(2)},
@manpage{close(2)},
@manpage{read(2)},
@manpage{write(2)}, and
@manpage{ioctl(2)}.
@item @ref{Processing}
Processing and procedures within the @dfn{STREAMS} framework.  Gives an overview of the
@dfn{STREAMS} put and service routines.
@item @ref{Messages}
@dfn{STREAMS} Messages, organization, types, priority, queueing, and general handling.  Discusses
@dfn{STREAMS} messages, their structure, linkage, queueing, and interfacing with other @dfn{STREAMS}
components.
@item @ref{Polling}
Polling of @dfn{STREAMS} file descriptors and other asynchronous application techniques.  Describes
how @dfn{STREAMS} allows user processes to monitor, control, and poll Streams to allow an effective
utilization of system resources.
@item @ref{Modules and Drivers}
An overview of @dfn{STREAMS} modules, drivers and multiplexing drivers.  Describes the @dfn{STREAMS}
module and driver environment, input-output controls, routines, declarations, flush handling, driver-kernel
interface, and also provides general design guidelines for modules and drivers.
@item @ref{Modules}
Details of @dfn{STREAMS} modules, including examples.  Provides information on module construction
and function.
@item @ref{Drivers}
Details of @dfn{STREAMS} drivers, including examples.  Discusses @dfn{STREAMS} drivers, elements of
driver flow control, flush handling, cloning, and processing.
@item @ref{Multiplexing}
Details of @dfn{STREAMS} multiplexing drivers, including examples.  Describes the @dfn{STREAMS}
multiplexing facility.
@item @ref{Pipes and FIFOs}
Details of @dfn{STREAMS}-based Pipes and FIFOs.  Provides information on creating, writing, reading,
and closing of @dfn{STREAMS}-based pipes and FIFOs and unique connections.
@item @ref{Terminal Subsystem}
Details of @dfn{STREAMS}-based Terminals and Pseudo-terminals.  Discusses @dfn{STREAMS}-based
terminal and and pseudo-terminal subsystems.
@item @ref{Synchronization}
Discusses @dfn{STREAMS} in a symmetrical multi-processor environment.
@item @ref{Reference}
Reference section.
@item @ref{Conformance}
Conformance of the @cite{@value{PACKAGE_TITLE}} package to other @cite{UNIX} implementations of
@dfn{STREAMS}.
@item @ref{Portability}
Portability of @dfn{STREAMS} modules and drivers written for other @cite{UNIX} implementations of
@dfn{STREAMS} and how they can most easily be ported into @cite{@value{PACKAGE_TITLE}}; but, for
more details on this topic, see the @cite{@value{PACKAGE_TITLE} - @dfn{STREAMS} Portability Guide}.
@item @ref{Data Structures}
Primary @dfn{STREAMS} Data Sturctures, descriptions of their members, flags, constants and use.
Summarizes data structures commonly used by @dfn{STREAMS} modules and drivers.
@item @ref{Message Types}
@dfn{STREAMS} Message Type reference, with descriptions of each message type.  Describes
@dfn{STREAMS} messages and their use.
@item @ref{Utilities}
@dfn{STREAMS} kernel-level utility functions for the module or driver writer.  Describes
@dfn{STREAMS} utility routines and their usage.
@item @ref{Debugging}
@dfn{STREAMS} debugging facilities and their use.
Provides debugging aids for developers.
@item @ref{Configuration}
@dfn{STREAMS} configuration, the @dfn{STREAMS Administrative Driver} and the autopush facility.
Describes how modules and drivers are configured into the @dfn{Linux} and @dfn{UNIX} system, tunable
parameters, and the autopush facility.
@item @ref{Administration}
Administration of the @dfn{STREAMS} subsystem.
@item @ref{Examples}
Collected examples.
@c @item @ref{Device Numbers}
@c Specifics on device numbering and the @dfn{Shadow Special Filesystem}.
@c @item @ref{Multi-Threading}
@c Syncrhonization for Symmetrical Multiprocessor (SMP) architectures.
@end table
@end iftex


@subsubsection Conventions Used

This guide uses @cite{texinfo} typographical conventions.

Throughout this guide, the word @dfn{STREAMS} will refer to the mechanism and the word @dfn{Stream}
will refer to the path between a user application and a driver.  In connection with
@dfn{STREAMS}-based pipes @dfn{Stream} refers to the data transfer path in the kernel between the
kernel and one or more user processes.

Examples are given to highlight the most important and common capabilities of @dfn{STREAMS}.  They
are not exhaustive and, for simplicity, often reference fictional drivers and modules.  Some
examples are also present in the @cite{@value{PACKAGE_TITLE}} package, both for testing and example
purposes.

System calls, @dfn{STREAMS} utility routines, header files, and data structures are given using
@command{texinfo} @file{filename} typesetting, when they are mentioned in the text.

Variable names, pointers, and parameters are given using @command{texinfo} @var{variable}
typesetting conventions.  Routine, field, and structure names unique to the examples are also given
using @command{texinfo} @var{variable} typesetting conventions when they are mentioned in the text.

Declarations and short examples are in @command{texinfo} @samp{sample} typesetting.

@command{texinfo} displays are used to show program source code.
@ignore
Screens are used to simulate what a user will see on a video display screen or to show program
source code.
@end ignore

Data structure formats are also shown in @command{texinfo} displays.

@ignore
[Boxcaut.gif]

The caution sign is used to show possible harm or damage to a system, an application, a process, a
piece of hardware, etc.

[Boxnote.gif]

The note sign is used to emphasize points of interest, to present parenthetical information, and to
cite references to other documents and commands.
@end ignore

@subsection Other Documentation

Although the @cite{@value{MANUAL_TYPE}} for @cite{@value{PACKAGE_TITLE}} provides a guide to aid in
developing @dfn{STREAMS} applications, readers are encouraged to consult the
@cite{@value{PACKAGE_TITLE}} manual pages.  For a reference for writing code, the manual pages (see
@manref{STREAMS(9)}) provide a better reference to the programmer.
For detailed information on
system calls used by @dfn{STREAMS} (section 2), and
@dfn{STREAMS} utilities from section 8.
@dfn{STREAMS} specific input output control (ioctl) calls are provided in @manref{streamio(7)}.
@dfn{STREAMS} modules and drivers are described on section 7.
@dfn{STREAMS} is also described to some extent in the @cite{System V Interface Definition, Third Edition}.

@subsection UNIX Edition

This system conforms to @cite{UNIX System V Release 4.2} for @cite{Linux}.


@subsection Related Manuals

@cite{@value{PACKAGE_TITLE} Installation and Reference Manual}

@subsection Copyright

@copyright{} 1997-2005  OpenSS7 Corporation.  All Rights Reserved.

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@c ============================================================================
@node Introduction
@chapter Introduction
@menu
* Background::			STREAMS Background
* What is STREAMS?::		STREAMS Description
* Basic Streams Operations::	STREAMS Basic Operations
* Components::			STREAMS Components
* Multiplexing of Streams::	STREAMS Multiplexing
* Benefits of STREAMS::		STREAMS Benefits
@end menu

@c ----------------------------------------------------------------------------
@node Background
@section Background

@dfn{STREAMS} is a facility first presented in a paper by Dennis M. Ritchie in
1984,@footnote{@cite{A Stream Input-Output System, AT&T Bell Laboratories Technical Journal 63, No.
8 Part 2 (October, 1984), pp.  1897-1910.}} originally implemented on 4.1BSD and later part of
@cite{Bell Laboratories Eighth Edition UNIX}, incorporated into
@cite{UNIX System V Release 3.0}
@cindex UNIX System V Release 3.0
and enhanced in
@cite{UNIX System V Release 4}
@cindex UNIX System V Release 4
and
@cite{UNIX System V Release 4.2}.
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used in @cite{SVR4} for terminal input/output, pseudo-terminals, pipes, named
pipes (FIFOs), interprocess communication and networking.  Since its release in @cite{System V
Release 4}, @dfn{STREAMS} has been implemented across a wide range of @cite{UNIX}, @cite{UNIX}-like,
and @cite{UNIX}-based systems, making its implementation and use an @i{ipso facto} standard.

@dfn{STREAMS} is a facility that allows for a reconfigurable full duplex communications path,
@dfn{Stream}, between a user process and a driver in the kernel.  Kernel protocol modules can be
pushed onto and popped from the @dfn{Stream} between the user process and driver.  The @dfn{Stream}
can be reconfigured in this way by a user process.  The user process, neighbouring protocol modules
and the driver communicate with each other using a message passing scheme closely related to
@dfn{MOM (Message Oriented Middleware)}.  This permits a loose coupling between protocol modules,
drivers and user processes, allowing a third-party and loadable kernel module approach to be taken
toward the provisioning of protocol modules on platforms supporting @dfn{STREAMS}.

On @cite{UNIX System V Relase 4.2},
@cindex UNIX System V Release 4.2
@dfn{STREAMS} was used for terminal input-output, pipes, FIFOs (named pipes), and network
communications.  Modern @cite{UNIX}, @cite{UNIX}-like and @cite{UNIX}-based systems providing
@dfn{STREAMS} normally support some degree of network communications using @dfn{STREAMS}; however,
many do not support @dfn{STREAMS}-based pipe and FIFOs@footnote{For example, AIX.} or terminal
input-output.@footnote{For example, HP-UX}.

@cite{Linux} has not traditionally implemented a @dfn{STREAMS} subsystem.  It is not clear why,
however, perceived ideological differences between @dfn{STREAMS} and @dfn{Sockets} and also the
@dfn{XTI/TLI} and @dfn{Sockets} interfaces to @dfn{Internet Protocol} services are usually at the
centre of the debate.  For additional details on the debate,
@pxref{Top, , About This Manual, STREAMS_FAQ, @value{PACKAGE_TITLE} Frequently Asked Questions}.

@cite{Linux} pipes and FIFOs are @cite{SVR3}-style, and the @cite{Linux} terminal subsystem is
@cite{BSD}-like.  @cite{UNIX 98 Pseudo-Terminals}, @file{ptys}, have a specialized implementation
that does not follow the @dfn{STREAMS} framework and, therefore, do not support the pushing or
popping of @dfn{STREAMS} modules.  Internal networking implementation under @cite{Linux} follows the
@cite{BSD} approach with a native (system call) @dfn{Sockets} interface only.

@cite{RedHat} at one time provided an @cite{Intel Binary Compatibility Suite (iBCS)} module for
@cite{Linux} that supported the @dfn{XTI/TLI} interface and @file{socksys} system calls and
input-output controls, but not the @dfn{STREAMS} framework (and therefore cannot push or pop
modules).

A @dfn{STREAMS} package for @cite{Linux} was written and eventually distributed and maintained by
@uref{http://www.gcom.com/,GCOM Inc.}   This is the @cite{Linux STREAMS (LiS)} package.  This
package had some failings and was repeatedly rejected for mainline adoption, which prompted the
development of @cite{@value{PACKAGE_TITLE}}.  @cite{Linux STREAM (LiS)} is no longer supported (it
does not have a maintainer).

@cite{@value{PACKAGE_TITLE}} is the current open source implementation of @cite{STREAMS} for
@cite{Linux} and provides all of the capabilities of @cite{UNIX System V Release 4.2 MP}, plus
support for mainstream @cite{UNIX} implementations based on @cite{UNIX System V Release 4.2 MP}
through compatibility modules.

Although it is intended primarily as documentation for the @cite{@value{PACKAGE_TITLE}}
implementation of @cite{STREAMS}, much of the @cite{@value{MANUAL_TITLE} - @value{MANUAL_TYPE}} is
generally applicable to all @cite{STREAMS} implementations.

@c ----------------------------------------------------------------------------
@node What is STREAMS?
@section What is STREAMS?

@dfn{STREAMS} is a flexible, message oriented framework for the development of @cite{GNU/Linux}
communications facilities and protocols.  It provide a set of system calls, kernel resources, and
kernel utilities within a framework that is applicable to a wide range of communications facilities
including terminal subsystems, interprocess communication, and networking.  It provides standard
interfaces for communication input and output within the kernel, common facilities for device
drivers, and a standard interface@footnote{@cite{XPG 4.2/XNS 4.2}, @cite{XPG 5/XNS 5},
@cite{POSIX/SUSv2 XSI Extensions} and @cite{POSIX/SUSv3 XSR Extensions}.} between the kernel and the
rest of the @cite{GNU/Linux} system.

The standard interface and mechanism enable modular, portable development and easy integration of
high performance network services and their components.  Because it is a message passing
architecture, @dfn{STREAMS} does not impose a specific network architecture (as does the @dfn{BSD
Sockets} kernel architecture.  The @dfn{STREAMS} user interface is uses the familiar @cite{UNIX}
character special file input and output mechanisms
@manpage{open(2)},
@manpage{read(2)},
@manpage{write(2)},
@manpage{ioctl(2)},
@manpage{close(2)}; and provides additional system calls,
@manpage{poll(2)},
@manpage{getmsg(2)},
@manpage{getpmsg(2s)},
@manpage{putmsg(2)},
@manpage{putpmsg(2s)}, to assist in message passing between user-level applications and
kernel-resident modules.  Also, @dfn{STREAMS} defines a standard set of input-output controls
(@manpage{ioctl(2)}) for manipulation and configuration of @dfn{STREAMS} by a user-space
application.

As a message passing architecture, the @dfn{STREAMS} interface between the user process and kernel
resident modules can be treated either as fully synchronous exchanges or can be treated
asynchronously for maximum performance.

@subsection Characteristics

@dfn{STREAMS} has the the following characteristics that are not exhibited (or are exhibited in
different ways) by other kernel level subsystems:

@itemize @bullet

@item @dfn{STREAMS} is based on the character device special file which is one of the most flexible
special files available in the @cite{GNU/Linux} system.

@item @dfn{STREAMS} is a message passing architecture, similar to @cite{Message Oriented Middleware
(MOM)} that achieves a high degree of functional decoupling between modules.  This allows the
service interface between modules to correspond to the natural interfaces found or described between
protocol layers in protocol stack without requiring the implementation to conform to any given
model.

As a contrasting example, the @dfn{BSD Sockets} implementation, internal to the kernel, provides
strict socket-protocol, protocol-protocol and protocol-device function call interfaces.

@item By using @command{put} and @command{service} procedures for each module, and scheduling
@command{service} procedures, @dfn{STREAMS} combines background scheduling of coroutine service
procedures with message queueing and flow control to provide a mechanism robust for both event driven
subsystem and soft real-time subsystem.

In contrast, @dfn{BSD Sockets}, internal to the kernel, requires the sending component across the
socket-protocol, protocol-protocol, or protocol-device to handle flow control.  @dfn{STREAMS}
integrates flow control within the @dfn{STREAMS} framework.

@item @dfn{STREAMS} permits user runtime configuration of kernel data structure and modules to
provide for a wide range of novel configurations and capabilities in a live @cite{GNU/Linux} system.
The @dfn{BSD Sockets} protocol framework does not provide this capability.

@item @dfn{STREAMS} is as applicable to termination input-output and interprocess communication as
it is to networking protocols.

@dfn{BSD Sockets} is only applicable to a restricted range of networking protocols.

@item @dfn{STREAMS} provides mechanisms (the pushing and popping of modules, and the linking and
unlinking of @dfn{Streams} under multiplexing drivers) for complex configuration of protocol stacks;
the precise topology being typically under the control of user space daemon processes.

No other kernel protocol stack framework provides this flexible capability.  Under @dfn{BSD Sockets}
it is necessary to define specialized socket types to perform these configuration functions and not
in any standard way.

@end itemize

@subsection Components

@dfn{STREAMS} provides a full-duplex communications path for data and control information between a
kernel-resident driver and a user space process (see @figref{101}).

Within the kernel, a @dfn{Stream} is comprised of the following basic components:

@itemize @bullet
@item A @dfn{Stream head} that is inside the @cite{Linux} kernel, but which sits closest to the user
space process.  The @dfn{Stream head} is responsible for communicating with user space processes and
that presents the standard @dfn{STREAMS} I/O interface to user space processes and applications.
@item A @dfn{Stream end} or @dfn{Driver} that is inside the @cite{Linux} kernel, but which sits
farthest from the user space process.  A @dfn{Stream end} or @dfn{Driver} that interfaces to
hardware or other mechanisms within the @cite{Linux} kernel.
@item  A @dfn{Module} that sits between the @dfn{Stream head} and @dfn{Stream end}.  The
@dfn{Module} provides modular and flexible processing of control and data information passed up and
down the @dfn{Stream}.
@end itemize

@figuresized{SPG_fig01,101,Simple Stream,4in}

@subsubsection Stream head

A @dfn{Stream head} is the component of a @dfn{Stream} that is closest to the user space process.
The @dfn{Stream head} is responsible for directly communicating with the user space process in user
context and for converting system calls to actions performed on the @dfn{Stream head} or the
conversion of control and data information passed between the user space process and the
@dfn{Stream} in response to system calls.  All @dfn{Streams} are associate with a @dfn{Stream head}.
In the case of @dfn{STREAMS}-based pipes, the @dfn{Stream} may be associated with two
(interconnected) @dfn{Stream heads}.  Because the @dfn{Stream head} follows the same structure as a
@dfn{Module}, it can be viewed as a specialized module.

With @dfn{STREAMS}, pipes and FIFOs are also @dfn{STREAMS}-based.@footnote{Unlike the native
@cite{Linux} pipes and FIFOs that use the older @cite{UNIX System V Release 3} or @dfn{BSD}
approaches to these facilities.}  @dfn{STREAMS}-based pipes and FIFOs do not have a @dfn{Driver}
component.

@dfn{STREAMS}-based pipes place another @dfn{Stream head} in the position of the @dfn{Driver}.  That
is, a @dfn{STREAMS}-based pipe is a full-duplex communications path between two otherwise
independent @dfn{Stream heads}.  @dfn{Modules} may be placed between the @dfn{Stream heads} in the
same fashion as they can exist between a @dfn{Stream head} and a @dfn{Driver} in a normal
@dfn{Stream}.
A @dfn{STREAMS}-based pipe is illustrated in @figref{102}.

@figuresized{SPG_fig02,102,@dfn{STREAMS}-based Pipe,4in}

@dfn{STREAMS}-based FIFOs consist of a single @dfn{Stream head} that has its downstream path
connected to its upstream path where the @dfn{Driver} would be located.  @dfn{Modules} can be pushed
under this single @dfn{Stream Head}.
A @dfn{STREAMS}-based FIFO is illustrated in @figref{109}.

@figuresized{SPG_fig07,109,@dfn{STREAMS}-based @dfn{FIFO} (named pipe),4in}

For more information on @dfn{STREAMS}-based pipes and FIFOs, @pxref{Pipes and FIFOs}.

@subsubsection Module

A @dfn{STREAMS} @dfn{Module} is an optional processing element that is placed between the
@dfn{Stream head} and the @dfn{Stream end}.  The @dfn{Module} can perform processing functions on
the data and control information flowing in either direction on the @dfn{Stream}.  It can
communicate with neighbouring modules, the @dfn{Stream head} or a @dfn{Driver} using @dfn{STREAMS}
messages.  Each @dfn{Module} is self-contained in the sense that it does not directly invoke
functions provided by, nor access datastructures of, neighbouring modules, but rather communicates
data, status and control information using messages.  This functional isolation provides a loose
coupling that permits flexible recombination and reuse of @dfn{Modules}.  A @dfn{Module} follows the
same framework as the @dfn{Stream head} and @dfn{Driver}, has all of the same entry points and can
use all of the same @dfn{STREAMS} and kernel utilities to perform its function.

@dfn{Modules} can be inserted between a @dfn{Stream head} and @dfn{Stream end} (or another
@dfn{Stream head} in the case of a @dfn{STREAMS}-based pipe or FIFO).  The insertion and deletion of
@dfn{Modules} from a @dfn{Stream} is referred to as @dfn{pushing} and @dfn{popping} a @dfn{Module}
due to the fact that that modules are inserted or removed from just beneath the @dfn{Stream head} in
a push-down stack fashion.  Pushing and popping of modules can be performed using standard
@manpage{ioctl(2)} calls and can be performed by user space applications without any need for kernel
programming, assembly, or relinking.

For more information on @dfn{STREAMS Modules}, @pxref{Module Component}.

@subsubsection Driver

All @dfn{Streams}, with the sole exception of @dfn{STREAMS}-based pipe and FIFOs, contain a
@dfn{Driver} a the @dfn{Stream end}.  A @dfn{STREAMS} @dfn{Driver} can either be a @dfn{device
driver} that directly or indirectly controls hardware, or can be a @dfn{pseudo-device driver} that
interface with other software subsystems within the kernel.  @dfn{STREAMS} drivers normally perform
little processing within the @dfn{STREAMS} framework and typically only provide conversion between
@dfn{STREAMS} messages and hardware or software events (e.g. interrupts) and conversion between
@dfn{STREAMS} framework data structures and device related data structures.

For more information on @dfn{STREAMS Drivers}, @pxref{Driver Component}.

@subsubsection Queues

Each component in a @dfn{Stream} (@dfn{Stream head}, @dfn{Module}, @dfn{Driver}) has an associated
pair of queues.  One @dfn{queue} in each pair is responsible for managing the message flow in the
@dfn{downstream} direction from @dfn{Stream head} to @dfn{Stream end}; the other for the
@dfn{upstream} direction.  The @dfn{downstream} @dfn{queue} is called the @dfn{write-side}
@dfn{queue} in the @dfn{queue} pair; the @dfn{upstream} @dfn{queue}, the @dfn{read-side}
@dfn{queue}.

Each @dfn{queue} in the pair provides pointers necessary for organizing the temporary storage and
management of @dfn{STREAMS} messages on the @dfn{queue}, as well as function pointers to procedures
to be invoked when messages are placed on the @dfn{queue} or need to be taken off of the
@dfn{queue}, and pointers to auxillary and module-private data structures.  The @dfn{read-side}
@dfn{queue} also contains function pointers to procedures used to @command{open} and @command{close}
the @dfn{Stream head}, @dfn{Module} or @dfn{Driver} instance associated with the @dfn{queue} pair.
@dfn{Queue} pairs are dynamically allocated when an instance of the @dfn{driver}, @dfn{module} or
@dfn{Stream head} is created and deallocated when the instance is destroyed.

For more information on @dfn{STREAMS Queues}, @pxref{Queue Component}.

@subsubsection Messages

@dfn{STREAMS} is a message passing architecture.  @dfn{STREAMS} messages can contain control
information or data, or both.  Messages that contain control information are intended to illicit a
response from a neighbouring module, @dfn{Stream head} or @dfn{Stream end}.  The control information
typically uses the message type to invoke a general function and the fields in the control part of
the messge as arguments to a call to the function.  The data portion of a message represents
information that is (from the perspective of the @dfn{STREAMS} framework) unstructured.  Only
cooperating modules, the @dfn{Stream head} or @dfn{Stream end} need know or agree upon the format of
control or data messages.

A @dfn{STREAMS} message consists of one or more blocks.  Each block is a 3-tuple of a message block,
a data block and a data buffer.  Each data block has a message type, and the data buffer contains
the control information or data associated with each block in the message.  @dfn{STREAMS} messages
typically consist of one control-type block (@constant{M_PROTO}) and zero or more data-type blocks
(@constant{M_DATA}), or just a data-type block.

A set of specialized and standard message types define messages that can be sent by a @dfn{module}
or @dfn{driver} to control the @dfn{Stream head}.  A set of specialized and standard message types
define messages that can be sent by the @dfn{Stream head} to control a @dfn{module} or @dfn{driver},
normaly in response to a standard input-output control for the @dfn{Stream}.

@dfn{STREAMS} messages are passed between a module, @dfn{Stream head} or @dfn{Driver} using a
@command{put} procedure associated with the queue in the queue pair for the direction in which
the message is being passed.  Messages passed towards the @dfn{Stream head} are passed in the
@dfn{upstream} direction, and those towards the @dfn{Stream end}, in the @dfn{downstream} direction.
The @dfn{read-side} queue in the queue pair associated with the module instance to which a message
is passed is responsible for processing or queueing @dfn{upstream} messages; the @dfn{write-side}
queue, for processing @dfn{downstream} messages.

@dfn{STREAMS} messages are generated by the @dfn{Stream head} and passed @dfn{downstream} in
response to
@manpage{write(2)},
@manpage{putmsg(2)}, and
@manpage{putpmsg(2s)} system calls; they are
also consumed by the @dfn{Stream head} and converted to information passed to user space in response
to
@manpage{read(2)},
@manpage{getmsg(2)}, and
@manpage{getpmsg(2s)} system calls.

@dfn{STREAMS} messages are also generated by the @dfn{Driver} and passed @dfn{upstream} to
ultimately be read by the @dfn{Stream head}; they are also consumed when written by the @dfn{Stream
head} and ultimately arrive at the @dfn{Driver}.

For more information on @dfn{STREAMS Messages}, @pxref{Message Component}.

@c ----------------------------------------------------------------------------
@node Basic Streams Operations
@section Basic Streams Operations

This section provides a basic description of the user level interface and system calls that are used
to manipulate a @dfn{Stream}.

A @dfn{Stream} is similar, and indeed is implemented, as a character device special file and is
associated with a character device within the @cite{GNU/Linux} system.  Each @dfn{STREAMS} character
device special file (character device node, see @manref{mknod(2)}) has associated with it a major
and minor device number.  In the usual situation, a @dfn{Stream} is associated with each minor
character device node in a similar fashion to a minor device instance for regular character device
drivers.

@dfn{STREAMS} devices are opened, as are character device drivers, with the
@manpage{open(2)} system
call.@footnote{An exception is @dfn{STREAMS}-based pipes, that are opened with the
@manpage{pipe(2)}
system call.}  Opening a minor device node accesses a separate @dfn{Stream} instance between the
user level process and the @dfn{STREAMS} device driver.  As with normal character devices, the file
descriptor returned from the
@manpage{open(2)} call, can be used to further access the @dfn{Stream}.

Opening a minor device node for the first time results in the creation of a new instance of a
@dfn{Stream} between the @dfn{Stream head} and the @dfn{driver}.  Subsequent opens of the same minor
device node does not result in the creation of a new @dfn{Stream}, but provides another file
descriptor that can be used to access the same @dfn{Stream} instance.  Only the first open of a
minor device node will result in the creation of a new @dfn{Stream} instance.

Once it has opened a @dfn{Stream}, the user level process can send and receive data to and from the
@dfn{Stream} with the usual
@manpage{read(2)} and
@manpage{write(2)} system calls that are
compatible with the existing character device interpretations of these system calls.  @dfn{STREAMS}
also provides the additional system calls,
@manpage{getmsg(2)} and
@manpage{getpmsg(2s)}, to read
control and data information from the @dfn{Stream}, as well as
@manpage{putmsg(2)} and
@manpage{putpmsg(2s)} to write control and data information.  These additional system calls provide a
richer interface to the @dfn{Stream} than is provided by the traditional
@manpage{read(2)} and
@manpage{write(2)} calls.

A @dfn{Stream} is closed using the
@manpage{close(2)} system call (or a call that closes file
descriptors such as
@manpage{exit(2)}).  If a number of processes have the @dfn{Stream} open, only
the last
@manpage{close(2)} of a @dfn{Stream} will result in the destruction of the @dfn{Stream}
instance.

@subsection Basic Operations Example
An basic example of opening, reading from and writing to a @dfn{Stream} driver is shown in
@ref{Listing 1.1}.

@cartouche
@iftex
@float Listing,Listing 1.1
@end iftex
@smallexample
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
main()
@{
        char buf[1024]
        int fd, count;

        if ((fd = open("/dev/streams/comm/1", O_RDWR)) < 0) @{
                perror("open failed");
                exit(1);
        @}

        while ((count = read(fd, buf, 1024)) > 0) @{
                if (write(fd, buf, count) != count) @{
                        perror("write failed");
                        break;
                @}
        @}
        exit(0);
@}
@end smallexample
@iftex
@caption{@emph{Basic Operations}}
@end float
@end iftex
@ifnottex
@anchor{Listing 1.1}
@center @emph{Listing 1.1.@:  Basic Operations}
@end ifnottex
@end cartouche

The example in @ref{Listing 1.1} is for a communications device that provide a communications
channel for data transfer between two processes or hosts.   Data written to the device is
communicated over the channel to the remote process or host.  Data read from the device was written
by the remote process or host.

In the example in @ref{Listing 1.1}, a simple @dfn{Stream} is opened using the
@manpage{open(2)}
call.  @file{/dev/streams/comm/1} is the path to the character minor device node in the file system.
When the device is opened, the character device node is recognized as a @dfn{STREAMS} special file,
and the @dfn{STREAMS} subsystem creates a @dfn{Stream} (if one does not already exist for the minor
device node) an associates it with the minor device node.  @figref{103} illustrates the state of the
@dfn{Stream} at the point after the
@manpage{open(2)} call returns.

@figuresized{SPG_fig03,103,Stream to Communications Driver,3in}

The @command{while} loop in @ref{Listing 1.1} simply reads data from the device using the
@manpage{read(2)} system call and then writes the data back to the device using the
@manpage{write(2)} system call.

When a @dfn{Stream} is opened for blocking operation (i.e., neither @constant{O_NONBLOCK} nor
@constant{O_NDLEAY} were set),
@manpage{read(2)} will block until some data arrives.  The
@manpage{read(2)} call might, however, return less that the requested @samp{1024} bytes.  When data
is read, the routine simply writes the data back to the device.

@dfn{STREAMS} implements flow control both in the upstream and downstream directions.  Flow control
limits the amount of normal data that can be queued awaiting processing within the @dfn{Stream}.
High and low water marks for flow control are set on a queue pair basis.  Flow control is local and
specific to a given @dfn{Stream}.  High priority control messages are not subject to @dfn{STREAMS}
flow control.

When a @dfn{Stream} is opened for blocking operation (i.e., neither @constant{O_NONBLOCK} nor
@constant{O_NDLEAY} were set),
@manpage{write(2)} will block while waiting for flow control to
subside.
@manpage{write(2)} will always block awaiting the availability of @dfn{STREAMS} message
blocks to satisfy the call, regardless of the setting of @constant{O_NONBLOCK} or
@constant{O_NDELAY}.

In the example in @ref{Listing 1.1}, the
@manpage{exit(2)} system call is used to exit the program;
however, the
@manpage{exit(2)} results in the equivalent of a call to
@manpage{close(2)} for all
open file descriptors and the @dfn{Stream} is flushed and destroyed before the program is finally
exited.

@c ----------------------------------------------------------------------------
@node Components
@section Components
@menu
* Queue Component::
* Message Component::
* Module Component::
* Driver Component::
* Stream Head Component::
@end menu

This section briefly describes each @dfn{STREAMS} component and how they interact within a
@dfn{Stream}.  Chapters later in this manual describe the components and their interaction in
greater detail.

@c ----------------------------------------
@node Queue Component
@subsection Queues

This subsection provides a brief overview of message @dfn{queues} and their associated procedures.

A @dfn{queue} provides an interface between an instance of a @dfn{STREAMS} driver, module or
@dfn{Stream head}, and the other modules and drivers that make up a @dfn{Stream} for a direction of
message flow (i.e., @dfn{upstream} or @dfn{downstream}).  When an instance of a @dfn{STREAMS}
driver, module or @dfn{Stream head} is associated with a @dfn{Stream}, a pair of queues are
allocated to represent the driver, module or @dfn{Stream head} within the @dfn{Stream}.  Queue data
structures are always allocated in pairs.  The first queue in the pair is the @dfn{read-side} or
@dfn{upstream} queue in the pair; the second queue, the @dfn{write-side} or @dfn{downstream} queue.

Queues are described in greater detail in @ref{Queues and Priority}.

@subsubsection Queue Procedures

This subsection provides a brief overview of @dfn{queue} procedures.

The @dfn{STREAMS} module, driver or @dfn{Stream head} provides five procedures that are associated
with each queue in a queue pair: the @command{put}, @command{service}, @command{open},
@command{close} and @command{admin} procedures.  Normally the @command{open} and @command{close}
procedures (and possibly the optional @command{admin} procedure) are only associated with the
@dfn{read-side} of the queue pair.

Each queue in the pair has a pointer to a @command{put} procedure.  The @command{put} procedure is
used by @dfn{STREAMS} to present a new message to an upstream or downstream queue.  At the ends of
the @dfn{Stream}, the @dfn{Stream head} write-side, or @dfn{Stream end} read-side, queue
@command{put} procedure is normally invoked using the @manref{put(9)} utility.  A module within the
@dfn{Stream} typically has its @command{put} procedure invoked by an adjacent module, driver or
@dfn{Stream head} that uses the @manref{putnext(9)} utility from its own @command{put} or
@command{service} procedure to pass message to adjacent modules.  The @command{put} procedure of the
queue receiving the message is invoked.  The @command{put} procedure decides whether to process the
message immediately, queue the message on the message queue for later processing by the queue's
@command{service} procedure, or whether to pass the message to a subsequent queue using
@manpage{putnext(9)}.

Each queue in the pair has a pointer to an optional @command{service} procedure.  The purpose of a
@command{service} procedure process messages that were deferred by the @command{put} procedure by
being placed on the message queue with utilities such as @manref{putq(9)}.  A @command{service}
procedure typically loops through taking messages off of the queue and processing them.  The
procedure normally terminates the loop when it can not process the current message (in which case it
places the message back on the queue with @manref{putbq(9)}), or when there is no longer any
messages left on the queue to process.  A @command{service} procedure is optional in the sense that
if the @command{put} procedure never places any messages on the queue, a @command{service} procedure
is unnecessary.

Each queue in the pair also has a pointer to a @command{open} and @command{close} procedure;
however, the @var{qi_qopen} and @var{qi_qclose} pointers are only significant in the @dfn{read-side}
queue of the queue pair.

The queue @command{open} procedure for a driver is called each time that a driver (or @dfn{Stream
head}) is opened, including the first open that creates a @dfn{Stream} and upon each successive open
of the @dfn{Stream}.  The queue @command{open} procedure for a module is called when the module is
first pushed onto (inserted into) a @dfn{Stream}, and for each successive open of a @dfn{Stream}
upon which the module has already been pushed (inserted).

The queue @command{close} procedure for a module is called whenever the module is popped (removed)
from a @dfn{Stream}.  Modules are automatically popped from a @dfn{Stream} on the last close of the
@dfn{Stream}.  The queue @command{close} procedure for a driver is called with the last close of the
@dfn{Stream} or when the last reference to the @dfn{Stream} is relinquished.  If the @dfn{Stream} is
linked under a multiplexing driver (@ioctlref{I_LINK}), or has been named with @manref{fattach(3)},
then the @dfn{Stream} will not be dismantled on the last close and the @command{close} procedure not
called until the @dfn{Stream} is eventually unlinked (@ioctlref{I_UNLINK}) or detached
(@manref{fdetach(3)}).

Procedures are described in greater detail in @ref{Procedures}.

@c ----------------------------------------
@node Message Component
@subsection Messages

This subsection provides a brief overview of @dfn{STREAMS messages}.

In fitting with the concept of function decoupling, all control and data information is passed
between @dfn{STREAMS} modules, drivers and the @dfn{Stream head} using messages.  Utilities are
provided to the @dfn{STREAMS} module writer for passing messages using queue and message pointers.
@dfn{STREAMS} messages consist of a 3-tuple of a message block structure (@mantype{msgb(9)}), a data
block structure (@mantype{datab(9)}) and a data buffer.  The message block structure is used to
provide an instance of a reference to a data block and pointers into the data buffer.  The data
block structure is used to provide information about the data buffer, such as message type, separate
from the data contained in the buffer.  Messages are normally passed between @dfn{STREAMS} modules,
drivers and the @dfn{Stream head} using utilities that invoke the target module's @command{put}
procedure, such as @manref{put(9)}, @manref{putnext(9)}, @manref{qreply(9)}.  Messages travel along
a @dfn{Stream} with successive invocations of each driver, module and @dfn{Stream head}'s
@command{put} procedure.

Messages are described in greater detail in @ref{Messages Overview} and @ref{Messages}.

@subsubsection Message Types

This subsection provides a brief overview of @dfn{STREAMS message types}.

Each data block (@mantype{datab(9)}) is assigned a message type.  The message type discriminates the
use of the message by drivers, modules and the @dfn{Stream head}.  Most of the message types may be
assigned by a module or driver when it generates a message, and the message type can be modified as
a part of message processing.  The @dfn{Stream head} uses a wider set of message types to perform
its function of converting the functional interface to the user process into the messaging interface
used by @dfn{STREAMS} modules and drivers.

Most of the defined message types (@pxref{Message Type Overview}, and @ref{Message Types}) are
solely for use within the @dfn{STREAMS} framework.  A more limited set of message types
(@msg{M_PROTO}, @msg{M_PCPROTO} and @msg{M_DATA}) can be used to pass control and data information
to and from the user process via the @dfn{Stream head}.  These message type can be generated and
consumed using the @manref{read(2)}, @manref{write(2)}, @manref{getmsg(2)}, @manref{getpmsg(2s)},
@manref{putmsg(2)}, @manref{putpmsg(2s)} system calls and some @manref{streamio(7)} @dfn{STREAMS}
@manpage{ioctl(2)}.

Message types are described in detail in @ref{Message Type Overview} and @ref{Message Types}.

@subsubsection Message Linkage

Messages blocks of differing types can be linked together into composite messages as illustrated in
@figref{104}.

@figuresized{SPG_fig05,104,A Message,4in}

Messages, once allocated, or when removed from a queue, exist standalone (i.e., they are not
attached to any queue).  Messages normally exist standalone when they have been first allocated by
an interrupt service routine, or by the @dfn{Stream head}.  They are placed into the @dfn{Stream} by
the driver or @dfn{Stream head} at the @dfn{Stream end} by calling @manref{put(9)}.  After being
inserted into a @dfn{Stream}, message normally only exist standalone in a given queue's
@command{put} or @command{service} procedures.  A queue's @command{put} or @command{service}
procedure normally do one of the following:
@itemize @bullet
@item pass the message along to an adjacent queue with @manref{putnext(9)} or @manref{qreply(9)};
@item process and consume the message by deallocating it with @manref{freemsg(9)};
@item place the message on the queue from the @command{put} procedure with @manref{putq(9)} or from
the @command{service} procedure using @manref{putbq(9)}.
@end itemize
Once placed on a queue, a message exists only on that queue and all other references to the message
are dropped.

Only one reference to a message block (@manpage{msgb(9)}) exists within the @dfn{STREAMS} framework.
Additional references to the same data block (@manpage{datab(9)}) and data buffer can be established
by duplicating the messages block,
@manpage{msgb(9)} (without duplicating either the data
block,(@manpage{datab(9)}, or data buffer).  The @dfn{STREAMS} @manref{dupb(9)} and
@manref{dupmsg(9)} utilities can be used to duplicate message blocks.  Also, the entire 3-tuple of
message block, data block and data buffer can be copied using the @manref{copyb(9)} and
@manref{copymsg(9)} @dfn{STREAMS} utilities.

When a message is first allocated, it is the responsibility of the allocating procedure to either
pass the message to a queue @command{put} procedure, place the message on its own message queue, or
free the message.  When a message is removed from a message queue, the reference then becomes the
responsibility of the procedure that removed it from the queue.  Under special circumstances, it
might be necessary to temporarily store a reference to a standalone message in a module private
data structure, however, this is usually not necessary.

When a message has been placed on a queue, it is linked into the list of messages already on the
queue.  Messages that exist on a message queue await processing by the queue's @command{service}
procedure.  Essentially, queue @command{put} procedures are a way of performing immediate message
processing, and placing a message on a message queue for later processing by the queue's
@command{service} procedure is a way of deferring message processing until a later time: that is,
until @dfn{STREAMS} schedules the @command{service} procedure for execution.

Two messages linked together on a message queue is illustrated in @figref{105}.  In the figure,
@samp{Message 2} is linked to @samp{Message 1}.

@figuresized{SPG_fig06,105,Messages on a Message Queue,5in}

As illustrated in @figref{105}, when a message exists on a message queue, the first message block in
the message (which can possibly contain a chain of message blocks) is linked into a double linked
list used by the message queue to order and track messages.  The queue structure, @mantype{queue(9)},
contains the head and tail pointers for the linked list of messages that reside on the queue.  Some
of the fields in the first message block (such as the linked list pointers) are significant only in
the first message block of the message and applies to all the message blocks in the message (such as
message band).

Message linkage is described in detail in @ref{Message Structure}.

@subsubsection Message Queueing Priority

This subsection provides a brief overview of @dfn{message queueing priority}.

@dfn{STREAMS} message queues provide the ability to process messages of differing priority.  There
are three classes of message priority (in order of increasing priority):
@enumerate
@item Normal messages.
@item Priority messages.
@item High-priority messages.
@end enumerate

Normal messages are queued in priority band @samp{0}.  Priority messages are queued in bands greater
than zero (@samp{1} through @samp{255} inclusive).  Messages of a higher ordinal band number are of
greater priority.  For example, a priority message for band @samp{23} is queued ahead of messages
for band @samp{22}.  Normal and priority messages are subject to flow control within a @dfn{Stream},
and a queued according to priority.

High priority messages are assigned a priority band of @samp{0}; however, their message type
distinguishes them as high priority messages and they are queued ahead of all other messages.  (The
priority band for high priority messages is ignored and always set to @samp{0} whenever a high
priority message type is queued.) High priority messages are given special treatment within the
@dfn{Stream} and are not subjected to flow control; however, only one high priority message can be
outstanding for a given transaction or operation within a @dfn{Stream}.  The @dfn{Stream head} will
discard high priority messages that arrive before a previous high priority message has been acted
upon.

Because queue @command{service} procedures process messages in the order in which they appear in the
queue, messages that are queued toward the head of the queue yield a higher scheduling priority than
those toward the tail.  High priority messages are queue first, followed by priority messages of
descending band numbers, finally followed by normal (band @samp{0}) messages.

@dfn{STREAMS} provides independent flow control parameters for ordinary messages.  Normal message flow
control parameters are contained in the queue structure itself (@mantype{queue(9)}); priority
parameters, in the auxiliary queue band structure (@mantype{qband(9)}).  A set of flow control
parameters exists for each band (from @samp{0} to @samp{255}).

As a high priority message is defined by message type, some message types are available in
high-priority/ordinary pairs (e.g., @msg{M_PCPROTO}/@msg{M_PROTO}) that perform the same function
but which have differing priority.

Queueing priority is described in greater detail in @ref{Queues and Priority}.

@c ----------------------------------------
@node Module Component
@subsection Modules

This subsection provides a brief overview of @dfn{STREAMS modules}.

@dfn{Modules} are components of message processing that exist as a unit within a @dfn{Stream}
beneath the @dfn{Stream head}.  @dfn{Modules} are optional components and zero or more (up to a
predefined limit) instances of a module can exist within a given @dfn{Stream}.  Instances of a
@dfn{module} have a unique queue pair associated with them that permit the instance to be linked
among the other queue pairs in a @dfn{Stream}.

@figref{48} illustrates and instance each of two modules (@samp{A} and @samp{B}) that are linked
within the same @dfn{Stream}.  Each module instance consists of a queue pair (@samp{Ad/Au} and
@samp{Bd/Bu} in the figure).  Messages flow from the driver to the @dfn{Stream head} through the
@dfn{upstream} queues in each queue pair (@samp{Au} and then @samp{Bu} in the figure); and from
@dfn{Stream head} to driver through @dfn{downstream} queues (@samp{Bd} and then @samp{Ad}).

The @dfn{module} provides unique message processing procedures (@command{put} and optionally
@command{service} procedures) for each queue in the queue pair.  One set of @command{put} and
@command{service} procedures handles @dfn{upstream} messages; the other set, @dfn{downstream}
messages.  Each procedure is independent of the others.  @dfn{STREAMS} handles the passing of
messages but any other information that is to be passed between procedures must be performed
explicitly by the procedures themselves.  Each queue provides a module private pointer that can be
used by procedures for maintaining state information or passing other information between
procedures.

@figuresized{SPG_fig48,48,A @dfn{Stream} in More Detail,5in}

Each procedure can pass messages directly to the adjacent queue in either direction of message flow.
This is normally performed with the @dfn{STREAMS} @manref{putnext(9)} utility.  For example, in
@figref{48}, procedures associated with queue @samp{Bd} can pass messages to queue @samp{Ad};
@samp{Bu} to @samp{Au}.

Also, procedures can easily locate the other queue in a queue pair and pass messages along the
opposite direction of flow.  This is normally performed using the @dfn{STREAMS} @manref{qreply(9)}
utility.  For example, in @figref{48}, procedures associated with queue @samp{Ad} can easily locate
queue @samp{Au} and pass messages to @samp{Bu} using
@manpage{qreply(9)}.

Each queue in a module is associated with messages, processing procedures, and module private data.
Typically, each queue in the module has a distinct set of message, processing procedures and module
private data.

@table @dfn

@item Messages

Messages can be inserted into, and removed from, the linked list message queue associated with each
queue in the queue pair as they pass through the module.  For example, in @figref{48}, @samp{Message
Ad} exists on the @samp{Ad} queue; @samp{Message Bu}, on the @samp{Bu} queue.

@item Processing Procedures

Each queue in a @dfn{module} queue pair requires that a @command{put} procedure be defined for the
queue.  Upstream or downstream modules, drivers or the @dfn{Stream head} invoke a @command{put}
procedure of the module when they pass messages to the module along the @dfn{Stream}.

Each queue may optionally provide a @command{service} procedure that will be invoked when messages
are placed on the queue for later processing by the @command{service} procedure.  A
@command{service} procedure is never required if the module @command{put} procedure never enqueues a
message to either queue in the queue pair.

Either procedure in either queue in the pair can pass messages upstream or downstream and may alter
information within the module private data associated with either queue in the pair.

@item Data

Module processing procedures can make use of a pointer in each queue structure that is reserved for
use by the module writer to locate module private data structures.  These data structures are
typically attached to each queue from the module's  @command{open} procedure, and detached from then
module's @command{close} procedure.  Module private data is useful for maintaining state information
associated with the instance of the module and for passing information between procedures.

@end table

Modules are described in greater detail in @ref{Modules}.

@c ----------------------------------------
@node Driver Component
@subsection Drivers

This subsection provides a brief overview of @dfn{STREAMS drivers}.

The @dfn{Device} component of the @dfn{Stream} is an inital part of the regular @dfn{Stream}
(positioned just below the @dfn{Stream head}).  Most @dfn{Streams} start out life as a @dfn{Stream
head} connected to a @dfn{driver}.  The driver is positioned within the @dfn{Stream} at the
@dfn{Stream end}.  Note that not all @dfn{Streams} require the presence of a driver: a
@dfn{STREAMS}-based pipe or FIFO @dfn{Stream} do not contain a driver component.

A @dfn{driver} instance represented by a queue pair within the @dfn{Stream}, just as for modules.
Also, each queue in the queue pair has a message queue, processing procedures, and private data
associated with it in the same way as for @dfn{STREAMS} modules.  There are three differences that
distinguish drivers from modules:

@enumerate

@item Drivers are responsible for generating and consuming messages at the @dfn{Stream end}.

Drivers convert @dfn{STREAMS} messages into appropriate software or hardware actions, events and
data transfer.  As a result, drivers that are associated with a hardware device normally contain an
interrupt service procedure that handles the external device specific actions, events and data
transfer.  Messages are typically consumed at the @dfn{Stream end} in the driver's downstream
@command{put} or @command{service} procedure and action take or data transferred to the hardware
device.  Messages are typically generated at the @dfn{Stream end} in the driver's interrupt service
procedure, and inserted upstream using the @manref{put(9)} @dfn{STREAMS} utility.

Software drivers (so-called @dfn{pseudo-device drivers}) are similar to a hardware device driver
with the exception that they typically do not contain an interrupt service routine.  Pseudo-device
drivers are still responsible for consuming messages at the @dfn{Stream end} and converting them into
actions and data output (external to @dfn{STREAMS}), as well as generating messages in response to
events and data input (external to @dfn{STREAMS}).

In contrast, @dfn{modules} are intended to operate solely within the @dfn{STREAMS} framework.

@item  Because a driver sits at a @dfn{Stream} end and can support multiplexing, a driver can have
multiple @dfn{Streams} connected to it, either upstream (fan-in) or downstream (fan-out)
(@pxref{Multiplexing of Streams}).

In contrast, an instance of a @dfn{module} is only connected within a single @dfn{Stream} and does
not support multiplexing at the module queue pair.

@item An instance of a driver (queue pair) is created and destroyed using the
@manpage{open(2)} and
@manpage{close(2)} system calls.

In contrast, an instance of a @dfn{module} (queue pair) is created and destroyed using the
@streamio{I_PUSH} and @streamio{I_POP} @dfn{STREAMS}
@manpage{ioctl(2)} commands.

@end enumerate

Aside from these differences, the @dfn{STREAMS} @dfn{driver} is similar in most respects to the
@dfn{STREAMS} @dfn{module}.  Both drivers and modules can pass signals, error codes, return values,
and other information to processes in adjacent queue pairs using @dfn{STREAMS} messages of various
message types provided for that purpose.

Drivers are described in greater detail in @ref{Drivers}.

@c ----------------------------------------
@node Stream Head Component
@subsection Stream Head

This subsection provide a brief overview of @dfn{Stream heads}.

The @dfn{Stream head} is the first component of a @dfn{Stream} that is allocated when a @dfn{Stream}
is created.  All @dfn{Streams} have an associated @dfn{Stream head}.

In the case of @dfn{STREAMS}-based pipes, two @dfn{Stream heads} are associated with each other.
@dfn{STREAMS}-based FIFOs have one @dfn{Stream head} but no @dfn{Stream end} or @dfn{Driver}.
For all other @dfn{Streams}, as illustrated in @figref{48}, there exists a @dfn{Stream head} and a
@dfn{Stream end} or @dfn{Driver}.

The @dfn{Stream head} has a queue pair associated with them, just as does any other @dfn{STREAMS}
module or driver.  Also, just as any other module, the @dfn{Stream head} provides the processing
procedures and private data for processing of messages passed to queues in the pair.

The differences is that the processing procedures are provided by the @dfn{GNU/Linux} system rather
than being written by the @dfn{module} or @dfn{driver} writer.  These system provided processing
procedures perform the necessary functions to convert generate to and consume messages from the
@dfn{Stream} in response to system calls invoked by a user process.  Also, a set of specialized
behaviours are provided and a set of specialized message types that may be exchanged with modules
and drivers in the @dfn{Stream} to provide the standard interface expected by the user application.

@dfn{Stream heads} are described in greater detail in @ref{Mechanism}, @ref{Polling}, @ref{Pipes and
FIFOs}, and @ref{Terminal Subsystem}.

@c ----------------------------------------------------------------------------
@node Multiplexing of Streams
@section Multiplexing

This subsection provides a brief overview of @dfn{Stream Multiplexing}.

Basic @dfn{Streams} that can be created with the
@manpage{open(2)} or
@manpage{pipe(2)} system calls
are linear arrangements from @dfn{Stream head} to @dfn{Driver} or @dfn{Stream head} to @dfn{Stream
haed}.  Althoug these linear arrangements satisfy the needs of a large class of @dfn{STREAMS}
applications, there exits a class of application that are more naturally represented by
multiplexing: that is, an arrangements where one or more upper @dfn{Streams} feed into one or more
lower @dfn{Streams}.  Network protocol stacks (a significant application are for @dfn{STREAMS}) are
typically more easily represented by multiplexed arrangements.

A @dfn{fan-in} multiplexing arrangement is one in which multiple upper @dfn{Streams} feed into a
single lower @dfn{Stream} in a @dfn{many-to-one} relationship as illustrated in @figref{49}.

@figuresized{SPG_fig49,49,Many-to-one Multiplexor,1.5in}

A @dfn{fan-out} multiplexing arrangement is one in which a single upper @dfn{Stream} feeds into
multiple lower @dfn{Streams} in a @dfn{one-to-many} relationship as illustrated in @figref{50}.
(This is the more typically arrangement for communications protocol stacks.)

@figuresized{SPG_fig50,50,One-to-many Multiplexor,1.5in}

A @dfn{fan-in/fan-out} multiplexing arrangement is one in which multiple upper @dfn{Streams} feed
into mutliple lower @dfn{Streams} in a @dfn{many-to-many} relationship as illustrated in
@figref{51}.

@figuresized{SPG_fig51,51,Many-to-many Multiplexor,1.5in}

To support these arrangements, @dfn{STREAMS} provide a mechanism that can be used to assemble
multiplexing arrangements in a flexible way.  An, otherwise normal, @dfn{STREAMS} pseudo-device
driver can be specified to be a multiplexing driver.

Conceptually, a multiplexing driver can perform @dfn{upper multiplexing} between multiple
@dfn{Streams} on its @dfn{upper} side connecting the user process and the multiplexing driver, and
@dfn{lower multiplexing} between multiple @dfn{Streams} on its @dfn{lower} side connecting the
multiplexing driver and the device driver.

As with normal @dfn{STREAMS} drivers, @dfn{multiplexing drivers} can have multiple @dfn{Streams}
created on its @dfn{upper} side using the
@manpage{open(2)} system call.  Unlike regular
@dfn{STREAMS} drivers, however, @dfn{multiplexing drivers} have the additional capability that other
@dfn{Streams} can be linked to the @dfn{lower} side of the driver.  The linkage is performed by
issuing specialized
@manpage{streamio(7)} commands to to the driver that are recognized by
multiplexing drivers (@streamio{I_LINK}, @streamio{I_PLINK}, @streamio{I_UNLINK},
@streamio{I_PUNLINK}).

Any @dfn{Stream} can be linked under a multiplexing driver (provided that it is not already linked
under another multiplexing driver).  This includes an upper @dfn{Stream} of a multiplexing driver.
In this fashion, complex trees of multiplexing drivers and linear @dfn{Stream} segments containing
pushed @dfn{modules} can be assembled.  Using these linkage commands, complex arrangements can be
assembled, manipulated and dismantled by a user or daemon process to suit application needs.

The @dfn{fan-in} arrangement of @figref{49} performs @dfn{upper multiplexing}; the @dfn{fan-out}
arrangement of @figref{50}, @dfn{lower multiplexing}; and the @dfn{fan-in/fan-out} arrangement of
@figref{51}, both @dfn{upper} and @dfn{lower multiplexing}.

@subsection Fan-Out Multiplexers

@figref{47} illustrates an example, closely related to the @dfn{fan-out} arrangement of @figref{50},
where the @cite{Internet Protocol (IP)} within a networking stack is implemented as a multiplexing
driver and independent @dfn{Streams} to three specific device drivers are linked beneath the
@cite{IP} multiplexing driver.

@figuresized{SPG_fig47,47,Internet Multiplexing @dfn{Stream},5in}

The @cite{IP} multiplexing driver is capable of routing messages to the lower @dfn{Streams} on the
basis of address and the subnet membership of each device driver.  Messages received from the lower
@dfn{Streams} can be discriminated an sent to the appropriate user process upper @dfn{Stream} (e.g.
on the basis of, say, protocol Id).  Each lower @dfn{Stream}, @samp{Module 1}, @samp{Module 2},
@samp{Driver 3}, presents the same service interface to the @cite{IP} multiplexing driver,
regardless of the specific hardware or lower level communications protocol supported by the driver.
For example, the lower @dfn{Streams} could all support the @cite{Data Link Provider Interface
(DLPI)}.

As depicted in @figref{47}, the @cite{IP} multiplexing driver could have additional multiplexing
drivers or modules above it.  Also, @samp{Driver 1}, @samp{Driver 2} or @samp{Driver 3} could
themselves be multiplexing drivers (or replaced by multiplexing drivers).  In general, multiplexing
drivers are independent in the sense that it is not necessary that a given multiplexing driver be
aware of other multiplexing drivers upstream of its upper @dfn{Stream}, nor downstream of its lower
@dfn{Streams}.

@subsection Fan-In Multiplexers

@figref{52} illustrates an example, more closely related to the @dfn{fan-in} arrangement of
@figref{49}, where an @cite{X.25 Packet Layer Protocol} multiplexing driver is used to switch
messages between upper @dfn{Streams} supporting @cite{Permanent Virtual Circuits (PVCs)} or
@cite{Switch Virtual Circuits (SVCs)} and (possibly) a single lower @dfn{Stream}.

@figuresized{SPG_fig52,52,Multiplexing @dfn{Stream},4in}

The ability to multiplex upper @dfn{Streams} to a driver is a characteristic supported by all
@dfn{STREAMS} drivers: not just @dfn{multiplexing drivers}.  Each
@manpage{open(2)} to a minor
device node results in another uppper @dfn{Stream} that can be associated with the device driver.
What the @dfn{multiplexing driver} permits over the normal @dfn{STREAMS} driver is the ability to
link one or more lower @dfn{Streams} (possibly containing modules and another multiplexing driver)
beneath it.

@subsection Complex Multiplexers

When constructing multiplexers for applications, even more complicated arrangements are possible.
Multiplexing over multiple @dfn{Streams} on both the upper and lower side of a @dfn{multiplexing
driver} is possible.  Also, a driver the provides lower multiplexing can be linked beneath a driver
that provide upper multiplexing as depicted by the dashed box in @figref{52}.  Each multiplexing
driver can perform @dfn{upper} multiplexing, @dfn{lower} multiplexing, or both, providing a
flexibility for the designer.

@dfn{STREAMS} provides multiplexing as a general purpose facility that is flexible in that
multiplexing drivers can be stacked and linked in a wide array of complex configurations.
@dfn{STREAMS} imposes few restrictions on processing within the multiplexing driver making the
mechanism applicable to a many classes of applications.

Multiplexing is described in greater detail in @ref{Multiplexing}.

@c ----------------------------------------------------------------------------
@node Benefits of STREAMS
@section Benefits of STREAMS
@menu
* Standardized Service Interfaces::
* Manipulating Modules::
@end menu

@dfn{STREAMS} provides a flexible, scalable, portable, and resuable kernel and user level facility
for the development of @cite{GNU/Linux} system communications services.  @dfn{STREAMS} allows the
creation of kernel resident modules that offer standard message passing facilities and the ability
for user level processes to manipulate and configure those modules into complex topologies.
@dfn{STREAMS} offers a standard way for user level processes to select and interconnect
@dfn{STREAMS} modules and drivers in a wide array of combinations without the need to alter
@cite{Linux} kernel code, recompile or relink the kernel.

@dfn{STREAMS} also assists in simplifying the user interface to device drivers and protocol stacks
by providing powerful system calls for the passing of control information from user to driver.
With @dfn{STREAMS} it is possible to directly implement asynchronous primitive-based service
interfaces to protocol modules.

@c ----------------------------------------
@node Standardized Service Interfaces
@subsection Standardized Service Interfaces

Many modern communications protocols define a service primitive interface between a service user and
a service provider.  Examples include the @cite{ISO Open Systems Interconnect (OSI)} and protocols
based on @dfn{OSI} such as @cite{Signalling System Number 7 (SS7)}.  Protocols based on @cite{OSI}
can be directly implemented using @dfn{STREAMS}.

In contrast to other approaches, such as @dfn{BSD Sockets}, @dfn{STREAMS} does not impose a
structured function call interface on the interaction between a user level process or kernel
resident protocol module.  Instead, @dfn{STREAMS} permits the service interface between a service
user and service provider (whether the service user is a user level process or kernel resident
@dfn{STREAMS} module) to be defined in terms of @dfn{STREAMS} messages that represent standardized
service primitives across the interface.

A service interface is defined@footnote{See ITU-T Recommendation X.200 and ITU-T Recommendation
X.210 for more information about service primitive interfaces.} at the boundary between neighbouring
modules.  The upper module at the boundary is termed the @dfn{service user} and the lower module at
the boundary is termed the @dfn{service provider}.  Implemented under @dfn{STREAMS}, a service
interface is a specified set of messages and the rules that allow passage of these messages across
the boundary.  A @dfn{STREAMS} module or driver that implements a service interface will exchange
messages within the defined set across the boundary and will respond to received messages in
accordance with the actions defined for the specific message and the sequence of messages preceding
receipt of the message (i.e., in accordance with the state of the module).

Instances of protocol stacks are formed using @dfn{STREAMS} facilities for pushing modules and
linking multiplexers.  For proper and consistent operation, protocol stacks are assembled so that
each neighboring module, driver and multiplexer implement the same service interface.  For example,
a module that implements the @cite{SS7 MTP} protocol layer, as shown in @figref{53}, presents a
protocol service interface at it input and output sides.  Other modules, drivers and multiplexers
should only be connected at the input and output sides of the @cite{SS7 MTP} protocol module if they
provide the same interface in the symetric role (i.e., user or provider).

It is the ability of @dfn{STREAMS} to implement service primitive interfaces between protocol
modules that makes it most appropriate for implementation of protocols based on the @cite{OSI}
service primitie interface such as @cite{X.25}, @cite{Integrated Services Digital Network (ISDN)},
@cite{Signalling System No. 7 (SS7)}.

@c ----------------------------------------
@node Manipulating Modules
@subsection Manipulating Modules
@menu
* Protocol Portability::
* Protocol Substitution::
* Protocol Migration::
* Module Reusability::
@end menu

@dfn{STREAMS} provides the ability to manipulate the configuration of drivers, modules and
multiplexers from user space, easing configuration of protocol stacks and profiles.  Modules,
drivers and multiplexers implementing common service interfaces can be substituted with ease.  User
level processes may access the protocol stack at various levels using the same set of standard
system calls, while also permitting the service interface to the user process to match that of the
topmost module.

It is this flexibility that makes @dfn{STREAMS} well suited to the implementation of communications
protocols based on the @dfn{OSI} service primitive interface model.  Additional benefits for
communications protocols include:

@itemize @bullet
@item User level programs use a service interface that is independent of underlying protocols,
drivers, device implementation, and physical communications media.

@item Communications architecture and upper layer protocols can be independent of underlying
protocol, drivers, device implementation, and physical communications media.

@item Communications protocol profiles can be created by selecting and connection constituent lower
layer protocols and services.
@end itemize

The benfits of the @dfn{STREAMS} approach are protocol portability, protocol substitution, protocol
migration, and module reusability.  Examples provided in the sections that follow are real-world
examples taken from the open source @cite{Signalling System No. 7 (SS7)} stack implemented by the
@uref{http://www.openss7.org/,OpenSS7 Project}.

@node Protocol Portability
@subsubsection Protocol Portability

@figref{53}, shows how the same @cite{SS7 Signalling Link} protocol module can be used with
different drivers on different machines by implementing compatible service interfaces.  The
@cite{SS7 Signalling Link} are the @dfn{Data Link Provider Interface (DLPI)} and the
@dfn{Communications Device Interface (CDI)} for @dfn{High-Level Data Link Control (HDLC)}.

@figuresized{SPG_fig53,53,Protocol Module Portability,4in}

By using standard @dfn{STREAMS} mechanisms for the implementation of the @cite{SS7 Signalling Link}
module, only the driver needs to be ported to port an entire protocol stack from one machine to
another.  The same @cite{SS7 Signalling Link} module (and upper layer modules) can be used on both
machines.

Because the @dfn{Driver} presents a standardized service interface using @dfn{STREAMS}, porting a
driver from the machine architecture of @samp{Machine A} to that of @samp{Machine B} consists of
changes internal to the driver and external to the @dfn{STREAMS} environment.  Machine dependent
issues, such as bus architectures and interrupt handling are kept independent of the primary state
machine and service interface.  Porting a driver from one major @cite{UNIX} or @cite{UNIX}-like
operating system and machine architecture supporting @dfn{STREAMS} to another is a straightforward
task.

With @cite{@value{PACKAGE_TITLE}}, @dfn{STREAMS} provides the ability to directly port a large body
of existing @dfn{STREAMS} modules to the @cite{GNU/Linux} operating system.

@node Protocol Substitution
@subsubsection Protocol Substitution

@dfn{STREAMS} permits the easy substitution of protocol modules (or devic drivers) within a protocol
stack providing a new protocol profile.  When protocol modules are implemented to a compatible
service interface the can be recombined and substituted, providing a flexible protocol architecture.
In some circumstances, and through proper design, protocol modules can be substituted that implement
the same service interface, even if they were not originally intended to be combined in such a
fashion.

@figuresized{SPG_fig56,300,Protocol Substitution,4in}

@figref{300} illustrates how @dfn{STREAMS} can substitute upper layer protocol modules to implement
a different protocol stack over the same @dfn{HDLC} driver.  As each module and driver support the
same service interface at each level, it is conceivable that the resulting modules could be
recombined to support, for example, @cite{SS7 MTP} over an @cite{ISDN LAPB} channel.@footnote{SS7
MTP over ISDN LAPB was originally defined under ISDN as an E-Channel.}

Another example would be substituting an @cite{M2PA} signalling link module for a traditional
@cite{SS7 Signalling Link Module} to provide @cite{SS7 over IP}.

@node Protocol Migration
@subsubsection Protocol Migration

@figref{54} illustrates how @dfn{STREAMS} can move functions between kernel software and front end
firmware.  A common downstream service interface allows the transport protocol module to be
independent of the number or type of modules below.  The same transport module will connect without
modification to either an @cite{SS7 Signalling Link} module or @cite{SS7 Signalling Link} driver
that presents the same service interface.

@figuresized{SPG_fig54,54,Protocol Migration,4in}

The @uref{http://www.openss7.org/,OpenSS7} @cite{SS7 Stack} uses this capability also to adapt the
protocol stack to front-end hardware that supports differing degrees of @cite{SS7 Signalling Link}
support  in firmware.  Hardware cards that support as much as a transparent bit stream can have
@cite{SS7 Signalling Data Link}, @cite{SS7 Signalling Data Terminal} and @cite{SS7 Signalling Link}
modules pushed to provide a complete @cite{SS7 Signalling Link} that might, on another hardware
card, be mostly implemented in firmware.

By shifting functions between software and firmware, developers can produce cost effective,
functionally equivalent systems over a wide range of configurations.  They can rapidly incorporate
technological advances.  The same upper layer protocol module can be used on a lower capacity
machine, where economics may preclude the use of front-end hardware, and also on a larger scale
system where a front-end is economically justified.

@node Module Reusability
@subsubsection Module Reusability

@figref{55} shows the same canonical module (for example, one that provides
delete and kill processing on character strings) reused in two different @dfn{Streams}.  This module
would typically be implemented as a filter, with no downstream service interface.  In both cases, a
tty interface is presented to the @dfn{Stream}'s user process since the module is nearest the
@dfn{Stream head}.

@figuresized{SPG_fig55,55,Module Reusability,4in}

@c ============================================================================
@node Overview
@chapter Overview
@menu
* Definitions::			STREAMS Definitions
* Concepts::			STREAMS Concepts
* Application Interface::	STREAMS Application Interface
* Kernel Level Facilities::	STREAMS Kernel Facilities
* Subsystems::			STREAMS Subsystems
@end menu

@node Definitions
@section Definitions

@node Concepts
@section Concepts

@node Application Interface
@section Application Interface

@node Kernel Level Facilities
@section Kernel Level Facilities

@node Subsystems
@section Subsystems

@c ============================================================================
@node Mechanism
@chapter Mechanism
@menu
* Mechanism Overview::		STREAMS Mechanism Overview
* Stream Construction::		STREAMS Stream Construction
@end menu

This chapter describes how applications programs create and interact with a @dfn{Stream} using
traditional and standardized @dfn{STREAMS} system calls.  General system call and
@dfn{STREAMS}-specific system calls provide the interface required by user level processes when
implementing user level applications programs.

@node Mechanism Overview
@section Mechanism Overview

The system call interface provided by @dfn{STREAMS} is upward compatible with the traditional
character device system calls.

@dfn{STREAMS} devices appears as character device nodes within the file system in the
@dfn{GNU/Linux} system.
The @manref{open(2)} system call recognizes that a character special file is a @dfn{STREAMS} device,
creates a @dfn{Stream} and associates it with a device in the same fashion as a character device.

Once open, a user process can send and receive data to and from the @dfn{STREAMS} special file using
the traditional @manref{write(2)} and @manref{read(2)} system calls in the same manner as is
performed on a traditional character device special file.

Character device input-output controls using the @manref{ioctl(2)} system call can also be performed
on a @dfn{STREAMS} special file.  @dfn{STREAMS} defines a set of standard input-output control
commands (see @manref{ioctl(2p)} and @manref{streamio(7)}) specific to @dfn{STREAMS} special files.
Input-output controls that a defined for a specific device are also supported as they are for
character device drivers.

With support for these general character device input and output system calls, it is possible to
implement a @dfn{STREAMS} device driver in such a way that an application is unaware that it has
opened and is controlling a @dfn{STREAMS} device driver: the application could treat the device in
the identical manner to a character device.  This make it possible to convert an existing character
device driver to @dfn{STREAMS} and make possible the portability, migration, substitution and
reusability benefits of the @dfn{STREAMS} framework.

@dfn{STREAMS} provides @dfn{STREAMS}-specific system calls and
@manpage{ioctl(2)} commands, in
addition to support for the traditional character device I/O system calls and
@manpage{ioctl(2)}
commands.

The @manref{poll(2)} system call@footnote{Although the
@manpage{poll(2)} system call has been
implemented in @cite{GNU/Linux}, it was historically provided only by @dfn{STREAMS}.  This is
evident from the fact that
@manpage{poll(2)} system can supports events like @constant{POLLRDBAND}
that have no meaning outside of the @dfn{STREAMS} framework.} provides the ability for the
application to poll multiple @dfn{Streams} for a wide range of events.

The @manref{putmsg(2)} and @manref{putpmsg(2s)} system calls provide the ability for applications
programs to transfer both control and data information to the @dfn{Stream}.  The
@manpage{write(2)}
system call only supports the transfer of data to the @dfn{Stream}, whereas,
@manpage{putmsg(2)} and
@manpage{putpmsg(2s)} permit the transfer of prioritized control information in addition to data.

The @manref{getmsg(2)} and @manref{getpmsg(2s)} system calls provide the ability for applications
programs to receive both control and data information from the @dfn{Stream}.  The
@manpage{read(2)}
system call can only support the transfer of data (and in some cases the inline control
information), whereas,
@manpage{getmsg(2)} and
@manpage{getpmsg(2s)} permit the transfer of
prioritized control information in addition to data.

Implementation of standardized service primitive interfaces is enabled through the use of the
@manpage{putmsg(2)},
@manpage{putpmsg(2s)},
@manpage{getmsg(2)} and
@manpage{getpmsg(2s)} system
calls.

@dfn{STREAMS} also provides kernel level utilities and facilities for the development of kernel
resident @dfn{STREAMS} modules and drivers.  Within the @dfn{STREAMS} framework, the @dfn{Stream
head} is responsible for conversion between @dfn{STREAMS} messages passed up and down a @dfn{Stream}
and the system call interface presented to user level applications programs.  The @dfn{Stream head}
is common to all @dfn{STREAMS} special files and the conversion between the system call interface
and message passed on the @dfn{Stream} does not have to be reimplemented by the module and device
driver writer as is the case for traditional character device I/O.

@subsection STREAMS System Calls

The @dfn{STREAMS}-related system calls are:

@multitable @columnfractions .20 .80
@item @manpage{open(2)}
@tab Open a @dfn{STREAMS} special file and create a new (or access an existing) @dfn{Stream}.
@item @manpage{close(2)}
@tab Close a @dfn{STREAMS} special file and possibly cause the destruction of a @dfn{Stream} (i.e.,
on the last close of the @dfn{Stream}.
@item @manpage{read(2)}
@tab Read data from an open @dfn{Stream}.
@item @manpage{write(2)}
@tab Write data to an open @dfn{Stream}.
@item @manpage{ioctl(2)}
@tab Control an open @dfn{Stream}.
@item @manpage{getmsg(2)},
@manpage{getpmsg(2s)}
@tab Receive a (prioritized) message at the @dfn{Stream head}.
@item @manpage{putmsg(2)},
@manpage{putpmsg(2s)}
@tab Send a (prioritized) message from the @dfn{Stream head}.
@item @manpage{poll(2)}
@tab Receive notification when selected events occur on one or more @dfn{Streams}.
@item @manpage{pipe(2)}
@tab Create a channel that provides a @dfn{STREAMS}-based bidirectional communication path between
multiple processes.
@end multitable

@node Stream Construction
@section Stream Construction
@menu
* Opening a STREAMS Device File::
* Opening a STREAMS-based FIFO::
* Creating a STREAMS-based Pipe::
* Adding and Removing Modules::
* Closing the Stream::
* Stream Construction Example::
@end menu

@dfn{STREAMS} constructs a @dfn{Stream} as a double linked list of kernel data structures.  Elements
of the linked list are queue pairs that represent the instantiation of a @dfn{Stream head}, modules
and drivers.  Linear segments of link queue pairs can be connected to multiplexing drivers to form
complex tree topologies.  The branches of the tree are closest to the user level process and the
roots of the tree are closest to the device driver.

The uppermost queue pair of a @dfn{Stream} represents the @dfn{Stream head}.  The lowermost queue
pair of a @dfn{Stream} represents the @dfn{Stream end} or @dfn{device driver}, @dfn{pseudo-device
driver}, or another @dfn{Stream head} in the case of a @dfn{STREAMS}-based pipe.

The @dfn{Stream head} is responsible for conversion between a user level process using the system
call interface  and @dfn{STREAMS} messages passed up and down the @dfn{Stream}.  The @dfn{Stream
head} uses the same set of kernel routines available to module a driver writers to communicate with
the @dfn{Stream} via the queue pair associated with the @dfn{Stream head}.

@figref{13} illustrates the queue pairs in the most basis of @dfn{Streams}: one consisting of a
@dfn{Stream head} and a @dfn{Stream end}.  Depicted are the upstream (read) and downstream (write)
paths along the @dfn{Stream}.  Of the uppermost queue pair illustrated, @samp{H1} is the upstream
(read) half of the @dfn{Stream head} queue pair; @samp{H2}, the downstream (write) half.  Of the
lowermost queue pair illustrated, @samp{E2} is the upstream half of the @dfn{Stream end} queue pair;
@samp{H1} the downstream half.

@figuresized{SPG_fig13,13,Upstream and Downstream @dfn{Stream} Construction,2.5in}

Each queue specifies an entry point (that is, a procedure) that will be used to process messages
arriving at the queue.  The procedures for queues @samp{H1} and @samp{H2} process messages sent to
(or that arrive at) the @dfn{Stream head}.  These procedures are defines by the @dfn{STREAMS}
subsystem and are responsible for the interface between @dfn{STREAMS} related system calls and the
@dfn{Stream}.  The procedures for queues @samp{E1} and @samp{E2} process messages at the @dfn{Stream
end}.  These procedures are defined by the device driver, pseudo-device driver, or @dfn{Stream head}
at the @dfn{Stream end} (tail).  In accordance with the procedures defined for each queue, messages
are processed by the queue and typically passed from queue to queue along the linked list segment.

@figref{14} details the data structures involved.  The data structures are the @mantype{queue(9)},
@mantype{qband(9)}, @mantype{qinit(9)}, @mantype{module_init} and @mantype{module_stat} structures.

The @manpage{queue(9)} structure is the primary data structure associated with the queue.  It
contains a double linked list (message queue) of messages contained on the queue.  It also includes
pointers to other queues used in @dfn{Stream} linkage, queue state information and flags, and
pointers to the @manpage{qband(9)} and @manpage{qinit(9)} structures associated with the queue.

The @manpage{qband(9)} structure is used as an auxiliary structure to the @manpage{queue(9)}
structure that contains state information and pointers in to the message list for each priority band
within a queue (except for band @samp{0} information, which is contained in the @manpage{queue(9)}
structure itself).  @manpage{qband(9)} structures are linked into a list and connected to the
@manpage{queue(9)} structure to which they belong.

The @manpage{qinit(9)} structure is defined by the module or driver and contains procedure pointers
for the procedures associated with the queue, as well as pointers to module or driver information
and initialization limits contained in the @manpage{module_info(9)} structure as well as an optional
pointer to a @manpage{module_stat(9)} structure that contains collected run-time statistics for the
entire module or driver.  Normally, a separate @manpage{qinit(9)} structure exists for all of the
upstream and downstream instances of a queue associated with a driver or module.

The @manpage{module_info(9)} structure contains information about the module or driver, such as
module identifier and module name, as well as minimum and maximum packet size and queue flow control
high and low water marks.  It is important to note that this structure is used only to initialize
the corresponding limit values for an instance of the @manpage{queue(9)} structure.  The values
contained within a particular @manpage{queue(9)} structure can be changed in a running module or
driver without affecting the @manpage{module_init(9)} structure.  The @manpage{module_init(9)}
structure is considered to be a read-only structure for the purpose of modules and drivers written
for @dfn{STREAMS}.

The @manpage{module_stat(9)} structure contains runtime counts of the entry into the various
procedures contained in the @dfn{qinit(9)} structure as well as a pointer to any module private
statistics that need to be collected.  As depicted in @figref{14}, there is normally only one
@manpage{module_stat(9)} structure per queue pair that collects statistics for the entire module or
driver.  @dfn{STREAMS} does not peg this counts automatically and will not manipulate this
structure, even when one is attached.  It is the responsibility of the module or driver writer to
peg counts as required.  @cite{@value{PACKAGE_TITLE}} does, however, provide some user level
administrative tools that can be used to examine the statistics contained in this structure.  The
@manpage{module_stat(9)} structure is opaque to the @dfn{STREAMS} subsystem and can be read from or
written to by module or driver procedures.

@figuresized{SPG_fig14,14,@dfn{Stream} Queue Relationship,5.5in}

Note that it is possible to have a separate @manpage{qinit(9)}, @manpage{module_init(9)} and
@manpage{module_stat(9)} structure for each queue in the queue pair; however, typically there are
two @manpage{qinit(9)} structures and only one @manpage{module_info} and @manpage{module_stat}
structure per module or driver.  @manpage{qinit(9)}, @manpage{module_info} and @manpage{module_stat}
structures are statically allocated by the module or driver, and the @manpage{queue(9)} and
@manpage{qband(9)} structures are dynamically allocated by @dfn{STREAMS} on demand.

All of these queue related data structures are in @ref{Data Structures} (and in the
@cite{@value{PACKAGE_TITLE}} @cite{Manual Pages}).

@figref{14} illustrates two adjacent queue pairs with links between them in both directions on the
@dfn{Stream}.  When a module is opened, @dfn{STREAMS} creates a queue pair for the module and then
links the the queue pair into the list.  Each queue is linked to the next queue in the direction of
message flow.  The @var{q_next} member of the @manpage{queue(9)} data structure is used to perform
the linkage.  @dfn{STREAMS} allocates @manpage{queue(9)} structures in pairs (that is, as an array
containing two @manpage{queue(9)} structures).  The read-side queue of the pair is the lower ordinal
and the write-side the higher.  Nevertheless, @dfn{STREAMS} provides some utility functions (or
macros) that assist queue procedures in locating the other queue in the pair.  The @dfn{Stream head}
and @dfn{Stream end} are known to procedures only a destinations toward which messages are
sent.@footnote{However, for the purpose of the @dfn{STREAMS} executive, most implementations cache a
pointer to the @dfn{Stream head} in the @manpage{queue(9)} structure.}

There are two ways for the user level process to construct a @dfn{Stream}:

@enumerate

@item Open a @dfn{STREAMS} device special file using the @manref{open(2)} system call.  Construction
of a @dfn{Stream} with the @dfn{open(2)} system call is detailed in @ref{Opening a STREAMS Device
File} and @ref{Opening a STREAMS-based FIFO} and illustrated in @figref{15}. 

@item Create a @dfn{STREAMS}-based pipe using the @manref{pipe(2)} system call.  Construction of a
@dfn{Stream} with the @dfn{pipe(2)} system call is detailed in @ref{Creating a STREAMS-based Pipe}
and illustrated in @figref{16}.

@end enumerate

@node Opening a STREAMS Device File
@subsection Opening a STREAMS Device File

A @dfn{Stream} is constructed when a @dfn{STREAMS}-based driver file is opened using the
@manref{open(2)} system call.  A @dfn{Stream} constructed in this fashion is illustrated in
@figref{15}.

In the traditional @cite{UNIX} system, a @dfn{STREAMS}-based driver file is a character device
special file within the @cite{UNIX} file system.  In the @cite{GNU/Linux} system, under
@cite{@value{PACKAGE_TITLE}}, a @dfn{STREAMS}-based driver file is either a character device special
file within a @cite{GNU/Linux} file system, or a character device special file within the mounted
@dfn{Shadow Special File System (specfs)}.  When the @file{specfs} is mounted, @file{specfs} device
nodes can be opened directly.  When the @file{specfs} is not mounted, @file{specfs} device nodes can
only be opened indirectly via character device nodes in a @cite{GNU/Linux} file system external to
the @file{specfs}.

All @dfn{STREAMS} drivers (and modules) have their entry points defined by the
@mantype{streamtab(9)} structure for that driver (or module).  The @type{streamtab} structure has
the following format:

@cartouche
@smallexample
struct streamtab @{
    struct qinit *st_rdinit;
    struct qinit *st_wrinit;
    struct qinit *st_muxrinit;
    struct qinit *st_muxwinit;
@};
@end smallexample
@end cartouche

The @type{streamtab} structure defines a module or driver.  @member{st_rdinit} points to the read
@type{qinit} structure for the driver and @member{st_wrinit} points to the driver's write
@type{qinit} structure.  For a multiplexing driver, the @member{st_muxrinit} and
@member{st_muxwinit} point to the @type{qinit} structures for the lower side of the multiplexing
driver.  For a regular non-multiplexing driver these members are @constant{NULL}.

@figuresized{SPG_fig15,15,Opened @dfn{STREAMS}-based Driver,5in}

@subsubsection First Open of a Stream

When a @dfn{STREAMS}-based file is opened, a new @dfn{Stream} is created if one does not already
exists for the file, or if the @code{D_CLONE} flag is set for the file indicating that a new
@dfn{Stream} is to be created on each open of the file.  First, a file descriptor is allocated in
the process' file descriptor table, a file pointer is allocated to represent the opened file.  The
file pointer is initialized to point to the @type{inode} associated with the character special file
in the external file system (see @member{f_inode} in @figref{15}).  This @type{inode} is of type
character special (@code{S_IFCHR}).  The @cite{Linux} kernel recognizes the @type{inode} as a
character special file and invokes the character device open routine in
@cite{@value{PACKAGE_TITLE}}.  This @type{inode} is equivalent to the @type{vnode} used by
@cite{UNIX System V Release 4.2}.

@cite{@value{PACKAGE_TITLE}} uses the major and minor device numbers associated with the character
special file to locate an @type{inode} within the @cite{Shadow Special File System (specfs)} that is
also provided by @cite{@value{PACKAGE_TITLE}}, and the @member{f_inode} pointer of the file
pointeris adjusted to point directly to this @file{specfs} @type{inode}.  This @file{specfs}
@type{inode} is equivalent to the common @type{snode} used by @cite{UNIX System V Release 4.2}.

Next, a @dfn{Stream header} is created from a @mantype{stdata(9)} data structure and a @dfn{Stream
head} is created from a pair of @type{queue} structures.  The content of the @type{stdata} data
structure is initialized with predetermined @dfn{STREAMS} values applicable to all character special
@dfn{Streams}.  The content of the @type{queue} data structures in the @dfn{Stream head} are
initialized with values from the @type{streamtab} structure statically defined for @dfn{Stream
heads} in the same manner as any @dfn{STREAMS} module or driver.

The @type{inode} within the @file{specfs} contains @dfn{STREAMS} file system dependent information.
This @type{inode} corresponds to the common @type{snode} of @cite{UNIX System V Release 4.2}.  The
@member{sd_inode} filed of the @type{stdata} structure is initialized to point to this @type{inode}.
The @member{i_pipe} filed of the @type{inode} data structure is initialized to point to the
@dfn{Stream header} (@type{stdata} structure), thus there is a forward and backward pointer between
the @dfn{Stream header} and the @type{inode}.

The @member{private_data} member of the @type{file} pointer is initialized to point to the
@dfn{Stream header} and the @member{sd_file} member of the @code{stdata} structure is initialized to
point to the @type{file} pointer.

After the @dfn{Stream header} and @dfn{Stream head} queue pair is allocated and initialized, a
@type{queue} structure pair is allocated and initialized for the driver.  Each @type{queue} in the
queue pair has its @member{q_init} pointer initialized to the corresponding @type{qinit} structure
defined in the driver's @type{streamtab}.  Limit values in each @type{queue} in the pair are
initialized the queue's @type{module_init} structure, now accessible via the @member{q_init}
pointer in the @type{queue} structure and the @member{qi_minfo} pointer in the @type{qinit}
structure.

The @member{q_next} pointers in each @type{queue} structure are set so that the @dfn{Stream head}
write queue points to the driver write queue and the driver read queue points to the @dfn{Stream
head} read queue.  The @member{q_next} pointers at the ends of the @dfn{Stream} are set to
@constant{NULL}.  Finally, the driver open procedure (accessible via the @member{qi_qopen} member of
the @type{qinit} structure for the read-side @type{queue}) is called.

@subsubsection Subsequent Open of a Stream

When the @dfn{Stream} has already been created by a call to @manpage{open(2)} and has not yet been
destroyed, that is, on a subsequent open of the @dfn{Stream}, and the @dfn{STREAMS} driver is not
marked for clone open with the @constant{D_CLONE} flag in the @mantype{cdevsw(9)} structure, the
only actions performed are to call the driver's @command{open} procedure and the @command{open}
procedures of all pushable modules present on the already existing @dfn{Stream}.

@node Opening a STREAMS-based FIFO
@subsection Opening a STREAMS-based FIFO

A @dfn{STREAMS}-based FIFO @dfn{Stream} is also constructed with a call to @manpage{open(2)}. A
@dfn{Stream} constructed in this fashion is illustrated in @figref{15b}.

A @dfn{STREAMS}-based FIFO appears as a FIFO special file within a @cite{GNU/Linux} file system, as
a character special file within a @cite{GNU/Linux} file system, or as a FIFO special file within the
@dfn{Shadow Special File System (specfs)}.@footnote{This is different that the situation in the
@cite{UNIX System V Release 4.2} system and other @cite{UNIX} variants in the following respects: In
@cite{SVR 4.2} all FIFOs are @dfn{STREAMS}-based.  In other @cite{UNIX} implementations FIFOs are
either @cite{SVR 3.2}-style or, in some systems, optionally @dfn{STREAMS}-based.  In @cite{SVR 4.2}
FIFOs are FIFO special files.  In other @cite{UNIX} implementations (and in @cite{LiS}), FIFOs are
character special files.  Under @cite{GNU/Linux}, system FIFOs are by default @cite{SVR 3.2}-style
FIFOs.  To acheive the greatest possible degree of compatibility, @cite{@value{PACKAGE_TITLE}}
provides the option of making all @cite{GNU/Linux} system FIFOs @dfn{STREAMS}-based, and also
provides a character special file implementation of @dfn{STREAMS}-based FIFOs.}

@figref{15b} illustrates an @dfn{STREAMS}-based FIFO that has been opened and a @dfn{Stream}
created.

@figuresized{SPG_fig15b,15b,Opened @dfn{STREAMS}-based FIFO,5in}

The sequence of events the cause the creation of a @dfn{Stream} when a @dfn{STREAMS}-based FIFO is
opened using the @manref{open(2)} system call are the same as that for regular @dfn{STREAMS} device
special files with the following differences:

@enumerate

@item When the @dfn{Stream header} (@type{stdata} structure) is created, it is attached to the
external @cite{GNU/Linux} file system @type{inode} instead of an @type{inode} within the
@cite{Shadow Special File System (specfs)}.  This is also true of the @type{file} pointer: that is,
the @type{file} pointer refers to the external file system @type{inode} instead of a @file{specfs}
@type{inode}.  The result is illustrated in @figref{15b}.

@item The @dfn{Stream header} (@type{stdata} structure) is initialized with limits and values
appropriate for a @dfn{STREAMS}-based FIFO rather than a regular @dfn{STREAMS} driver.  This is
because the behaviour of a @dfn{STREAMS}-based FIFO @dfn{Stream head} must be somewhat different
from a regular @dfn{STREAMS} driver to be compliant with @cite{POSIX}.@footnote{For example, a FIFO
opened read-only will block waiting for another process to open the FIFO for writing.}

@item No driver queue pair is created or attached to the @dfn{Stream}.  The @dfn{Stream head}
write-side queue @member{q_next} pointer is set to the read-side queue as illustrated in
@figref{15b}.

@end enumerate

Aside from these differences, opening a @dfn{STREAMS}-based FIFO is structurally equivalent to
opening a regular @dfn{STREAMS} driver.  The similarity makes it possible to also implement
@dfn{STREAMS}-based FIFOs as character special files.

@node Creating a STREAMS-based Pipe
@subsection Creating a STREAMS-based Pipe

A @dfn{Stream} is also constructed when a @dfn{STREAMS}-based pipe is created using the
@manref{pipe(2)} system call.@footnote{Note that, by default, @cite{GNU/Linux} system pipes obtained
with the @manref{pipe(2)} system call are @cite{SVR 3.2}-style unidirectional pipes.
@cite{@value{PACKAGE_TITLE}} provides a @manpage{pipe(2)} library function in the @file{libstreams}
library that can be used to override the normal @manref{pipe(2)} system call for some applications
programs.  Also, @cite{@value{PACKAGE_TITLE}} provides the option of overriding all system pipes
returned by the @manpage{pipe(2)} system call to be bidirectional @dfn{STREAMS}-based pipes.} A
@dfn{Stream} constructed in this fashion is illustrated in @figref{16}.

@figuresized{SPG_fig16,16,Created @dfn{STREAMS}-based Pipe,5.5in}

Pipes have no @type{inode} in an external @cite{GNU/Linux} file system that can be opened with the
@manpage{open(2)} system call and, therefore, they must be created with a call to
@manref{pipe(2)}.@footnote{Some @cite{UNIX} implementations, notably @cite{UnixWare}, provide the
ability to open two character special files and associate them together into a @dfn{STREAMS}-based
pipe (see @manref{sfx(4)}).  In that case, opening each end of a @dfn{STREAMS}-based pipe is no
different than opening a regular @dfn{STREAMS} driver.} When the @manpage{pipe(2)} system call is
executed, two @dfn{Streams} are are created.  The construction of each @dfn{Stream} is similar to
that when a @dfn{STREAMS} driver is opened with the following differences:

@itemize @bullet

@item Instead of creating one process file table entry and one @type{file} pointer, as was the case
for regular @dfn{STREAMS} drivers, @manpage{pipe(2)} creates two file table entries (file
descriptors) and two @type{file} pointers, as shown in @figref{16}.

@item Because a character special device is not being opened, there is no @type{inode} in an
external file system, so @dfn{STREAMS} allocated two @type{inode}s from the
@file{specfs}.@footnote{Some @cite{UNIX} implementations, and @cite{UNIX System V Release 4},
provide a separate file system, the @file{pipefs}, upon which @type{vnodes} are created.  In a
simlar fashion, @cite{GNU/Linux} @cite{SVR 3.2}-style system pipes also allocates @type{inode}s from
a @file{pipefs} file system.}  Each @type{inode} has a file type of @constant{S_IFIFO}.  The
@type{file} pointer and @type{stdata} structure for each @dfn{Stream header} is attached to one of
these @type{inode}s.

@item When the @dfn{Stream header} associated with each file descriptor is initialized, the
@type{stdata} structure is initialized with values appropriate for a @dfn{STREAMS}-based pipe
instead of a regular @dfn{Stream}.@footnote{Examples of differences include that pipes issue
@constant{SIGPIPE} when the @dfn{Stream} encounters an error, that is, the @constant{SNDPIPE} write
option is enabled, and pipe cannot send zero-length data by default, that is, the @constant{SNDZERO}
write option is disabled.  Both of these are the reverse for a regular @dfn{Stream}.}

@item Instead of creating a driver queue pair for the @dfn{Stream}, the @member{q_next} pointer for
the write-side @type{queue} of each @dfn{Stream head} is initialized to point to the read-side queue
of the other @dfn{Stream head}.  This is illustrated in @figref{16}.

@end itemize

@node Adding and Removing Modules
@subsection Adding and Removing Modules
@menu
* Pushing Modules::
* Popping Modules::
@end menu

When a @dfn{Stream} has been constructed, modules can be inserted into the @dfn{Stream} between the
@dfn{Stream head} and the @dfn{Stream end} (or between the @dfn{Stream head} and the midpoint of a
@dfn{STREAMS}-based pipe or FIFO.)  Addition (or pushing) of modules is accomplished by inserting
the module into the @dfn{Stream} immediately below the @dfn{Stream head}.  Removal (or poppping) of
modules is accomplished by deleting the module immediately below the @dfn{Stream head} from the
@dfn{Stream}.

When a module is pushed onto a @dfn{Stream}, the module's @command{open} procedure is called for the
newly inserted queue pair.  When a module is popped from the @dfn{Stream}, the module's
@command{close} procedure is called prior to deleting the queue pair from the @dfn{Stream}.

Modules are pushed onto an open @dfn{Stream} by issuing the @ioctlref{I_PUSH} @manpage{ioctl(2)}
command on the file descriptor associated with the open @dfn{Stream}.  Modules are popped from a
@dfn{Stream} with the @ioctlref{I_POP} @manpage{ioctl(2)} command on the file descriptor associated
with the open @dfn{Stream}.

@streamio{I_PUSH} and @streamio{I_POP} allow a user level process to dynamically reconfigure the
ordering and type of modules on a @dfn{Stream} to meet any requirement.

@node Pushing Modules
@subsubsection Pushing Modules

When the @dfn{Stream head} receives an @streamio{I_PUSH} @command{ioctl} command, @dfn{STREAMS}
locates the module's @type{streamtab} entry and creates a new queue pair to represent the instance
of the module.  Each queue in the pair is initialized in a similar fashion as for drivers: the
@member{q_init} pointers are initialized to point to the @type{qinit} structures of the module's
@type{streamtab}, and the limit values are initialized to the values found in the corresponding
@type{module_init} structures.

Next, @dfn{STREAMS} positions the module's queue pair in the @dfn{Stream} immediately beneath the
@dfn{Stream head} and above the driver and all existing modules on the @dfn{Stream}.  Then the
module's @command{open} procedure is called for the queue pair.  (The @command{open} procedure is
located in the @member{qi_qopen} member of the @type{qinit} structure associated with the read-side
queue.)

Each push of a module onto a @dfn{Stream} results in the insertion of a new queue pair representing
a new instance of the module.  If a module is (successfully) pushed twice on the same @dfn{Stream},
two queue pairs and two instances of the module will exist on the @dfn{Stream}.

To assist in identifying misbehaving applications programs that might push the same set of modules
in an indefinite loop, swallowing an excessive amount of system resources, @dfn{STREAMS} imposes a
limit on the number of modules that can be pushed on a given @dfn{Stream} to a practical number.
The number is limited by the @dfn{NSTRPUSH} kernel parameter (@pxref{Configuration}) which is set to
either @samp{16} or @samp{64} on most systems.

Once an instance of a module is pushed on a @dfn{Stream}, its @command{open} procedure will be
called each time that the @dfn{Stream} is reopened.

@node Popping Modules
@subsubsection Popping Modules

When the @dfn{Stream head} receives a @streamio{I_POP} @command{ioctl} command, @dfn{STREAMS}
locates the module directly beneath the @dfn{Stream head} and calls it's @command{close} procedure.
(The @command{close} procedure is located by the @member{qi_qclose} member in the @type{qinit}
structure associated with the module instance's read-side @type{queue}.)  Once the @command{close}
procedure returns, @dfn{STREAMS} deletes the queue pair from the @dfn{Stream} and deallocates the
queue pair.

@node Closing the Stream
@subsection Closing the Stream

Relinquishing the last reference to a @dfn{Stream} dismantles the @dfn{Stream} and deallocates its
components.  Normally, the last direct or indirect call to @manref{close(2)} for a @dfn{Stream}
results in the @dfn{Stream} being dismantled in this fashion.@footnote{Exceptions are when the
@dfn{Stream} has been named with @manref{fattach(8)}, that is, it is still @dfn{mounted}, or when
the @dfn{Stream} is still linked under a multiplexing driver.} Calls to @manpage{close(2)} before
the last close of a @dfn{Stream} will not result in the dismantling of the @dfn{Stream} and no
module or driver @command{close} procedure will be called on closes prior to the last close of a
@dfn{Stream}.

Dismantling a @dfn{Stream} consists of the following sequence of actions:

@enumerate

@item If the @dfn{Stream} is a @dfn{STREAMS}-based pipe and the other end of the pipe is not open by
any process, but is named (i.e., mounted by @manref{fattach(3)}), then the named end of the pipe is
detached as with @manref{fdetach(3)} and then the @dfn{Stream} is dismantled.

@item If the @dfn{Stream} is a multiplexing driver, dismantling a @dfn{Stream} first consists of
unlinking any @dfn{Streams} that remain temporarily linked (by a previous @streamio{I_LINK} command)
under the multiplexing driver using the @dfn{control stream} being closed.  Unlinking of temporary
links consists of issuing an @msg{M_IOCTL} message to the driver indicating the @streamio{I_UNLINK}
operation and entering an uninterrupted wait for an acknowledgement.  Waiting for acknowledgement to
the @msg{M_IOCTL} command can cause the close to be delayed.  If unlinking any temporary links
results in the last reference being released to the now unlinked @dfn{Stream}, that @dfn{Stream}
will be dismantled before proceding.

@item Each module that is present on the @dfn{Stream} being dismantled will be popped from the
@dfn{Stream} by calling the module's @command{close} procedure and then deleting the module instance
queue pair from the @dfn{Stream}.

@item If a driver exists on the @dfn{Stream} being dismantled, the driver's @command{close}
procedure is called and then the @dfn{Stream end} queue pairs are deallocated.

If the @dfn{Stream} invoking the chain of events that resulted in the dismantling of a @dfn{Stream}
is open for blocking operation (neither @constant{O_NDELAY} nor @constant{O_NONBLOCK} were set), no
signal is pending for the process causing dismantling of the @dfn{Stream}, and there are messages on
the module or driver's write-side queue, @dfn{STREAMS} may wait for an interval for the messages to
drain before calling the module or driver's @command{close} procedure.  The maximum interval to wait
is traditionally @samp{15} seconds.  If any of these conditions are not met, the module or driver is
closed immediately.

When each module or driver queue pair is deallocated, any messages that remain on the queue are
flushed prior to deallocation.  Note that @dfn{STREAMS} frees only the messages contained on a
message queue: any message or data structures used internally by the driver or module must be freed
by the driver or module before it returns from its @command{close} procedure.

@item The queue pair associated with the @dfn{Stream head} is closed@footnote{Note that the messges
are not queued on the @dfn{Stream head} write-side queue and so no delay in closing the @dfn{Stream
head} queue pair is considered.} and the queue pair and @dfn{Stream header} (@type{stdata}
structure) are deallocated and the associated @type{inode}, @type{file} pointer, and file
descriptors are released.

@end enumerate

@node Stream Construction Example
@subsection Stream Construction Example
@menu
* Inserting Modules::
* Module and Driver Control::
* Stream Dismantling with Modules::
* Stream Construction Example Summary::
@end menu

This @dfn{Streams} construction example builds on the previous example (see @ref{Listing 1.1} in
@ref{Basic Streams Operations}), by adding the pushing of a module onto the open @dfn{Stream}.

@node Inserting Modules
@subsubsection Inserting Modules

This example demonstrates the ability of @dfn{STREAMS} to push modules, not available with
traditional character devices.  The ability to push modules onto a @dfn{Stream} allows the
independent processing an manipulation of data passing between the driver and user level process.
This example is of a character conversion module is given a command and a string of characters by
the user.  Once this command is received, the character conversion module examines all character
passing through it for an occurrence of the characters in the command string.  When an instance of
the string is discovered in the data path, the requested command acition is performed on matching
characters.

The declarations for the user program are shown in @ref{Listing 3.1}.

@cartouche
@iftex
@float Listing,Listing 3.1
@end iftex
@smallexample
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/uio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stropts.h>

#define   BUFLEN      1024

/*
 *  These defines would typically be
 *  found in a header file for the module
 */
#define   XCASE       1         /* change alphabetic case of char */
#define   DELETE      2         /* delete char */
#define   DUPLICATE   3         /* duplicate char */

main()
@{
    char buf[BUFLE];
    int fd, count;
    struct strioct1 strioctl;
@end smallexample
@iftex
@caption{@emph{Inserting Modules Example}}
@end float
@end iftex
@ifnottex
@anchor{Listing 3.1}
@center @emph{Listing 3.1.@:  Inserting Modules Example}
@end ifnottex
@end cartouche

As in the previous example of @ref{Listing 1.1}, first a @dfn{Stream} is opened using the
@manref{open(2)} system call.  In this example, the @dfn{STREAMS} device driver is
@file{/dev/streams/comm/01}.

@cartouche
@iftex
@float Listing,Listing 3.2
@end iftex
@smallexample
    if ((fd = open("/dev/streams/comm/01", O_RDWR)) < 0) @{
        perror("open failed");
        exit(1);
    @}
@end smallexample
@iftex
@caption{@emph{Inserting Modules Example (cont'd)}}
@end float
@end iftex
@ifnottex
@anchor{Listing 3.2}
@center @emph{Listing 3.2.@:  Inserting Modules Example (cont'd)}
@end ifnottex
@end cartouche

Next, the character conversion module (named @file{chconv}) is pushed onto the open @dfn{Stream}
using the @ioctlref{I_PUSH} @manref{ioctl(2)} command.

@cartouche
@iftex
@float Listing,Listing 3.3
@end iftex
@smallexample
    if (ioctl(fd, I_PUSH, "chconv") < 0) @{
        perror("ioctl  I_PUSH failed");
        exit(2);
    @}
@end smallexample
@iftex
@caption{@emph{Inserting Modules Example (cont'd)}}
@end float
@end iftex
@ifnottex
@anchor{Listing 3.3}
@center @emph{Listing 3.3.@:  Inserting Modules Example (cont'd)}
@end ifnottex
@end cartouche

The difference in creating an instance of a @dfn{STREAMS} driver and module are illustrated in
@ref{Listing 3.2} and @ref{Listing 3.3}.  An instance of a driver is created with the
@manref{open(2)} system call, and each driver requires at least one device node in a file system for
access.  Naming of device nodes follow device naming conventions.  On the other hand, an instance of
a module is created with the @ioctlref{I_PUSH} @manref{ioct(2)} command.  No file system device node
is required.  Naming of modules is separate from any file system considerations, and are chosen by
the module writer.  The only restrictions on a module name is that it be less than
@constant{FMNAMESZ} in length, and that it be unique.

When successful, the @ioctlref{I_PUSH} @manref{ioctl(2)} call directs @dfn{STREAMS} to locate and
insert the @dfn{STREAMS} module named @file{chconv} onto the @dfn{Stream}.  If the @file{chconv}
module has not been loaded into the @cite{Linux} kernel, @cite{@value{PACKAGE_TITLE}} will attempt
to demand load the kernel module named @file{streams-chconv}.  Once the @file{chconv} @dfn{STREAMS}
module is loaded in the kernel, @dfn{STREAMS} will create a queue pair for the instance of the
module, insert it into the @dfn{Stream} beneath the @dfn{Stream head}, and call the module's
@command{open} procedure.  If the module's @command{open} procedure returns an error (typically only
@errno{ENXIO}), that error will be returned to the @manref{ioctl(2)} call.  If the module's
@command{open} procedure is successful, it (and the @manref{ioctl(2)} call), return @samp{0}.  The
resulting @dfn{Stream} configuration is illustrated in @figref{17}.

@figuresized{SPG_fig17,17,Case Converter Module,3in}

Modules are always pushed and popped from the position immediately beneath the @dfn{Stream head} in
the manner of a push-down stack.  This results in a @dfn{Last-In-First-Out (LIFO)} order of modules
being pushed and popped.  For example, if another module were to be pushed on the @dfn{Stream}
illustrated in @figref{17}, it would be placed between the @dfn{Stream head} and the @dfn{Character
Converter} module.

@node Module and Driver Control
@subsubsection Module and Driver Control

The next steps in this example are to pass control information to the module to tell it what command
to execute on which string of characters.  A sequence that acheives this is shown in @ref{Listing
3.4}.  The sequence makes use of the @ioctlref{I_STR} @manref{ioctl(2)} command for @dfn{STREAMS}
special files.

@cartouche
@iftex
@float Listing,Listing 3.4
@end iftex
@smallexample
/* change all uppercase vowels to lowercase */
strioctl.ic_cmd = XCASE;
strioctl.ic_timout = 0;         /* default timeout (15 sec) */
strioctl.ic_dp = "AEIOU";
strioctl.ic_len = strlen(strioctl.ic_dp);

if (ioctl(fd, I_STR, &strioctl) < 0) @{
    perror("ioctl I_STR failed");
    exit(3);
@}

/* delete all instances of trhe chars 'x' and  'X' */
strioctl.ic_cmd = DELETE;
strioctl.ic_dp = "xX";
strioctl.ic_len = strlen(strioctl.ic_dp);

if (ioctl(fd, I_STR, &strioctl) < 0) @{
    perror("ioctl I_STR failed");
    exit(4);
@}
@end smallexample
@iftex
@caption{@emph{Module and Driver Control Example}}
@end float
@end iftex
@ifnottex
@anchor{Listing 3.4}
@center @emph{Listing 3.4.@:  Module and Driver Control Example}
@end ifnottex
@end cartouche

There exist two methods for controlling modules and drivers using the @manref{ioctl(2)} system call:

@table @dfn

@item Transparent

In a transparent @manpage{ioctl(2)} call, the @var{cmd} argument to the call is the command issued
to the module or device, and the @var{arg} argument is specific to the command and defined by the
receiver of the command.  This is the traditional method of controlling character devices and can
also be supported by a @dfn{STREAMS} module and driver.

@item I_STR

In an @streamio{I_STR} @manpage{ioctl(2)} call, the @var{cmd} argument to the call is
@streamio{I_STR} and the @var{arg} argument of the call is a pointer to a @type{strioctl}
structure (defined in @header{sys/stropts.h}) describing the particulars of the call.  This method
is specific to @dfn{STREAMS} special files.

It is this later method that illustrated in @ref{Listing 3.4}.

@end table

The @type{strioctl} structure, defined in @header{sys/stropts.h}, has the following format:

@cartouche
@smallexample
struct strioctl @{
    int ic_cmd;                         /* ioctl request */
    int ic_timout;                      /* ACK/NAK timeout */
    int ic_len;                         /* length of data argument */
    char *ic_dp;                        /* ptr to data argument */
@};
@end smallexample
@end cartouche

@multitable @columnfractions .15 .85
@item @member{ic_cmd}
@tab identifies the command intended for a module or driver,
@item @member{ic_timout}
@tab specifies the number of seconds an @streamio{I_STR} request should wait for an acknowledgement
before timing out,
@item @member{ic_len}
@tab is the number of bytes of data to accompany the request, and
@item @member{ic_dp}
@tab points to that data.
@end multitable

In the @ref{Listing 3.4}, two commands are issued to the character conversion module,
@constant{XCASE} and @constant{DELETE}.@footnote{These commands are fictitious.}

To issue the example @constant{XCASE} command, @member{ic_cmd} is set to the command,
@constant{XCASE}, and @member{ic_dp} and @member{ic_len} are set to the the string @samp{AEIOU}.
Upon receiving this command, the example module will convert uppercase vowels to lowercase in the
data subsequently passing through the module.  @member{ic_timout} is set to zero to indicated that
the default timeout (@samp{15} seconds) should be used if no response is received.

To issue the example @constant{DELETE} command, @member{ic_cmd} is set to the command,
@constant{DELETE}, and @member{ic_dp} and @member{ic_len} are set to the the string @samp{xX}.  Upon
receiving this command, the example module will delete all occurrences of the characters @samp{X}
and @samp{x} from data subsequently passing through the module.  @member{ic_timout} is set to zero
to indicated that the default timeout (@samp{15} seconds) should be used if no response is received.

Once issued, the @dfn{Stream head} takes an @streamio{I_STR} @manpage{ioctl(2)} command and packages
its contents into a @dfn{STREAMS} message consisting of an @msg{M_IOCTL} block and a @msg{M_DATA}
block and passes it downstream to be considered by modules and drivers on the @dfn{Stream}.  The
@member{ic_cmd} and @member{ic_len} values are stored in the @msg{M_IOCTL} block and the data
described by @member{ic_dp} and @member{ic_len} are copied into the @msg{M_DATA} block.  Each
module, and ultimately the driver, examines the @member{ioc_cmd} filed in the @msg{M_IOCTL} message
to see if the command is known to it.  If the command is unknown to a module, it is passed
downstream for consideration by other modules on the @dfn{Stream} or for consideration by the
driver.  If the command is unknown to a driver, it is negatively acknowledged and a error is
returned from the @manref{ioctl(2)} call.

The user level process calling @manref{ioctl(2)} with the @ioctlref{I_STR} command will block
awaiting an acknowledgement.  The calling process will block up to @member{ic_timout} seconds
waiting for a response.  If @member{ic_timout} is @samp{0}, it indicates that the default timeout
value (typically @samp{15} seconds) should be used.  If @member{ic_timout} is @samp{-1}, it
indicates that an infinite timeout should be used.  If the timeout occurs, the @manref{ioctl(2)}
command will fail with error @errno{ETIME}.  Only one process (thread) can be executing an
@ioctlref{I_STR} @manref{ioctl(2)} call on a given @dfn{Stream} at time.  If an @streamio{I_STR} is
being executed when another process (or thread) issues an @streamio{I_STR} of its own, the process
(or thread) will block until the previous @streamio{I_STR} operation completes.  However, the
process (or thread) will not block indefinitely if @member{ic_timout} is set to a finite timeout
value.

When successful, the @streamio{I_STR} command returns the value defined by the command operation
itself, and also returns any information to be returned in the area pointed to by @member{ic_dp} on
the call.  The @member{ic_len} member is ignored for the purposes of returning data, and it is the
caller's responsibility to ensure that the buffer pointed to by @member{ic_dp} is large enough to
hold the returned data.

@node Stream Dismantling with Modules
@subsubsection Stream Dismantling with Modules

As shown in @ref{Listing 3.5}, the remainder of this example follows the example in @ref{Listing
1.1} in @ref{Basic Streams Operations}: data is read from the @dfn{Stream} and then echoed back to
the @dfn{Stream}.

@cartouche
@iftex
@float Listing,Listing 3.5
@end iftex
@smallexample
    while ((count = read(fd, buf, BUFLEN)) > 0) @{
        if (write(fd, buf, count) != count) @{
            perror("write failed");
            break;
        @}
    @}
    exit(0);
@}
@end smallexample
@iftex
@caption{@emph{Module and Driver Control Example (cont'd)}}
@end float
@end iftex
@ifnottex
@anchor{Listing 3.5}
@center @emph{Listing 3.5.@:  Module and Driver Control Example (cont'd)}
@end ifnottex
@end cartouche

The @manref{exit(2)} system call in @ref{Listing 3.5} will results in the dismantling of the
@dfn{Stream} as it is closed.  However, in this example, when the @dfn{Stream} is closed with the
@file{chconv} module still present on the @dfn{Stream}, the module is automatically popped as the
@dfn{Stream} is dismantled.

Alternatively, it is possible to explicitly pop the module from the @dfn{Stream} using the
@ioctlref{I_POP} @manref{ioctl(2)} command.  The @streamio{I_POP} command removes the module that
exists immediately below the @dfn{Stream head}.  It is not necessary to specify the module to be
popped by name: whatever module exists just beneath the @dfn{Stream head} will be popped.

@node Stream Construction Example Summary
@subsubsection Stream Construction Example Summary

This example provided illustration of the ability of @dfn{STREAMS} to modify the behaviour of a
driver without the need to modify driver code.  A @dfn{STREAMS} module was pushed that provided the
extended behaviour independent of the underlying driver.  The @streamio{I_PUSH} and @streamio{I_POP}
commands used to push and pop @dfn{STREAMS} modules were also illustrated by the example.

Many other @manref{streamio(7)} @manpage{ioctl} commands are available to the applications
programmer to manipulate and interrogate configuration and other characteristics of a @dfn{Stream}.
See @manref{streamio(7)} for details.

@c ============================================================================
@node Processing
@chapter Processing
@menu
* Procedures::			STREAMS Put and Service Procedures
* Asynchronous Example::	STREAMS Asynchronous Stream Example
@end menu

Each module or driver queue pair has associated with it @command{open} @command{close} and
optionally @command{admin} procedures.  These procedures are specified by the @member{qi_qopen},
@member{qi_qclose} and @member{qi_qadmin} function pointers in the @mantype{qinit(9)} structure
associated with the read-side @mantype{queue(9)} of the queue pair.  The @command{open} and
@command{close} procedures was the focus of previous chapters.

Each @mantype{queue(9)} in a module or driver queue pair has associated with it a @command{put} and
optional @command{serivce} procedure.  These procedures are specified by the @member{qi_putp} and
@member{qi_srvp} function pointers in the @mantype{qinit(9)} structure associated with each
@mantype{queue(9)} in the queue pair.  The @command{put} and @command{sevice} procedures are
responsible for the processing of messages the implementation of flow control, and are the focus of
this chapter.

@c ----------------------------------------------------------------------------
@node Procedures
@section Procedures

The @command{put} and @command{service} procedures associated with a given @manref{queue(9)} in a
module queue pair are reponsible for the processing of messages entering and leaving the queue.
Processing within these procedures is performed according to the message type of the message being
processed.  Messages can be modified, queued, passed in either direction on a @dfn{Stream}, freed,
copied, duplicated, or otherwise manipulated.  In processing for typical filter module, a resulting
message is normally passed along the @dfn{Stream} in the same direction it was travelling when it
was received.

A queue must always have a @command{put} procedure.  The @command{put} procedure will be invoked
when messages are passed to the queue from an upstream or downstream module.  A @command{put}
procedure will either process the message immediately, or place the message on its queue awaiting
later processing by the module or driver's @command{service} procedure.

Optionally, a queue can also have an associated @command{service} procedure.  The @command{service}
procedure is responsible for processing the backlog of any queued messages from the message queue.

With both a @command{put} and @command{service} procedure it is possible to tune performance of a
module or driver by performing actions required immediately from the @command{put} procedure while
performing actions that can be deferred from the @command{service} procedure.  The @command{service}
procedure provides for the implementation of flow control and can also be used to promote bulk
processing of messages.

The @command{put} and particularly the @command{service} procedures are not directly associated with
any user level process.  They are kernel level coroutines that normally run under the context of the
@dfn{STREAMS Scheduler} kernel thread.@footnote{Under some restricted circumstances, a module or
driver @command{put} procedure is run under a user context when invoked from a @dfn{Stream head}, or
under an interrupt service routine or software interrupt when invoked from a @dfn{Stream end}
(@dfn{driver}).}

@subsection Put Procedure

The @command{put} procedure is invoked whenever a message is passed to a queue.  A message can be
passed to a queue using the @manref{put(9)}, @manref{putnext(9)}, @manref{putctl(9)},
@manref{putctl1(9)}, @manref{putctl2(9)}, @manref{putnextctl(9)}, @manref{putnextctl1(9)},
@manref{putnextctl2(9)}, @manref{qreply(9)} @dfn{STREAMS} utilities.  The @dfn{Stream head}, modules
and drivers use these utilities to deliver messages to a queue.@footnote{The @member{qi_putp}
procedure should not be called directly.} Invoking the @command{put} procedure of a queue with one
of these utilities is the only accepted way of passing a message to a queue.@footnote{In special
circumstances, such as in a @dfn{Stream end} or driver, it is possible to use @dfn{putq(9)} to place
a message on a queue to be later retreived by the driver's @command{service} procedure; however,
this practice is the same as seting the driver's @member{qi_putp} pointer to @manref{putq(9)}.}

A queue's @command{put} procedure is specified by the @member{qi_putp} member of the
@mantype{qinit(9)} structure associated with the @mantype{queue(9)}.  This is illustrated in
@figref{18a}.  In general, the read- and write-side queues of a module or driver have different
@mantype{qinit(9)} structures associated with them as there are differences in upstream and
downstream message processing; however, it is possible for read- and write-side queues to share the
same @mantype{qinit(9)} structure.

@figuresized{SPG_fig18a,18a,Put Procedure Example,4in}

The @command{put} procedure processes a message immediately or places it onto the message queue for
later processing (generally by the @command{service} procedure).  Because the @command{put}
procedure is invoked before any queueing takes place, it provides a processing point at which the
module or driver can take actions on time critical messages.  @command{put} procedures are
executed a higher priority than @command{service} prcedures.  @command{put} propcedures in the
upstream direction may even be executed with interrupts disabled.

As illustrated in @figref{18a}, when a queue's @command{put} procedure is invoked by an adjacent
queue's @command{put} procedure (e.g. using @manref{putnext(9)}), the @member{qi_putp} member of the
queue's associated @mantype{qinit(9)} structure is invoked by @dfn{STREAMS} as subroutine call.

When a number of modules are present in a @dfn{Stream}, as illustrated in @figref{18a}, each
successive direct invocation of a @command{put} procedure is nested inside the others.  For example,
if the @command{put} procedure on the read-side of the driver is invoked by calling @manref{put(9)}
from the driver's interrupt service routine, and then each successive @command{put} procedure calls
@manref{putnext(9)}, by the time that the message reaches the @dfn{Stream head}, the driver,
@samp{ModA}, @samp{ModB}, @samp{ModC}, and the @dfn{Stream head} @command{put} procedures will be
nested within another.

The advantage of this approach is that @command{put} processing is invoked sequentially and
immediately.  A disadvantage of this approach is that, if there are additional stack frames nested
in each @command{put} procedure, the interrupt service routine stack limits can be exceeded, causing
a kernel crash.  This is also the case for normal (non-ISR) operation and the kernel stack limits
might be exceeded if execessive nesting of @command{put} procedures occurs.@footnote{Because the
@dfn{Interrupt Service Routine (ISR)} stack is particularly limited, @manref{put(9)} should not be
called from @samp{in_irq()} context under @cite{Linux}, execution of @manref{put(9)} should be
deferred by the ISR, either with an immediate bottom half procedure (i.e., software interrupt), or
by placing messages on the driver queue and processing from the queue's @command{service}
proceedure: either of which run with a full kernel stack instead of an interrupt stack.}

The driver and module writers need to be congnizant of the fact that a limited stack might exist at
the time that the @command{put} procedure is invoked.  However, @dfn{STREAMS} also provides the
@command{service} procedure as a way to defer processing to a @samp{!in_irq()} context.

@subsection Service Procedure

Each queue in module or driver queue pair can also have a @command{service} procedure associated
with it.

A queue's @command{service} procedure is specified by the @member{qi_srvp} member of the
@mantype{qinit(9)} structure associated with the @mantype{queue(9)}.  If a queue does not have a
@command{service} procedure, the associated @member{qi_srvp} member is set to @constant{NULL}.  If
the queue has a @command{service} procedure, the associated @member{qi_srvp} member points to the
@command{service} procedure function.  As with @command{put} procedures, in general, the read- and
write-side queues of a module or driver have different @mantype{qinit(9)} structure associated with
them as there are normally differences between the upstream and downstream message processing;
however, it is possible for read- and write-side queues to share the same @mantype{qinit(9)}
structure.

A queue's @command{service} procedure is never invoked directly by an adjacent module or driver.
Adjacent modules or drivers invoke a queue's @command{put} procedure.  The @command{put} procedure
can then defer processing to the @command{service} procedure in a number of ways.  The most direct
way that a @command{put} procedure can invoke a @command{service} procedure for a message is to
place that message on the message queue using @manref{putq(9)}.  Once the message is placed on the
message queue in this manenr, the @command{put} procedure can return, freeing the associated stack
frame.  Also, placing a message on the message queue with @manref{putq(9)} will normally result in
the queue's @command{service} procedure being @dfn{scheduled} for later execution by the
@dfn{STREAMS} scheduler.

Note that the @dfn{STREAMS} scheduler is separate and distinct from the @cite{Linux} scheduler.  The
@cite{Linux} scheduler is responsible for scheduling tasks, whereas the @dfn{STREAMS} scheduler is
only responsible for scheduling the execution of queue @command{service} procedures (and a few other
deferrable @dfn{STREAMS} housekeeping chores).  The @dfn{STREAMS} scheduler executes pending queue
@command{service} procedures on a @dfn{First-Come-First-Served (FCFS)} basis.  When a queue's
@command{service} procedure is scheduled, its @mantype{queue(9)} structure is linked onto the tail
of the list of queues awaiting @command{service} procedure execution for the @dfn{STREAMS}
scheduler.  When the @dfn{STREAMS} scheduler runs queues, each queue on the list is unlinked,
starting at the head of the list, and its @command{service} procedure executed.

To provide reponsive scheduling of @command{service} procedures without necessarily requiring a task
switch (to the @dfn{STREAMS} kernel thread), the @dfn{STREAMS} scheduler is invoked and queue
@command{service} procedures executed within user context before returning to user level from any
@dfn{STREAMS} system call.

Processing of messages within a queue @command{service} procedure is performed by taking messages
off of the message queue and processing them in order.  Because messages a queued on the message
queue with consideration to the priority class of the message, messages of higher priority are
processed by the @command{service} procedure first.  However, providing that no other condition
impedes further processing of messages (e.g. flow control, inability to obtain a message block),
@command{service} procedures process all of the messages on the message queue available to them and
then return.  Because @command{service} procedures are invoked by the @dfn{STREAMS} scheduler on a
@dfn{FCFS} basis, a priority message on a queue does not increase the scheduling priority of a
queue's @command{service} procedure with respect to other queue @command{service} procedures: it
only affects the priority of processing one message on message queue with respect to other messages
on the queue.  As a result, higher priority messages will experience a shorter processing latency
that lower priority messages.

In general, because drivers run at a software priority higher than the @dfn{STREAMS} scheduler,
drivers calling @manref{put(9)} can cause multiple messages to be queued for service before the
@command{service} procedure runs.  On the other hand, because the @dfn{STREAMS} scheduler is always
invoked before return to user level at the end of a system call, it is unlikely that the @dfn{Stream
head} calling @manref{put(9)} will result in mutliple messages being accumulated before the
corresponding @command{service} procedure runs.

@subsection Put and Service Procedure Summary

Processing of messages can be divided between @command{put} and @command{service} procedures to meet
the requirements for @dfn{STREAMS} processing, and to meet the demands of the module or driver.
Some message types might be processed entirely within the @command{put} procedure.  Others might be
processed only with the @command{service} procedure.  A third class of messages might have
processing split between @command{put} and @command{service} procedures.  Processing of upstream and
downstream messages can be independent, giving consideration to the needs of each message flow.  The
mechanism allows a flexible arrangement for the module and driver writer.

@command{put} and @command{service} procedures are addressed in more detail under @ref{Modules and
Drivers}.  Design guildlines for @command{put} and @command{service} processing are given in
@ref{Design Guidlines}, @ref{Module Design Guidlines}, and @ref{Driver Design Guidlines}.

@c ----------------------------------------------------------------------------
@node Asynchronous Example
@section Asynchronous Example

@ignore
In the following example, our computer runs the @b{Linux} system and supports different kinds of
asynchronous terminals, each logging in on its own port.  The port hardware is limited in function;
for example, it detects and reports line and modem status, but does not check parity.

Communications software support for these terminals is provided via a @dfn{STREAMS} based
asynchronous protocol.  The protocol includes a variety of options that are set when a terminal
operator dials in to log on.  The options are determined by a @dfn{STREAMS} user process,
@command{getstrm}, which analyzes data sent to it through a series of dialogs (prompts and
responses) between the process and terminal operator.

The process sets the terminal options for the duration of the connection by pushing modules onto the
@dfn{Stream} or by sending control messages to cause changes in modules (or in the device driver)
already on the @dfn{Stream}.  The options supported include:

@itemize @bullet
@item @dfn{ASCII} or @dfn{EBCDIC} character codes
@item For @dfn{ASCII} code, the parity (odd, even or none)
@item Echo or not echo input characters
@item Canonical input and output processing or transparent (raw) character handling
@end itemize

These options are set with the following modules:

@vtable @var
@item CHARPROC
Provides input character processing functions, including dynamically settable (via control messages
passed to the module) character echo and parity checking.  The module's default settings are to echo
characters and not check character parity.
@item CANONPROC
Performs canonical processing on @dfn{ASCII} characters upstream and downstream (note that this
performs some processing in a different manner from the standard @b{Linux} system character I/O
@dfn{tty} subsystem).
@item ASCEBC
Translates @dfn{EBCDIC} code to @dfn{ASCII} upstream and @dfn{ASCII} to @dfn{EBCDIC} downstream.
@end vtable

At system initialization a user process, @command{getstrm}, is created for each @dfn{tty} port.
@command{getstrm} opens a @dfn{Stream} to its port and pushes the @constant{CHARPROC} module onto the
@dfn{Stream} by use of an @command{ioctl} @ioctlref{I_PUSH} command.  Then, the process issues a getmsg
system call to the @dfn{Stream} and sleeps until a message reaches the @dfn{Stream} head.  The
@dfn{Stream} is now in its idle state.

The initial idle @dfn{Stream}, shown in @figref{18}, contains only one pushable module,
@constant{CHARPROC}.  The device driver is a limited function raw @dfn{tty} driver connected to a
limited-function communication port.  The driver and port transparently transmit and receive one
unbuffered character at a time.

@figuresized{SPG_fig18,18,Idle @dfn{Stream} Configuration for Example,3in}

Upon receipt of initial input from a @dfn{tty} port, @command{getstrm} establishes a connection with
the terminal, analyzes the option requests, verifies them, and issues @dfn{STREAMS} system calls to
set the options.  After setting up the options, @command{getstrm} creates a user application
process.  Later, when the user terminates that application, @command{getstrm} restores the
@dfn{Stream} to its idle state by use of similar system calls.

@figref{19} continues the example and associates kernel operations with user-level system calls.  As
a result of initializing operations and pushing a module, the @dfn{Stream} for port one has the
following configuration:

@figuresized{SPG_fig19,19,Operational @dfn{Stream} for Example,3in}

As mentioned before, the upstream queue is also referred to as the read queue reflecting the message
flow direction.  Correspondingly, downstream is referred to as the write queue.

@subsection Read-Side Processing

In our example, read-side processing consists of driver processing, @constant{CHARPROC} processing, and
@constant{CANONPROC} processing.

@subsubsection Driver Processing

The user process has been blocked on the @manpage{getmsg(2)} system call while waiting for a message
to reach the @dfn{Stream head}, and the device driver independently waits for input of a character
from the port hardware or for a message from upstream.  Upon receipt of an input character interrupt
from the port, the driver places the associated character in an @msg{M_DATA} message, allocated
previously.  Then, the driver sends the message to the @constant{CHARPROC} module by calling
@constant{CHARPROC}'s upstream put procedure.  On return from @constant{CHARPROC}, the driver calls the
@manpage{allocb(9)} utility routine to get another message for the next character.

@subsubsection CHARPROC

@constant{CHARPROC} has both @command{put} and @command{service} procedures on its read-side.  In the
example, the other queues in the modules also have both procedures:

@figuresized{SPG_fig20,20,Module Put and Service Procedures,3in}

When the driver calls @constant{CHARPROC}'s read queue @command{put} procedure, the procedure checks
private data flags in the queue.  In this case, the flags indicate that echoing is to be performed
(recall that echoing is optional and that we are working with port hardware which can not
automatically echo).  @constant{CHARPROC} causes the echo to be transmitted back to the terminal by first
making a copy of the message with a @dfn{STREAMS} utility routine.  Then, @constant{CHARPROC} uses
another utility routine to obtain the address of its own write queue.  Finally, the @constant{CHARPROC}
read @command{put} procedure calls its write @command{put} procedure and passes it the message copy.
The write procedure sends the message to the driver to effect the echo and then returns to the read
procedure.

This part of read-side processing is implemented with @command{put} procedures so that the entire
processing sequence occurs as an extension of the driver input character interrupt.  The
@constant{CHARPROC} read and write @command{put} procedures appear as subroutines (nested in the case of
the write procedure) to the driver.  This manner of processing is intended to produce the character
echo in a minimal time frame.

After returning from echo processing, the @constant{CHARPROC} read @command{put} procedure checks another
of its private data flags and determines that parity checking should be performed on the input
character.  Parity should most reasonably be checked as part of echo processing.  However, for this
example, parity is checked only when the characters are sent upstream.  This relaxes the timing in
which the checking must occur, that is, it can be deferred along with the canonical processing.
@constant{CHARPROC} uses @manpage{putq(9)} to schedule the (original) message for parity check processing
by its read @command{service} procedure.  When the @constant{CHARPROC} read @command{service} procedure
is complete, it forwards the message to the read @command{put} procedure of @constant{CANONPROC}.  Note
that if parity checking was not required, the @constant{CHARPROC} @command{put} procedure would call the
@constant{CANONPROC} @command{put} procedure directly.

@subsubsection CANONPROC

@constant{CANONPROC} performs canonical processing.  As implemented, all read queue processing is
performed in its @command{service} procedure so that @constant{CANONPROC}'s @command{put} procedure
simply calls @manpage{putq(9)} to schedule the message for its read @command{service} procedure and
then exits.  The @command{service} procedure extracts the character from the message buffer and
places it in the "line buffer" contained in another @msg{M_DATA} message it is constructing.  Then,
the message which contained the single character is returned to the buffer pool.  If the character
received was not an @dfn{end-of-line}, @constant{CANONPROC} exits.  Otherwise, a complete line has been
assembled and @constant{CANONPROC} sends the message upstream to the @dfn{Stream head} which unblocks the
user process from the @manpage{getmsg(2)} call and passes it the contents of the message.

@subsection Write-Side Processing

The write-side of this Stream carries two kinds of messages from the user process: @command{ioctl}
messages for @constant{CHARPROC}, and @msg{M_DATA} messages to be output to the terminal.

@command{ioctl} messages are sent downstream as a result of an @manpage{ioctl(2)} system call.  When
@constant{CHARPROC} receives an @command{ioctl} message type, it processes the message contents to modify
internal flags and then uses a utility routine to send an acknowledgement message upstream to the
@dfn{Stream head}.  The @dfn{Stream head} acts on the acknowledgement message by unblocking the user
from the @command{ioctl}.

For terminal output, it is presumed that @msg{M_DATA} messages, sent by @manpage{write(2)} system
calls, contain multiple characters.  In general, @dfn{STREAMS} returns to the user process
immediately after processing the @command{write} call so that the process may send additional
messages.  Flow control will eventually block the sending process.  The messages can queue on the
write-side of the driver because of character transmission timing.  When a message is received by
the driver's write @command{put} procedure, the procedure will use @manpage{putq(9)} to place the
message on its write-side service message queue if the driver is currently transmitting a previous
message buffer.  However, there is generally no write queue @command{service} procedure in a device
driver.  Driver output interrupt processing takes the place of scheduling and performs the
@command{service} procedure functions, removing messages from the queue.

@subsection Analysis

For reasons of efficiency, a module implementation would generally avoid placing one character per
message and using separate routines to echo and parity check each character, as was done in this
example.  Nevertheless, even this design yields potential benefits.  Consider a case where
alternate, more intelligent, port hardware was substituted.  If the hardware processed multiple
input characters and performed the echo and parity checking functions of @constant{CHARPROC}, then the
new driver could be implemented to present the same interface as @constant{CHARPROC}.  Other modules such
as @constant{CANONPROC} could continue to be used without modification.
@end ignore


@c ============================================================================
@node Messages
@chapter Messages
@menu
* Messages Overview::		STREAMS Messages Overview
* Message Structure::		STREAMS Message Structure
* Queues and Priority::		STREAMS Message Queues and Priority
* Service Interfaces::		STREAMS Service Interfaces
* Message Allocation::		STREAMS Message Allocation and Freeing
* Extended Buffers::		STREAMS Extended Buffers
@end menu

@c ----------------------------------------------------------------------------
@node Messages Overview
@section Messages Overview
@menu
* Message Type Overview::	STREAMS Message Type Overview
* Expedited Data::		STREAMS Handling of Expedited Data
@end menu

All communications between the @dfn{Stream head}, modules and drivers within the @dfn{STREAMS}
framework is based on message passing.  Control and data information is passed along the
@dfn{Stream} as opposed to direct function calls between modules.  Adjacent modules and driver are
invoked by passing pointers to messages to the target queue's @command{put} procedure.  This permits
processing to be deferred (i.e. to a @command{service} procedure) and to be subjected to flow
control and scheduling within the @dfn{STREAMS} framework.

At the @dfn{Stream head}, conversion between functional call based systems calls and the message
oriented @dfn{STREAMS} framework is performed.  Some system calls retrieve upstream messages or
information about upstream messages at the @dfn{Stream head} queue pair, others create messages and
pass them downstream from the @dfn{Stream head}.

At the @dfn{Stream end} (driver), conversion between device or pseudo-device actions and events and
@dfn{STREAMS} messages is performed in a similar manner to that at the @dfn{Stream head}.
Downstream control messages are consumed converted into corresponding device actions, device events
generate appropriate control messages and the driver sends these upstream.  Downstream messages
containing data are transferred to the device, and data received from the device is converted to
upstream data messages.

Within a linear segment from @dfn{Stream head} to @dfn{Stream end}, messages are modified, created,
destroyed and passed along the @dfn{Stream} as required by each module in the @dfn{Stream}.

Messages consist of a 3-tuple of a message block structure (@mantype{msgb(9)}), a data block
structure (@mantype{datab(9)}) and a data buffer.  The message block structure is used to provide an
instance of a reference to a data block and pointers into the data buffer.  The data block structure
is used to provide information about the data buffer, such as message type, separate from the data
contained in the buffer.  Messages are normally passed between @dfn{STREAMS} modules, drivers and
the @dfn{Stream head} using utilities that invoke the target module's @command{put} procedure, such
as @manref{put(9)}, @manref{putnext(9)}, @manref{qreply(9)}.  Messages travel along a @dfn{Stream}
with successive invocations of each driver, module and @dfn{Stream head}'s
@command{put} procedure.

@c ------------------------------------
@node Message Type Overview
@subsection Message Types

Each data block (@mantype{datab(9)}) is assigned a message type.  The message type discriminates the
use of the message by drivers, modules and the @dfn{Stream head}.  Message types are defined in
@header{sys/stream.h}.  Most of the message types may be assigned by a module or driver when it
generates a message, and the message type can be modified as a part of message processing.  The
@dfn{Stream head} uses a wider set of message types to perform its function of converting the
functional interface to the user process into the messaging interface used by @dfn{STREAMS} modules
and drivers.

Most of the defined message types are solely for use within the @dfn{STREAMS} framework.  A more
limited set of message types (@msg{M_PROTO}, @msg{M_PCPROTO} and @msg{M_DATA}) can be used to pass
control and data information to and from the user process via the @dfn{Stream head}.  These message
type can be generated and consumed using the @manref{read(2)}, @manref{write(2)},
@manref{getmsg(2)}, @manref{getpmsg(2s)}, @manref{putmsg(2)}, @manref{putpmsg(2s)} system calls and
some @manref{streamio(7)} @dfn{STREAMS} @manpage{ioctl(2)}.

Below the message types are classified by queueing priority, direction of normal travel (downstream
or upstream), and briefly described:

@subsubsection Ordinary Messages

Ordinary Messages (also called normal messages) are listed in the table below.
Messages with a @samp{D} beside them can normally travel in the @dfn{downstream} direction; with a
@samp{U}, @dfn{upstream}.  Messages with an @samp{H} beside them can be generated by the @dfn{Stream
head}; an @samp{M}, a module; an @samp{E}, the @dfn{Stream end} or driver.
Messages with an @samp{h} beside them are consumed and interpreted by the @dfn{Stream head}; an
@samp{m}, interpreted by a module; an @samp{e}, consumed and interpreted by the @dfn{Stream end} or driver.

The following message types are defined by @cite{SVR 4.2}:

@multitable @columnfractions .15 .05 .05 .08 .08 .59
@item @msg{M_DATA} @tab D @tab U @tab HME @tab hme @tab User data message for I/O system calls
@item @msg{M_PROTO} @tab D @tab U @tab HME @tab hme @tab Protocol control information
@item @msg{M_BREAK} @tab D @tab - @tab ME @tab me @tab Request to a @dfn{Stream} driver to send a "break"
@item @msg{M_PASSFP} @tab - @tab U @tab H @tab h @tab File pointer passing message@footnote{@msg{M_PASSFP} is never passed on the @dfn{Stream} but is placed on one @dfn{Stream head} directly by the opposite @dfn{Stream head} of a @dfn{STREAMS}-based pipe.}
@item @msg{M_SIG} @tab - @tab U @tab ME @tab h @tab Signal sent from a module/driver to a user
@item @msg{M_DELAY} @tab D @tab - @tab ME @tab me @tab Request a real-time delay on output
@item @msg{M_CTL} @tab D @tab U @tab ME @tab me @tab Control/status request used for inter-module communication
@item @msg{M_IOCTL} @tab D @tab - @tab H @tab me @tab Control/status request generated by a @dfn{Stream head}
@item @msg{M_SETOPTS} @tab - @tab U @tab ME @tab h @tab Set options at the @dfn{Stream head}, sent upstream
@item @msg{M_RSE} @tab D @tab U @tab ME @tab me @tab Reserved for internal use
@end multitable

The following message types are @emph{not} defined by @cite{SVR 4.2} and are
@cite{@value{PACKAGE_TITLE}} specific, or are specific to another @cite{SVR 4.2}-based
implementation:

@multitable @columnfractions .15 .05 .05 .08 .08 .59
@item @msg{M_EVENT}
@item @msg{M_TRAIL}
@item @msg{M_BACKWASH} @tab @tab @tab @tab @tab @cite{AIX} specific message for driver direct I/O.
@end multitable

Ordinary messages are described in detail throughout this chapter and in @ref{Message Types}.

@subsubsection High Priority Messages

High Priority Messages messae are listed in the table below.
Messages with a @samp{D} beside them can normally travel in the @dfn{downstream} direction; with a
@samp{U}, @dfn{upstream}.  Messages with an @samp{H} beside them can be generated by the @dfn{Stream
head}; an @samp{M}, a module; an @samp{E}, the @dfn{Stream end} or driver.
Messages with an @samp{h} beside them are consumed and interpreted by the @dfn{Stream head}; an
@samp{m}, interpreted by a module; an @samp{e}, consumed and interpreted by the @dfn{Stream end} or driver.

The following message types are defined by @cite{SVR 4.2}:

@multitable @columnfractions .15 .05 .05 .08 .08 .59
@item @msg{M_IOCACK} @tab - @tab U @tab ME @tab h @tab Positive @manpage{ioctl(2)} acknowledgement
@item @msg{M_IOCNAK} @tab - @tab U @tab ME @tab h @tab Negative @manpage{ioctl(2)} acknowledgement
@item @msg{M_PCPROTO} @tab D @tab U @tab HME @tab hme @tab Protocol control information
@item @msg{M_PCSIG} @tab - @tab U @tab ME @tab h @tab Signal sent from a module/driver to a user
@item @msg{M_READ} @tab D @tab - @tab H @tab me @tab Read notification, sent downstream
@item @msg{M_FLUSH} @tab D @tab U @tab HME @tab hme @tab Flush module queue
@item @msg{M_STOP} @tab D @tab - @tab ME @tab me @tab Suspend output
@item @msg{M_START} @tab D @tab - @tab ME @tab me @tab Restart stopped device output
@item @msg{M_HANGUP} @tab - @tab U @tab ME @tab h @tab Set a @dfn{Stream head} hangup condition, sent upstream
@item @msg{M_ERROR} @tab - @tab U @tab ME @tab h @tab Report downstream error condition, sent upstream
@item @msg{M_COPYIN} @tab - @tab U @tab ME @tab h @tab Copy in data for transparent@footnote{Transparent @command{ioctl}s support applications developed prior to the introduction of @dfn{STREAMS}.} @command{ioctl}s, sent upstream
@item @msg{M_COPYOUT} @tab - @tab U @tab ME @tab h @tab Copy out data for transparent@footnote{Ibid.} @command{ioctl}s, sent upstream
@item @msg{M_IOCDATA} @tab D @tab - @tab H @tab me @tab Data for transparent@footnote{Ibid.} @command{ioctl}s, sent downstream
@item @msg{M_PCRSE} @tab D @tab U @tab ME @tab hme @tab Reserved for internal use
@item @msg{M_STOPI} @tab D @tab - @tab ME @tab me @tab Suspend input
@item @msg{M_STARTI} @tab D @tab - @tab ME @tab me @tab Restart stopped device input
@end multitable

The following message types are @emph{not} defined by @cite{SVR 4.2} and are
@cite{@value{PACKAGE_TITLE}} specific, or are specific to another @cite{SVR 4.2}-based
implementation:

@multitable @columnfractions .15 .05 .05 .08 .08 .59
@item @msg{M_PCCTL} @tab D @tab U @tab ME @tab me @tab Same as @msg{M_CTL}, but high priority.
@item @msg{M_PCSETOPTS} @tab - @tab U @tab ME @tab h @tab Same as @msg{M_SETOPTS}, but high priority.
@item @msg{M_PCEVENT} @tab @tab @tab @tab @tab Same as @msg{M_EVENT}, but high priority.
@item @msg{M_UNHANGUP} @tab - @tab U @tab ME @tab h @tab Reverses a previous @msg{M_HANGUP} message.
@item @msg{M_NOTIFY}
@item @msg{M_HPDATA} @tab D @tab U @tab HME @tab hme @tab Same as @msg{M_DATA}, but high priority.
@item @msg{M_LETSPLAY} @tab @tab @tab @tab @tab @cite{AIX} specific message for driver direct I/O.
@item @msg{M_DONTPLAY} @tab @tab @tab @tab @tab @cite{AIX} specific message for driver direct I/O.
@item @msg{M_BACKDONE} @tab @tab @tab @tab @tab @cite{AIX} specific message for driver direct I/O.
@item @msg{M_PCTTY}
@end multitable

High Priority messages are described in detail throughout this chapter and in @ref{Message Types}.

@c ------------------------------------
@node Expedited Data
@subsection Expedited Data

@ignore
The @cite{Open Systems Interconnection (OSI) Reference Model} developed by the @cite{International
Standards Organization (ISO)} and @cite{International Telegraph and Telephone Consultative Committee
(CCITT)} provides an international standard seven-layer architecture for the development of
communication protocols.  @cite{AT&T} adheres to this standard and also supports the
@dfn{Transmission Control Protocol and Internet Protocol (TCP/IP)}.

@dfn{OSI} and @dfn{TCP/IP} support the transport of expedited data (see note below) for transmission
of high priority, emergency data.  This is useful for flow control, congestion control, routing, and
various applications where immediate delivery of data is necessary.

Expedited data are mainly for exceptional cases and transmission of control signals.  These are
emergency data that are processed immediately, ahead of normal data.  These messages are placed
ahead of normal data on the queue, but after @dfn{STREAMS} high priority messages and after any
expedited data already on the queue.

Expedited data flow control is unaffected by the flow control constraints of normal data transfer.
Expedited data have their own flow control because they can easily run the system out of buffers if
their flow is unrestricted.

Drivers and modules define separate high and low water marks for priority band data flow.  (Water
marks are defined for each queue and they indicate the upper and lower limit of bytes that can be
contained on the queue; see @msg{M_SETOPTS} in @pxref{Message Types}).  The default water marks for
priority band data and normal data are the same.  The @dfn{Stream} head also ensures that incoming
priority band data are not blocked by normal data already on the queue.  This is accomplished by
associating a priority with the messages.  This priority implies a certain ordering of the messages
in the queue.  (Message queues and priorities are discussed later in this chapter.)

Within the @dfn{STREAMS} mechanism and in this guide expedited data are also referred to as priority
band data.
@end ignore

@c ----------------------------------------------------------------------------
@node Message Structure
@section Message Structure
@menu
* Message Linkage::
* Sending and Receiving Messages::
* Control of Stream Head Processing::
@end menu

@dfn{STREAMS} messages consist of a chain of one or more message blocks.  A message block is a
triplet of a @mantype{msgb(9)} structure, a @mantype{datab(9)} structure, and a variable length data
buffer.  A message block (@mantype{msgb(9)} structure) is an instance of a reference to the data
contained in the data buffer.  Many message block structures can refer to a data block and data
buffer.  A data block (@mantype{datab(9)} structure) contains information not contained in the data
buffer, but directly associated with the data buffer (e.g., the size of the data buffer).  One and
only one data block is normaly associated with each data buffer.  Data buffers can be internal to
the message block, data block, data buffer triplet, automatically allocated using
@manref{kmem_alloc(9)}, or allocated by the module or driver and associated with a data block (i.e.,
using @manref{esballoc(9)}).

The @mantype{msgb(9)} structure is defined in @header{sys/stream.h} and has the following format and
members:

@cartouche
@smallexample
typedef struct msgb @{
        struct msgb *b_next;            /* next msgb on queue */
        struct msgb *b_prev;            /* prev msgb on queue */
        struct msgb *b_cont;            /* next msgb in message */
        unsigned char *b_rptr;          /* rd pointer into datab */
        unsigned char *b_wptr;          /* wr pointer into datab */
        struct datab *b_datap;          /* pointer to datab */
        unsigned char b_band;           /* band of this message */
        unsigned char b_pad1;           /* padding */
        unsigned short b_flag;          /* message flags */
        long b_pad2;                    /* padding */
@} mblk_t;
@end smallexample
@end cartouche

The members of the @mantype{msgb(9)} structure are described as follows:

@multitable @columnfractions .15 .85
@item @member{b_next} @tab points to the next message block on a message queue;
@item @member{b_prev} @tab points to the previous message block on a message queue;
@item @member{b_cont} @tab points to the next message block in the same message chain;
@item @member{b_rptr} @tab points to the beginning of the data (the point from which to read);
@item @member{b_wptr} @tab Points to the end of the data (the point from which to write);
@item @member{b_datap} @tab points to the associated datablock (@mantype{datab(9)});
@item @member{b_band} @tab indicates the priority band;
@item @member{b_pad1} @tab provides padding; and
@item @member{b_flag} @tab holds flags for this message block.  Flags are normally set only on the first
block of a message.  Valid flags are discussed below.
@item @member{b_pad2} @tab Reserved.@footnote{Note that @cite{@value{PACKAGE_TITLE}} does not
include the @member{b_pad2} member to reduce the size of the triplet and provide more room for a
cache-aligned internal data buffer.}
@end multitable

The @member{b_band} member determines the priority band of the message.  This member determines the
queueing priority (placement) in a message queue when the message type is an ordinary message
type.  High priority message types are always queued ahead of ordinary message types, and the
@member{b_band} member is always set to @samp{0} whenever a high priority message is queued by a
@dfn{STREAMS} utility function.  When @manref{allocb(9)} or @manref{esballoc(9)} are used to
allocate a message block, the @member{b_band} member is initially set to @samp{0}.  This member may
be modified by a module or driver.

@quotation
Note that in @cite{System V Release 4.0}, certain data structures fundamental to the kernel (for
example, device numbers, user IDs) were enlarged to enable them to hold more information.  This
feature was referred to as Expanded Fundamental Types (EFT).  Since some of this information was
passed in @dfn{STREAMS} messages, there was a binary compatibility issue for pre-@cite{System V
Release 4} drivers and modules.  @code{#ifdef}'s were added to the kernel to provide a transition
period for these drivers and modules to be recompiled, and to allow it to be built to use the
pre-@cite{System V Release 4} short data types or the @cite{System V Release 4} long data types.
Support for short data types will be dropped in some future releases.@footnote{System V Release 4
Programmer's Guide: STREAMS.}
@end quotation

The values that can be used in @member{b_flag} are exposed when @header{sys/stream.h} is included:

@cartouche
@smallexample
#define MSGMARK         (1<<0)  /* last byte of message is marked */
#define MSGNOLOOP       (1<<1)  /* don't loop mesage at stream head */
#define MSGDELIM        (1<<2)  /* message is delimited */
#define MSGNOGET        (1<<3)  /* UnixWare/Solaris/Mac OT/ UXP/V getq does not 
                                   return message */
#define MSGATTEN        (1<<4)  /* UXP/V attention to on read side */
#define MSGMARKNEXT     (1<<4)  /* Solaris */
#define MSGLOG          (1<<4)  /* UnixWare */
#define MSGNOTMARKNEXT  (1<<5)  /* Solaris */
#define MSGCOMPRESS     (1<<8)  /* OSF: compress like messages as space allows */
#define MSGNOTIFY       (1<<9)  /* OSF: notify when message consumed */
@end smallexample
@end cartouche

The following flags are defined by @cite{SVR 4.2}:

@multitable @columnfractions .25 .75
@item @constant{MSGMARK} @tab  last byte of message is marked
@item @constant{MSGNOLOOP} @tab  don't loop mesage at stream head
@item @constant{MSGDELIM} @tab  message is delimited
@end multitable

The following flags are @emph{not} defined by @cite{SVR 4.2} and are
@cite{@value{PACKAGE_TITLE}} specific, or are specific to another @cite{SVR 4.2}-based
implementation:

@multitable @columnfractions .25 .75
@item @constant{MSGNOGET} @tab  UnixWare/Solaris/Mac OT/ UXP/V getq does not return message
@item @constant{MSGATTEN} @tab  UXP/V attention to on read side
@item @constant{MSGMARKNEXT} @tab  Solaris
@item @constant{MSGLOG} @tab  UnixWare
@item @constant{MSGNOTMARKNEXT} @tab  Solaris
@item @constant{MSGCOMPRESS} @tab  OSF: compress like messages as space allows
@item @constant{MSGNOTIFY} @tab  OSF: notify when message consumed
@end multitable

@cartouche
@smallexample
typedef struct free_rtn @{
        void (*free_func) (caddr_t);
        caddr_t free_arg;
@} frtn_t;

typedef struct datab @{
        union @{
                struct datab *freep;
                struct free_rtn *frtnp;
        @} db_f;
        unsigned char *db_base;
        unsigned char *db_lim;
        unsigned char db_ref;
        unsigned char db_type;
        unsigned char db_class;
        unsigned char db_pad;
        unsigned int db_size;
#if 0
        unsigned char db_cache[DB_CACHESIZE];
#endif
#if 0
        unsigned char *db_msgaddr;
        long db_filler;
#endif
        /* Linux Fast-STREAMS specific members */
        atomic_t db_users;
@} dblk_t;

#define db_freep db_f.freep
#define db_frtnp db_f.frtnp
@end smallexample
@end cartouche

The following members are defined by @cite{SVR 4.2}:

@multitable @columnfractions .20 .80
@item @member{db_freep} @tab pointer to an external data buffer to be freed;
@item @member{db_frtnp} @tab pointer to an routine to free an extended buffer;
@item @member{db_base} @tab base of the buffer (first usable byte);
@item @member{db_lim} @tab limit of the buffer (last usable byte plus 1);
@item @member{db_ref} @tab numer of references to this data block by message blocks;
@item @member{db_type} @tab the data block type (i.e., @dfn{STREAMS} message type);
@item @member{db_class} @tab the class of the message (normal or high priority);
@item @member{db_iswhat} @tab another name for @member{db_class};
@item @member{db_pad} @tab padding;
@item @member{db_filler2} @tab another name for @member{db_pad};
@item @member{db_size} @tab size of the buffer;
@item @member{db_cache} @tab SVR 3.1 internal buffer;@footnote{This is an old SVR 3.1 member that
was used to contain the internal data buffer.  It is not longer at this location and this member is
not present in @cite{@value{PACKAGE_TITLE}}.}
@item @member{db_msgaddr} @tab pointer to @mantype{msgb(9)} structure allocated with this data block in a 3-tuple;@footnote{This
member is used by some implementations to locate the initial @mantype{msgb(9)} structure allocated
with this data block as a 3-tuple.  @cite{@value{PACKAGE_TITLE}} calculates this address from the
address of the data block itself and discards this member to reduce the overall size of the 3-tuple
and to increase the cache-aligned size of the internal data buffer.}
@item @member{db_filler} @tab filler; and,@footnote{@cite{@value{PACKAGE_TITLE}} discards this field
to reduce the overall size of the structure and to increase the cache-aligned size of the internal
data buffer.}
@end multitable

The following members are @emph{not} defined by @cite{SVR 4.2} and are @cite{@value{PACKAGE_TITLE}}
specific:

@multitable @columnfractions .20 .80
@item @member{db_users} @tab same as @member{db_ref} but atomic.
@end multitable

@c ------------------------------------
@node Message Linkage
@subsection Message Linkage

The message block (@mantype{msgb(9)} structure) provides an instance of a reference to the data
buffer associated with the message block.  Multiple message blocks can be chained together (with
@member{b_cont} pointers) into a composite message.  When multiple messages blocks are chained the
type of the first message block (its @member{db_type}) determines the type of the overall message.
For example, a message consisting of an @msg{M_IOCTL} message block followed by an @msg{M_DATA}
message block is considered to be an @msg{M_IOCTL} message.  Other message block members of the
first message block, such as @member{b_band}, also apply to the entire message.  The intial message
block of a message block chain can be queued onto a message queue (with the @member{b_next} and
@member{b_prev} pointers).  The chaining of message blocks into messages using the @member{b_cont}
pointer, and linkage onto message queues using the @member{b_next} and @member{b_prev} pointers, are
illustrated in @figref{21}.

@figuresized{SPG_fig21,21,Message Form and Linkage,5.5in}

A message can occur stand-alone (that is, it is not present on any message queue as it is in a
module or driver's @command{put} procedure) or can be queued on a message queue awaiting processing
by the queue's @command{service} procedure.  The @member{b_next} and @member{b_prev} pointers are
not significant for a stand-alone message and are initialized to @constant{NULL} by @dfn{STREAMS}
when the message is not queued on a message queue.

A message block is an instance of a reference to a data block (and therefore data buffer).  Multiple
message block can refer to the same data block.  This is illustrated in @figref{21}.  In the figure,
the second message block of @samp{Message 1} shares a data block with the second message block of
@samp{Message 2}.  Message blocks that share data blocks result from use of the @manref{dupb(9)} and
@manref{dupmsg(9)} @dfn{STREAMS} utilities.  The first of these utilities, @manref{dupb(9)}, will
duplicate a message block, obtiaining a new reference to the data block.  The @member{db_ref} member
of the associated data block will be increased by one to indicate the number of message blocks that
refer to this data block.  The second of these utilities, @manref{dupmsg(9)} duplicate all of the
message blocks in a message, following the @member{b_cont} pointers, resulting in a duplicated
message.

Duplication of message blocks provides an excellent way of obtaining a new reference to a data
buffer without the overhead of copying each byte of the buffer.  A common use of duplication is to
obtain a duplicate of a message to be held for retransmission, while another duplicate is passed to
the next module for transmission.

Despite the advantages of duplication, copying a message block or message chain is also possible
with the @manref{copyb(9)} and @manref{copymsg(9)} @dfn{STREAMS} utilities.  These utilities copy
the message block, data block, and data buffer for one message block (@manref{copyb(9)}) or each
message block in a chain (@manref{copymsg(9)}).

@figuresized{SPG_fig09,21b,Data Buffer References,3.75in}

Being a reference to a data buffer, the message block has two pointer into the data buffer
that define the range of data used by the reference.  The @member{b_rptr} indicates the beginning of
the range of data in the data buffer, and represents the position at which a module or driver would
begin reading data; the @member{b_wptr}, the end of the range of data, where a module or driver
would begin writing data.  The data block, on the other hand, has two pointers representing the
absolute limits of the data buffer.  The @member{db_base} indicates the begining of the data buffer;
@member{db_lim}, the end.  This relationship between pointers into the data buffer is illustrated in
@figref{21b}.

@dfn{STREAMS} provides a library of utility functions used to manipulate message blocks, data blocks
and data buffers.  The members of a message block or data block should not be manipulated directly
by the module or driver write: an appropriate @dfn{STREAMS} message utility should be used instead.
@xref{Utilities}.

@c ------------------------------------
@node Sending and Receiving Messages
@subsection Sending and Receiving Messages
@menu
* putmsg(2)::			Message oriented write(2)-like system call.
* getmsg(2)::			Message oriented read(2)-like system call.
* putpmsg(2s)::			Priority message write(2)-like system call.
* getpmsg(2s)::			Priority message read(2)-like system call.
@end menu

As shown in the message lists of @ref{Messages Overview}, a large subsset of the available message
types can be generated and consumed by modules and drivers.  Another subset, are dedicated to
generation and consumption by the @dfn{Stream head}.

Message types that are dedicated for passing control and data information between the @dfn{Stream}
and a user level process are the @msg{M_PROTO}, @msg{M_PCPROTO}, and @msg{M_DATA}
messages.@footnote{Some @cite{SVR 4.2}-based implementations also provide the @msg{M_HPDATA} message
for passing high priority data in the same fashion as @msg{M_DATA} messages.}
@dfn{STREAMS}-specific system calls are provided to user level processes so that they may exchange
@msg{M_PROTO}, @msg{M_PCPROTO} and @msg{M_DATA} message with a @dfn{Stream}.  This permits a user
level process to interact with the @dfn{Stream} in a similar fashion as a module on the
@dfn{Stream}, allowing user level processes to also present a service interface.@footnote{For a
complete applications framework based on @dfn{STREAMS} and service interfaces, see the
@url{http://www.cs.wustl.edu/~schmidt/ACE.html,ADAPTIVE Communications Environment (ACE)}
communications framework}.

In general, all system calls interact directly (by subroutine interface) with the @dfn{Stream head}.
An exception is the @manref{open(2)} and @manref{close(2)} system calls which directly invoke a
subroutine call to the module or driver @member{qi_qopen} and @member{qi_qclose} procedures.  All
other system calls call subroutines provided by the @dfn{Stream header} that can result in the
generation and transmission of a message on the @dfn{Stream} from the @dfn{Stream head}, or
consumption of a message at the @dfn{Stream head}.

The traditional @manref{write(2)} system call is capable of directly generating @msg{M_DATA}
messages and having them passed downstream.  The traditional @manref{read(2)} system call can
collect @msg{M_DATA} messages (and in some read modes, @msg{M_PROTO} and @msg{M_PCPROTO} messages)
that have arrived at the @dfn{Stream head}.  These system calls provide a backward compatible
interface for character device drivers implemented under @dfn{STREAMS}.@footnote{One example of
backwards compatibility to a character device driver implemented under @dfn{STREAMS} is the
@dfn{STREAM} implementation of terminal and pseudo-terminal devices.}

The @dfn{STREAMS}-specific @manref{putmsg(2)}, @manref{putpmsg(2s)} system calls provide the user
level process with the ability to directly generate @msg{M_PROTO}, @msg{M_PCPROTO} or @msg{M_DATA}
messages and have send downstream on the @dfn{Stream} from the @dfn{Stream head}.
@manref{getmsg(2)}, @manref{getpmsg(2s)} system calls provide the ability to collect @msg{M_PROTO},
@msg{M_PCPROTO} and @msg{M_DATA} messages from the @dfn{Stream head}.  These system calls are
superior to the @manref{write(2)} and @manref{read(2)} system calls in that the provide a finer
control over the composition of the generated message, and more information concerning the
composition of a consumed message.  Whereas, @manref{write(2)} and @manref{read(2)} pass only one
buffer from the user, @manref{putmsg(2)}, @manref{putpmsg(2s)}, @manref{getmsg(2)},
@manref{getpmsg(2s)} provide two buffers: one for the control part of the message to transfer
@msg{M_PROTO} or @msg{M_PCPROTO} message blocks with preservation of boundaries; another for the
data part, to transfer @msg{M_DATA} messages blocks -- all in a single call.  Also, data transfer
with @manref{write(2)} and @manref{read(2)} are by nature byte-stream oriented, whereas, control and
data transfer with @manref{putmsg(2)} and @manref{getmsg(2)} are by nature message oriented.
@manref{write(2)} and @manref{read(2)} provide no mechanism for assigning priority to messages
generated or indicating the priority of messages to be received: @manref{putpmsg(2s)} and
@manref{getpmsg(2s)} provide the ability to specify criteria for the band (@member{b_band}) of the
generated or consumed message.

@node putmsg(2)
@subsubsection putmsg(2)

@manref{putmsg(2)} provides the ability for a user level process to generate @msg{M_PROTO},
@msg{M_PCPROTO} and @msg{M_DATA} messages and have them send downstream on a @dfn{Stream}.  The user
specifies a control part of the message that is used to fill the @msg{M_PROTO} or @msg{M_PCPROTO}
message block in the resulting message, and a data part of the message that is used to fill the
@msg{M_DATA} message block in the resulting message.

The prototype for the @manref{putmsg(2)} system call is exposed by including the
@header{sys/stropts.h} system header file.  The prototype for the @manref{putmsg(2)} system call is
as follows:

@cartouche
@example
int @b{putmsg}(int @i{fildes}, const struct strbuf *@i{ctlptr},
           const struct strbuf *@i{dataptr}, int @i{flags});
@end example
@end cartouche

Where the arguments are interpreted as follows:

@table @var
@item fildes
specifies the @dfn{Stream} upon which to generate messages and is a file descriptor that was
returned by the corresponding call to @manref{open(2)} or @manref{pipe(2)} that created the
@dfn{Stream}.
@item ctlptr
is a pointer to a read-only @mantype{strbuf(5)} structure that is used to specify the control part
of the message.
@item dataptr
is a pointer to a read-only @mantype{strbuf(5)} structure that is used to specify the data part of
the message.
@item flags
specifies whether the control part of the message is to be of type @msg{M_PROTO} or of type
@msg{M_PCPROTO}.  It can have values @samp{0} (specifying that an @msg{M_PROTO} message be
generated) or @samp{RS_HIPRI} (specifying that an @msg{M_PCPROTO} message be generated).
@end table

The @var{ctlptr} and @var{dataptr} point to a @mantype{strbuf(5)} structure that is used to specify
the control and data parts of the message.  The @mantype{strbuf(5)} structure has the format and
members as follows:

@cartouche
@smallexample
struct strbuf @{
        int maxlen;     /* maximum buffer length */
        int len;        /* length of data */
        char *buf;      /* pointer to buffer */
@};
@end smallexample
@end cartouche

The members of the @mantype{strbuf(5)} structure are interpreted by @manref{putmsg(2)} as follows:

@multitable @columnfractions .15 .85
@item @member{maxlen} @tab specifies the maximum length of the buffer and is ignored by
@manref{putmsg(2)};
@item @member{len} @tab specifies the length of the data for transfer in the control or data part of
the message; and,
@item @member{buf} @tab specifies the location of the data buffer containing the data for transfer
in the control or data part of the message.
@end multitable

If @var{ctlptr} is set to @samp{NULL} on call, or the @member{len} member of the @mantype{strbuf(5)}
structure pointed to by @var{ctlptr} is set to @samp{-1}, then no control part (@msg{M_PROTO} or
@msg{M_PCPROTO} message block) will be placed in the resulting message.

If @var{dataptr} is set to @samp{NULL} on call, or the @member{len} member of the
@mantype{strbuf(5)} structure pointed to by @var{dataptr} is set to @samp{-1}, then no data part
(@msg{M_DATA} message block) will be placed in the resulting message.

For additional details, see the @manref{putmsg(2)} or @manref{putmsg(2p)} reference page.

@node getmsg(2)
@subsubsection getmsg(2)

@manref{getmsg(2)} provides the ability for a user level process to retrieve @msg{M_PROTO},
@msg{M_PCPROTO} and @msg{M_DATA} messages that have arrived at the @dfn{Stream head}.  The user
specifies an area into which to receive any control part of the message (from @msg{M_PROTO} or
@msg{M_PCPROTO} message blocks in the message), and an area into which to receive any data part of
the message (from @msg{M_DATA} message blocks in the message).

The prototype for the @manref{getmsg(2)} system call is exposed by including the
@header{sys/stropts.h} system header file.  The prototype for the @manref{getmsg(2)} system call is
as follows:

@cartouche
@example
int @b{getmsg}(int @i{fildes}, struct strbuf *@i{ctlptr}, struct strbuf *@i{dataptr},
           int *@i{flagsp});
@end example
@end cartouche

Where the arguments are interpreted as follows:

@table @var
@item fildes
specifies the @dfn{Stream} upon which to generate messages and is a file descriptor that was
returned by the corresponding call to @manref{open(2)} or @manref{pipe(2)} that created the
@dfn{Stream}.
@item ctlptr
is a pointer to an @mantype{strbuf(5)} structure that is used to specify the area to accept the
control part of the message.
@item dataptr
is a pointer to an @mantype{strbuf(5)} structure that is used to specify the area to accept the
data part of the message.
@item flagsp
is a pointer to an integer flags word that is used both to specify the criteria for the type of
message to be retrieved, on call, as well as indicating the type of the message retrieved, on
return.
@end table

On call, the integer pointed to by @var{flagsp} can contain @samp{0} indicating that the first
available message is to be retrieved regardless of priotity; or, @samp{RS_HIPRI}, indicating that
only the first high priority message is to be retrieved and no low priority message.
On successful return, the integer pointed to by @var{flagsp} will contain @samp{0} to indicate that
the message retrieved was an ordinary message (@msg{M_PROTO} or just @msg{M_DATA}), or
@samp{RS_HIPRI} to indicate that the message retrieved was of high priority (@msg{M_PCPROTO} or just
@msg{M_HPDATA}).

The members of the @mantype{strbuf(5)} structure are interpreted by @manref{getmsg(2)} as follows:

@multitable @columnfractions .15 .85
@item @member{maxlen} @tab specifies the maximum length of the buffer into which the message part is
to be writen;
@item @member{len} @tab ignored by @manref{getmsg(2)} on call, but set on return to indicate the
length of the data that was actually written to the buffer by @manref{getmsg(2)}; and,
@item @member{buf} @tab specifies the location of the data buffer to contain the data retrived for 
the control or data part of the message.
@end multitable

If @var{ctlptr} or @var{dataptr} are @samp{NULL} on call, or the @member{maxlen} field of the
corresponding @mantype{strbuf(5)} structure is set to @samp{-1}, then @manref{getmsg(2)} will not
retrieve the corresponding control or data part of the message.

For additional details, see the @manref{getmsg(2)} or @manref{getmsg(2p)} reference page.

@node putpmsg(2s)
@subsubsection putpmsg(2s)

@manref{putpmsg(2s)} is similar to @manref{putmsg(2)}, but provides the additional ability to
specify the queue priority band (@member{b_band}) of the resulting message.  The prototype for the
@manref{putpmsg(2s)} system call is exposed by including the @header{sys/stropts.h} system header
file.  The prototype for the @manref{putpmsg(2s)} system call is as follows:

@cartouche
@example
int @b{putpmsg}(int @i{fildes}, const struct strbuf *@i{ctlptr},
            const struct strbuf *@i{dataptr}, int @i{band}, int @i{flags});
@end example
@end cartouche

The arguments to @manref{putpmsg(2s)} are intepreted the same as those for @manref{putmsg(2)} as
described in @ref{putmsg(2)} with the exception of the @var{band} and @var{flags} arguments.

The @var{band} argument provides a band number to be placed in the @member{b_band} member of the
first message block of the resulting message.  @var{band} can only be non-zero if the message to be
generated is a normal message.

The @var{flags} argument is interpreted differently by @manref{putpmsg(2s)}: it can have values
@samp{MSG_BAND} or @samp{MSG_HIPRI}, but these are equivalent to the @samp{0} and @samp{RS_HIPRI}
flags for @manref{putmsg(2)}.

Under @cite{@value{PACKAGE_TITLE}},
@manref{putmsg(2)} is implemented as a library call to @manref{putpmsg(2s)}.  This is possible
because the call:

@smallexample
putmsg(fildes, ctlptr, dataptr, flags);
@end smallexample

is equivalent to:

@smallexample
putpmsg(fildes, ctlptr, dataptr, 0, flags);
@end smallexample

For additional details, see the @manref{putpmsg(2s)} or @manref{putpmsg(2p)} reference page.

@node getpmsg(2s)
@subsubsection getpmsg(2s)

@manref{getpmsg(2s)} is similar to @manref{getmsg(2)}, but provides the additional ability to
specify the queue priority band (@member{b_band}) of the retreived message.  The prototype for the
@manref{getpmsg(2s)} system call is exposed by including the @header{sys/stropts.h} system header
file.  The prototype for the @manref{getpmsg(2s)} system call is as follows:

@cartouche
@example
int @b{getpmsg}(int @i{fildes}, struct strbuf *@i{ctlptr}, struct strbuf *@i{dataptr},
            int *@i{bandp}, int *@i{flagsp});
@end example
@end cartouche

The arguments to @manref{getpmsg(2s)} are interpreted the same as those for @manref{getmsg(2)} as
described in @ref{getmsg(2)}, with the exception of the @var{bandp} and @var{flags} arguments.

The @var{bandp} argument points to a band number on call that specifies a criteria for use with
selecting the band of the retrieved message and returns the band number of the retrieved message
upon successful return.  The integer pointed to by @var{bandp} can take on values as follows:

@table @constant
@item MSG_ANY
Only specified on call.  Specifies that the first available message is to be retrieved, regardless
of priority or band.
@item MSG_BAND
On call, specifies that an orinary message of message band @var{bandp} or greater is to be retrieved.
On return, indicates that an ordinary message was retrieved of the band returned in @var{bandp}.
@item MSG_HIPRI
On call, specifies that a high priority message is to be retrieved.  On return, indicates that a
high priority message was retreived.
@end table

On call, @var{bandp} is ignored unless @var{flagsp} specifies @samp{MSG_BAND}.  When @samp{MSG_BAND}
is specified, @var{bandp} specifies the minimum band number of the message to be retrieved.  On
return, @var{bandp} indicates the band number (@member{b_band}) of the retrieved message, or
@samp{0} if the retreived message was a high priority message.

Under @cite{@value{PACKAGE_TITLE}},
@manref{getmsg(2)} is implemented as a library call to @manref{getpmsg(2s)}.  This is possible
because the calls:

@smallexample
int flags = 0;
getmsg(fildes, ctlptr, dataptr, &flags);

int flags = RS_HIPRI;
getmsg(fildes, ctlptr, dataptr, &flags);
@end smallexample

are equivalent to:

@smallexample
int band = 0;
int flags = MSG_ANY;
getpmsg(fildes, ctlptr, dataptr, &band, &flags);

int band = 0;
int flags = MSG_HIPRI;
getpmsg(fildes, ctlptr, dataptr, &band, &flags);
@end smallexample

For additional details, see the @manref{getpmsg(2s)} or @manref{getpmsg(2p)} reference page.

@c ------------------------------------
@node Control of Stream Head Processing
@subsection Control of Stream Head Processing
@menu
* Read Options::
* Write Options::
* Write Offset::
@end menu

@dfn{Stream head} message processing can be controlled by the user level process, or by a module or
driver within the @dfn{Stream}.

Modules and drivers can control @dfn{Stream head} processing using the @msg{M_SETOPTS} message.  At
any time, a module or driver can issue an @msg{M_SETOPTS} message upstream.  The @msg{M_SETOPTS}
contains a @mantype{stroptions(9)} structure (@pxref{Data Structures}) specifying which @dfn{Stream
head} characteristics to alter in the read-side queue of the @dfn{Stream head} (including
@member{q_hiwat}, @member{qi_lowat}, @member{q_minpsz} and @member{q_maxpsz}), however, of interest
to the current discussion are the read and write options associated with the @dfn{Stream head}.

User level processes can also alter the read and write options associated with the @dfn{Stream
head}.  User level processes use the @ioctlref{I_SRDOPT}, @ioctlref{I_GRDOPT}, @ioctlref{I_SWROPT}
and @ioctlref{I_GWROPT} @manref{ioctl(2)} commands to acheive the same purpose as the
@msg{M_SETOPTS} message used by modules and drivers.

@node Read Options
@subsubsection Read Options

Read options are altered by a user level process using the @ioctlref{I_SRDOPT} and
@ioctlref{I_GRDOPT} @manref{ioctl(2)} commands; or altered by a module or driver using the
@constant{SO_READOPT} flag and @member{so_readopt} member of the @mantype{stroptions(9)} data
structure contained in an @msg{M_SETOPTS} message passed upstream.

Two flags, each selected from two sets of flags, can be set in this manner.  The two sets of flags
are as follows:

@subsubsection Read Mode

The read mode affects how the @manref{read(2)} and @manref{readv(2)} system calls treat message
boundaries.  One read mode can be selected from the following modes:

@table @constant
@item RNORM
byte-stream mode.  This is the default read mode.  This is the normal byte-stream mode where message
boundaries are ignored.  @manref{read(2)} and @manref{readv(2)} return data until the read count has
been satisfied or a zero length message is received.
@item RMSGD
message non-discard mode.  The @manref{read(2)} and @manref{readv(2)} system calls will return when
either the count is satisfied, a zero length message is received, or a message boundary is
encountered.  If there is any data left in a message after the read count has been satisfied, the
message is placed back on the @dfn{Stream head} read queue.  The data will be read on a subsequent
@manref{read(2)} or @manref{readv(2)} call.
@item RMSGN
message discard mode.  Similar to @constant{RMSGN} mode, above, but data that remains in a message
after the read count has been satisfied is discarded.
@item RFILL
message fill mode.  Similar to @constant{RNORM} but requests that the @dfn{Stream head} fill a
buffer completely before returning to the application.  This is used in conjunction with a
cooperating module and @msg{M_READ} messages.@footnote{The @constant{RFILL} option is not defined by
@cite{SVR 4.2}, but is defined by some implementations based on @cite{SVR 4.2}.}
@end table

@subsubsection Read Protocol

The read protocol affects hos @manref{read(2)} and @manref{readv(2)} system calls treat the control
part of a message.  One read protocol can be selected from the following protocols:@footnote{Note
that earlier releases, such as @cite{UNIX System V Release 3.0}, did not support read protocols.
Under these earlier implementations, the read protocol was always @constant{RPROTNORM}.}

@table @constant
@item RPROTNORM
fail read when control part present.  Fail @manref{read(2)} with @errno{EBADMSG} if a message
containing a control part is at the front of the @dfn{Stream head} read queue.  Otherwise, the
message wi read as normal.  This is the default setting for new @dfn{Stream heads}.@footnote{This
setting is used with the @manref{timod(4)} module requiring the use of the @manref{tirdwr(4)} module
for use with the @manref{xti(3)} library.}
@item RPROTDAT
deliver control part of a message as data.  The control part of a message is prepended to the data
part and delivered.@footnote{This may be useful for specialized libraries or at the user's option with
@manref{timod(4)} or @manref{sockmod(4)} modules.}
@item RPROTDIS
discard control part of message, delivering only any data part.  The control part of the message is
discarded and the data part is processed.@footnote{This setting is used with the @manref{sockmod(4)} module,
or at the user's option with other modules or drivers.}
@item RPROTCOMPRESS
compress like data.@footnote{The @constant{RPROCOMPRESS} option is not defined by @cite{SVR 4.2},
but is defined by some implementations based on @cite{SVR 4.2}.}
@end table

Note that, although all modes terminate the read on a zero-length message, @cite{POSIX} requires
that zero only be returned from @manref{read(2)} when the requested length is zero or an end of file
(@msg{M_HANGUP}) has occurred.  Therefore, @cite{@value{PACKAGE_TITLE}} only returns on a
zero-length message if some data has been read already.

@node Write Options
@subsubsection Write Options

No mechanism is provided to permit a @manref{write(2)} system call to generate either a
@msg{M_PROTO} or @msg{M_PCPROTO} message.  The @manref{write(2)} system call will only generate one
or more @msg{M_DATA} messages.

Write options are altered by a user level process using the @ioctlref{I_SWROPT} and
@ioctlref{I_GWROPT} @manref{ioctl(2)} commands.  It is not possible for a module or driver to affect
these options with the @msg{M_SETOPTS} message.

@table @constant
@item SNDZERO
Permits the sending of a zero-length message downstream when a @manref{write(2)} of zero length is
issued.  Without this option being set, @manref{write(2)} will succeed and return @samp{0} if a
zero-lenth @manref{write(2)} is issued, but no zero-length message will be generated or sent.  This
option is the default for regular @dfn{Stream}, but is @emph{not} set by default for
@dfn{STREAMS}-based pipes.
@item SNDPIPE
Issues a @signal{SIGPIPE} signal to caller of @manref{write(2)} if the caller attempts to write to a
@dfn{Stream} that has received a hangup (@msg{M_HANGUP}) or an error (@msg{M_ERROR}).  When not set,
@signal{SIGPIPE} will not be signalled.  This option is the default for @dfn{STEAMS}-based pipes but
is @emph{not} set by default for regular @dfn{Streams}.
@item SNDHOLD
Requests that the @dfn{Stream head} hold messages temporarily in an attempt to coalesce smaller
messages into larger ones for efficiency.  This feature is largely deprecated, but is supported by
@cite{@value{PACKAGE_TITLE}}.  When not set (as is the default), messages are sent immediately.
This option is @emph{not} set by default for any @dfn{Stream}.
@end table

@node Write Offset
@subsubsection Write Offset

A write offset is provided as a option to allow for reservation of bytes at the beginning of the
@msg{M_DATA} message resulting from a call to the @manref{write(2)} system call.

The write offset can be altered by a module or driver using the @constant{SO_WROFF} flag and
@member{so_wroff} member of the @mantype{stroptions(9)} data structure contained in an
@msg{M_SETOPTS} message passed upstream.  It is not possible for a user level process to alter the
write offset using any @manref{streamio(7)} command.

The write offset associated with a @dfn{Stream head} determines the amount of space that the
@dfn{Stream head} will attempt to reserve at the beginning of the initial @msg{M_DATA} message
generated in response to the @manref{write(2)} system call.  The purpose of a write offset is to
permit modules and drivers to request that bytes at the beginning of a downstream messages be
reserved to permit, for example, the addition of protocol headers to the message as it passes
without the need to allocate additional message blocks and prepend them.

The write offset, however, is advisory to the @dfn{Stream head} and if it cannot include the offset,
a @msg{M_DATA} message with no offset may still be generated.  It is the responsibility of the
module or driver to ensure that sufficient bytes are reserved at the start of a message before
attempting to use them.

@c ----------------------------------------------------------------------------
@node Queues and Priority
@section Queues and Priority
@menu
Queue Priority Utilities::
Queue Priority Commands::
The queue Structure::
The qband Structure::
Message Processing::
Scheduling::
@end menu

Each queue in a @dfn{Stream} has associated with it a message queue that consists of a double linked
list of message blocks.  Messages are normally placed onto a message queue by the queue's
@command{put} procedure, and removed by the @command{service} procedure.  Messages will accumulate
in the message queue whenever the rate at which messages are place onto the message queue by the
@command{put} procedure exceeds the rate at which they are removed by the @command{service}
procedure.  The @command{service} procedure can become blocked for a number of reasons: the
@dfn{STREAMS} scheduler is delayed in invoking the @command{service} procedure due to higher
priority system tasks; the @command{service} procedure is awaiting a message block necessary to
complete its processing of a message; the @command{service} procedure is blocked by flow control
forward in the @dfn{Stream}.

When a queue @command{service} procedure runs, it take messages off of the message queue from the
head of the message queue in the order in which they appear in the queue.  Messages are queued
according to their priority: high priority messages appear first, followed by priority messages of
descending band number, followed by normal messages in band zero.  Within a band, messages are
processed in the order in which they arrived at the queue (that is, on a @dfn{First-In-First-Out
(FIFO)} basis).  High priority messages are also processed in the order in which they arrived at the
queue.  This ordering within the queue is illustrated in @figref{22}.


@figuresized{SPG_fig22,22,Message Ordering on a Queue,5in}

When a message is placed on a queue, (e.g., by @manref{putq(9)}), it is placed on the queue behind
messages of the same priority. High priority messages are not subjected to flow control.  Priority
messages will affect the flow control parameters in the @mantype{qband(9)} structure associated with
the band.  Normal messages will affect the flow control parameter in the @mantype{queue(9)}
structure.  Message priority range from @samp{0} to @samp{255}, where @samp{0} is the lowest
queueing priority and @samp{255} the highest.  High priority messages are considered to be of
greater priority than all other messages.

Bands can be used for any purpose required by a service interface.  For example, simple
@dfn{Expedited Data} implementation can be accomplished by using one band in addition to normal
messages, band @samp{1}.  This is illustrated in @figref{23}.

@figuresized{SPG_fig23,23,Message Ordering with One Priority Band,2.5in}

High priority messages are considered to be of greatest priority and are not subjected to flow
control.  High priority messages are a rare occurrence on the typical @dfn{Stream}, and the
@dfn{Stream head} only permits one high priority message (@msg{M_PCPROTO}) to be outstanding for a
user.  If a high priority message arrives at the @dfn{Stream head} and one is already waiting to be
read by the user, the message is discarded.  High priority messages are typically handled directly
from a queue's @command{put} procedure, but they may also be queued to the message queue.  When
queue, a high priority message will always cause the @command{service} procedure of the queue (if
any) to be scheduled for execution by the @dfn{STREAMS} scheduler.  When a @command{service}
procedure runs, and a message is retrieved from the message queue (e.g., with @manref{getq(9)}),
high priority messages will always be retrieved first.  High priority messges must be acted upon
immediately by a @command{service} procedure, it is not possible to place a high priority message
back on a queue with @manref{putbq(9)}.

@node Queue Priority Utilities
@subsection Queue Priority Utilities
@menu
* strqget(9)::
* strqset(9)::
@end menu

The following @dfn{STREAMS} utilities are provided to module and driver writers for use in
@command{put} and @command{service} procedures.  These utilities assist with handling flow control
within a @dfn{Stream}.

@table @manref
@item flushq(9)
@itemx flushband(9)
These utilities provide the ability to flush specific messages from a message queue.  They are
discussed under @ref{Flush Handling}, and under @ref{Utilities}.  These utilities are also described
in the corresponding manual page.
@item canput(9)
@itemx bcanput(9)
@itemx canputnext(9)
@itemx bcanputnext(9)
These utilities provide the ability to test the current or next queue for a flow control condition
for normal (band zero) messages or priority messages within a message band.  They are discussed
under @ref{Flow Control}, and under @ref{Utilities}.  These utilities are also described in the
corresponding manual page.
@item strqset(9)
@itemx strqget(9)
These utilities provide the ability to examine and modify flow control parameters associated with a
queue (@mantype{queue(9)}) or queue band (@mantype{qband(9)}).  They are discussed below, and under
@ref{Utilities}.  These utilities are also described in the corresponding manual page.
@end table

The @manref{strqget(9)} and @manref{strqset(9)} @dfn{STREAMS} utilities are provided to access and
modify members of the @mantype{queue(9)} and @mantype{qband(9)} data structures.  In general, the
specific members of these data structures should not be access directly by the module writer.  This
restriction is necessary for several reasons:

@itemize @bullet

@item The size and format of the @mantype{queue(9)} and @mantype{qband(9)} structures might change,
breaking binary modules compiled against the older definitions.  @manref{strqget(9)} and
@manref{strqset(9)} provide structure independent access to these members.

@item On @dfn{Symetric Multi-Processing (SMP)} architectures, it may be necessary to protect access
to a member of these structures to guarnatee atomicity of operations.  @manref{strqget(9)} and
@manref{strqset(9)} provide necessary locking on @dfn{SMP} architectures.

@end itemize

@node strqget(9)
@subsubsection strqget(9)

A declaration for the @manref{strqget(9)} utility is exposed by including the @header{sys/stream.h}
kernel header file.  The prototype is as follows:

@cartouche
@example
int @b{strqget}(queue_t *@i{q}, qfields_t @i{what}, unsigned char @i{band}, long *@i{val});
@end example
@end cartouche

Where the arguments are interpreted as follows:

@table @var
@item q
Specifies the @mantype{queue(9)} structure (and indirectly the @mantype{qband(9)} structure) from
which to retrieve a member.
@item what
Specifies which member to retrieve.  Specific values for various members are described below.
@item band
When zero, specifies that the member is to be retrieved from the @mantype{queue(9)} structure
specified by @var{q}; when non-zero, the band number of the @mantype{qband(9)} structure from which
to retrieve the member.
@item val
Points to a @type{long} value into which the result is to be placed.  All results are converted to a
@type{long} before being written to this location.
@end table

The @mantype{qfields_t(9)} enumeration is defined as follows:

@cartouche
@smallexample
typedef enum qfields @{
        QHIWAT,         /* hi water mark */
        QLOWAT,         /* lo water mark */
        QMAXPSZ,        /* max packet size */
        QMINPSZ,        /* min packet size */
        QCOUNT,         /* count */
        QFIRST,         /* first message in queue */
        QLAST,          /* last message in queue */
        QFLAG,          /* state */
        QBAD,           /* last (AIX and SUPER-UX) */
@} qfields_t;
@end smallexample
@end cartouche

Each value of the @mantype{qfields_t} enumeration specifies a different member to be set by
@manref{strqset(9)} or retrieved by @manref{strqget(9)}.  When @var{band} is zero, the member to be
set or retrieved is the corresponding member of the @mantype{queue(9)} structure indicated by
@var{q}.  When @var{band} is non-zero, the member to be set or retrieved is the corresponding member
of the @mantype{qband(9)} structure, associated with @var{q}, of band number @var{band}.

@multitable @columnfractions .15 .85
@item @constant{QHIWAT} @tab  Set or return the high water mark (@member{q_hiwat} or @member{qb_hiwat}).
@item @constant{QLOWAT} @tab Set or return the low water mark (@member{q_lowat} or @member{qb_lowat}).
@item @constant{QMAXPSZ} @tab Set or return the maximum packet size (@member{q_maxpsz} or @member{qb_maxpsz}).
@item @constant{QMINPSZ} @tab Set or return the minimum packet size (@member{q_minpsz} or @member{qb_minpsz}).
@item @constant{QCOUNT} @tab Return the count of bytes queued (@member{q_count} or @member{qb_count}).
This field is only valid for @manref{strqget(9)}.
@item @constant{QFIRST} @tab Return a pointer to the first message queued (@member{q_first} or @member{qb_first}).
This field is only valid for @manref{strqget(9)}.
@item @constant{QLAST} @tab Return a pointer to the last message queued (@member{q_last} or @member{qb_last}).
This field is only valid for @manref{strqget(9)}.
@item @constant{QFLAG} @tab Return the flags word (@member{q_flag} or @member{qb_flag}).
This field is only valid for @manref{strqget(9)}.
@ignore
@item @constant{QBAD} @tab
@end ignore
@end multitable

Additional information is given under @ref{Utilities}, and provided in the @manref{strqget(9)}
manual page.

@node strqset(9)
@subsubsection strqset(9)

A declaration for the @manref{strqset(9)} utility is exposed by including the @header{sys/stream.h}
kernel header file.  The prototype is as follows:

@cartouche
@example
int @b{strqset}(queue_t *@i{q}, qfields_t @i{what}, unsigned char @i{band}, long @i{val});
@end example
@end cartouche

Where the arguments are interpreted as follows:

@table @var
@item q
Specifies the @mantype{queue(9)} structure (and indirectly the @mantype{qband(9)} structure) to
which to write a member.
@item what
Specifies which member to write.  Specific values for various members are described above under
@ref{strqget(9)}.
@item band
When zero, specifies that the member is to be written to the @mantype{queue(9)} structure
specified by @var{q}; when non-zero, the band number of the @mantype{qband(9)} structure to which
to write the member.
@item val
Specifies the @type{long} value to write to the member.  All values are converted to a @type{long}
to be passed in this argument.
@end table

Additional information is given under @ref{Utilities}, and provided in the @manref{strqset(9)}
manual page.

@node Queue Priority Commands
@subsection Queue Priority Commands
@menu
* I_FLUSHBAND::
* I_CKBAND::
* I_GETBAND::
* I_CANPUT::
* I_ATMARK::
* I_GETSIG::
* I_SETSIG::
@end menu

Aside from the @manref{putpmsg(2)} and @manref{getpmsg(2)} system calls, a number of
@manref{streamio(7)} commands associated with queueing and priorities can be issued by a user level
process using the @manref{ioctl(2)} system call.  The intput output controls that accept a queue
band or indicate a queue band event are as follows:

@table @ioctlref
@item I_FLUSHBAND
Flushes the @dfn{Stream} for a specified band.
This @manref{ioctl(2)} command is equivalent to the @manref{flushq(9)} and @manref{flushband(9)}
utilities available to modules and drivers.  It is discussed under @ref{Flush Handling}.
@item I_CKBAND
Checks whether a message is available to be read from a specified queue band.
It is discussed below.
@item I_GETBAND
Gets the priority band associated with the next message on the @dfn{Stream head} read queue.
It is discussed below.
@item I_CANPUT
Checks whether messages can be written to a specified queue band.
This @manref{ioctl(2)} command is equivalent to the @manref{canput(9)} and @manref{bcanput(9)}
utilities available to modules and drivers.  It is discussed under @ref{Flow Control}.
@item I_ATMARK
This @manref{ioctl(2)} command supports @dfn{Transmission Control Protocol (TCP)} urgent data in a
byte-stream.  It indicates when a marked message has arrived at the @dfn{Stream head}.
It is discussed below.
@item I_GETSIG
@itemx I_SETSIG
Sets the mask of events for which the @dfn{Stream} head will send a calling process a
@signal{SIGPOLL} or @signal{SIGURG} signal.  Events include @constant{S_RDBAND}, @constant{S_WRBAND}
and @constant{S_BANDURG}.
This @manref{ioctl(2)} command is discussed under @ref{Input and Output Polling}.
@end table

The @manref{streamio(7)} input output controls in the following sections are all of the form:

@cartouche
@example
int @b{ioctl}(int @i{fildes}, int @i{cmd}, long @i{arg});
@end example
@end cartouche

@node I_FLUSHBAND
@subsubsection @code{I_FLUSHBAND}

Flushes the @dfn{Stream} for a specified band.
This @manref{ioctl(2)} command is equivalent to the @manref{flushq(9)} and @manref{flushband(9)}
utilities available to modules and drivers.  It is discussed under @ref{Flush Handling}.

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_FLUSHBAND}; and,
@item arg @tab is a pointer to a @mantype{bandinfo(9)} structure.
@end multitable

The @mantype{bandinfo(9)} structure is exposed by including the @header{sys/stropts.h} system header
file.  Its format and members are as follows:

@cartouche
@smallexample
struct bandinfo @{
        unsigned char bi_pri;
        int bi_flag;
@};
@end smallexample
@end cartouche

where,

@multitable @columnfractions .15 .85
@item bi_pri @tab the priority band to flush;
@item bi_flag @tab how to flush: one of @constant{FLUSHR}, @constant{FLUSHW} or @constant{FLUSHRW}.
@end multitable

@node I_CKBAND
@subsubsection @code{I_CKBAND}

Checks whether a message is available to be read from a specified queue band.

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_CKBAND}.
@item arg @tab contains the band number for which to check for an available message.
@end multitable

@node I_GETBAND
@subsubsection @code{I_GETBAND}

Gets the priority band associated with the next message on the @dfn{Stream head} read queue.

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_GETBAND}.
@item arg @tab is a pointer to an @type{int} into which to receive the band number.
@end multitable

@node I_CANPUT
@subsubsection @code{I_CANPUT}

The @ioctlref{I_CANPUT} @manref{ioctl(2)} command has the following form:

@cartouche
@example
int @b{ioctl}(int @i{fildes}, int @b{cmd}, long @i{arg});
@end example
@end cartouche

where,

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_CANPUT}.
@item arg @tab contains the band number for which to check for flow control.
@end multitable

Checsk whether message can be written to the queue band specified by @var{arg}.  @var{arg} is an
integer which contains the queue band to test for flow control.  @var{arg} can also have the
following value:

@table @constant
@item ANYBAND
When this value is specified, instead of testing a specified band, @ioctlref{I_CANPUT} tests whether
any (existing) band is writable.
@end table

Upon success, the @ioctlref{I_CANPUT} @manref{ioctl(2)} command returns zero (@samp{0}) or a
positive integer.  The @ioctlref{I_CANPUT} command returns false (@samp{0}) if the band cannot be
written to (due to flow control), and returns true (@samp{1}) if the band is writable.  Upon
failure, the @manref{ioctl(2)} call returns @samp{-1} and sets @manref{errno(3)} to an appropriate
error number.

When the @ioctlref{I_CANPUT} @manref{ioctl(2)} command fails, it returns @samp{-1} and sets
@manref{errno(3)} to one of the following errors:

@table @errno
@item EINVAL
@var{arg} is outside the range @samp{0} to @samp{255} and does not represent a valid priority band,
or is not @constant{ANYBAND}.
@item EIO
@var{fildes} refers to a @dfn{Stream} that is closing.
@item ENXIO
@var{fildes} refers to a @dfn{Stream} that has received a hangup.
@item EPIPE
@var{fildes} refers to a @dfn{STREAMS}-based pipe and the other end of the pipe is closed.
@item ESTRPIPE
@var{fildes} refers to a @dfn{STREAMS}-based pipe and a write operation was attempted with no
readers at the other end, or a read operation was attempted, the pipe is empty, and there are no
readers writers the other end.
@item EINVAL
@var{fildes} refers to a @dfn{Stream} that is linked under a multiplexing driver.  If a @dfn{Stream}
is linked under a multiplexing driver, all @manref{ioctl(2)} commands other than
@ioctlref{I_UNLINK} or @ioctlref{I_PUNLINK} will return @errno{EINVAL}.
@end table

Any error received in an @msg{M_ERROR} message indicating a persistent write error for the
@dfn{Stream} will cause @ioctlref{I_CANPUT} to fail, and the write error will be returned in
@manref{errno(3)}.

Any error number returned in @manref{errno(3)} in response to a general @manref{ioctl(2)} failure
can also be returned in response to @ioctlref{I_ATMARK}.  See also @manref{ioctl(2p)}.

@cite{@value{PACKAGE_TITLE}} implements the special flag, @constant{ANYBAND}, that can be used for
an @var{arg} value instead of the band number to check whether any existing band is writable.  This
is similar to the @constant{POLLWRBAND} flag to @manref{poll(2)}.  @constant{ANYBAND} uses the
otherwise invalid band number @samp{-1}.  Portable @dfn{STREAMS} applications programs will not use
the @constant{ANYBAND} flag and will not rely upon @ioctlref{I_CANPUT} to generate an error if
passed @samp{-1} as an invalid argument.


@node I_ATMARK
@subsubsection @code{I_ATMARK}

The @ioctlref{I_ATMARK} @manref{ioctl(2)} command has the following form:

@cartouche
@example
int @b{ioctl}(int @i{fildes}, int @b{cmd}, long @i{arg});
@end example
@end cartouche

where,

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_ATMARK}.
@item arg @tab specifies a criteria for checking for a mark.
@end multitable

The @ioctlref{I_ATMARK} command informs the user if the current message on the @dfn{Stream head}
read queue is marked by a downstream module or driver.  The @var{arg} argument determines how the
checking is done when there are multiple marked messages on the @dfn{Stream head} read queue.  The
possible values of the @var{arg} argument are as follows:

@table @constant
@item ANYMARK
Determine if the message at the head of the @dfn{Stream head} read queue is makred by a donwstream
module or driver.
@item LASTMARK
Determine if the message at the head of the @dfn{Stream head} read queue is the last message that is
marked on the queue by a downstream module or driver.
@end table

The bitwise inclusive @emph{OR} of the flags @constant{ANYMARK} and @constant{LASTMARK} is
permitted.

@dfn{STREAMS} message blocks that have the @constant{MSGMARK} flag set in the @member{b_flag} member
of the @mantype{msgb(9)} structure are marked messages.  @cite{Solaris} also provides the
@constant{MSGMARKNET} and @constant{MSGNOTMARKNET} flags.  The use of these flags is not very clear,
but @cite{@value{PACKAGE_TITLE}} could use them in the @manref{read(2)} logic to determine whether
the next message is marked without removing the message from the queue.

When @manref{read(2)} encounters a marked message and data has already been read, the read
terminates with the amount of data read.  The resulting short read is an indication to the user that
a marked message could exist on the read queue.  (Short reads can also result from zero-byte data,
or from a delimited message: one with the @constant{MSGDELIM} flag set in @member{b_flag}).  When a
short read occurs, the user should test for a marked message using the @constant{ANYMARK} flag to
the @ioctlref{I_ATMARK} @manref{ioctl(2)} command.  A subsesuent @manref{read(2)} will consume the
marked message following the marked message.  This can be checked by using the @constant{LASTMARK}
flag to the @ioctlref{I_ATMARK} @manref{ioctl(2)} command.

The @member{b_flag} member of the @mantype{msgb(9)} structure can have the flag, @constant{MSGMARK},
set that allows a module or driver to mark a message sent to the @dfn{Stream head}.  This is used to
support @manref{tcp(4)}'s ability to indicate the last bye of out-of-band data.  Once marked, a
message sent to the @dfn{Stream head} causes the @dfn{Stream head} to remember the message.  A user
may check to see if the message on the front of the @dfn{Stream head} read queue is marked, and
whether it is the last marked message on the queue, with the @ioctlref{I_ATMARK} @manref{ioctl(2)}
command.  If a user is reading data from the @dfn{Stream head} and there are multiple messages on
the @dfn{Stream head} read queue, and one of those messages is marked, @manref{read(2)} terminates
when it reaches the marked message and returns the data only up to that marked message.  The rest of
the data may be obtained with successive reads.  @constant{ANYMARK} indicates that the user merely
wants to check if the message at the head of the @dfn{Stream head} read queue is marked.
@constant{LASTMARK} indicates that the user wants to see if the message is the only one marked on
the queue.

Upon success, the @ioctlref{I_ATMARK} @manref{ioctl(2)} command returns zero (@samp{0}) or a
positive integer.  The @ioctlref{I_ATMARK} operation returns a value of true (@samp{1}) if the
marking criteria is met.  It returns false (@samp{0}) if the marking criteria is not met.  Upon
failure, the @ioctlref{I_ATMARK} @manref{ioctl(2)} command returnes @samp{-1} and sets
@manref{errno(3)} to an appropriate error number.

When the @ioctlref{I_ATMARK} @manref{ioctl(2)} command fails, it returns @samp{-1} and sets
@manref{errno(3)} to one of the following errors:

@table @errno
@item EINVAL
@var{arg} was other than @constant{ANYMARK} or @constant{LASTMARK}, or a bitwise-@emph{OR} of the
two.
@end table

Any error number returned in @manref{errno(3)} in response to a general @manref{ioctl(2)} failure
can also be returned in response to @ioctlref{I_ATMARK}.  See also @manref{ioctl(2p)}.

@ignore
In general, any @manref{ioctl(2)} command can fail if:

@table @errno
@item EFAULT
@var{arg}, or a member of @var{arg}, points to an address that is outside the caller's valid address
space.
@item EINVAL
@var{fildes}, @var{cmd}, @var{arg} or a member of @var{arg} is invalid.
@item EBADF
@var{fildes} is not a valid open file descriptor.
@item ENOSTR
@var{fildes} is not a @dfn{STREAMS} special character device.
@item EOPNOTSUPP
@var{fildes} does not support the requested operation.
@item EIO
@var{fildes} refers to a @dfn{Stream} that is closing.
@item ENOTTY
@var{fildes} does not refer to a @dfn{STREAMS} device that supports I/O controls.
@item ENODEV
@var{fildes} refers to a @dfn{STREAMS} device that does not support the @manref{ioctl(2)} system
call.
@item ENXIO
@var{fildes} refers to a @dfn{Stream} that has received a hangup (@msg{M_HANGUP}).
@item ENXIO
the I/O control command cannot be performed by this particular subdevice.
@item EPIPE
@var{fildes} refers to a @dfn{STREAMS}-based pipe and the other end of the pipe is closed.
@item ESTRPIPE
@var{fildes} refers to a @dfn{STREAMS}-based pipe and a write operation was attempted with no
readers at the other end, or a read operation was attempted, the pipe is empty, and there are no
readers at the other end.
@item EINVAL
@var{fildes} referes to a @dfn{Stream} that is linked under a multiplexing driver.  If a
@dfn{Stream} is linked under a multiplexing driver, all @manref{ioctl(2)} commands other than
@ioctlref{I_UNLINK} or @manref{I_PUNLINK} will return @errno{EINVAL}.
@item ERESTARTSYS
a signal was received before the operation could begin.
@item EINTR
a signal was received before the operation could complete.
@item EAGAIN
a file is set for asynchronous I/O and the operation would block.
@item EWOULDBLOCK
same as @errno{EAGAIN}.
@item ETIME
the operation timed out awiating an acknowledgement or response from the driver.
@item ENOSR
a message block could not be allocated during the operation and the operation is not permitted to
block.
@end table

Any error delivered to the @dfn{Stream head} is an @msg{M_ERROR} message can be returned in
@manref{errno(3)}.

Where the command is passed to the module or driver, or the command results in the call to a module
or driver @command{open} or @command{close} procedure, or @command{link} or @command{unlink}
operations, the error number returned by the module or driver @command{open} or @command{close}
procedure can also be returned in @manref{errno(3)}.

Any error returned in an @msg{M_IOCNAK} message from the driver in response to a @ioctlref{I_STR}
@manref{ioctl(2)} command can be returned in @manref{errno(3)}.

Note that @dfn{STREAMS} @manref{ioctl(2)} calls are complex and there is much conflicting
documentation in specific areas of behaviour.  Not all bugs are bugs and not all features are
features.
@end ignore

@node I_GETSIG
@subsubsection @code{I_GETSIG}

Sets the mask of events for which the @dfn{Stream} head will send a calling process a
@signal{SIGPOLL} or @signal{SIGURG} signal.  Events include @constant{S_RDBAND}, @constant{S_WRBAND}
and @constant{S_BANDURG}.
This @manref{ioctl(2)} command is discussed under @ref{Input and Output Polling}.

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_GETSIG}.
@item arg @tab is a pointer to a @type{int} to contain the retreived event flags.
@end multitable

Event flags can include the following band related events:

@multitable @columnfractions .15 .85
@item @constant{S_RDBAND} @tab a message of non-zero priority band has been placed to the
@dfn{Stream head} read queue.
@item @constant{S_WRBAND} @tab a priority band that was previously flow controlled has become
available for writing (i.e., is no longer flow controlled).
@item @constant{S_BANDURG} @tab a modifier to @constant{S_RDBAND} to generate @signal{SIGURG}
instead of @signal{SIGPOLL} in response to the event.
@end multitable

@node I_SETSIG
@subsubsection @code{I_SETSIG}

Sets the mask of events for which the @dfn{Stream} head will send a calling process a
@signal{SIGPOLL} or @signal{SIGURG} signal.  Events include @constant{S_RDBAND}, @constant{S_WRBAND}
and @constant{S_BANDURG}.
This @manref{ioctl(2)} command is discussed under @ref{Input and Output Polling}.

@multitable @columnfractions .10 .90
@item fildes @tab the @dfn{Stream} for which the command is issued;
@item cmd @tab is @samp{I_SETSIG}.
@item arg @tab is an integer value that contains the event flags.
@end multitable

Event flags can include the following band related events:

@multitable @columnfractions .15 .85
@item @constant{S_RDBAND} @tab a message of non-zero priority band has been placed to the
@dfn{Stream head} read queue.
@item @constant{S_WRBAND} @tab a priority band that was previously flow controlled has become
available for writing (i.e., is no longer flow controlled).
@item @constant{S_BANDURG} @tab a modifier to @constant{S_RDBAND} to generate @signal{SIGURG}
instead of @signal{SIGPOLL} in response to the event.
@end multitable


@c ------------------------------------
@node The queue Structure
@subsection The @code{queue} Structure
@menu
* Using queue Information::
* queue Flags::
@end menu

The @mantype{queue(9)} structure is exposed by including @header{sys/stream.h}.

@cartouche
@smallexample
typedef struct queue @{
        struct qinit *q_qinfo;          /* info structure for the queue */
        struct msgb *q_first;           /* head of queued messages */
        struct msgb *q_last;            /* tail of queued messages */
        struct queue *q_next;           /* next queue in this stream */
        struct queue *q_link;           /* next queue for scheduling */
        void *q_ptr;                    /* private data pointer */
        size_t q_count;                 /* number of bytes in queue */
        unsigned long q_flag;           /* queue state */
        ssize_t q_minpsz;               /* min packet size accepted */
        ssize_t q_maxpsz;               /* max packet size accepted */
        size_t q_hiwat;                 /* hi water mark for flow control */
        size_t q_lowat;                 /* lo water mark for flow control */
        struct qband *q_bandp;          /* band's flow-control information */
        unsigned char q_nband;          /* number of priority bands */
        unsigned char q_blocked;        /* number of bands flow controlled */
        unsigned char qpad1[2];         /* reserved for future use */
        /* Linux fast-STREAMS specific members */
        ssize_t q_msgs;                 /* messages on queue, Solaris counts
                                           mblks, we count msgs */
        rwlock_t q_lock;                /* lock for this queue structure */
        int (*q_ftmsg) (mblk_t *);      /* message filter ala AIX */
@} queue_t;
@end smallexample
@end cartouche

The following members are defined in @cite{SVR 4.2}:

@multitable @columnfractions .15 .85
@item @member{q_qinfo} @tab points to the @mantype{qinit(9)} structure associated with this queue;
@item @member{q_first} @tab first message on the message queue (@constant{NULL} if message queue is emptry);
@item @member{q_last} @tab last message on the message queue (@constant{NULL} if message queue is empty);
@item @member{q_next} @tab next queue in the @dfn{Stream};
@item @member{q_link} @tab next queue in the @dfn{STREAMS} scheduler list;
@item @member{q_ptr} @tab pointer to module/driver private data;
@item @member{q_count} @tab number of bytes of messages on the queue;
@item @member{q_flag} @tab queue flag bits (current state of the queue);
@item @member{q_minpsz} @tab minimum packet size accepted;
@item @member{q_maxpsz} @tab maximum packet size accepted;
@item @member{q_hiwat} @tab high water mark (queued bytes) for flow control;
@item @member{q_lowat} @tab low water mark (queued bytes) for flow control;
@item @member{q_bandp} @tab pointer to @mantype{qband(9)} structures associated with this queue;
@item @member{q_nband} @tab the number of @mantype{qband(9)} structures associated with this queue;
@item @member{q_blocked} @tab the number of currently blocked (flow controlled) queue bands;
@item @member{qpad1} @tab reserved for future use;
@end multitable

The following members are not defined in @cite{SVR 4.2} and are
@cite{@value{PACKAGE_TITLE}} specific:

@multitable @columnfractions .15 .85
@item @member{q_msgs} @tab number of messages on the queue;
@item @member{q_lock} @tab queue structure lock; and,
@item @member{q_ftmsg} @tab message filter ala AIX.
@end multitable

@node Using queue Information
@subsubsection Using @code{queue} Information

@node queue Flags
@subsubsection @code{queue} Flags

@cartouche
@smallexample
#define QENAB           (1<< 0) /* queue is enabled to run */
#define QWANTR          (1<< 1) /* flow controlled forward */
#define QWANTW          (1<< 2) /* back-enable necessary */
#define QFULL           (1<< 3) /* queue is flow controlled */
#define QREADR          (1<< 4) /* this is the read queue */
#define QUSE            (1<< 5) /* queue being allocated */
#define QNOENB          (1<< 6) /* do not enable with putq */
#define QUP             (1<< 7) /* uni-processor emulation */
#define QBACK           (1<< 8) /* the queue has been back enabled */
#define QOLD            (1<< 9) /* module supports old style open/close */
#define QHLIST          (1<<10) /* stream head is on scan list */
#define QTOENAB         (1<<11) /* to be enabled */
#define QSYNCH          (1<<12) /* flag for queue sync */
#define QSAFE           (1<<13) /* safe callbacks needed */
#define QWELDED         (1<<14) /* flags for welded queues */
#define QSVCBUSY        (1<<15) /* service procedure running */
#define QWCLOSE         (1<<16) /* q in close wait */
#define QPROCS          (1<<17) /* putp, srvp disabled */
@end smallexample
@end cartouche

The following @mantype{queue(9)} flags are defined by @cite{SVR 4.2}:

@multitable @columnfractions .20 .80
@item @constant{QENAB} @tab queue is enabled to run
@item @constant{QWANTR} @tab flow controlled forward
@item @constant{QWANTW} @tab back-enable necessary
@item @constant{QFULL} @tab queue is flow controlled
@item @constant{QREADR} @tab this is the read queue
@item @constant{QUSE} @tab queue being allocated
@item @constant{QNOENB} @tab do not enable with putq
@item @constant{QBACK} @tab the queue has been back enabled
@item @constant{QOLD} @tab module supports old style open/close
@item @constant{QHLIST} @tab stream head is on scan list
@end multitable

The following are not defined by @cite{SVR 4.2}, but are used by @cite{@value{PACKAGE_TITLE}} and
other @cite{SVR 4.2}-based implementations:

@multitable @columnfractions .20 .80
@item @constant{QUP} @tab uni-processor emulation
@item @constant{QTOENAB} @tab to be enabled
@item @constant{QSYNCH} @tab flag for queue sync
@item @constant{QSAFE} @tab safe callbacks needed
@item @constant{QWELDED} @tab flags for welded queues
@item @constant{QSVCBUSY} @tab service procedure running
@item @constant{QWCLOSE} @tab q in close wait
@item @constant{QPROCS} @tab putp, srvp disabled
@end multitable

@c ------------------------------------
@node The qband Structure
@subsection The @code{qband} Structure
@menu
* Using qband Information::
@end menu

The @mantype{qband(9)} structure and @mantype{qband_t(9)} type are exposed when
@header{sys/stream.h} is included and are formatted and contain the following members:

@cartouche
@smallexample
typedef struct qband @{
        struct qband *qb_next;          /* next (lower) priority band */
        size_t qb_count;                /* number of bytes queued */
        struct msgb *qb_first;          /* first queue message in this band */
        struct msgb *qb_last;           /* last queued message in this band */
        size_t qb_hiwat;                /* hi water mark for flow control */
        size_t qb_lowat;                /* lo water mark for flow control */
        unsigned long qb_flag;          /* flags */
        long qb_pad1;                   /* OSF: reserved */
@} qband_t;

#define qb_msgs qb_pad1
@end smallexample
@end cartouche

Where the members are interpreted as follows:

@multitable @columnfractions .15 .85
@item @member{qb_next} @tab points to the next (lower) priority band;
@item @member{qb_count} @tab number of bytes queued to this band in the message queue;
@item @member{qb_first} @tab the first message queued in this band (@constant{NULL} if band is empty);
@item @member{qb_last} @tab the last message queued in this band (@constant{NULL} if band is empty);
@item @member{qb_hiwat} @tab high water mark (in bytes queued) for this band;
@item @member{qb_lowat} @tab low water mark (in bytes queued) for this band;
@item @member{qb_flag} @tab queue band flags (see below);
@item @member{qb_pad1} @tab reserved for future used; and,
@item @member{qb_msgs} @tab same as @member{qb_padq}: contains the number of messages queued to the band.
@end multitable

Including @header{sys/stream.h} also exposes the following constants for use with the
@member{qb_flag} member of the @mantype{qband(9)} structure:

@multitable @columnfractions .15 .85
@item @constant{QB_FULL} @tab when set, indicates that the band is considered full;
@item @constant{QB_WANTW} @tab when set, indicates that a preceding queue wants to write to this band; and,
@item @constant{QB_BACK} @tab when set, indicates that the queue needs to be back-enabled.
@end multitable

@node Using qband Information
@subsubsection Using @code{qband} Information

@c ------------------------------------
@node Message Processing
@subsection Message Processing
@menu
* Flow Control::
@end menu

@node Flow Control
@subsubsection Flow Control

@c ------------------------------------
@node Scheduling
@subsection Scheduling
@menu
* Flow Control Variables::
* Flow Control Procedures::
* The STREAMS Scheduler::
@end menu

@node Flow Control Variables
@subsubsection Flow Control Variables

@node Flow Control Procedures
@subsubsection Flow Control Procedures

@node The STREAMS Scheduler 
@subsubsection The @dfn{STREAMS} Scheduler 

@c ----------------------------------------------------------------------------
@node Service Interfaces
@section Service Interfaces
@menu
* Service Interface Benefits::
* Service Interface Library Example::
@end menu

@c ------------------------------------
@node Service Interface Benefits
@subsection Service Interface Benefits

@c ------------------------------------
@node Service Interface Library Example
@subsection Service Interface Library Example
@menu
* Accessing the Service Provider::
* Closing the Service Provider::
* Sending Data to the Service Provider::
* Receiving Data::
* Module Service Interface Example::
@end menu

@node Accessing the Service Provider
@subsubsection Accessing the Service Provider

@node Closing the Service Provider
@subsubsection Closing the Service Provider

@node Sending Data to the Service Provider
@subsubsection Sending Data to the Service Provider

@node Receiving Data
@subsubsection Receiving Data

@node Module Service Interface Example
@subsubsection Module Service Interface Example

@c ----------------------------------------------------------------------------
@node Message Allocation
@section Message Allocation
@menu
* Recovering From No Buffers::
@end menu

@c ------------------------------------
@node Recovering From No Buffers
@subsection Recovering From No Buffers

@c ----------------------------------------------------------------------------
@node Extended Buffers
@section Extended Buffers

@c ============================================================================
@node Polling
@chapter Polling
@menu
* Input and Output Polling::	STREAMS Input and Output Polling
* Controlling Terminal::	STREAMS Stream as Controlling Terminal
@end menu


@node Input and Output Polling
@section Input and Output Polling

@node Controlling Terminal
@section Controlling Terminal

@c ============================================================================
@node Modules and Drivers
@chapter Modules and Drivers
@menu
* Environment::			STREAMS Module and Driver Environment
* Input-Output Control::	STREAMS Input and Output Control
* Flush Handling::		STREAMS Flush Handling
* Driver-Kernel Interface::	STREAMS Driver-Kernel Interface
* Design Guidelines::		STREAMS Design Guidelines
@end menu


@node Environment
@section Environment

@node Input-Output Control
@section Input-Output Control

@node Flush Handling
@section Flush Handling

@node Driver-Kernel Interface
@section Driver-Kernel Interface

@node Design Guidelines
@section Design Guidelines

@c ============================================================================
@node Modules
@chapter Modules
@menu
* Module::			STREAMS Modules
* Module Flow Control::		STREAMS Module Flow Control
* Module Design Guidelines::	STREAMS Module Design Guidelines
@end menu


@node Module
@section Module

@node Module Flow Control
@section Module Flow Control

@node Module Design Guidelines
@section Module Design Guidelines

@c ============================================================================
@node Drivers
@chapter Drivers
@menu
* External Device Numbers::	External Device Numbering
* Internal Device Numbers::	Internal Device Numbering
* spec File System::		Avoiding Device Numbering
* Clone Device::		Clone Device Numbering
* Named STREAMS Device::	Reusable Device Numbering
* Driver::			STREAMS Drivers
* Cloning::			STREAMS Driver Cloning
* Loop-Around Driver::		STREAMS Loop-Around Driver Example
* Driver Design Guidelines::	STREAMS Driver Design Guidelines
@end menu


@node External Device Numbers
@section External Device Numbers

@node Internal Device Numbers
@section Internal Device Numbers

@node spec File System
@section spec File System

@node Clone Device
@section Clone Device

@node Named STREAMS Device
@section Named STREAMS Device

@node Driver
@section Driver

@node Cloning
@section Cloning

@node Loop-Around Driver
@section Loop-Around Driver

@node Driver Design Guidelines
@section Driver Design Guidelines

@c ============================================================================
@node Multiplexing
@chapter Multiplexing
@menu
* Multiplexors::		STREAMS Multiplexing
* Connecting and Disconnecting Lower Stream::
				STREAMS Multiplexor Connect and Disconnect Lower Stream
* Multiplexor Construction Example::
				STREAMS Multiplexor Construction Example
* Multiplexing Driver::		STREAMS Multiplexing Driver
* Persistent Links::		STREAMS Multiplexor Persistent Links
* Multiplexing Driver Design Guidelines::
				STREAMS Multiplexing Driver Design Guidelines
@end menu


@node Multiplexors
@section Multiplexors

@node Connecting and Disconnecting Lower Stream
@section Connecting and Disconnecting Lower Stream

@node Multiplexor Construction Example
@section Multiplexor Construction Example

@node Multiplexing Driver
@section Multiplexing Driver

@node Persistent Links
@section Persistent Links

@node Multiplexing Driver Design Guidelines
@section Multiplexing Driver Design Guidelines

@c ============================================================================
@node Pipes and FIFOs
@chapter Pipes and FIFOs
@menu
* STREAMS Pipes and FIFOs::	STREAMS-based Pipes and FIFOs
* Flushing Pipes and FIFOs::	Flushing STREAMS-based Pipes and FIFOs
* Named Streams::		Named STREAMS-based Pipes and FIFOs
* Unique Connections::		Unique Connections for STREAMS-based Pipes and FIFOs
@end menu


@node STREAMS Pipes and FIFOs
@section Pipes and FIFOs

@node Flushing Pipes and FIFOs
@section Flushing Pipes and FIFOs

@node Named Streams
@section Named Streams

@node Unique Connections
@section Unique Connections

@c ============================================================================
@node Terminal Subsystem
@chapter Terminal Subsystem
@menu
* STREAMS Terminal Subsystem::	STREAMS-based Terminal Subssytem
* Pseudo-Terminal Subsystem::	STREAMS-based Pseudo-Terminal Subsystem
@end menu


@node STREAMS Terminal Subsystem
@section Terminal Subsystem

@node Pseudo-Terminal Subsystem
@section Pseudo-Terminal Subsystem

@c ============================================================================
@node Synchronization
@chapter Synchronization
@menu
* MT Configuration::		MP STREAMS MT Configuration
* Asynchronous Entry Points::	MP STREAMS Asynchronous Entry Points
* Asynchronous Callbacks::	MP STREAMS Asynchronous Callbacks
* Synchronous Entry Points::	MP STREAMS Synchronous Entry Points
* Synchronous Callbacks::	MP STREAMS Synchronous Callbacks
* STREAMS Framework Integrity::
* MP Message Ordering::
* MP-UNSAFE Modules::
* MP Put and Service Procedures::
* MP Timeout and Buffer Callbacks::
* MP Open and Close Procedures::
* MP Module Unloading::
* MP Locking::
* MP Asynchronous Callbacks::
* Stream Integrity::
@end menu


@node MT Configuration
@section MT Configuration

@node Asynchronous Entry Points
@section Asynchronous Entry Points

@node Asynchronous Callbacks
@section Asynchronous Callbacks

@node Synchronous Entry Points
@section Synchronous Entry Points

@node Synchronous Callbacks
@section Synchronous Callbacks

@node STREAMS Framework Integrity
@section STREAMS Framework Integrity

@node MP Message Ordering
@section MP Message Ordering

@node MP-UNSAFE Modules
@section MP-UNSAFE Modules

@node MP Put and Service Procedures
@section MP Put and Service Procedures

@node MP Timeout and Buffer Callbacks
@section MP Timeout and Buffer Callbacks

@node MP Open and Close Procedures
@section MP Open and Close Procedures

@node MP Module Unloading
@section MP Module Unloading

@node MP Locking
@section MP Locking

@node MP Asynchronous Callbacks
@section MP Asynchronous Callbacks

@node Stream Integrity
@section Stream Integrity

@c ============================================================================
@node Reference
@chapter Reference
@menu
* Files::			STREAMS Files
* System Modules::		STREAMS Modules
* System Drivers::		STREAMS Drivers
* System Calls::		STREAMS System Calls
* Input-Output Controls::	STREAMS Input-Output Controls
* Module Entry Points::		STREAMS Module Entry Points
* Structures::			STREAMS Structures
* Registration::		STREAMS Module and Driver Registration Functions
* Message Handling::		STREAMS Message Handling Functions
* Queue Handling::		STREAMS Queue Handling Functions
* Miscellaneous Functions::	STREAMS Miscellaneous Functions
* Extensions::			STREAMS Extension Functions
* Compatibility::		STREAMS Compatibility Functions
@end menu


@node Files
@section Files

@node System Modules
@section System Modules

@node System Drivers
@section System Drivers

@node System Calls
@section System Calls

@node Input-Output Controls
@section Input-Output Controls

@node Module Entry Points
@section Module Entry Points

@node Structures
@section Structures

@node Registration
@section Registration

@node Message Handling
@section Message Handling

@node Queue Handling
@section Queue Handling

@node Miscellaneous Functions
@section Miscellaneous Functions

@node Extensions
@section Extensions

@node Compatibility
@section Compatibility

@c ============================================================================
@node Conformance
@chapter Conformance
@menu
* SVR 4.2 Compatibility::	SVR 4.2 MP DDI/DKI Compatibility
* AIX Compatibility::		AIX 5L Version 5.1 Compatibility
* HP-UX Compatibility::		HP-UX 11.0i v2 Compatibility
* OSF/1 Compatibility::		OSF/1 1.2/Digital UNIX Compatibility
* UnixWare Compatibility::	UnixWare 7.1.3 Compatibility
* Solaris Compatibility::	Solaris 9/SunOS 5.9 Compatibility
* SUX Compatibility::		Super/UX Compatibility
* UXP Compatibility::		UXP/V Compatibility
* LiS Compatibility::		LiS 2.18.4 Compatibility
@end menu


@node SVR 4.2 Compatibility
@section SVR 4.2 Compatibility

@node AIX Compatibility
@section AIX Compatibility

@node HP-UX Compatibility
@section HP-UX Compatibility

@node OSF/1 Compatibility
@section OSF/1 Compatibility

@node UnixWare Compatibility
@section UnixWare Compatibility

@node Solaris Compatibility
@section Solaris Compatibility

@node SUX Compatibility
@section SUX Compatibility

@node UXP Compatibility
@section UXP Compatibility

@node LiS Compatibility
@section LiS Compatibility

@c ============================================================================
@node Portability
@chapter Portability
@menu
* Core Function Support::	Porting with Core Function Support
* SVR 4.2 Portability::		Porting from SVR 4.2 MP
* AIX Portability::		Porting from AIX 5L Version 5.1
* HP-UX Portability::		Porting from HP-UX 11.0i v2
* OSF/1 Portability::		Porting from OSF/1 1.2/Digital UNIX
* UnixWare Portability::	Porting from UnixWare 7.1.3
* Solaris Portability::		Porting from Solaris 9/SunOS 5.9
* SUX Portability::		Porting from Super/UX
* UXP Portability::		Porting from UXP/V
* LiS Portability::		Porting from LiS 2.18.4
@end menu


@node Core Function Support
@section Core Function Support

@node SVR 4.2 Portability
@section SVR 4.2 Portability

@node AIX Portability
@section AIX Portability

@node HP-UX Portability
@section HP-UX Portability

@node OSF/1 Portability
@section OSF/1 Portability

@node UnixWare Portability
@section UnixWare Portability

@node Solaris Portability
@section Solaris Portability

@node SUX Portability
@section SUX Portability

@node UXP Portability
@section UXP Portability

@node LiS Portability
@section LiS Portability

@c ============================================================================
@node Data Structures
@appendix Data Structures
@menu
* Stream Structures::
* Queue Structures::
* Message Structures::
* Input Output Control Structures::
* Link Structures::
* Options Structures::
@end menu


@node Stream Structures
@section Stream Structures

@node Queue Structures
@section Queue Structures

@node Message Structures
@section Message Structures

@node Input Output Control Structures
@section Input Output Control Structures

@node Link Structures
@section Link Structures

@node Options Structures
@section Options Structures

@c ============================================================================
@node Message Types
@appendix Message Types
@menu
* Message Type::
* Ordinary Messages::
* High Priority Messages::
@end menu


@node Message Type
@section Message Type

@node Ordinary Messages
@section Ordinary Messages

@node High Priority Messages
@section High Priority Messages

@c ============================================================================
@node Utilities
@appendix Utilities
@menu
@end menu

@c ============================================================================
@node Debugging
@appendix Debugging
@menu
@end menu

@c ============================================================================
@node Configuration
@appendix Configuration
@menu
@end menu

@c ============================================================================
@node Administration
@appendix Administration
@menu
* Administrative Utilities::	STREAMS Administrative Utilities
* System Controls::		STREAMS System Controls
* /proc File System::		STREAMS /proc File System
@end menu


@node Administrative Utilities
@section Administrative Utilities

@node System Controls
@section System Controls

@node /proc File System
@section /proc File System

@c ============================================================================
@node Examples
@appendix Examples
@menu
* Module Example::		STREAMS Module Example
* Driver Example::		STREAMS Driver Example
@end menu


@node Module Example
@section Module Example

@node Driver Example
@section Driver Example

@c ============================================================================
@node Copying
@appendix Copying
@menu
* GNU General Public License::		GPL
* GNU Free Documentation License::	FDL
@end menu

@page
@include texi/gpl.texi

@page
@include texi/fdl.texi

@c ============================================================================
@node Glossary
@unnumbered Glossary

@multitable @columnfractions .30 .70

@item @dfn{anchor} @tab
@cindex anchor
A @dfn{STREAMS} locking mechanism that prevents the removal of @dfn{STREAMS} modules with the
@streamio{I_POP} @command{ioctl}.  Anchors are placed on @dfn{STREAMS} modules by adding the
@samp{[anchor]} flag to @manref{autopush(8)} configuration files or directly with the
@streamio{I_ANCHOR} @command{ioctl}.

@item @dfn{autopush} @tab
@cindex autopush
A @dfn{STREAMS} mechanism that enables a pre-specified list of modules to be pushed automatically
onto a @dfn{Stream} when a @dfn{STREAMS} device is opened.  This mechanism is used only for
administrative purposes.

@item @dfn{back-enable} @tab
@cindex back-enable
To enable (by @dfn{STREAMS}) a preceding blocked queue's @command{service} procedure when
@dfn{STREAMS} determines that a succeeding queue has reached its low-water mark.

@item @dfn{blocked} @tab
@cindex blocked
A queue's @command{service} procedure that cannot be enabled due to flow control.

@item @dfn{clone device} @tab
@cindex clone device
A @dfn{STREAMS} device that returns an unused major/minor device number when initially opened,
rather than requiring the minor device to be specified by name in the @command{open} call.

@item @dfn{close procedure} @tab
@cindex close procedure
A routine that is called when a module is popped from a @dfn{Stream} or when a driver is closed.
A pointer to this procedure is specified in the @member{qi_qopen} member of the @mantype{queue(9)}
structure associated with the read side of the module's queue pair.

@item @dfn{control Stream} @tab
@cindex control Stream
A @dfn{Stream} above a multiplexing driver used to establish lower multiplexer connections.
Multiplexed @dfn{Stream} configurations are maintained through the controlling @dfn{Stream} to a
multiplexing driver.

@item @dfn{Device Driver Interface} @tab
@cindex Device Driver Interface
An interface that facilitates driver portability across different @cite{UNIX} system versions.

@item @dfn{device driver} @tab
@cindex device driver
A @dfn{Stream} component whose principle functions are handling an associated physical device and
transforming data and information between the external interface and the @dfn{Stream}.

@item @dfn{Driver Kernel Interface} @tab
@cindex Driver Kernel Interface
An interface between the @cite{UNIX} system kernel and different types of drivers.  It consists of a
set of driver defined functions that are called by the kernel.  These functions are entry points
into a driver.

@item @dfn{downstream} @tab
@cindex downstream
A direction of data flow going from the @dfn{Stream head} toward a driver.  Also called the
@dfn{write-side} and @dfn{output-side}.

@item @dfn{driver} @tab
@cindex driver
A module that forms the @dfn{Stream end}.  It can be a device driver or a pseudo-device driver.  It
is a required component in @dfn{STREAMS} (except in @dfn{STREAMS}-based pipes and FIFOs), and is
physically identical to a module.  It typically handles data transfer between the kernel and a
device and does little or no processing of data.

@item @dfn{enable} @tab
@cindex enable
A term used to describe scheduling of a queue's @command{service} procedure.

@item @dfn{FIFO} @tab
@cindex FIFO
@dfn{First In, First Out}.  A term used in @dfn{STREAMS} for named pipes.  This term is also used in
queue scheduling.

@item @dfn{flow control} @tab
@cindex flow control
A @dfn{STREAMS} mechanism that regulates the rate of message transfer within a @dfn{Strema} and from
user space into a @dfn{Stream}.

@item @dfn{hardware emulation module} @tab
@cindex hardware emulation module
A module required when the terminal line discipline is on a @dfn{Stream} but there is no terminal
driver at the @dfn{Stream end}.  This module recognizes all @manref{termio(7)} @command{ioctl}s
necessary to support terminal semantics specified by @mantype{termio(9)} and @mantype{termios(9)}.

@item @dfn{input side} @tab
@cindex input side
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{read-side} and @dfn{upstream}.

@item @dfn{line discipline} @tab
@cindex line discipline
A @dfn{STREAMS} module that performs @manref{termio(7)} canonical and non-canonical processing.  It
shares some @manref{termio(7)} processing with a driver in a @dfn{STREAMS} terminal subsystem.

@item @dfn{lower Stream} @tab
@cindex lower Stream
A @dfn{Stream} connected beneath a multiplexing pseudo-device driver, by means of an
@streamio{I_LINK} or @streamio{I_PLINK} @command{ioctl}.  The far end of a lower @dfn{Stream}
terminates at a device driver or another multiplexer driver.

@item @dfn{master driver} @tab
@cindex master driver
A @dfn{STREAMS}-based device supported by the pseudo-terminal subsystem.  It is the controlling part
of the pseudo-terminal subsystem (also called @samp{ptm}).

@item @dfn{message} @tab
@cindex message
One or more linked message blocks.  A message is referenced by its first message block and its type
is defined by the message type of that block.

@item @dfn{message block} @tab
@cindex message block
A triplet consisting of a data buffer and associated control structures, a @mantype{msgb(9)}
structure, a @mantype{datab(9)} structure.  It carries data or information, as identified by its
message type, in a @dfn{Stream}.

@item @dfn{message queue} @tab
@cindex message queue
A linked list of zero or more messages connected together.

@item @dfn{message type} @tab
@cindex message type
A enumerated set of values identifying the contents of a message.

@item @dfn{module} @tab
@cindex module
A defined set of kernel-level routines and data structure used to process data, status, and control
information on a @dfn{Stream}.  It is an optional element, but there can be many modules in one
@dfn{Stream}.  It consists of a pair of queues (read queue and write queue), and it communicates to
other components in a @dfn{Stream} by passing messages.

@item @dfn{multiplexer} @tab
@cindex multiplexer
A @dfn{STREAMS} mechanism that allows message to be routed among multiple @dfn{Streams} in the
kernel.  A multiplexing configuration includes at least one multiplexing pseudo-device driver
connected to one or more upper @dfn{Streams} and one or more lower @dfn{Streams}.

@item @dfn{named Stream} @tab
@cindex named Stream
A @dfn{Stream}, typically a pipe, with a name associated with it by way of a call to
@manref{fattach(3)} (that is, a @manref{mount(2)} operation).  This is different from a named pipe
(FIFO) in two ways: a named pipe (FIFO) is unidirectional while a named @dfn{Stream} is
bidirectional; a name @dfn{Stream} need not refer to a pipe, but can be another type of
@dfn{Stream}.

@item @dfn{open routine} @tab
@cindex open routine
A procedure in each @dfn{STREAMS} driver and module called by @dfn{STREAMS} on each @command{open}
system call made on the @dfn{Stream}.  A module's @command{open} procedure is also called when the
module is pushed.

@item @dfn{packet mode} @tab
@cindex packet mode
A feature supported by the @dfn{STREAMS}-based pseudo-terminal subsystem.  It is used to inform a
process on the master side when state changes occur on the slave side of a pseudo-TTY.  It is
enabled by pushing a module called @samp{pckt} on the master side.

@item @dfn{persistent link} @tab
@cindex persistent link
A connection below a multiplexer that can exist without having an open controlling @dfn{Stream}
associated with it.

@item @dfn{pipe} @tab
@cindex pipe
See @dfn{STREAMS}-based pipe.

@item @dfn{pop} @tab
@cindex pop
A term used when a module that is immediately below the @dfn{Stream} head is removed.

@item @dfn{pseudo-device driver} @tab
@cindex pseudo-device driver
A software driver, not directly associated with a physical device, that performs functions internal
to a @dfn{Stream} such as a multiplexer or @manref{log(4)} driver.

@item @dfn{pseudo-terminal subsystem} @tab
@cindex pseudo-terminal subsystem
A user interface identical to a terminal subsystem except that there is a process in place of a
hardware device.  It consists of at least a master device, slave device, line discipline module, and
hardware emulation module.

@item @dfn{push} @tab
@cindex push
A term used when a muodule is inserted in a @dfn{Stream} immediately below the @dfn{Stream head}.

@item @dfn{pushable module} @tab
@cindex pushable module
A module put between the @dfn{Stream head} and driver.  It performs intermediate transformations on
messages flowing between the @dfn{Stream head} and driver.  A driver is a non-pushable module.

@item @dfn{put procedure} @tab
@cindex put procedure
A routine in a module or driver associated with a queue that receives messages from the preceding
queue.  It is the single entry point into a queue from a preceding queue.  It may perform processing
on the message and will then generally either queue the message for subsequent processing by this
queue's @command{service} procedure, or will pass the message to the @command{put} procedure of the
following queue (using @manref{putnext(9)}).

@item @dfn{queue} @tab
@cindex queue
A data structure that contains status information, a pointer to routines processing message, and
pointers for administering a @dfn{Stream}.  It typically contains pointer to @command{put} and
@command{service} procedures, a message queue, and private data.

@item @dfn{read-side} @tab
@cindex read-side
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{upstream} and @dfn{input-side}.

@item @dfn{read queue} @tab
@cindex read queue
A message queue in a module or driver containing messages moving @dfn{upstream}.  Associated with
the @manref{read(2)} system call and input from a driver.

@item @dfn{remote mode} @tab
@cindex remote mode
A feature available with the pseudo-terminal subsystem.  It is used for applications that perform
the canonical and echoing functions normally done by line discipline module and TTY driver.  It
enables applications on the master side to turn off the canonical processing.

@item @dfn{STREAMS Administrative Driver} @tab
@cindex STREAMS Administrative Driver
A @dfn{STREAMS} Administrative Driver that provides an interface to the @manref{autopush(8)}
mechanism.

@item @dfn{schedule} @tab
@cindex schedule
To place a queue on the internal list of queues that will subsequently have their service procedure
called by the @dfn{STREAMS} scheduler.  @dfn{STREAMS} scheduling is independent of @cite{Linux}
process scheduling.

@item @dfn{service interface} @tab
@cindex service interface
A set of primitives that define a service at the boundary between a service user and a service
provider and the rules (typically represented by a state machine) for allowable sequences of the
primitives across the boundary.  At a @dfn{Stream}/user boundary, the primitives are typically
contained in the control part of a message; within a @dfn{Stream}, in @msg{M_PROTO} or
@msg{M_PCPROTO} message blocks.

@item @dfn{service procedure} @tab
@cindex service procedure
A module or driver routine associated with a queue that receives messages queue for it by the
@command{put} procedure is called by the @dfn{STREAMS} scheduler.  It may perform processing on the
message and generally passes the message to the @command{put} procedure of the following queue.

@item @dfn{service provider} @tab
@cindex service provider
An entity in a service interface that responds to request primitives from the service user with
response and event primitives.

@item @dfn{service user} @tab
@cindex service user
An entity in a service interface that generates request primitives for the service provider and
consumes response and event primitives.

@item @dfn{slave driver} @tab
@cindex slave driver
A @dfn{STREAMS}-based device supported by the pseudo-terminal subsystem.  It is also called
@samp{pts} and works with a line discipline module and hardware emulation module to provide an
interface to a user process.

@item @dfn{standard pipe} @tab
@cindex standard pipe
A mechanism for the unidirectional flow of data between two processes where data written by one
process becomes data read by the other process.

@item @dfn{Stream} @tab
@cindex Stream
A kernel level aggregate created by connecting @dfn{STREAMS} components, resulting from an
application of the @dfn{STREAMS} mechanism.  The primary components are the @dfn{Stream head}, the
driver (or @dfn{Stream end}), and zero or more pushable modules between the @dfn{Stream head} and
driver.

@item @dfn{STREAMS-based pipe} @tab
@cindex STREAMS-based pipe
A mechanism used for bidirectional data transfer implemented using @dfn{STREAMS}, and sharing the
properties of @dfn{STREAMS}-based devices.

@item @dfn{Stream end} @tab
@cindex Stream end
A @dfn{Stream} component furthest from the user process that contains a driver.

@item @dfn{Stream head} @tab
@cindex Stream head
A @dfn{Stream} component closest to the user process.  It provides the interface between the
@dfn{Stream} and the user process.

@item @dfn{STREAMS} @tab
@cindex STREAMS
A kernel mechanism that provides the framework for network services and data communication.  It
defines interface standards for character intput/output within the kernel, and between the kernel
and user level.  The @dfn{STREAMS} mechanism includes integral functions, utility routines, kernel
facilities, and a set of structures.

@item @dfn{TTY driver} @tab
@cindex TTY driver
A @dfn{STREAMS}-based device used in a terminal subsystem.

@item @dfn{upper stream} @tab
@cindex upper stream
A @dfn{Stream} that terminates above a multiplexing driver.  The beginning of an upper @dfn{Stream}
originates at the @dfn{Stream head} or another multiplexing driver.

@item @dfn{upstream} @tab
@cindex upstream
A direction of data flow going from a driver toward the @dfn{Stream head}.  Also called
@dfn{read-side} and @dfn{input side}.

@item @dfn{water mark} @tab
@cindex water mark
A limit value used in flow control.  Each queue has a high-water mark and a low-water mark.  The
high-water mark value indicates the upper limit related to the number of bytes contained on the
queue.  When the queued character reaches its high water mark, @dfn{STREAMS} causes another queue
that attempts to send a message to this queue to become blocked.  When the characters in this queue
are reduced to the low-water mark value, the other queue is unblocked by @dfn{STREAMS}.

@item @dfn{write queue} @tab
@cindex write queue
A message queue in a module or driver containing messages moving downstream.  Associated with the
@manref{write(2)} system call and output from a user process.

@item @dfn{write-side} @tab
@cindex write-side
A direction of data flow going from the @dfn{Stream head} toward a driver.  Also called downstream
and output side.

@end multitable

@c ============================================================================
@ifnotinfo
@node List of Figures
@unnumbered List of Figures

@listoffloats Figure
@end ifnotinfo

@c ============================================================================
@iftex
@node List of Listings
@unnumbered List of Listings

@listoffloats Listing
@end iftex

@c ============================================================================
@node Index
@unnumbered Index

@c @page
@c @node Indices
@c @unnumbered Indices
@c @menu
@c * Concept Index::		Index of Concepts
@c * Type Index::			Index of Data Types
@c * Function Index::		Index of Functions and Macros
@c * Variable Index::		Index of Variables and Constants
@c * File Index::			Index of Files and Programs
@c @end menu
@c 
@c @page
@c @node Concept Index
@c @unnumberedsec Concept Index
@printindex cp

@c @page
@c @node Type Index
@c @unnumberedsec Type Index
@c @printindex tp
@c 
@c @page
@c @node Function Index
@c @unnumberedsec Function and Macro Index
@c @printindex fn
@c 
@c @page
@c @node Variable Index
@c @unnumberedsec Variable and Constant Macro Index
@c @printindex vr
@c 
@c @page
@c @node File Index
@c @unnumberedsec Program and File Index
@c @printindex pg

@page
@shortcontents
@page
@contents
@bye

