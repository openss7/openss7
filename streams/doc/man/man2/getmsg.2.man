'\" rt
.\" -*- nroff -*- vim: ft=nroff noautoindent nocindent nosmartindent
.\"
.\" @(#) $Id: getmsg.2.man,v 0.9.2.5 2004/04/17 23:14:55 brian Exp $
.\"
.\" =========================================================================
.\"
.\" Copyright (C) 2001-2004  OpenSS7 Corporation <www.openss7.com>
.\"
.\" All Rights Reserved.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" -------------------------------------------------------------------------
.\"
.\" U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
.\" on behalf of the U.S. Government ("Government"), the following
.\" provisions apply to you.  If the Software is supplied by the Department
.\" of Defense ("DoD"), it is classified as "Commercial Computer Software"
.\" under paragraph 252.227-7014 of the DoD Supplement to the Federal
.\" Acquisition Regulations ("DFARS") (or any successor regulations) and the
.\" Government is acquiring only the license rights granted herein (the
.\" license rights customarily provided to non-Government users).  If the
.\" Software is supplied to any unit or agency of the Government other than
.\" DoD, it is classified as "Restricted Computer Software" and the
.\" Government's rights in the Software are defined in paragraph 52.227-19
.\" of the Federal Acquisition Regulations ("FAR") (or any success
.\" regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
.\" NASA Supplement to the FAR (or any successor regulations).
.\"
.\" =========================================================================
.\" 
.\" Commercial licensing and support of this software is available from
.\" OpenSS7 Corporation at a fee.  See http://www.openss7.com/
.\" 
.\" =========================================================================
.\"
.\" Last Modified $Date: 2004/04/17 23:14:55 $ by $Author: brian $
.\"
.\" =========================================================================

.so streams.macros
.R1
bracket-label "\fR[\fB" "\fR]" "\fR, \fB"
no-default-database
database streams.refs
accumulate
move-punctuation
abbreviate A
join-authors ", " ", " " and "
et-al " et al" 2 3
abbreviate-label-ranges ".."
sort-adjacent-labels
.R2
.\"
.\"
.TH GETMSG 2 "$Date: 2004/04/17 23:14:55 $" "$Name:  $" "Linux Fast-STREAMS System Calls"
.\"
.\"
.SH NAME
getmsg \- get next message off a stream
.\"
.\"
.SH SYNOPSIS
.PP
.B #include <stropts.h>
.HP 8
.BI "int getmsg(int " fd ", struct strbuf *" ctlptr ", struct strbuf *" dataptr ", int *" flagsp );
.\"
.\"
.SH ARGUMENTS
.PP
.TP
.I fd
the file descriptor from which to get a message.
.TP
.I ctlptr
a pointer to a
.B strbuf
structure to hold any control part of the message.
.TP
.I dataptr
a pointer to a
.B strbuf
structure to hold any data part of the message.
.TP
.I flagsp
a pointer to a integer containing passed in and returned flags.
.\"
.\"
.SH DESCRIPTION
.PP
.B getmsg
reads a STREAMS message from the read queue of a stream head into the
caller supplied buffers.  The read messages will contain a control part or a
data part or both.  The data and control parts of the message are handled
separately by
.BR getmsg() .
.PP
The meaning and interpretation of the contents of the control part and data
part are specific to the STREAMS module to which the stream head is attached.
The semantics of these contents forms a necessary part of the STREAMS module
documentation.
.PP
The arguments to
.B getmsg()
are interpreted as follows:
.PP
.I fd
specifies a file descriptor referencing an open stream.
.PP
.I ctlptr
a pointer to a
.B strbuf
structure which describes the area used to store the control part of the
received message.
.PP
.I datptr
a pointer to a
.B strbuf
structure which describes the area used to store the data part of the
received message.
.PP
The
.B strbuf
structure contains the following members:
.sp
.nf
\fC\s-1\
struct strbuf {
    int maxlen;         /* maximum buffer length */
    int len;            /* length of data */
    char *buf;          /* ptr to buffer */
};
\s+1\fR
.fi
.TP
.I maxlen
specifies the maximum number of bytes that the buffer pointed to by
.I buf
can hold.
When 0 is specified,
.I maxlen
requests that only zero-length message be retrieved.
When -1 is specified,
.I maxlen
requests that the corresponding control or data part not be retrieved.
When set to a positive value,
.I maxlen
requests that at maximum only
.I maxlen
bytes of the control or data part be retrieved.
.TP
.I len
is a return value only.  See
.BR "\*(lqRETURN VALUES\*(rq" ,
below.
.TP
.I buf
points to the buffer into which the data or control information is to be placed.
.PP
If
.IR ctlptr " or " datptr
is
.BR NULL ,
or the corresponding
.I maxlen
field is set to -1, the control or data part of the message is not
processed and is left on the stream head read queue.
.PP
.I flagsp
should point to an integer that indicates the type of message
the user is able to receive and will return the type of message received.
.PP
For
.BR getmsg() ,
.I flagsp
points to an integer that
can have one of the following values:
.TP
.B 0
requests retrieval of the first available message on the stream
head read queue regardless of message priority;
.TP
.B RS_HIPRI
requests retrieval of the first high priority message on the stream
head read queue, and that low priority messages not be processed.
.PP
If the stream head is set for non-blocking operation and no message of the
specified type and priority band is available to be read,
.B getmsg()
will fail and set
.I errno
to
.RB [ EAGAIN "] or [" EWOULDBLOCK ].
If the stream head is set for blocking operation,
.B getmsg()
will block until a message of the specified type and priority band becomes
availble on the stream head read queue, or the call is interrupted by a
signal.
If the call is interrupted by a signal in this fashion,
.B getmsg()
will fail and set
.I errno
to
.BR EINTR .
.\"
.PP
If a hangup occurs on the stream from which messages are to be retrieved,
\fBgetmsg\fR continues to operate normally, as described above, until the
stream head read queue is empty.  Thereafter, it returns 0 in the \fIlen\fR
field of \fIctlptr\fR and \fIdataptr\fR.
.\"
.\"
.SH "RETURN VALUES"
.PP
Upon failure,
.B getmsg()
will return -1 and set
.I errno
as described under
.BR "\*(lqERRORS\*(rq" ,
below.
.PP
Upon success,
.B getmsg()
will return a non-negative value with any of the following flags set:
.TP
.B MORECTL
indicates that more control information belonging to the same message is
waiting to be retrieved from the stream head read queue with a subsequent
.B getmsg()
operation.
.TP
.B MOREDATA
indicates that more data belonging to the same message is waiting to be
retrieved from the stream head read queue with a subsequent
.B getmsg()
operation.
.B 0
indicates that the entire message was received successfully.
.PP
.B getmsg()
with the appropriate arguments will retrieve a higher priority message before
the remainder of a partially retreived lower priority message is retrieved.
.PP
Upon success,
.B getmsg()
will also alter the
.I len
values in the
.B strbuf
structures pointed to by
.IR ctlbuf " and " datbuf
and the integer value pointed to by
.IR flagp ,
as follows:
The
.I maxlen
member is not altered on return.
If the
.IR ctlptr " or " datptr
a not
.BR NULL ,
and
.I maxlen
is not -1,
the existence and length of the retrieved message is returned in the
.I len
member.
If there is no control or data part retrieved, the
.I len
member of the corresponding
.B strbuf
structure is set to -1.
.PP
If the control or data part retrieved is of zero-length, the control or data
part is removed from the stream head read queue and the returned
.I len
is set to 0.
If
.I maxlen
is greater than or equal to 0 and the number of bytes in the control or
data part is greater than
.IR maxlen ,
only
.I maxlen
bytes are retrieved and the remaining bytes of the corresponding part are left
on the stream head read queue.  In the return value
the corresponding more flag
.BR "" ( MORECTL " or " MOREDATA )
is set.
The
.I buf
member is not altered on return.
.PP
The integer pointed to by
.I flagsp
will contain one of the following values:
.TP
.BR 0,
the retrieved message is not a high priority message;
.TP
.BR RS_HIPRI,
the retrived message is a high priority message.
.\"
.\"
.SH ERRORS
.PP
Upon failure,
.B getmsg()
will
return -1 and set
.I errno
as follows:
.TP
.RB [ EISDIR ]
.I fd
refers to a directory.
.TP
.RB [ EBADF ]
.I fd
is not a valid file descriptor or is not open for reading.
.TP
.RB [ EFAULT ]
A specified address is outside the user's accessible address space.
Specified addresses include,
.IR ctlptr ", " datptr ", " flagsp ,
and the
.I buf
fields of the
.B strbuf
structure pointed to by
.IR cttlptr " and " datptr .
.TP
.RB [ ENODEV ]
.I fd
refers to a device that does not support the
.B getmsg()
system call.
.TP
.RB [ ENOSTR ]
.I fd
refers to a device that has no stream associated with it.
.TP
.RB [ EIO ]
I/O error, or,
.I fd
refers to a stream that is open but is in the process of closing.
.\".TP
.\".RB [ EPERM ]
.\".I fd
.\"points to a dynamic device and read permission on the device is denied.
.\"
.\"
.\"
.TP
.RB [ EINVAL ]
.I fd
is linked under a multiplexing driver; or,
.B getmsg()
is not supported; or, the flags pointed to by
.I flagsp
were invalid for
.BR getmsg() .
.TP
.RB [ EAGAIN "], [" EWOULDBLOCK ]
The stream head is set for non-blocking operation and
.B getmsg()
would block: that is, no message of the requested type and priority band is
available to be read.
.TP
.RB [ EINTR ]
A signal was caught, or an
.B M_SIG
message processed, before the call to
.B getmsg()
could return any data.
.TP
.RB [ ENOSTR ]
.I fd
has no stream associated with the file descriptor.
.TP
.RB [ EBADMSG ]
The message at the head of the queue is of an invalid message type (valid
message types include:
.BR M_DATA ", " M_PROTO " and " M_PCPROTO );
or, the message at head of the of the queue is not of the requested type
as specified by
.IR flagsp .
.PP
Other errors may be returned by
.BR getmsg() .
If the STREAMS module sends a
.B M_ERROR
message to the stream head, the error returned on all subsequent read
operations, including
.BR getmsg() ,
is specified in the
.B M_ERROR
message by the STREAMS module.
Which errors are returned under which conditions form part of the
necessary documentation of the STREAMS module.
.\"
.\"
.SH NOTICES
.PP
.SS "Multi-Threading"
.PP
.BR getmsg ()
is thread-safe; however, multiple threads performing concurrent partial reads
on the same stream will interfere with each other.  POSIX mandatory file
locks, (see
.BR lockf (3)),
can be used to avoid interference.
.SS "Asynchronous I/O"
.PP
If the file is set for blocking operation (see
.BR fcntl (2)),
then
.BR getmsg ()
will block waiting for a  message to arrive on the stream head.  When the file
is set for non-blocking operation,
.BR getmsg ()
will not block, but will return the appropriate error number
.RB ([EBADMSG "], [" ERESTARTSYS "], [" EAGAIN "], [" EWOULDBLOCK ])
if a message of the correct type was not immediately available for retrieval at the stream head.
.\"
.\"
.SH "SEE ALSO"
.PP
.BR intro (2),
.BR poll (2),
.BR putmsg (2),
.BR read (2),
.BR write (2),
.BR streamio (7).
.\"
.\"
.SH BUGS
.PP
.BR getmsg ()
has no known bugs.
.\"
.\"
.SH COMPATIBILITY
.PP
.BR getmsg ()
is compatible with SVID,
.[
svid
.]
XID,
.[
xbd5
.]
SUSv2,
.[
susv2
.]
SUSv3,
.[
susv3
.]
POSIX,
and implementations based on
.IR "SVR 4.2" ,
.[
svr42cr
.]
including
.IR AIX \(rg,
.IR HP-UX \(rg,
.IR LiS ,
.IR OSF/1 \(rg,
.IR Solaris \(rg,
.IR SUPER-UX \(rg,
.IR UnixWare \(rg,
.IR UXP/V \(rg.
.PP
.BR getmsg ()
is compatible with LiS
.[
LiS
.]
with the following exceptions:
.IP \(em 4
.B LiS
.[
LiS
.]
implements
.B getmsg()
as a call to
.B getpmsg()
with a
.B NULL
.I bandp
pointer.
.IP \(em 4
.B LiS
.[
LiS
.]
incorrectly returns
.RB [ EINVAL ]
instead of
.RB [ EIO ]
when the internal head queue pointer points to a structure that is not a queue
structure, or is mangled.
.IP \(em 4
.B LiS
.[
LiS
.]
incorreclty returns
.RB [ EINVAL ]
instead of
.RB [ EIO ]
when
.I q->q_first
yeilds a
.BR "" non- NULL
message pointer, but
.B getq()
later cannot retrieve a message.
.IP \(em 4
.B LiS
.[
LiS
.]
does not return
.RB [ EIO ]
when
.B getmsg()
is called on a closing stream.
.IP \(em 4
.B LiS
.[
LiS
.]
incorrectly returns
.RB [ EAGAIN "] or [" EWOULDBLOCK ]
instead of
.RB [ EINTR ]
when an
.B M_SIG
message causes a signal that interrupts the call to
.B getmsg()
before any data is read.
.IP \(em 4
.B LiS
.[
LiS
.]
incorrectly returns
.RB [ ENODEV ]
instead of
.RB [ ENOSTR ]
when there is no stream associated with
.IR fd .
.IP \(em 4
.B LiS
.[
LiS
.]
incorrectly returns
.RB [ EINVAL ]
instead of
.RB [ ENODEV ]
when
.I fd
refers to a device that does not support the
.B getmsg()
system call.
.PP
.B Linux Fast-STREAMS
provides system calls for
.IR __NR_getpmsg " and " __NR_putpmsg
that are used to implement this system call.
(glibc has prototypes for this system call.)
In addition,
.B Linux Fast-STREAMS
recognizes the \*(lqinvalid\*(rq buffer length to
.BR read (2)
used by LiS to emulate the
.I __NR_getpmsg
system call, permitting LiS libaries to be used with
.BR "Linux Fast-STREAMS" .
.\"
.\"
.SH CONFORMANCE
.PP
SVID,
.[
svid
.]
XID,
.[
xbd5
.]
SUSv2,
.[
susv2
.]
SUSv3,
.[
susv3
.]
POSIX.
.\"
.\"
.SH HISTORY
.PP
.B getmsg()
first appeared in SVR 3.
.[
svr3
.]
.\"
.\"
.[
$LIST$
.]
.TI
