<html>



<head>

<title>Demand loading LiS</title>
<meta name="title" content="Demand loading LiS">
<meta name="keywords" content="Linux, streams, demand, loading, LiS">
<meta name="description" content="About demand loading LiS">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<style type="text/css">

<!--

h2 {  font-family: Arial, Helvetica, sans-serif}

h1 {  font-family: Arial, Helvetica, sans-serif}

h3 {  font-family: Arial, Helvetica, sans-serif}

p {  font-family: Arial, Helvetica, sans-serif; font-size: 12pt}

a {  font-family: Arial, Helvetica, sans-serif; color: #0000FF}

a:link {  font-family: Arial, Helvetica, sans-serif; color: #0000FF}

a:hover {  font-family: Arial, Helvetica, sans-serif; color: #FF3333}

li {  font-family: Arial, Helvetica, sans-serif; font-size: 10pt}

ol {  font-family: Arial, Helvetica, sans-serif; font-size: 10pt}

-->

</style>

<script language="JavaScript">

<!--

function MM_swapImgRestore() { //v3.0

  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;

}



function MM_preloadImages() { //v3.0

  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();

    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)

    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}

}



function MM_findObj(n, d) { //v3.0

  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {

    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}

  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];

  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document); return x;

}



function MM_swapImage() { //v3.0

  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)

   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}

}

//-->

</script>

</head>







<body bgcolor="#FFFFFF" onLoad="MM_preloadImages('i/kernel_on.gif','i/download_on.gif','i/install_on.gif','i/removal_on.gif','i/loading_on.gif','i/drivers_on.gif','i/config_on.gif','i/demand_on.gif','i/compiled_on.gif','i/apps_on.gif','i/otherres_on.gif','i/command_on.gif','i/dki_on.gif','i/libs_on.gif','i/lisdrvrs_on.gif')">
<table width="700" border="0" cellspacing="0" cellpadding="0" height="120" bgcolor="#6666CC">

	 <tr> 

		  <td width="120" height="120" rowspan="3"><a href="index.html"><img src="i/penguin.gif" width="120" height="120" border="0"></a></td>

		  <td rowspan="3" width="570" height="120" align="center" valign="middle"> 

			   <h1><font color="#FFFFFF" style="font-size:30pt;">Linux STREAMS (LiS)</font></h1>

			 </td>

		  <td bgcolor="#ffffff" rowspan="3" width="10" height="120"><img src="./i/sideborder.gif" width="10" height="130"></td>

	 </tr>

	 <tr> </tr>

	 <tr> </tr>

</table>

<img src="./i/bottomborder.gif" width="703" height="15"> <br>

<table width="700" border="0" cellspacing="0" cellpadding="0">

  <tr> 

    <td rowspan="2" width="100" align="left" valign="top"> 
      <table width="90" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td><a href="kernel.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('kernel','','i/kernel_on.gif',1)"><img name="kernel" border="0" src="i/kernel_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="download.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('download','','i/download_on.gif',1)"><img name="download" border="0" src="i/download_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="install.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('install','','i/install_on.gif',1)"><img name="install" border="0" src="i/install_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="removal.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('removal','','i/removal_on.gif',1)"><img name="removal" border="0" src="i/removal_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="loading.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('loading','','i/loading_on.gif',1)"><img name="loading" border="0" src="i/loading_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="drivers.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('drivers','','i/drivers_on.gif',1)"><img name="drivers" border="0" src="i/drivers_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="config.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('config','','i/config_on.gif',1)"><img name="config" border="0" src="i/config_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="demand.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('demand','','i/demand_on.gif',1)"><img name="demand" border="0" src="i/demand_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="compiled.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('compiled','','i/compiled_on.gif',1)"><img name="compiled" border="0" src="i/compiled_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="apps.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('apps','','i/apps_on.gif',1)"><img name="apps" border="0" src="i/apps_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="otherres.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('otherres','','i/otherres_on.gif',1)"><img name="otherres" border="0" src="i/otherres_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="cmds.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('cmds','','i/command_on.gif',1)"><img name="cmds" border="0" src="i/command_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="dki.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('dki','','i/dki_on.gif',1)"><img name="dki" border="0" src="i/dki_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="libc.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('libs','','i/libs_on.gif',1)"><img name="libs" border="0" src="i/libs_off.gif" width="81" height="35"></a></td>
        </tr>
        <tr> 
          <td><a href="drvrs.html" onMouseOut="MM_swapImgRestore()" onMouseOver="MM_swapImage('lisdrvrs','','i/lisdrvrs_on.gif',1)"><img name="lisdrvrs" border="0" src="i/lisdrvrs_off.gif" width="81" height="35"></a></td>
        </tr>
      </table>
    </td>

    <td width="600" height="75"> 

      <div align="center"> 
        <h2><a name="demand_loading"></a>Demand loading LiS modules and drivers 
        </h2>

      </div>

    </td>

  </tr>

  <tr> 
    <td width="600" height="100%" align="left" valign="top"> 
      <p align="left">The LiS demand load system supports both the old kerneld 
        and the new kmod mechanisms for demand loading kernel modules. </p>
      <p>The convention for LiS kernel loadable object files is: </p>
      <ul>
        <li>Their name start with <tt>&quot;<font face="Courier New, Courier, mono">streams-</font>&quot;</tt>.</li>
        <li>They are placed in <tt><font face="Courier New, Courier, mono">/lib/modules/</font></tt><b><tt>&lt;kver&gt;</tt></b><tt><font face="Courier New, Courier, mono">/misc/</font></tt>, 
          where <b><tt>&lt;kver&gt;</tt></b> is the kernel version.</li>
      </ul>
      <h2><font size="4"><a name="kernelversiondiffs"></a>Kernel Version Diffrences</font></h2>
      <p>For 2.4 kernels you can install your loadable module simply by copying 
        the &quot;.o&quot; file for our module to the directory <tt><font face="Courier New, Courier, mono">/lib/modules/</font></tt><b><tt>&lt;kver&gt;</tt></b><tt><font face="Courier New, Courier, mono">/misc/</font></tt>.</p>
      <p>For 2.6 the procedure involves an additional step. Loadable modules in 
        2.6 are &quot;.ko&quot; files instead of &quot;.o&quot; files. The mechanism 
        to turn a driver.o into a driver.ko is non-trivial. To do this, copy your 
        driver.o file to <font face="Courier New, Courier, mono">/usr/src/LiS/modules</font>. 
        Then do a &quot;make install&quot; in the LiS directory. LiS will turn 
        all &quot;.o&quot; files in its <font face="Courier New, Courier, mono">modules</font> 
        subdirectory into &quot;.ko&quot; files and copy the resultant files to 
        the proper subdirectory of <font face="Courier New, Courier, mono">/lib/modues</font>.</p>
      <h2><font size="4">Unconfig</font><font size="4">ured drivers and modules</font></h2>
      <p>An unconfigured driver or module is a driver or module that LiS does 
        not have any special information about. Even in this case, you can take 
        advantage of demand loading. </p>
      <h4>Modules</h4>
      <p>Module demand loading is simple. When a user does an <font face="Courier New, Courier, mono">I_PUSH 
        </font>requesting that module <tt><font face="Courier New, Courier, mono">mymod</font></tt> 
        be pushed onto a stream, LiS will check if <tt><font face="Courier New, Courier, mono">mymod</font></tt> 
        is already registered. If not, LiS asks the kernel to load <tt>streams-<font face="Courier New, Courier, mono">mymod</font></tt>. 
      </p>
      <p>A security related implication of this is that any user capable of doing 
        an <font face="Courier New, Courier, mono">I_PUSH</font> can provoke loading 
        of any module that has the <tt>streams-</tt> prefix. </p>
      <p>Demand loading also works when autopushing modules, but you should be 
        aware that when a module is unloaded, it is silently removed from all 
        autopush lists. </p>
      <p>You can have more than one module in a single kernel loadable module, 
        but for demand loading to work with modules whose object names are not 
        derived from the module name, you have to set up <tt>alias</tt> lines 
        in <tt>/etc/conf.modules</tt>. <br>
        For example, if you have modules <tt><font face="Courier New, Courier, mono">mymod</font></tt> 
        and <tt><font face="Courier New, Courier, mono">mymod2</font></tt> in 
        the kernel loadable object file <tt>streams-mymod.o</tt>, you have to 
        add the line </p>
      <blockquote> 
        <p><tt>alias streams-<font face="Courier New, Courier, mono">mymod2</font> 
          streams-<font face="Courier New, Courier, mono">mymod</font></tt></p>
      </blockquote>
      <p>in your <tt>/etc/conf.modules</tt> for demand loading to work properly 
        when pushing <tt><font face="Courier New, Courier, mono">mymod2</font></tt>. 
      </p>
      <h4>Drivers</h4>
      <p>Demand loading drivers is slightly more complicated. When a device special 
        node with major device number <b><tt>major</tt></b> is opened, the kernel 
        checks if device <b><tt>major</tt></b> is registered in the kernel. If 
        not, the kernel will try to load <tt>&quot;char-major-</tt><b><tt>major&quot;</tt></b>.</p>
      <p><br>
        If a clone open is done LiS will check if the driver is registered. If 
        not, LiS will ask the kernel to load <tt>char-major-</tt><b><tt>minor</tt></b>, 
        where <b><tt>minor</tt></b> is the minor device number of the clone device 
        opened. In this case the value of <b><tt>minor</tt></b> is the major device 
        number of the driver that needs to be loaded and opened.</p>
      <p>Kernel loadable modules generally do not have names of the form <tt>char-major-<b>number</b></tt>, 
        so a mapping to the correct name is needed. This is done with <tt>alias</tt> 
        lines in <tt>/etc/conf.modules</tt>, or, on newer systems, <tt>/etc/modules.conf</tt>. 
        If your driver has major device number <tt>123</tt> and is in the kernel 
        loadable object file <tt>streams-mydriver.o</tt>, you should have the 
        line </p>
      <blockquote> 
        <p><tt>alias char-major-123 streams-mydriver</tt></p>
      </blockquote>
      <p>in your <tt>/etc/conf.modules</tt>. </p>
      <p><br>
        If you also have the line </p>
      <blockquote> 
        <p><tt>alias char-major-240 streams</tt></p>
      </blockquote>
      <p>in your <tt>/etc/conf.modules</tt> and the clone driver major is 240, 
        both LiS and your driver will be demand loaded when you do a clone open 
        of your driver. </p>
      <p>You can configure autopush on an unconfigured driver, but you should 
        be aware that when the driver is unloaded, all its autopush lists are 
        silently removed. </p>
      <p>You can have more than one driver in a single kernel loadable module, 
        but you should set up a separate <tt>alias</tt> line for each driver. 
      </p>
      <h2><font size="4">Configured drivers and modules</font></h2>
      <p>When drivers and modules are added to the <a href="config.html#config_files">LiS 
        configuration files</a>, you can specify the object name that will be 
        used for requesting a demand load of the driver or module. If demand loading 
        of the configured object name fails, LiS will revert to the procedure 
        for demand loading an unconfigured driver or module.</p>
      <p><br>
        The advantage of configured drivers and modules is that the LiS installation 
        procedure takes care of adding the needed <tt>alias</tt> lines to <tt>/etc/conf.modules</tt>. 
        Also, the autopush configuration is not changed when a configured driver 
        or module is unloaded. </p>
      <h2><font size="4">Writing kernel loadable modules for LiS</font></h2>
      <p>It takes little extra effort to make LiS modules and drivers loadable. 
        In most cases, all you have to do is to add the special Linux module functions 
        <tt>init_module()</tt> and <tt>cleanup_module()</tt> and some lines to 
        maintain the usage count of the loadable module. </p>
      <p>The <tt>init_module()</tt> function id used for initializing the loadable 
        module, and can be as simple as: <tt>&nbsp;&nbsp;&nbsp; </tt></p>
      <pre><tt>  int init_module(void)</tt>   
 <tt> {</tt> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>   
    <tt>return lis_register_strmod(&amp;mymod_info, &quot;mymod&quot;);</tt>  
  <tt>}</tt>        </pre>
      <p>for a module, or <tt>&nbsp;&nbsp;&nbsp; </tt></p>
      <pre><tt>  int init_module(void)
  {</tt>
    <tt>return lis_register_strdev(123,&amp;mydrv_info,</tt> <tt>10, &quot;mydrv&quot;);
  }</tt></pre>
      <p>for a driver.</p>
      <p>In this example, the driver's major device number is assumed to be 123. 
        You must know this major device number ahead of time so that you can make 
        the entry in the <font face="Courier New, Courier, mono">/dev</font> directory 
        that will cause your driver to autoload. The major number in your <font face="Courier New, Courier, mono">/dev</font> 
        entry and in your call to <font face="Courier New, Courier, mono"><tt>lis_register_strdev</tt></font> 
        must match.</p>
      <p>The <tt>cleanup_module()</tt> function is called by the kernel just before 
        a loadable module is unloaded. This function has to unregister the drivers 
        and/or modules registered in the <tt>init_module()</tt> function.</p>
      <p><br>
        The <tt>cleanup_module()</tt> function can be as simple as: <br>
        <tt>&nbsp;&nbsp;void cleanup_module(void)</tt> <br>
        <tt>&nbsp;&nbsp;{</tt> <br>
        <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lis_unregister_strmod(&amp;mymod_info);</tt> 
        <br>
        <tt>&nbsp;&nbsp;}</tt> <br>
        for a module, or <br>
        <tt>&nbsp;&nbsp;void cleanup_module(void)</tt> <br>
        <tt>&nbsp;&nbsp;{</tt> <br>
        <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lis_unregister_strdev(123);</tt> <br>
        <tt>&nbsp;&nbsp;}</tt> <br>
        for a driver. </p>
      <p>To avoid that the loadable module is unloaded while somebody is still 
        using it, a usage count has to be maintained. This is done using the macros 
        <tt>MOD_INC_USE_COUNT</tt> and <tt>MOD_DEC_USE_COUNT</tt>. <tt>MOD_INC_USE_COUNT</tt> 
        is used in the open routines, but be careful not to call it if your open 
        fails. <tt>MOD_DEC_USE_COUNT</tt> is used in the close routines. </p>
      <p>For a complete example, see the <a href="drvrs.html#link-drvr"><font face="Courier New, Courier, mono">ldl</font></a> 
        driver in <tt>drivers/str/linux/ldl.c</tt>. </p>
      <h3><a name="QueueLocking"></a>Queue Locking in Loadable Modules</h3>
      <p>Declared modules can use the <a href="config.html#QueueLockingSpecification">strconf 
        qlock option</a> to control the locking style for entering the driver's 
        put and service procedures. A loadable module can call one of the following 
        routines, most likely at module load time.</p>
      <pre>int lis_register_driver_qlock_option(major_t major, int qlock_option);
int lis_register_module_qlock_option(modID_t id, int qlock_option);        </pre>
      <p>The parameters <i>major</i> and <i>id</i> are obtained from the driver 
        and module registration functions described above.</p>
      <p>The <i>qlock_option</i> parameter is one of the following:</p>
      <table width="45%">
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_NONE</td>
        </tr>
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_QUEUE</td>
        </tr>
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_QUEUE_PAIR</td>
        </tr>
        <tr> 
          <td width="11%">&nbsp;</td>
          <td width="89%">LIS_QLOCK_GLOBAL</td>
        </tr>
      </table>
      <p>&nbsp;</p>
      <p>&nbsp;</p>
    </td>

  </tr>

</table>

<p align="left">&nbsp;</p>



</body>



</html>



