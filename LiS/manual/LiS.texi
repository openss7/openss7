% -*- texinfo -*- vim: ft=texinfo
% =========================================================================
%
% @(#) $Id: LiS.texi,v 1.1.6.4 2005/03/15 00:56:39 brian Exp $
%
% =========================================================================
%
% Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
% Copyright (C) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any success
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2005/03/15 00:56:39 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename LiS.info
@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE Installation and Reference Manual
@settitle @value{MANUAL_TITLE}

@dircategory Kernel
@direntry
* Linux STREAMS: (LiS).                         Sys V STREAMS for Linux.
@end direntry

@defindex op

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE Installation and Reference Manual

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}.

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE Installation and Reference Manual

@ignore
@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@end ignore
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2005  OpenSS7 Corporation <@uref{http://www.openss7.com/}> @*
Copyright @copyright{} 1997-2000  Brian F. G. Bidulock <@email{bidulock@@openss7.org}> @*
All Rights Reserved. @*

@noindent
Published by OpenSS7 Corporation @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
This is texinfo edition @value{PACKAGE_RELEASE} of the @value{MANUAL_TITLE}
documentation, and is consistent with @value{PACKAGE_NAME} @value{PACKAGE_VERSION}.
This manual was developed under the @uref{http://www.openss7.org/, OpenSS7
Project} and was funded in part by
@uref{http://www.hob.de/, HOB International}.

@noindent
Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

@noindent
Permission is granted to copy and distribute translations of this manual into
another language, under the same conditions as for modified versions.

@vskip 0pt
@end titlepage
@page

@c Define an index of authors.
@defindex au

@c Define an index of configure output variables.
@c @defcodeindex ov

@c Define an index of configure variables.
@c @defcodeindex cv

@c Define an index of options.
@c @defcodeindex op

@c Define an index of targets.
@c @defcodeindex tr

@c Define an index of commands.
@c @defcodeindex cm

@c Put the macros and variables into their own index.
@c @syncodeindex fn cp
@c @syncodeindex ov vr
@c @syncodeindex cv vr
@c @syncodeindex fn vr

@c Put everything else into one index (arbitrarily chosen to be the concept index).
@c @syncodeindex op cp
@c @syncodeindex tr cp
@c @syncodeindex cm cp

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@unnumbered About This Manual
This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of @cite{The
@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
release @value{PACKAGE_RELEASE} of the @value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Introduction to LiS::			An introduction.
* Release Notes::			LiS release notes.
* Downloading LiS::			Obtaining LiS.
* Installation of LiS::			Installation of LiS.
* Removal of LiS::			Removal of LiS.
* Loading LiS::				Loading LiS.
* Coding LiS Drivers::			Writing LiS drivers.
* Configuration::			Configuration of LiS.
* Demand Loading LiS Modules::		Demand loading modules.
* Installing Pre-Compiled Drivers::	Using pre-compiled binaries.
* Coding STREAMS Applications::		Writing STREAMS applications.
* LiS SMP Implementation::		How LiS does SMP.
* Other Resources::			Links.
* LiS User Commands::			User command reference.
* LiS Driver/Kernel Interface::		Driver/Kernel function reference.
* LiS Library Routines::		Library call reference.
* LiS Drivers::				Included drivers and modules.
* Licenses::				GPL, LGPL and GFDL.

* Author Index::			Index of LiS authors.
* Concept Index::			Index of LiS concepts.
* Function and Macro Index::		Index of functions and macros.
* Variable and Constant Macro Index::	Index of variables and macros.
* Data Type Index::			Index of data structures.
* Program and File Index::		Index of programs and files.
* Configuration Keyword Index::		Index of configuration keywords.
@end menu

@menu
  ---- detailed node listing ----

Release Notes:

* OpenSS7 Releases::			OpenSS7 releases of LiS.
* Kernel Compatibility Issues::		Kernel compatibility issues.
* Open Flags::				Use of the flags to open.
* System Calls::			System call interface.
* Libraries::				Libraries for STREAMS functions
* Other Interactions::			Interactions with kernel packages.
* Kernel Version 2.3.x::		Old kernel compatibility.
* stropts.h Compatibility::		Old header compatibility.
* Major Device Number Compatibility::	Major device numbers.

Downloading LiS:

* Downloading the Binary RPMs::		The easiest method.
* Downloading the Source RPM::		The next best method.
* Downloading the Tar Ball::		The final resort method.
* Old LiS Download Instructions::	Don't do this.

Installation of LiS:

* Installing the Binary RPMs::		The easiest method.
* Installing the Source RPM::		The next best method.
* Installing the Tar Ball::		The final resort method.
* Old LiS Installation Instructions::	Don't do this.

Removal of LiS:

* Removing the Binary RPMs::		The easiest method.
* Removing the Source RPM::		The next best method.
* Removing the Tar Ball::		The final resort method.
* Old LiS Removal Instructions::	Don't do this.

Configuration:

* Config Files::			Configuration files.
* SVR4 Compatibility::			Compatibility with Sys V.
* Loadable STREAMS Modules::		Loadable modules.
* The strconf Utility::			Configuration utilities.
* Configuration File Syntax::		The driver config file format.
* Driver Specification::		Specifying a driver.
* Module Specification::		Specifying a module.
* Node Specification::			Node specification.
* Device Specifications::		Device specification.
* Initialization Specification::	Driver initialization.
* Termination Specification::		Driver termination.
* Interrupt Specification::		Driver interrupts.
* Object Name Specification::		Module object name.
* Loadable Specification::		Loadable module specification.
* Autopush Specification::		Autopush specification.
* Tunable Parameter Specification::	Tunable parameters.
* The Space.c File::			The optional Space.c file.
* A Simple Example::			Examples.
* Installing Your Driver::		Installation.

LiS User Commands:

* fattach::				Attach a file to a stream.
* fdetach::				Detach a file from a stream.
@ignore
* ldlconfig::				Configure the Linux DL driver.
* ldltest::				Test the Linux DL driver.
@end ignore
* polltst::				Test poll.
* streams::				Control LiS.
* strmakenodes::			Make fundamental devices.
* strtst::				Test LiS.
* timetst::				Test timers.

LiS Driver/Kernel Interface:

* Operating System Interface::		OS interface functions.
* PCI BIOS Interface::			PCI BIOS interface functions.
* PCI Interface::			PCI interface functions.
* IRQ Interface::			IRQ interface functions.
* I/O Memory Mapping::			I/O memory mapping functions.
* I/O Port Access::			I/O port access functions.
* Memory Allocation::			Memory allocation functions.
* DMA Routines::			DMA functions.
* Delay Routines::			Delay functions.
* Printing Routines::			Printing functions.
* Timer Routines::			Timer functions.
* Sleep and Wakeup Routines::		Sleep and wakeup functions.
* Thread Creation::			Thread creation functions.
* Major/Minor Device Numbering::	Device numbering functions.
* LiS Memory Allocation::		LiS memory allocation.
* LiS malloc and free Equivalents::	LiS memory allocation.
* LiS Kernel Memory Allocators::	LiS memory allocation.
* LiS Page Allocator::			LiS memory allocation.
* LiS PCI Interface::			LiS PCI interface.
* The LiS PCI Device Structure::	LiS PCI interface.
* LiS PCI Search Routines::		LiS PCI interface.
* LiS PCI Configuration Space Routines:: LiS PCI interface.
* LiS PCI DMA Routines::		LiS PCI interface.
* LiS Atomic Functions::		LiS atomic functions.
* LiS Locks::				LiS locking functions.
* LiS Spin Locks::			LiS locking functions.
* Lock Nesting::			LiS locking functions.
* LiS Read/Write Locks::		LiS locking functions.
* LiS Interrupt Enable/Disable::	LiS interrupt functions.
* LiS Semaphores::			LiS semaphores.
* Debugging Spin Locks::		Debugging locks.
* Debugging Semaphores::		Debugging sempahores.
* STREAMS Utility Routines::		STREAMS utility functions.
* Flushing Queue Bands::		Flushing queues.
* Utility Prototypes::			STREAMS utility prototypes.
* System Calls from within the Kernel::	Linux system calls.

LiS Library Routines:

* Library Routines::			STREAMS library routines.
* Using the Library::			STREAMS library routines.

LiS Drivers:

* STREAMS Drivers::			LiS STREAMS drivers.
* Pushable Modules::			LiS STREAMS modules.

STREAMS Drivers:

* clone-drvr::				The clone driver.
* fifo::				STREAMS-based FIFOs.
@ignore
* link-drvr::				Linux DL driver.
@end ignore
* loop-around::				Loop-around test driver.
* mini-mux::				Mini multiplexing driver.
* printk::				Print test driver.
* sad::					STREAMS Administrative Driver.

Pushable Modules:

* connld::				Connection listening daemon.
@ignore
* ip_strms::				IP streams driver.
@end ignore
* pipemod::				STREAMS-based Pipes.
* relay relay2::			Relay test driver.
@ignore
* timod::				XTI/TLI library module.
* tirdwr::				XTI/TLI read/write module.
@end ignore
@end menu

@node Introduction to LiS
@chapter Introduction to LiS

LiS is a software package that comprises an implementation of SVR4
compatible STREAMS for Linux.  It takes the form of a loadable module for
the Linux kernel.  LiS installs in any directory on your system, not in the
kernel source tree.  (@pxref{Installation of LiS}) When it is built it is
possible to link pre-compiled STREAMS drivers with it so that when LiS
loads into the kernel it brings "application" drivers with it.
(@pxref{Installing Pre-Compiled Drivers}) Alternatively, STREAMS drivers
can be coded as loadable Linux drivers which depend upon LiS.
(@pxref{Demand Loading LiS Modules}) In this way, individual
STREAMS drivers can be loaded and unloaded dynamically.

@ignore
LiS includes two adapter drivers to assist in interfacing STREAMS drivers
to the Linux Kernel's TCP/IP protocols.  One driver, @dfn{ip_strm_mod}
(@pxref{ip_strms}), acts as an IP interface driver.  It fits below IP using
standard ifconfig procedures.  It, in turn, communicates downstream with
any STREAMS driver using the DLPI protocol in a fashion similar to the
manner in which IP on Unix systems interfaces to lower interface drivers.
This allows a DLPI STREAMS driver to act as an interface driver to Linux
TCP/IP.

A second driver, @dfn{ldl} (@pxref{link-drvr}), sits on top of any
existing Linux IP interface driver and presents a DLPI interface to
STREAMS drivers above.  This allows any STREAMS driver that communicates
downstream using DLPI to utilize the services of existing Linux drivers
for Ethernet, token ring, etc.
@end ignore

LiS-2.12 and beyond utilizes aggressive multi-tasking in multiple CPU SMP
environments.  For further information concerning this implementation, see
the section on LiS SMP Implementation.

@ignore
LiS is licensed using the GNU General Public Library License.
@@ignore
(except for
ldl, which is licensed under the standard GNU Public License).
@@end ignore
This means
that you can link proprietary STREAMS drivers with LiS and load the
entirety into the Linux kernel without violating license restrictions.
This licensing arrangement is intended to encourage commercial software
vendors to port STREAMS based driver packages to Linux.
@end ignore

@strong{WARNING:} This autoconf/RPM release of Linux STREAMS is distributed
under the terms of the GNU Public License (GPL) and @emph{not} the GNU
Lesser Public License (LGPL).

This means that you @emph{cannot} link proprietary STREAMS drivers with LiS
and load the entirety into the Linux kernel without violating license
restrictions.  OpenSS7 Corporation can remove this restriction for subscribers
and sponsors of the OpenSS7 Project.

@section LiS Documentation

These documentation pages are included in the LiS distribution.  You can
also access the original documentation release from Gcom's home page at
@uref{http://www.gcom.com}.  Gcom's site offers a search capability that
allows you to search the LiS documentation.  Just use the search mechanism
on the home page and restrict the search to the Linux portion of the site.

@section Authors

Linux STREAMS, termed LiS, is an SVR4 compatible STREAMS executive which
runs in the Linux Kernel as a loadable module.  It is the product of a
joint effort among the following authors.

Francisco J. Ballesteros @email{nemo@@gsyc.escet.urjc.es}
@auindex Ballesteros, Francisco J.

John Boyd @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

Denis Froschauer @email{Denis.Froschauer@@hol.fr}
@auindex Froschauer, Denis

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole

Jürgen Magin @email{juergen.magin@@octogon.de}
@auindex Magin, Jürgen

Graham Wheeler @email{gram@@cdsec.com}
@auindex Wheeler, Graham

G Yeganjaiah @email{yegag@@hclt.com}
@auindex Yeganjaiah, G

Brian Bidulock @email{bidulock@@openss7.org}
@auindex Bidulock, Brian F. G.

Brian Bidulock is the principal active supporter of LiS, so please direct
questions to hime rather than the others.
@footnote{David Grothe was the previous maintainer of the LiS-2.16 releases;
however, David is no longer maintaining any version of LiS.  Please do not
direct maintenance requests at David.}
@ignore
David Grothe is the principal active supporter of LiS, so please direct
questions to him rather than to the others.
@end ignore
Ole Husgaard
@ignore
is responsible for the ldl driver and
@end ignore
has contributed to the kerneld support and installation
procedures.  Jürgen Magin contributed patches for Linux SPARC.  G Yeganjaiah
added interrupt routine support.  John Boyd implemented fattach and STREAMS
pipes and FIFOs.  Brian Bidulock developed a complete set of manual pages
for LiS, converted the build process to autoconf, wrapped the source RPMS
and updated this manual for texinfo.

See @ref{Author Index}, for a complete listing and cross-index of authors to
sections of this document.

Francisco Ballesteros still maintains an LiS mailing list.  Click Here to
Subscribe to the LiS mailing list
@auindex Grothe, David
@auindex Husgaard, Ole
@auindex Boyd, John
@auindex Ballesteros, Francisco J.
@auindex Magin, Jürgen
@auindex Yeganjaiah, G
@auindex Bidulock, Brian F. G.

You can mail to the group by addressing email to
@email{linux-streams@@gsyc.escet.urjc.es}.

You can view the archives at
@uref{http://gsyc.escet.urjc.es/mailarchive/linux-streams}.

@node Release Notes
@chapter Release Notes

@menu
* OpenSS7 Releases::			OpenSS7 releases of LiS.
* Kernel Compatibility Issues::		Kernel compatibility issues.
* Open Flags (obsolete)::		Use of the flags to open.
* System Calls (obsolete)::		System call interface.
* Libraries::				Libraries for STREAMS functions
* Other Interactions::			Interactions with kernel packages.
* Kernel Version 2.3.x::		Old kernel compatibility.
* stropts.h Compatibility::		Old header compatibility.
* Major Device Number Compatibility::	Major device numbers.
@end menu

@node OpenSS7 Releases
@section OpenSS7 Releases

@subsection OpenSS7 Release LiS-2.16.18-22

Replaced m4 and automake files with common equivalents.  This allows the same
set of m4 macros and automake fragments to be used with all of the OpenSS7
release packages.  Maintenance is easier as one correction will propagate across
all items.  Performed similar function with texinfo documentation pieces.

@subsection OpenSS7 Release LiS-2.16.18-21

Removed all XTI/TLI and Linux networking code, headers and documentation from
LiS distribution and bumped epoch to 2.  Linux networking code has been
migrated to the @strong{strxns}, @strong{strxnet}, @strong{strinet} and
@strong{strsctp} packages.  The purpose for doing this was to allow the Linux
networking to build against Linux Fast-STREAMS as well as Linux STREAMS and is
a preparation for phasing out LiS and phasing in LfS.

Added missing @file{configure.nexusware} to distribution.  LiS cache options
now default to 'no' because of instabilities with timers.

Not publicly released.

@subsection OpenSS7 Release LiS-2.16.18-20

Minor corrections: made conflicting manpage @file{xti_sctp.3} dependent on
OpenSS7 SCTP kernel.

Not publicly released.

@subsection OpenSS7 Release LiS-2.16.18-19

Changes to compile, install and builds rpms for Fedora Core 1 (FC1), Whitebox
Enterprise Linux (WBEL) and RedHat Enterprise Linux 3 (EL3).  Included
explicit epoch in internal dependencies in spec file for RPM versions 4.2.1,
4.2.2 and higher.  Added hugemem kernel detection and moved getpmsg and
putpmsg manual pages.

Correction to symbolic linking and system map file location during non-rpm
autoconf installation.

Correction to zero @code{maxlen} behavior in @code{t_rcvconnect()}.

@subsection OpenSS7 Release LiS-2.16.18-18

Added check for @code{CONFIG_REGPARM}, addition of @code{-mregparm=3}
@code{CFLAGS}, addition of @code{regparm_} prefix for exported ksyms.

Minor corrections to separate build directory install of devices and caching
of detected ksyms.

@subsection OpenSS7 Release LiS-2.16.18-17

Added option @code{--disable-k-modversions} to supress versioning of LiS
exported symbols.

A couple of corrections to the build process reported by Gurol.  Changed order
of build in `make rebuild' target to build tools last so that the rpm debug
package is built correctly on RH9.

Change @code{MODULE_PARM} to static so that @code{make install-strip} does not
strip module parameter symbols.

Added @code{lis_check_mem_region()}, @code{lis_release_mem_region()} and
@code{lis_request_mem_region()} for memory mapped io instead of just io.

Added @code{printk} patches discussed on linux-stream mailling list.  Added
gcc @code{printf} checking and corrected errors in LiS debugging @code{printk}
statements.

Added HP patches.  There are a couple of questionable components in the HP
patches that I reversed.  They include;

@itemize @bullet
@item
modification of @code{lis_msgsize} to @code{lis_msgdsize}.  This would change
the calculation of queue counts.  Queue counts aren't @code{M_DATA} counts,
they are "data" message counts.  LiS probably doesn't have this the right way,
but @code{lis_msgdsize} is not correct either.

@item
addition of @code{qi_mstat->ms_pcnt} increment on @code{lis_safe_putmsg}.
Same for @code{ms_scnt}, @code{ms_ocnt}, @code{ms_ccnt}.  STREAMS is not
supposed to increment counts.  It is the module writer's responsibility to
increment counts in their own queue procedures.
@end itemize


Added HP @code{ldl} patches.

Made modifications to @code{putq()}, @code{putbq()}, @code{insq()} and
@code{appq()} discussed on linux-streams mailing list.  These do not free
messages on failure.  Modified all ocurrences internal to LiS to free the
message on error to ensure old behavior.

Added HP dejagnu patches to @code{strtst} and added dejagnu testsuite
directory and file.  Added the @code{make check} target.  Use @code{DEJATOOLS}
on the make command line to invoke the tests, such as
`@code{make DEJATOOLS=strtst check}' to invoke the tests.  Because a patched
@code{netperf} is not commonly available and @code{netperf} will not be
distributed with the package, GNU @code{autotest} might be a better choice.
But that's for a later release.

@subsection OpenSS7 Release LiS-2.16.18-16

General updates to the build process, optimization options, build options.
Corrected library linkage.  Synced TLI modules and INET driver to Linux
Fast-STREAMS.  Removed deadlock from INET driver and loosened locking.
Unfortunately suitable libraries must be installed before distcheck will
clear.

Smoother and more reliable stripping of kernel symbols, starts with
/proc/ksyms if applicable then System.map then modversions.h to attempt to
choose symbols most closely synced with an installed or running kernel.

Improvements to autoconf installation of manpages (autocompressed now) and
info and pdf manuals are distributed.  install-strip target will actually
properly strip kernel modules.

Included an option to build and install only kernel or user parts of package
to speed rpm rebuild process for multiple kernel.  Added `rebuild' target to
rebuild the rpms from srpm for multiple kernel and architectures.  Added a
`sign' and `resign' target to sign srpm and rebuilt rpms respectively.

Greatly enhanced cross-build and cross-compile support, primarily in support
of the NexusWare embedded target.  Added NexusWare helper script and
documentation.  DESTDIR is now a blessed environment variable used by
configure to set the cross-build root as well as the install root.  Try adding
--with-k-optimize='size' to configure to optimize for size for embedded
targets.  Builds clean against NexusWare24 (810p0674.10-rc4).

Added start of an option to build as linkable object for embedded targets
rather than loadable kernel module.

@subsection OpenSS7 Release LiS-2.16.18-15

Fixed several symbol errors that made -13 and -14 unusable.  Corrected error
in calculation of kernel debug flags.

@subsection OpenSS7 Release LiS-2.16.18-14

A few more enhancements to the build process to work with autoconf 2.59.

@subsection OpenSS7 Release LiS-2.16.18-13

Enhanced build process for autoconf-2.59, automake-1.8.3, gettext-0.14.1, and
libtool-1.5.6.

@subsection OpenSS7 Release LiS-2.16.18-12

Added defaults for SK_WMEM_MAX and SK_RMEM_MAX for lastest 2.4.25 and 2.4.26
kernel builds.

Enhanced build process.
  
All kernel symbols exported by LiS are versioned on kernels that have
versioned symbols.  This makes it safer to compile kernel modules against
kernel/LiS combinations.  This is in preparation for splitting off the strxnet
package, and the technique was imported from the Linux Fast-STREAMS build.

@subsection OpenSS7 Release LiS-2.16.18-11

Ripped three additional kernel symbols in support of INET driver that were
missing in -10 release.

@subsection OpenSS7 Release LiS-2.16.18-10

Added support for cooked manpages both for non-rpm systems and for rpm
systems.  It is still better to leave manpages uncooked for rpm releases
because they are much smaller that way.  Give the --with-cooked-manpages flag
to configure if you want cooked manpages.  You still need grefer on the build
system.

Updates to all manual pages in man7, and some others (xti) in man3.  Removed
unused .macros and .refs files.

Moved automake fragments into separate directory.  Cleaned up automake
fragments.

Rearranged header files in the xti subdirectory to install in LiS package
include directory instead.  Reworked xti, tihdr and tiuser file groups to
include properly from kernel or user space independent of order.  tiuser and
xti still cannot be included together.  Added older TLI interface <tiuser.h>
that is still consistent with newer XTI interface.  Changed references in man
pages to XTI/TLI instead of just XTI.

Added ticlts.h, ticots.h and ticotsord.h header files.  Updated dlpi.h and
npi.h header files.  Removed sys/LiS/tpicommon.h because it is largely
replaced by sys/tli.h and sys/tpi.h.  Removed the, now redundant, xti header
file subdirectory.

A series of bug fixes to xnet.c (libxnet) that resulted from discussions with
Gurol Akman on openss7-develop mailing list.  Mostly surrounding t_alloc and
t_getinfo behaviour and the behavior when NULL pointers are passed to various
XTI/TLI library calls.  Updated xti documentation as well.

Many changes to the inet.c INET driver.  Wildcard IP addresses can now be
bound and wildcard addresses will be assigned with no address is passed to
most providers.  (/dev/rawip still requires an address or TNOADDR is
returned.)  Option management has been extensively rewritten to be more
conformant to XNS documentation.  Test programs test-inet_raw, test-inet_udp,
test-inet_tcp have been upgraded and converted to multiple child processes.  A
number of fixes to SMP lock behavior and M_FLUSH have beend added as reported
by Dave Grothe.  Corrected all level and TBADOPT behavior on negotiation.

Although this driver is now closer to expected behavior, it has not been
tested for XNS 5.2 compliance, nor will it be until someone has the time to
extend the test programs to handle all test cases in a similar manner as was
done for the library.  Your mileage many vary.  Remember, there is no
warranty.

@subsection OpenSS7 Release LiS-2.16.18-9

Changes primarily in support of builds on HPPA (PARISC) architectures.  LiS
doesn't build too well on PARISC so some modifications where used from the
Linux Fast-STREAMS package to correct deficiencies.  Better building on recent
2.4 kernels (2.4.23, 2.4.24, 2.4.25) is also provided.

@subsection OpenSS7 Release LiS-2.16.18-8

Changes to permit better builds on recent RedHat kernels, and especially
kernel-2.4.20-30.9.

@subsection OpenSS7 Release LiS-2.16.18-7

Fixed a module loading bug in LiS.  Previously modules would not demand load.

@subsection OpenSS7 Release LiS-2.16.18-6

Fixed a possible null pointer dereference in libxnet.  Corrected t_bind to
return TNOADDR instead of TBADADDR on wildcard bind attempt.  Module loading
bug patched.

@subsection OpenSS7 Release LiS-2.16.18-5

Fixes a t_open and t_bind problem in libxnet.  Fixes alignemnt of data portion
of mblks.  Adds (untested) ticots_ord, ticots and ticlts devices over UNIX
domain sockets.

@subsection OpenSS7 Release LiS-2.16.18-4

Adds back in missing strms_up/down/status scripts to distribution and install.

@subsection OpenSS7 Release LiS-2.16.18-3

Not publicly released.

@subsection OpenSS7 Release LiS-2.16.18-2

Not publicly released.

@subsection OpenSS7 Release LiS-2.16.18-1

This OpenSS7 release of LiS-2.16.18 updates the previous LiS-2.16.16 rpm
release to the lastest LiS-2.16 release level.

@subsection OpenSS7 Release LiS-2.16.16-1

This OpenSS7 release of LiS-2.16.16 includes autoconf for configuration,
complete manual pages and documentation, and packaging in source and
binary RPMs for ease and repeatability of installation.  The package also
builds and installs properly versioned LiS shared object libraries.

Before the OpenSS7 release of LiS, it was necessary to have a significant
working knowledge of the Linux kernel, kernel source, headers and other
intricacies.  This made it difficult to distribute software based on LiS
to users not proficient in those areas.  The OpenSS7 release removes the
configuration and installation tasks from the user and permits
distribution of applications, modules and driver software based on LiS to
users without sufficient kernel expertise to install the package.

This OpenSS7 release fixes few of the outstanding bugs and deficiencies of
the LiS software.  This release is intended to package and distribute LiS
in an efficient manner and, for the most part, does not address LiS
deficiencies or errors.

This OpenSS7 release is compatible with Linux 2.4 kernels only and will
refuse to configure for older or newer kernels.

Following are the new features of the OpenSS7 release of LiS:

@itemize @bullet
@item
adds configuration using the GNU tools, autoconf, automake and autotest.

These tools greatly enhance the ability to maintain a repeatable and
testable release cycle as well as being compatible with most major package
managers such as Redhat's RPM.

@item
adds long options to all LiS utilities.

This change was necessitated because we use GNITS (the strictest level) of
configuration with autoconf that requires for distribution checking that
all utility programs support the @samp{--help} and @samp{--version} long
options wtihout side-effects.

@item
provides a source and binary release mechanism using both autoconf
distributions as well as RedHat source and binary RPMs.

Use of the RPM mechanism for release permits add-on packages to ensure
that they have sufficient level of support and verionsing of the LiS load
during their build and installation process.  It is now also possible to
ensure that add on binaries are compatible with a loaded LiS during
installation.

@item
includes a complete set of kernel programmer manual pages for all LiS
exported kernel functions for use by STREAMS module and driver developers.

@item
includes a complete set of user manual pages for all libLiS functions and
separate administrative utilities.

@item
includes the OpenSS7 strinet driver providing XTI/TLI access to the Linux
native NET4 IP stack including TCP, UDP, IP and (and OpenSS7 SCTP if your
kernel is so equipped).

@item
includes functional @code{tirdwr} and @code{timod} modules for use with the
included XTI/TLI library.@footnote{The @code{tirdwr} module included with the
Gcom LiS-2.16.18 (and even more current) releases is almost completely
disfunctional and has been replaced in entirety.}

@item
includes complete, thread-safe XNS 5.2 XTI/TLI library support with the
@file{libxnet} library, complete manual pages and documentation released under
the LGPL (@pxref{GNU Lesser General Public License}).
@end itemize

The next release may include some @dfn{strss7} software.

The remainder of the sections in this chapter are for historical purposes
for LiS and are not applicable to this release.


@node Kernel Compatibility Issues
@section Kernel Compatibility Issues Concerning LiS

@subsection LiS-2.18 Kernel and Driver Compatibility

LiS-2.18 contains a number of changes from LiS-2.16.  LiS-2.17 was pretty much
and experimental version.  Documented here are the principles of change between
2.16 and 2.18.

Note: STREAMS drivers must be recompiled against LiS-2.18 header files to
utilize LiS-2.18.  Do not attempt to install LiS-2.18 underneath drivers
compiled against LiS-2.16 or LiS-2.17.

Here are the principal changes.  I am not documenting all the little bug fixes,
just the main changes that users may find visible.

@itemize @bullet
@item
OpenSS7 inet driver in, then out, then in, then out of LiS distribution.
Currently out.  Download separately from openss7.org.

@item
Discontinue support for 2.2 kernels.

@item
More sophisticated choosing of version of C compiler to use when building LiS.

@item
Several interations of timeout/untimeout implementation ending with a blend of
the original, plush hash table for lookup speed, plus use of kernel cache blocks
to allocate structures.

@item
Orgianize so as not to hold any spin locks when entering STREAMS driver
functions.  This means that queue locking now uses a semaphore instead of a spin
lock.  This means, in turn that you really cannot call putnext() from interrupt
context.

@item
Some contributions for LiS on S/390, PPC, IA64 and SPARC.

@item
Eliminate poll() routine from libLiS.  You should be using the standard libc
version.

@item
Some contributed fixes for fattach, pipes and fifos.

@item
Reworking of open routine for races involving open vs. open and open vs. close.

@item
Eliminate use of special LiS system calls to kernel.  getpmsg uses the read
function and putpmsg uses the write function.

@item
Some contributions to make rpm building easier.

@item
A contribution for performance enhancement mainly involving use of kernel
caches.

@item
More performance enhancements involving minimizing of lock contention, and an
LiS mechanism to track lock contention.

@item
Tracking code for queue contention to assist users in optimizing.

@item
Code to build a histogram of semaphore wakeup latency and print out the table.

@item
Compatibility with 2.6 kernel.

@item
Revision of internal LiS definition of dev_t to incorporate 12 bits of major
device number and 20 bits of minor device number.

@item
A contribution for quieter makes with 2.6 style progress messages.  Use "make
V=1" for verbose make output.

@item
A new file <sys/LiS/module.h> for loadable drivers to include as the first
include file to get include file ordering involving <linux/module.h> correct
portably for both 2.4 and 2.6 kernels.

@item
Improved queue scheduling, which is responsible for more performance
improvements, especially on multiple CPU systems.

@item
A contribution to renumber message types for compatibility with other STREAMS
implementations.

@item
Queues are no longer run on user threads.  They are only run from the LiS queue
scheduler threads.

@item
Add lis_down_nosig() function to do a "down" with signals blocked.  Useful in
close routines that must sleep.

@item
Streams command option "-L" to print out lock contention tracking.

@item
Qlock command for strconf to control queue locking style.

@item
Qlock registration routine for loadable modules to specify their queue locking
style.

@item
putnext() et all no longer free the message upon failure as per SVR4 specs.

@item
Improved errno reporting in strtst.

@item
Implement a message deferred list in each queue and use it for puts to queues
that are in a "qprocsoff" state.

@item
Implement freezestr() and defer message processing while stream is frozen.

@item
Use of freezestr() and defer message processing while stream is frozen.

@item
Greatly reduce the number of exported symbols.
@end itemize

@subsubsection Compatibility of LiS-2.18 with 2.6 Kernel

There are several issues that needed to be addressed for compatibility with the
2.6 Linux kernel.  You are encouraged to follow the links in the paragraphs
below to see more detailed information on each of these topics.

@enumerate
@item
The 2.6 kernel redefined the size of the dev_t structure.  LiS has extended its
internal dev_t structure to be compatible with the 2.6 method for some time.
For more information FIXME.

@item
The 2.6 kernel changed the approach to building and installing kernel modules.
This affects LiS as a whole and also affects how you install separate loadable
STREAMS drivers.  LiS provides a mechanism that allows STREAMS drivers and
moduels to be easily installed.

@item
The 2.6 kernel offers an option to compile the kernel using machine registers to
pass parameters to functions.  LiS takes this into account.

@item
The 2.6 kernel needs GCC version 3.3.3 to be compiled properly.  LiS needs to be
compiled using the same version of the compiler when running with the 2.6
kernel.

@item
You may have to edit the file /etc/rc.d/rc.sysinit to get demand loadable
modules to work correctly.  This is especially true when hosting a 2.6 kernel on
a 2.4 distribution.

@end enumerate

@subsection LiS-2.16 Kernel and Driver Compatibility

LiS-2.16 is a small change from LiS-2.15.  The change is that it no longer
uses Linux system calls to implement getpmsg and putpmsg.  Instead it
overloads the read and write file system functions with particular values
for the count parameter, values that are otherwise invalid.@footnote{This
change is far from small because it outdates @file{libLiS.a} and
@file{libLiS.so}.  A @file{libLiS.a} or @file{libLiS.so} from a previous
version will not work correctly.  All applications statically linking
@file{libLiS.a} must be recompiled to use a @file{libLiS.a} from the more
recent version.  Unfortunately, LiS did not include versioning on its
libraries.  This has been corrected with the OpenSS7 release of LiS.}

@subsection LiS-2.15 Kernel and Driver Compatibility

LiS-2.15 continues to insulate STREAMS drivers from the Linux kernel.  It
works with 2.2, 2.4, and 2.5 versions of the kernel.  Support for 2.0
kernels has been dropped.

Driver writers will need to recompile their drivers against LiS-2.15 include
files.  You will see the following major changes.

@itemize @bullet
@item
LiS spin locks and semaphores have been rearranged so that the kernel memory
is at the end of the structure instead of the beginning.

@item
The former change allows for there to be dynamic allocation routines for
spin locks and semaphores.
(@pxref{LiS Spin Locks})

@item
LiS now provides an abstraction for read/write locks, with dynamic
allocation.
(@pxref{LiS Read/Write Locks})

@item
Those experimenting with 2.5 kernels will notice that the "sleep while holding
spin lock" problems have been fixed.

@item
Porting to 2.5 has necessitated some changes to the major/minor device
structure handling.
(@pxref{Major/Minor Device Numbering})

@item
The fattach related functions are functional on kernels version 2.4.7 and
later.

@item
STREAMS pipes and FIFOs are now functional.

@item
OS interface code has been added for the kernel's DMA mapping functions.
@end itemize

There is one known bug in LiS-2.15 relative to 2.5 kernels.  It has to do with
a memory leak involving timer structures, and may prove to be a kernel bug
rather than an LiS bug.  Since the 2.5 kernel is not suitable for general use I
am saving the investigation of this bug for later.

@subsection LiS-2.14 Kernel and Driver Compatibility

LiS-2.13 was a series of beta releases.  LiS-2.14 represents the culmination of
this series.  There should be enough distribution and kernel compatibility that
LiS-2.14 will hold up for some time.

The known fattach and FIFO bugs have still not been fixed.  The author of those
subsystems has not found the time to put in the fixes, nor have I.

@subsection LiS-2.13 Kernel and Driver Compatibility

This version of LiS has been tested with 2.4 kernels up to 2.4.16.  LiS does
not yet support the fattach/fdetach functions on kernel versions 2.4.7 and
beyond.  There are also known bugs in the LiS pipe/FIFO code.  All of these
problems are scheduled to be fixed in early 2002.

LiS-2.13 adds the ability for drivers to make their own "/dev" nodes via
the @dfn{lis_mknod} function (see @pxref{System Calls from within the Kernel}).
Also provided is an @dfn{lis_unlink} function that allows drivers to
remove their device files.

There is almost no new functionality added by LiS-2.13.  The differences
between LiS-2.13 and LiS-2.12 are almost entirely kernel compatibility issues
and bug fixes.

@subsection LiS-2.12 Kernel and Driver Compatibility

This version of LiS is compatible with all 2.2.x versions of the kernel and
with early versions of the 2.4.x kernel, at least up to 2.4.2 and perhaps
later versions as well.

If you have drivers that have worked with LiS-2.10 or LiS-2.11 (or earlier)
please recompile them using the header files from LiS-2.12.  This may be the
last recompile in quite some time that you will need for your driver code.

LiS-2.12 contains a sufficient Driver/Kernel Interface (DKI), (see
@pxref{LiS Driver/Kernel Interface}), that it is straightforward to write
a STREAMS driver that can be compiled against LiS-2.12 and the resulting
object modules used either on a 2.2 or 2.4 kernel, with only LiS needing
recompilation on the target machine.

When run on 2.4 kernels, LiS makes full use of multiple CPUs (see
@pxref{LiS SMP Implementation}).  It forks a queue runner task for each CPU
and locks each task onto its CPU.  Queue runner tasks are awakened to
assist with service procedure processing as the number of scheduled queues
increases.

Because of this aggressive use of processors, you may find that your drivers
do not function properly when run with LiS-2.12 in a multi-CPU SMP
environment.  You should expect that drivers that worked in single-CPU
environments will continue to work as before.

Making your drivers MP safe involves the use of spin locks.  The DKI
documentation contains advice on the use of these locks.  @xref{LiS Spin
Locks}.

This version of LiS also contains a rewrite of the flushing code and tests
added to strtst for flushing.  In particular the details of the rules for
flushing queue bands are now adhered to.  @xref{Flushing Queue Bands}.  Be
advised, however, that Solaris STREAMS does not adhere strictly to these
rules so there may be some subtle differences in behavior between LiS and
Solaris when flushing queue bands.

Speaking of queue bands, the queue band handling code has been debugged a bit
more and a test added to strtst to illustrate its correct behavior.

@subsection Differences between LiS-2.12.2 and LiS-2.12.1

@itemize @bullet
@item
LiS installation will attempt a kernel "make dep" if modversions.h is needed
but absent
@end itemize

@subsection Differences between LiS-2.12.1 and LiS-2.12

@itemize @bullet
@item
Added an environment variable to control the base of the LiS major
device numbers.  @xref{The strconf Utility}.

@item
LDL needed ifdef for ETH_P_ECHO for 2.4.4 (de-implemented symbol).

@item
Queue runner threads change to root directory at startup time.

@item
Fixed a lock ordering problem with lis_backenable.

@item
Stopped acquiring the inode i_sem; not needed and led to lock ordering
problems.
@end itemize

@subsection Differences between LiS-2.12 and LiS-2.11

The following is a list of differences between LiS-2.11 and LiS-2.12.  The
list may not be complete.

@itemize @bullet
@item
The aggressive use of multiple CPUs on 2.4 kernels is the biggest
difference.  @xref{LiS SMP Implementation}.

@item
Debugging support for spin locks and semaphores.
@xref{Debugging Spin Locks}, @xref{Debugging Semaphores}.

@item
Rewrite of flushing code to adhere to AT&T semantics for flushing queue
bands.  @xref{Flushing Queue Bands}.

@item
Improve queue band handling code.

@item
Fix some problems with orphan inode structures with pipes, fifos and fattach.

@item
Put and service procedure prototypes changed to return int rather than void
(AT&T compatibility).

@item
Propogatetaskcredentials(user id and capabilities) of stream opener to service
procedures.

@item
Ensure that opener's user id is associated with the opened stream.

@item
Use defined type toid_t for return from timeout function.

@item
@code{M_SIG} causes signal as soon as it reaches front of queue without having to be
read.
@vrindex M_SIG

@item
Fix problem with flushing stream head queue with @code{M_PCPROTO} at front.
@vrindex M_PCPROTO

@item
Getpmsg did not always update the strbuf len field correctly for empty
messages.

@item
Cross compile patches for PPC from Wolfgang Denk.

@item
Change in LiS major device numbers.
@xref{The strconf Utility}.

@item
Support for 2.0 kernels no longer maintained.  If you are using an older kernel
you must use an older LiS version as well (try LiS-2.8).

@item
No longer use @file{/etc/ld.so.preload}.  Instead just copy LiS libs to
@file{/lib} and run ldconfig.
@pgindex /etc/ld.so.preload
@pgindex /lib
@pgindex ldconfig

@item
Make very-clean now removes LiS libs as well as other stuff.
@end itemize

@subsection LiS-2.10 Kernel and Driver Compatibility

This version of LiS is compatible with all 2.2.x versions of the Linux kernel.
It may work with 2.4.x kernels, but you should probably wait for LiS-2.11 for
that.

If you have drivers that worked with LiS-2.8 or earlier, you must recompile
your drivers in the context of the LiS-2.10 header files.  The queue_t
structure has changed in size since LiS-2.8 which means that the old RD and WR
macros will not compute the correct addresses.

LiS-2.10 contains features that are intended to greately reduce the necessity
of recompiling STREAMS driver code in future versions of LiS or future
versions of the kernel.  The goal is to be able to compile STREAMS drivers
against LiS-2.10 header files and use the resulting object code on both 2.2.x
kernels and 2.4.x kernels.

For more details about the interface between STREAMS drivers and the kernel,
see the Driver/Kernel Interface documentation, (@pxref{LiS Driver/Kernel
Interface}).

@subsection New Features in LiS-2.11

LiS-2.11 only differs from LiS-2.10 in that LiS-2.11 runs on kernel version
2.4.0 in addition to the 2.2 series of kernels.

NOTE: When running with a 2.4 kernel, make sure that you are using modutils at
least as recent as 2.3.21.  The alignment of the text segment in loadable
modules changed in the 2.4 kernel and the old modutils do not understand the
new alignment.  The strtst program will not run correctly unless LiS is loaded
using the newer modutils.  You can find the source for the new modutils at
@uref{http://www.kernel.org/pub/linux/utils/kernel/modutils/v2.3}.

@subsection New Features in LiS-2.10

LiS-2.10 contains a number of new features since LiS-2.8.  LiS-2.9 was largely
a beta release that tested these features.

@itemize
@item
fattach/fdetach - These SVR4 functions have finally been implemented.

@item
STREAMS pipes - The default LiS library contains a "pipe" routine that uses
STREAMS to implement inter-process pipes.

@item
STREAMS fifos - You can now write pipe server processes to which clients can
attach simply by opening a named file.

@item
SMP Safety - LiS will now run on multi-CPU systems.

@item
Driver insulation - LiS now provides a rich set of interface routines that
insulate a STREAMS driver from the kernel version on which it is running.

@item
Improved Configuration - The installation script recognizes more versions and
distributions of the kernel.

@item
libc Compatibility - LiS and glibc are getting more compatible all the time.
The LiS and glibc @file{stropts.h} files are now completely compatible.
@pgindex stropts.h

@item
Improved Documentation - There is at least some documentation for all of the
new features.

@item
Searchable Documentation - Gcom has published a new web site at
@uref{http://www.gcom.com/} with search capabilities.  This includes the ability to
search LiS documentation from the web.
@end itemize

@subsection Kernel Version 2.3.x

For LiS version 2.7 and later and for kernel version 2.3.x there are some
significant compatibility issues.  See @ref{Kernel Version 2.3.x}, for
more on this topic.

@subsection Kernel Version 2.2.x

For LiS version 2.5 and later and for kernel version 2.2.x there are no
compatibility issues; there are no kernel patches whatsoever required to
install LiS.  You will need LiS-2.4 at minimum to run in a 2.2.x kernel.

@subsection Kernel Version 2.0.36

The latest version of LiS has not been tested on 2.0 kernels.  Therefore, do
not be surprised if it does not install or execute correctly in these kernels.
If you are using an old kernel, you must also use an older version of LiS,
perhaps LiS-2.5.

For LiS version 2.5 and later and for kernel version 2.0.36 there are no
kernel patches required to run LiS as a "bottom half" process.  A one-line
patch is required to run LiS as a kernel daemon process.  The installation
default is to run as a bottom half process in 2.0.36.  LiS-1.25 or later should
install properly with 2.0.36.  The more recent the version of LiS, the less
kernel patching is required.

@subsection Extracting Old LiS Kernel Patches (obsolete)

Previousversions of LiS installed inside the kernel source tree and included
patches to the kernel in order to install LiS into the kernel.  There was no
provision made for removing these patches from the kernel.

Beginning with LiS-1.25 any patches made to kernels whose version number is
2.0.35 or later can be removed from the kernel just by doing a "make
realclean" in the LiS installation directory.  If you have installed the older
version of LiS in your kernel then you need to take steps to remove it prior
to installing this version of LiS.

There are two methods of doing this.  Both are manual procedures.

@enumerate
@item
Change the name of your kernel source directory, as in
@example
% mv /usr/src/linux /usr/src/linux.old
@end example
and then untar a fresh kernel source as @code{/usr/src/linux}.  This method
works fine if LiS was the only patch to your kernel.  Once the new kernel
works, remove the @code{linux.old} directory.

@item
In your kernel tree, do the following:
@example
% cd /usr/src/linux/drivers
% rm -r streams
@end example
That deletes almost all of the files that came with the old version of LiS.
Next, you must restore the patched kernel files to their original state.  From
the directory @code{/usr/src/linux}, look for the following files:

@table @code
@item LiS:
@itemize @bullet
@item
arch/i386/kernel/entry.S.orig
@item
fs/read_write.c.orig
@item
fs/select.c.orig
@item
kernel/ksyms.c.orig
@item
init/main.c.orig
@item
include/asm-i386/unistd.h.orig
@item
drivers/Makefile.orig
@pgindex Makefile
@end itemize

@item Semaphores:
@itemize @bullet
@item
arch/i386/lib/semaphore.S.orig
@item
kernel/sched.c.orig
@item
include/asm/semaphore.h.orig
@end itemize
@end table

If you do not have any other patches applied to these files, then change their
names back to the original file names (these names minus the @file{.orig} suffix).
Not all of these files will be present on every version of the kernel.  Kernels
later than 2.0.30 would not have had the semaphore patch, for example.

If you have other patches in these files then you will need to consult one of
the following files from the newly installed @file{/usr/src/LiS} directory:
@pgindex /usr/src/LiS

@itemize @bullet
@item patches.kernel.24-27
@item patches.kernel.28-34
@end itemize

There is really no recourse at this point other than to examine the patches
and manually extract the LiS patches from the affected files.
@end enumerate

@node Open Flags (obsolete)
@section Open Flags (obsolete)
The open flags MODOPEN and CLONEOPEN have been changed since the previous
version.  You must recompile your STREAMS drivers using the new header files in
order to incorporate this change.  The change brings the bit assignments into
conformance with SVR4.  STREAMS drivers compiled against the old header files
should not be linked into LiS without recompiling.  The old open routines will
misinterpret their flags argument.

@node System Calls (obsolete)
@section System Calls (obsolete)
This change affects all application level programs that use the STREAMS
constructs getpmsg, putpmsg or poll.

For kernel versions prior to 2.0.36, LiS did not have official system call
numbers assigned for getpmsg, putpmsg and poll.  Beginning with kernel version
2.0.36, and all 2.2 kernels, LiS has official system call numbers assigned for
getpmsg and putpmsg.  The 2.2 kernels have a built-in poll system call.
Therefore, there is no LiS poll system call in 2.2 kernels.

The system call slots that LiS used for getpmsg and putpmsg in earlier kernels
were, of course, taken up by other functions by the time the official system
call slots got assigned for the 2.2 (and 2.1) kernel.  That means that older
STREAMS applications compiled for use with earlier versions of LiS, when run
on newer kernels, will be issuing incorrect system calls for getpmsg and
putpmsg.  These applications need to be recompiled and relinked using the new
LiS.

The new version of LiS, even when run on kernels prior to 2.0.36, will always
plug the system call table slots for the new "official" STREAMS system calls
in addition to the older ad hoc slots.  This means that you can use
applications that utilize putpmsg and getpmsg with the new system calls on
older kernels by using the new version of LiS.

However, the poll system call is not so easy.  If your application uses poll
then you must maintain a version of it that is compatible with kernel versions
prior to 2.0.36 and another version that is compatible with kernel versions
2.0.36 and beyond, including 2.2 kernels.  The reason for this is that prior
to 2.0.36, LiS contained the only implementation of the poll system call.
However, starting with 2.0.36, the kernel contains its own implementation of
poll and the LiS implementation must yield to the kernel's implementation.
The system call slot used by LiS for poll and the one used by the Linux kernel
are different.  So there is  really no way around maintaining two versions of
such applications.

The following table summarizes the system call number assignments for
different kernel versions.  Numbers in plain text are the ad hoc numbers used
by earlier versions of LiS.  Numbers in italics are official kernel assigned
numbers.  The problem with the poll system call is that the number 169, used
by earlier version of LiS, is used for a different system call in kernel
version 2.0.36 and beyond.  Thus, it is not possible for LiS to plug that
system call slot with a pointer to its poll routine for backward
compatibility.

@smallexample
       Version                          Getpmsg Putpmsg Poll
       LiS for kernel versions < 2.0.36   168     167   169
       LiS for kernel version 2.0.36      188     189   168
       LiS for kernel versions >= 2.2.0   188     189   168
@end smallexample

In kernel versions 2.0.36 and earlier, LiS provides the implementation of the
poll system call.  In 2.2 kernels, the kernel provides the implementation of
poll and LiS hooks into it on behalf of its STREAMS drivers.

@node Libraries
@section Libraries
The older version of LiS had direct inline code for STREAMS system calls
defined in @file{stropts.h}.  The new version contains function prototypes in
@file{stropts.h} with the actual system call code contained in a library that
you link with your application program.  The library resides in the directory
@file{/lib} and is named libLiS.a.  Thus, you need to include the directive "-lLiS"
with the link of your STREAMS applications.  For more about LiS libraries,
@xref{LiS Library Routines}.
@pgindex /lib
@pgindex stropts.h

@node Other Interactions
@section Interactions with Other Packages

In kernel versions around 2.2.14 there were some compile time clashes with the
irda driver.  These have been resolved and/or worked around in LiS-2.10.

On kernel version prior to 2.0.36 there can be problems with LiS interacting
with other packages such as JDK and, perhaps, iBSC.  In particular, JDK looks
to see if system call number 168 has been assigned.  If it has, it assumes that
the operating system implements the poll system call in that slot.  As you can
see from the chart above, older versions of LiS did plug system call 168, but
with the getpmsg routine, not with poll.  Although we do not know for sure
there is a possibility that iBSC would have the same problem.

The solution is to upgrade to a kernel at least as new as 2.0.36 or a 2.2
series kernel.

@node Kernel Version 2.3.x
@section Compatibility with Kernel Version 2.3.x

Version 2.3 of the Linux kernel brings with it some compatibility issues that
need to be addressed by the LiS user.  The two most important ones concern the
file @file{<sys/stropts.h>} and the major device numbers used by LiS.
@pgindex stropts.h

@node stropts.h Compatibility
@section @file{stropts.h} Compatibility
There are no more compatibility problems with @file{<sys/stropts.h>} with
glibc-2.1 and LiS-2.10.  The following is more for historical purposes than
practical necessity.

Beginning at least with egcs-2.91.66 (egcs-1.1.2 release), which comes with
Red Hat 6.0, there is a file in the standard include directory named
@file{<sys/stropts.h>}.  This file has constant definitions that are
incompatible with those used in @file{LiS/include/sys/stropts.h}.  If you
compile an application against the glibc version of @file{stropts.h}, and
compile LiS using its own version then certain ioctls may not work correctly.
You should be aware of this problem and be sure to include
"-I/usr/src/LiS/include" in the compiler options that you use in compiling
your STREAMS based applications.

In this version of LiS, some of the constants in @file{stropts.h} have been
changed to conform to the values used by UnixWare and Solaris.  These are
different values than previously used in LiS.  When you install LiS the
installation procedure will ask you whether you want LiS compiled with the
backward-compatible LiS constants, or the UnixWare/Solaris compatible
constants.  Logically speaking, it does not matter which set you use as long as
LiS and your application code are both compiled with the same values.

I highly recommend that you use the UnixWare/Solaris compatible version,
however.  A future release of egcs, utilizing glibc 2.2, will contain an
updated version of its @file{stropts.h} which has constants that are
compatible with UnixWare, Solaris and LiS.  So by selecting the
UnixWare/Solaris compatible version at this time you can ensure that your
applications will be fully compatible with these values in the future.

With any luck, these constants will never have to change again.

@node Major Device Number Compatibility
@section Major Device Number Compatibility
The second major compatibility issue concerns the major device numbers that
LiS assigns to STREAMS devices.  In the past LiS based these device numbers at
50, since the Linux kernel did not pre-define many major device numbers.  As of
kernel version 2.3.x there are major device numbers defined up to 220 and
beyone! So starting with LiS-2.12, we have used the major number of 240 as the
base for STREAMS device files.  This range is supposed to be reserved for
"experimental drivers" which should make it safe to use.

What this means is that you must be sure to run the strmakenodes program
before running any STREAMS applications after installing LiS-2.12.  This need
not concern you overly, since doing a "make install" in the @file{/usr/src/LiS}
directory causes strmakenodes to be run anyway.  This is more a concern if you
are compiling LiS on one machine and then loading it onto another for
execution.  In such cases you may need to load the new strmakenodes program and
run it.
@pgindex /usr/src/LiS

I am hoping that the kernel developers will expand the major and minor device
number spaces for 2.6.  If they do that then LiS should be able to get a block
of majors allocated to it.




@node Downloading LiS
@chapter Downloading LiS

The OpenSS7 release of LiS can be downloaded from the downloads page at
@uref{http://www.openss7.org/download.html}.  It is available in tar ball,
SRPM and (for popular architectures) RPM format.

If you are using a browsable viewer, you can obtain this OpenSS7 release
of LiS from the following links:

@menu
* Downloading the Binary RPMs::		The easiest method.
* Downloading the Source RPM::		The next best method.
* Downloading the Tar Ball::		The final resort method.
* Old LiS Download Instructions::	Don't do this.
@end menu

@node Downloading the Binary RPMs
@section Downloading the Binary RPMs

To install from Binary RPM, you will need all of the following kernel
indepdendent packages for your architecture, and one of the
kernel-depdendent packages from the next section.

@unnumberedsubsec Kernel-Independent Binary RPMs

All of the following kernel-independent packages are required for your
architecture.  If your architecture is not on the list, you can build
binary RPMs from the source RPM (@pxref{Downloading the Source RPM}).

@table @asis
@item @uref{http://www.openss7.org/rh9/RPMS/i686/LiS-lib-2.16.18-22.i686.rpm, LiS-lib-2.16.18-22.i686.rpm}
The LiS-libs package contains the run-time shared libraries necessary to run
applications programs developed for Linux STREAMS.  In addition, it contains a
user-space implementation of the STREAMS subsystem.
@item @uref{http://www.openss7.org/rh9/RPMS/i686/LiS-doc-2.16.18-22.i686.rpm, LiS-doc-2.16.18-22.i686.rpm}
The LiS-docs package contains html documentation for the development of
STREAMS applications, modules and drivers.
@item @uref{http://www.openss7.org/rh9/RPMS/i686/LiS-devel-2.16.18-22.i686.rpm, LiS-devel-2.16.18-22.i686.rpm}
The LiS-devel package contains library archives for static compilation,
headers files to develop STREAMS modules and drivers.  This also includes the
header files and static libraries required to compile STREAMS applications
programs.  In addition it contains all of the manual pages necessary for
developing STREAMS application programs.
@item @uref{http://www.openss7.org/rh9/RPMS/i686/LiS-dev-2.16.18-22.i686.rpm, LiS-dev-2.16.18-22.i686.rpm}
The LiS-devs package contains the device definitions necessary to run
applications programs developed for Linux STREAMS.
@item @uref{http://www.openss7.org/rh9/RPMS/i686/LiS-source-2.16.18-22.i686.rpm, LiS-source-2.16.18-22.i686.rpm}
The LiS-source package contains the source code necessary for building the LiS
release.  It includes the autoconf configuration utilities ncessary to create
and distribute this rpm.
@item @uref{http://www.openss7.org/rh9/RPMS/i686/LiS-util-2.16.18-22.i686.rpm, LiS-util-2.16.18-22.i686.rpm}
The LiS-utils package provides adminstrative and configuration test utilities
and commands associated with the Linux STREAMS package.
@end table

@unnumberedsubsec Kernel-Dependent Binary RPMs

One of the following kernel-dependent packages is required.  We have
provided binary RPMS for RedHat 7.x UP boot kernels only.

@table @asis
@item @uref{http://www.openss7.org/rh7.2/RPMS/i686/LiS-core-2.4.20-30.9BOOT-2.16.18-22.i686.rpm, LiS-core-2.4.20-30.9BOOT-2.16.18-22.i686.rpm}
The LiS-core-2.4.20-30.9BOOT package contains the kernel modules that provide
the Linux kernel SVR 4.2 STREAMS facility.  This also includes assorted basic
STREAMS drivers and modules such as pipes, fifos, timod, tirdwr, echo, etc.
This package is heavily tied to the kernel for which it was compiled.  This
package applies to kernel version 2.4.20-30.9BOOT.
@end table

@unnumberedsubsec Installation

To install the binary RPMs, @xref{Installing the Binary RPMs}.

@node Downloading the Source RPM
@section Downloading the Source RPM

If you cannot obtain a binary RPM for your architecture, or would like to
roll your own binary RPM, download the following source RPM.

@table @asis
@item @uref{http://www.openss7.org/rpms/SRPMS/LiS-2.16.18-22.src.rpm, LiS-2.16.18-22.src.rpm}
This is the source RPM for the package.  From this souce RPM it is
possible to build binary RPMs for any supported architecture and for any
2.4 kernel.  For details on this process, @xref{Installation of LiS}.
@end table

@unnumberedsubsec Installation

To install the source RPM, @xref{Installing the Source RPM}.

@node Downloading the Tar Ball
@section Downloading the Tar Ball

For non-RPM architectures such as the NexusWare embedded target, download the
tarball as follows:

@table @asis
@item @uref{http://www.openss7.org/LiS-2.16.18-22.tar.gz, LiS-2.16.18-22.tar.gz}
@itemx @uref{http://www.openss7.org/LiS-2.16.18-22.tar.bz2, LiS-2.16.18-22.tar.bz2}

These are the tar balls

@end table

@node Old LiS Download Instructions
@section Old LiS Download Instructions

@strong{WARNING}: the following instructions are for downloading the
original releases of LiS from Gcom's website:

@heading Downloading LiS (obsolete)

LiS can be downloaded using a browser, or the FTP utility.  Save the file
somewhere outside the kernel source code tree.  We recommend using the
directory @file{/usr/src} or @file{/usr/local/src}.
@pgindex /usr/src
@pgindex /usr/local/src

@subheading Downloading via Browser

If you are viewing this document with a web browser, you can download LiS
by clicking @uref{ftp://ftp.gcom.com/pub/linux/src/LiS, here}.  This will
take you to a directory containing a number of LiS tar archives.  The
symbolic link @file{Latest-LiS} points to the latest version.  The .message
file also contains information about the latest version.

@subheading Downloading via FTP

Connect to @uref{ftp://ftp.gcom.com/, ftp.gcom.com} and change to the
directory @file{/pub/linux/src/LiS}.  This directory contains all the LiS
tar archives.  The symbolic link @file{Latest-LiS} points to the latest
version.  The @file{.message} file also contains information about the
latest version.

@subheading After Downloading

Untar the file using a command similar to the following:

@example
% tar xzf LiS-2.16.tgz
@end example

This will create a subdirectory named LiS-2.16 containing all of the files and
subdirectories for LiS.

@subheading Installation

@xref{Old LiS Installation Instructions}.


@node Installation of LiS
@chapter Installation of LiS

@menu
* Installing the Binary RPMs::		The easiest method.
* Installing the Source RPM::		The next best method.
* Installing the Tar Ball::		The final resort method.
* Old LiS Installation Instructions::	Don't do this.
@end menu

@node Installing the Binary RPMs
@section Installing the Binary RPMs

If you have downloaded the necessary binary RPMs (@pxref{Downloading the
Binary RPMs}) or have built binary RPMS (@pxref{Installing the Source
RPM}) then the following instructions will install the RPMs on your
system.  (See rpm(8) for additional information on rpm.)

@example
% cd RPMS/i686
% rpm -ihv LiS-*-22.i686.rpm
@end example

You must have the correct binary RPMs downloaded or built for this to be
successful.

@node Installing the Source RPM
@section Installing the Source RPM

If you have downloaded the necessary source RPM (@pxref{Downloading the Source
RPM}), then the following instructions will rebuild the binary RPMs on your
system.  Once the binary RPMs are rebuilt, you may install then a described
above (@pxref{Installing the Binary RPMs}).

The source RPM is rebuilt to binary RPMs as follows:

@example
% rpm --rebuild LiS-2.16.18-22.src.rpm
@end example

The rebuild process can also recognize a number of options that can be used to
tweak the resulting binaries.  They are as follows:

Note that distributions that use older versions of rpm do not have the
@samp{--with} or @samp{--without} options defined.  To acheive the same effect
as:
@example
--with someparm=somearg
@end example
do:
@example
--define "_with_someparm --with-someparm=somearg"
@end example

@ignore
This is a generic description of common @command{rpmbuild} options.  Not all
@command{rpmbuild} options are applicable to all SRPMs.  Options that are kernel
module specific are only applicable to SRPMs that build kernel modules.  STREAMS
options are only applicable to SRPMs that provide or require STREAMS.
@end ignore

@table @code
@item --define "_kversion $PACKAGE_KVERSION"
@vindex PACKAGE_KVERSION
@opindex k-release
Specifies the kernel version other than the running kernel for which to build.
If @command{_kversion} is not defined when rebuilding, the environment variable
@var{PACKAGE_KVERSION} is used.  If the environment variable
@var{PACKAGE_KVERSION} is not defined, then the version of the running kernel
(i.e. discovered with @samp{uname -r}) is used as the target version for
kernel-dependent packages.  This option can also be defined in an
@file{.rpmspec} file using the macro name @samp{_kversion}.

@ignore
@item --with checks
@itemx --without checks
@opindex checks
@end ignore

@item --with autotest
@item --without autotest
@opindex autotest
Enable preinstall checks.  Each packages supports a number of preinstall checks
that can be performed by invoking the @samp{check} target with @command{make}.
These currently consist of checking each kernel module for unresolved kernel
symbols, checking for documentation for exported kernel module symbols, checking
for documentation for exported library symbols, checking for standard options
for build and installable programs, checking for documentation for built and
installable programs.  Normally these checks are only run in maintainer mode,
but can be enabled and disabled with this option.

@itemx --with k-optimize=HOW
@item --without k-optimize
@opindex k-optimize
Specify @samp{HOW} optimization, @var{normal}, @var{size}, @var{speed} or
@var{quick}.  @var{size} compiles kernel modules @code{-Os}, @var{speed}
compiles kernel modules @code{-O3}, and @var{quick} compiles kernel modules
@code{-O0}.  The default is @var{normal}.  Use with care.

@item --with cooked-manpages
@itemx --without cooked-manpages
@opindex cooked-manpages
Some systems do not like @command{grefer} references in manpages.@footnote{In
particular, some @cite{Debian} systems do not load the @command{groff}
extensions package and do not have @command{grefer} installed.  Although this is
an oversight on the configuration of the particular @cite{Debian} system, we
accomodate such misconfiguration with this feature.}  This option will cook
@command{soelim}, @command{refer}, @command{tbl} and @command{pic} commands from
the manpages and also strip @command{groff} comments.  The default is to leave
manpages uncooked: they are actually smaller that way.

@item --with public
@itemx --without public
@opindex public
Release public packages or private packages.  This option has no effect on the
@file{@value{PACKAGE_NAME}} package.  The default is to release public packages.

@item --with k-debug
@itemx --without k-debug
@opindex k-debug
Specifies whether kernel debugging is to be performed on the build kernel
modules.  Mutually exclusive with @code{test} and @code{safe} below.  This has
the effect of removing static and inline attributes from functions and invoking
all debugging macros in the code.  The default is to not perform kernel
debugging.

@item --with k-test
@itemx --without k-test
@opindex k-test
Specifies whether kernel testing is to be performed.  Mutually exclusive with
@code{debug} above and @code{safe} below.  This has the effect of removing
static and inline attributes from functions and invoking most debugging macros
in the code.  The default is to not perform kernel testing.

@item --with k-safe
@itemx --without k-safe
@opindex k-safe
Specifies whether kernel saftey is to be performed.  Mutually exclusive with
@code{debug} and @code{test} above.  This has the effect of invoking some more
pedantic assertion macros in the code.  The default is not to apply kernel
safety.

@item --with k-inline
@itemx --without k-inline
@opindex k-inline
Specifies whether kernel @code{inline} functions are to be place inline.  This
has the effect of adding the @command{-finline-functions} flag to @var{CFLAGS}
for compiling kernel modules.  Linux 2.4 kernels are normally compiled
@command{-O2} which does not respect the @code{inline} directive.  This compiles
kernel modules with @command{-finline-functions} to get closer to @command{-O3}
optimization.  For better optimization controls, @xref{Configuring the Tar
Ball}.

@ignore
@item --with k-modversions
@itemx --without k-modversions
@opindex k-modversions
Specifies whether kernel symbol versioning is to be applied to symbols exported
by package kernel modules.  The default is to version exported module symbols.
This package does not export symbols so this option has no effect.
@end ignore

@item --with k-tools
@itemx --without k-tools
@opindex k-tools
Specifies whether user space packages are to be built.  The default is to build
user space packages.  This option can be useful when rebuilding for multiple
architectures and target kernels.  The @command{rebuild} automake target uses
this feature when rebuilding for all available architectures and kernels, to
rebuild user packages once per architecture instead of once per kernel.

@item --with k-modules
@itemx --without k-modules
@opindex k-modules
Specifies whether kernel modules packages are to be built.  The default is to
build kernel module packages.  This option can be useful when rebuilding for
multiple architectures and target kernels.  The @command{rebuild} automake
target uses this feature to rebuild for all available architectures and kernels.

@ignore
@item --with lis
@itemx --without lis
@opindex lis
Specifies that the package is to be rebuilt against @cite{Linux STREAMS}.  The
default is to automatically identify whether @file{LiS} or @file{streams} is
loaded on the build system and build accordingly.

@item --with lfs
@itemx --without lfs
@opindex lfs
Specifies that the package is to be rebuilt against @cite{Linux Fast-STREAMS}.
The default is to automatically identify whether @file{LiS} or @file{streams} is
loaded on the build system and build accordingly.
@end ignore
@end table

@include rpm.texi

In general, the default values of these options are sufficient for most purposes
and no options need be provided when rebuilding the Source RPMs.

@node Installing the Tar Ball
@section Installing the Tar Ball

@subsection Native Build Tar Ball Installation

Following is an example for a native build against the running kernel:

@example
% wget http://www.openss7.org/LiS-2.16.18-22.tar.bz2
% tar -xjvf LiS-2.16.18-22.tar.bz2
% cd LiS-2.16.18-22
% ./configure
% make
% make install-strip
@end example

@subsection Cross-Build Tar Ball Installation

Following is an example for a cross-build.  The kernel release version must
always be specified for a cross build.  If you are cross-building specify the
root for the build with @code{DESTDIR}.  The cross-compile host must be
specified if different from the build host and either the compiler and other
tools must be in the usual places where GNU autoconf can find them or they must
be specified with declarations such as @code{CC=/u5/NexusWare24/ppc-linux/gcc}
on the @code{configure} command line.  Look in the file
@file{configure.nexusware} for an example.

@example
% wget http://www.openss7.org/LiS-2.16.18-22.tar.bz2
% tar -xjvf LiS-2.16.18-22.tar.bz2
% cd LiS-2.16.18-22
% ./configure DESTDIR="/some/other/root" \
        --with-k-release=2.4.18 --host sparc-linux
% make
% make install-strip
@end example

@subsection NexusWare Tar Ball Installation

Additional support is provided for cross-building for the Performance
Technologies Inc. NexusWare embedded target for the CPC-384, CPC-388 and CPC-396
cards.  A configuration script wrapper (@code{configure.nexusware}) is provided
to simplify the cross-build operation for these targets.
@pgindex configure.nexusware

Follow the normal NexusWare instructions for rebuiding a @code{generic} kernel
and flash image as follows: (I keep my NexusWare build in
@code{/u5/NexusWare24}.)

@example
% cd /u5/NexusWare24
% source SETUP.sh
% make
@end example

Next download, unpack, configure using the provide @code{configure.nexusware}
wrapper for configure.  This wrapper simply tells the @code{configure} script
where to find the NexusWare sources and which NexusWare cross-building tools
to use for a cross compile.@footnote{Although I hvae not tried it, because we
use GNU autoconf for configuration, these instructions should work equally well
for the Solaris NexusWare cross-building environment as it does for the Linux
NexusWare cross-building environment.}

Any of the normal @code{configure} script options described below can be used
on the same line as @code{./configure.nexusware}.  One of particularl interest
to embedded targets is @code{--with-k-optimize=size} to attempt to reduce the
side of the kernel modules.

Install as normal, however, for embedded targets the @code{install-strip} target
should be used instead of the @code{install} target.  The @code{install-strip}
target will strip unnecessary symbols from kernel modules and further reduce
their size in the root filesystem flash image.

Following it what I use for configuration and installation:  (My NexusWare tree
is rooted at @file{/u5/NexusWare24}.)
@pgindex /u5/NexusWare24

@example
% wget http://www.openss7.org/LiS-2.16.18-22.tar.bz2
% tar -xjvf LiS-2.16.18-22.tar.bz2
% cd LiS-2.16.18-22
% # (cd /u5/Nexusware; source SETUP.sh)
% # or export NEXUSWARE_PREFIX=/u5/NexusWare24
% # if not done in step above
% ./configure.nexusware --with-k-optimize=size
% make
% make install-strip
@end example

Once built and installed in the NexusWare directory, you will have to (currently)
hand edit a @file{.spec} file to include the components you want in the
NexusWare root file system.  If you are cross-building for NexusWare you should
already know what that means.  Objects that you might be interested in copying
to the root file system are kernel modules that were installed in
@file{$NEXUSWARE_PREFIX/lib/modules/2.4.18/misc}, libraries installed in
@file{/usr/lib} and utility functions installed in @file{/usr/bin},
@file{/usr/sbin} and test programs in @file{/usr/libexec}.  If you would prefer
that these programs be installed in @file{/lib}, @file{/bin}, @file{/sbin} and
@file{/libexec} (say, because you want to remote mount the @file{/usr} directory
after boot), then specify @code{--exec-prefix /} to
@code{./configure.nexusware}.
@pgindex $NEXUSWARE_PREFIX/lib/modules/2.4.18/misc
@pgindex /usr/bin
@pgindex /usr/sbin
@pgindex /usr/libexec
@pgindex /bin
@pgindex /sbin
@pgindex /libexec
@pgindex configure.nexusware

In addition, because NexusWare does not include an @file{/etc/modules.conf} file
by default, it will be necessary to add one or edit your @file{rc.4} file to
@code{insmod} the necessary LiS modules at boot time.
@pgindex insmod

Once you have completed the necessare @file{.spec} and @file{rc.4} file entries,
you need to rebuild the generic kernel flash image once more for these objects
to be included in the flash file system.  It is important that this second build
of the kernel image be the same as the first.

When modifying and rebuilding a NexusWare kernel, it will be necessary to
rebuild and install LiS.  Simply perform the last @code{make install-strip}
stage or start again with @code{./configure.nexusware}.  You can place the
unpacked tarball in @file{$NEXUSWARE_PREFIX/usr/src/LiS}, and add the following
to the top-level NexusWare makefile to make the build process a single step
process instead of dual pass:
@pgindex $NEXUSWARE_PREFIX/usr/src/LiS

@example
all:
...
        (cd kernels/generic; $(MAKE) depend)
        (cd usr/src/pcmcia-cs-3.2.1; $(MAKE) config)
        (cd kernels/generic; $(MAKE))
        (cd usr/src/pcmcia-cs-3.2.1; $(MAKE) pti)
        (cd usr/src/pti; $(MAKE))
        (cd drivers; $(MAKE))
        (cd utility; $(MAKE))
#       uncomment for LiS build
#       (cd usr/src/LiS; ./configure.nexusware; make install-strip)
        (cd build/generic; $(MAKE))
...
@end example

@subsection Configuration Options

All of the normal GNU @code{autoconf} configuration options and environment
variables apply.  Additional options and environment variables are provided to
tailor or customize the build and are described below.

@subsubsection Configure Options
@cindex configure options

@ignore
This is a generic description of common @command{configure} options.  Not all
@command{configure} options are applicable to all release packages.  Options
that are kernel module specific are only applicable to release packages that
build kernel modules.  STREAMS options are only applicable to release packages
that provide or require STREAMS.
@end ignore

Following are the additional @command{configure} options, their meaning and use:

@table @command
@ignore
@item --enable-checks
@opindex checks
@end ignore

@item --enable-autotest
@itemx --disable-autotest
@opindex autotest
Enable preinstall checks.  Each packages supports a number of preinstall checks
that can be performed by invoking the @samp{check} target with @command{make}.
These currently consist of checking each kernel module for unresolved kernel
symbols, checking for documentation for exported kernel module symbols, checking
for documentation for exported library symbols, checking for standard options
for build and installable programs, checking for documentation for built and
installable programs.  Normally these checks are only run in maintainer mode,
but can be enabled and disabled with this option.

@item --disable-compress-manpages
@opindex compress-manpages
Compress manpages with @samp{gzip -9} or @samp{bzip2 -9} or leave them
uncompressed.  The default is to compress manpages with @samp{gzip -9}
or @samp{bzip2 -9} if a single compressed manpage exists in the target
installation directory (@command{--mandir}).  This disables automatic
compression.

@item --disable-public
@opindex public
Disable public release.  Has no effect on the @file{@value{PACKAGE_NAME}} release.
No private components exist in @file{@value{PACKAGE_NAME}} releases.

@item --disable-initscripts
@opindex initscripts
Disables the installation of init scripts.
The default is to configure and install init scripts and their associated
configuration files.

@item --enable-tools
@opindex tools
Specifies whether user space programs and libraries are to be built and
installed.  The default is to build and install user space programs and
libraries.  This option can be useful when rebuilding for multiple architectures
and target kernels, particularly under rpm.  The @command{rebuild} target uses
this feature when rebuilding RPMs for all available architectures and kernels,
to rebuild user packages once per architecture instead of once per kernel.

@item --enable-modules
@opindex modules
Specifies whether kernel modules are to be built and installed.  The default is
to build and install kernel modules.  This option can be useful when rebuilding
for multiple architectures and target kernels, particularly under rpm.  The
@command{rebuild} automake target uses this feature to rebuild for all available
architectures and kernels.
@ignore
This option has no effect if there are no kernel modules in the package.
@end ignore

@item --enable-arch
@opindex arch
Specifies whether architectural dependent package components are to be built and
installed.  This option can be useful when rebuilding for multiple architectures
and target kernels, particularly under dpkg.  The default is to configure, build
and install architecture dependent package components.
@ignore
This option has no effect if there are no architecture dependent components in
the package.
@end ignore

@item --enable-indep
@opindex indep
Specifies whether architecture independent package components are to be built
and installed.  This option can be useful when rebuilding for multiple
architectures and target kernels, particularly under dpkg.  The default is to
configure, build and install architecture independent package components.
@ignore
This options has no effect if there are no architecture independent components
in the package.
@end ignore

@item --enable-k-inline
@opindex k-inline
Enable kernel inline functions.  Most Linux kernels build without
@command{-finline-functions}.  This option adds the @command{-finline-functions}
and @command{-Winline} flags to the compilation of kernel modules.  Use with
care.
@ignore
This option has no effect if there are no kernel modules in the package.
@end ignore

@item --enable-k-safe
@opindex k-safe
Enable kernel module run-time safety checks.  Specifies whether kernel safety is
to be performed.  This option is mutually exclusive with
@command{--enable-k-test} and @command{--enable-k-debug} below.  This has the
effect of invoking some more pedantic assertion macros in the code.  The default
is not to apply kernel safety.
@ignore
This option has no effect if there are no kernel modules in the package.
@end ignore

@item --enable-k-test
@opindex k-test
Enable kernel module run-teim testing.  Specifies whether kernel testing is to
be performed.  This option is mutually exclusive with @command{--enable-k-safe}
above and @command{--enable-k-debug} below.  This has the effect of remove
@code{static} and @code{inline} attributes from functions and invoking most
non-performance affecting debugging macros in the code.  The default is not to
perform kernel testing.
@ignore
This option has no effect if there are no kernel modules in the package.
@end ignore

@item --enable-k-debug
@opindex k-debug
Enable kernel module run-time debugging.  Specifies whether kernel debugging is
to be performed.  This option is mutuallly exclusive with
@command{--enable-k-safe} and @command{--enable-k-test} above.  This has the
effect of removing @code{static} and @code{inline} attributes from functions and
invoking all debuggin macros in the code (including performance-affecting debug
macros).  The default is to not perform kernel debugging.
@ignore
This option has no effect if there are no kernel modules in the package.
@end ignore

@ignore
@itemx --disable-k-modversions
@opindex k-modversions
Disable module versions on @command{@value{PACKAGE_NAME}} symbols.  Specifies
whether kernel symbol versioning is to be used on symbols exported from built
@command{@value{PACKAGE_NAME}} modules.  The default is to provide kernel symbol
versioning on all exported symbols.
@ignore
This option has no effect if there are no kernel modules in the package.
@end ignore
@end ignore

@item --with-gpg-user=GNUPGUSER
@opindex gpg-user
Specify the @command{gpg} @samp{GNUPGUSER} for signing RPMs and tarballs.  The
default is the content of the environment variable @var{GNUPGUSER}.  If
unspecified, the @command{gpg} program will normally use the user name of the
account invoking the @command{gpg} program.  For building source RPMs, the RPM
macro @samp{_gpg_name} will override this setting.

@item --with-gpg-home=GNUPGHOME
@opindex gpg-home
Specify the @samp{GNUPGHOME} directory for signing RPMs and tarballs.  The
default is the user's @file{~/.gpg} directory.  For building source RPMs, the
RPM macro @samp{_gpg_path} will override this setting.

@item --with-pkg-epoch=EPOCH
@opindex pkg-epoch
Specifies the epoch for the package.  This is neither used for RPM nor Debian
packages, it applies to the tarball release as a whole.  The default is the
contents of the @file{.pkgepoch} file in the source directory or, if that file
does not exist, zero (0).

@item --with-pkg-release=RELEASE
@opindex pkg-release
Specifies the release for the package.  This is neither used for RPM nor Debian
packages, it applies to the tarball release as a whole.  The default is the
contents of the @file{.pkgrelease} file in the source directory or, if that file
does not exist, one (1).  This is the number after the last point in ther
package version number.

@item --with-pkg-distdir=DIR
@opindex pkg-distdir
Specifies the distribution directory for the package.  This is used by the
maintainer for building distributions of tarballs.  This is the directory into
which archives are copied for distribution.  The default is the top build
directory.

@item --with-cooked-manpages
@opindex cooked-manpages
Convert manual pages to remove macro dependencies and @command{grefer}
references.  Some systems do not like @command{grefer} references in
manpages.@footnote{In particular, some @cite{Debian} systems do not load the
@command{groff} extensions package and do not have @command{grefer} installed.
Although this is an oversight on the configuration of the particular
@cite{Debian} system, we accomodate such misconfiguration with this feature.}
This option will cook @command{soelim}, @command{refer}, @command{tbl} and
@command{pic} commands from the manpages and also strip @command{groff}
comments.  The default is to leave manpages uncooked (they are actually smaller
that way).

@item --with-rpm-epoch=PACKAGE_EPOCH
@opindex rpm-epoch
Specify the @samp{PACKAGE_EPOCH} for the RPM spec file.  The default is to use
the RPM epoch conatined in the file @file{.rpmepoch}.

@item --with-rpm-release=PACKAGE_RPMRELEASE
@opindex rpm-release
Specify the @samp{PACKAGE_RPMRELEASE} for the RPM rspec file.  The default is to
use the RPM release contained in the file @file{.rpmrelease}.

@item --with-rpm-extra=PACKAGE_RPMEXTRA
@opindex rpm-extra
Specify the @samp{PACKAGE_RPMEXTRA} extra release information for the RPM spec
file.  The default is to use the RPM extra release information contained in the
file @file{.rpmextra}.  Otherwise, this value will be determined from automatic
detection of the RPM distribution.

@item --with-rpm-topdir=PACKAGE_RPMTOPDIR
@opindex rpm-topdir
Specify the @samp{PACKAGE_RPMTOPDIR} top directory for RPMs.  If specified
with a null @samp{PACKAGE_RPMTOPDIR}, the default directory for the RPM
distribution will be used.  If this option is not provided on the command line,
the build directory will be used as the RPM top directory as well.

@item --with-deb-epoch=EPOCH
@opindex deb-epoch

@item --with-deb-release=RELEASE
@opindex deb-release

@item --with-deb-topdir=DIR
@opindex deb-topdir

@item --with-k-release=PACKAGE_KRELEASE
@opindex k-release
Specify the @samp{PACKAGE_KRELEASE} release of the Linux kernel for which the
build is targeted.  When not cross compiling, if this option is not set, the
build will be targeted at the kernel running in the build environment (e.g.,
@samp{uname -r}).  When cross-compiling this option must be specified or the
configure script will generate an error and terminate.

@ignore
@item --with-k-prefix=K-PREFIX-DIR
@opindex k-prefix
Specify the @samp{K-PREFIX-DIR} kernel directory prefix for install.  The
default is the root directory (@file{/}) of the build machine.  This directory
is normally located by the @command{configure} script and need only be provided
for special cross-build environments or when requested by a @command{configure}
script error message.

@item --with-k-rootdir=K-ROOTDIR
@opindex k-rootdir
Specify the @samp{K-ROOTDIR} root directory for configure.  The default is the
setting of environment variable @var{DESTDIR}, and if @var{DESTDIR} is not set,
the root directory (@file{/}) of the build machine.  This directory is normally
located by the @command{configure} script and need only be provided for special
cross-build environments or when requested by a @command{configure} script error
message.
@end ignore

@item --with-k-linkage=PACKAGE_KLINKAGE
@opindex k-linkage
Specify the @samp{PACKAGE_KLINKAGE} for kernel module linkage.  This can be one
of the following:
@itemize
@item @samp{loadable}
-- loadable kernel modules
@item @samp{linkable}
-- linkable kernel objects
@end itemize
The default is to build loadable kernel modules.

@item --with-k-modules=K-MODULES-DIR
@opindex k-modules
Specify the @samp{K-MODULES-DIR} directory to which kernel modules will be
installed.  The default is based on the option @command{--with-k-release},
@command{--with-k-prefix} and @command{--with-k-rootdir}.  The default is
@file{DESTDIR}/@file{K-MODULES-DIR} which is typically
@file{@var{DESTDIR}/lib/modules/@var{PACKAGE_KRELEASE}/}.  This directory is
normally located by the @command{configure} script and need only be provided for
special cross-build environments or when requested by a @command{configure}
script error message.

@item --with-k-build=K-BUILD-DIR
@opindex k-build
Specify the @samp{K-BUILD-DIR} base kernel build directory in which configured
kernel source resides.  The default is
@file{@var{DESTDIR}/@var{K-MODULES-DIR}/build}.  This directory is normally
located by the @command{configure} script and need only be provided for special
cross-build environments or when requested by a @command{configure} script error
message.

@item --with-k-sysmap=K-SYSMAP-FILE
@opindex k-sysmap
Specify the @samp{K-SYSMAP-FILE} kernel system map file.  The default is
@file{@var{K-BUILD-DIR}/System.map}.  This file is normally located by the
@command{configure} script and need only be provided for special cross-build
environments or when requested by a @command{configure} script error message.

@item --with-k-includes=K-INCLUDES-DIR
@opindex k-includes
Specify the @samp{K-INCLUDES-DIR} include directory of the kernel for which the
build is targeted.  The default is
@file{@var{DESTDIR}/@var{K-BUILD-DIR}/include}.  This directory is normally
located by the @command{configure} script and need only be provided for special
cross-build environments or when requested by a @command{configure} script error
message.

@item --with-k-archdir=K-ARCHDIR
@opindex k-archdir
Specify the @samp{K-ARCHDIR} kernel source architecture specific directory.  The
default is @file{@var{DESTDIR}/@var{K-BUILD-DIR}/arch}.  This directory is
normally located by the @command{configure} script and need only be provided for
special cross-build environments or when requested by a @command{configure}
script error message.

@item --with-k-machdir=K-MACHDIR
@opindex k-machdir
Specify the @samp{K-MACHDIR} kernel source machine specific directory.  The
default is @file{@var{DESTDIR}/@var{K-BUILD-DIR}/@var{target_cpu}}.  This
directory is normally located by the @command{configure} script and need only be
provided for special cross-build environments or when requested by a
@command{configure} script error message.

@item --with-k-config=K-CONFIG
@opindex k-config
Specify the @samp{K-CONFIG} kernel configuration file.  The default is
@file{@var{BOOT}/config-@var{K-RELEASE}}.  This configuration file is normally
located by the @command{configure} script and need only be provided forspecial
cross-build environments or when requested by a @command{configure} script error
message.

@item --with-k-optimize=HOW
@itemx --without-k-optimize
@opindex k-optimize
Specify @samp{HOW} optimization, @var{normal}, @var{size}, @var{speed} or
@var{quick}.  @var{size} compiles kernel modules @code{-Os}, @var{speed}
compiles kernel modules @code{-O3}, and @var{quick} compiles kernel modules
@code{-O0}.  The default is @var{normal}.  Use with care.

@ignore
@item --with-lis[=LIS-DIR]
@itemx --without-lis
@opindex lis
Specify the @samp{LIS-DIR} directory in which to find LiS headers.  Also
specifies that the build is to be made against Linux STREAMS.  The default is
@file{/usr/include/LiS} if it exists, @samp{no} otherwise.  This directory is
normally located by the @command{configure} script and need only be provided for
special cross-build environments or when requested by a @command{configure}
script error message.
This option has no effect on packages that do not use the STREAMS subsystem.

@item --with-lfs[=LFS-DIR]
@itemx --without-lfs
@opindex lfs
Specify the @samp{LFS-DIR} directory in which to find LfS headers.  Also
specifies that the build is to be made against Linux Fast-STREAMS.  The default
is @file{/usr/include/streams} if it exists, @samp{no} otherwise.  This
directory is normally located by the @command{configure} script and need only be
provided for special cross-build environments or when requested by a
@command{configure} script error message.
This option has no effect on packages that do not use the STREAMS subsystem.
@end ignore

@item --with-strconf-master=STRCONF_CONFIG
@opindex strconf-master
Specify the @samp{STRCONF_CONFIG} file name to which the configuration master
file is written.  The default is @file{Config.master}.
@ignore
This option has no effect on packages that do not use the STREAMS subsystem and
the strconf scripts.
@end ignore

@item --with-base-major=STRCONF_MAJBASE
@opindex base-major
Start numbering for major devices at @samp{STRCONF_MAJBASE}.  The default is
@samp{230}.
@ignore
This option has no effect on packages that do not use the STREAMS subsystem and
the strconf scripts.
@end ignore

@end table

@include configure.texi

@c ----------------------------------------------------------------------------

@subsubsection Environment Variables
@cindex configure environment variables

Following are additional environment variables to @command{configure}, their
meaning and use:

@vtable @var
@item GPG
GPG signature command.  This is used for signing distributions by the
maintainer.  By default, @command{configure} will search for this tool.

@item GNUPGUSER
GPG user name.  This is used for signing distributions by the maintainer.

@item GNUPGHOME
GPG home directory.  This is used for signing distributions by the maintainer.

@item GPGPASSWD
GPG password for signing.  This is used for signing distributions by the
maintainer.  This environment variable is not maintained by the
@command{configure} script and should only be used on an isolated system.

@item SOELIM
Roff source elimination command.  This is only necessary when the option
@command{--with-cooked-manpages} has been specified and @command{configure}
cannot find the proper @command{soelim} command.  By default,
@command{configure} will search for this tool.

@item REFER
Roff references command.  This is only necessary when the option
@command{--with-cooked-manpages} has been specified and @command{configure}
cannot find the proper @command{refer} command.  By default, @command{configure}
will search for this tool.

@item TBL
Roff table command.  This is only necessary when the option
@command{--with-cooked-manpages} has been specified and @command{configure}
cannot find the proper @command{tbl} command.  By default, @command{configure}
will search for this tool.

@item PIC
Roff picture command.  This is only necessary when the option
@command{--with-cooked-manpages} has been specified and @command{configure}
cannot find the proper @command{pic} command.  By default, @command{configure}
will search for this tool.

@item GZIP
Default compression options provided to @command{GZIP_CMD}.

@item GZIP_CMD
Manpages (and kernel modules) compression commands.  This is only necessary when
the option @command{--without-compressed-manpages} has @emph{not} been specified
and @command{configure} cannot find the proper @command{gzip} command.  By
default, @command{configure} will search for this tool.

@item BZIP2
Default compression options provided to @command{BZIP2_CMD}

@item BZIP2_CMD
Manpages compression commands.  This is only necessary when the option
@command{--without-compressed-manpages} has @emph{not} been specified and
@command{configure} cannot find the proper @command{bzip2} command.  By default,
@command{configure} will search for this tool.

@item MAKEWHATIS
Manpages apropros database rebuild command.  By default, @command{configure}
will search for this tool.  By default, @command{configure} will search for this
tool.

@item CHKCONFIG
Chkconfig command.  This was used for installation of init scripts.  All
pacakges now come with @command{init_install} and @command{init_remove} scripts
used to install and remove init scripts on both RPM and debian systems.

@item RPM
Rpm command.  This is only necessary for RPM builds.  By default,
@command{configure} will search for this tool.

@item RPMBUILD
Build RPM command.  This is only necessary for RPM builds.  By default,
@command{configure} will search for this tool.  @command{rpm} will be used
instead of @command{rpmbuild} only if @command{rpmbuild} cannot be found.

@item DPKG
Dpkg comand.
This command is used for building debian packages.
By default, @command{configure} will search for this tool.

@item DPKG_SOURCE
Dpkg-source command.
This command is used for building debian dsc packages.
By default, @command{configure} will search for this tool.

@item DPKG_BUILDPACKAGE
Dpkg-buildpackage command.
This command is used for building debian deb packages.
By default, @command{configure} will search for this tool.

@item DEB_BUILD_ARCH
Debian build architecture.
This variable is used for building debian packages.
The default is the autoconf build architecutre.

@item DEB_BUILD_GNU_CPU
Debian build cpu.
This variable is used for building debian packages.
The default is the autoconf build cpu.

@item DEB_BUILD_GNU_SYSTEM
Debian build os.
This variable is used for building debian packages.
The default is the autoconf build os.

@item DEB_BUILD_GNU_TYPE
Debian build alias.
This variable is used for building debian packages.
The default is the autoconf build alias.

@item DEB_HOST_ARCH
Debian host architecture.
This variable is used for building debian packages.
The default is the autoconf host architecture.

@item DEB_HOST_GNU_CPU
Debian host cpu.
This variable is used for building debian packages.
The default is the autoconf host cpu.

@item DEB_HOST_GNU_SYSTEM
Debian host os.
This variable is used for building debian packages.
The default is the autoconf host os.

@item DEB_HOST_GNU_TYPE
Debian host alias.
This variable is used for building debian packages.
The default is the autoconf host alias.

@item LDCONFIG
Configure loader command.  Command used to configure the loader when libraries
are installed.  By default, @command{configure} will search for this tool.

@item DESTDIR
Cross build root directory.  Specifies the root directory for build and
installation.  For example, for @cite{NexusWare} cross-builds, this is set to
environment variable @var{NEXUSWARE_PREFIX} on configuration to point to the
root of the cross-build tree for both configuration and installation.

@item DEPMOD
Build kernel module dependencies command.  This is used during installation of
kernel modules to a running kernel to rebuild the modules dependency database.
By default, @command{configure} will search for this tool.

@item MODPROBE
Probe kernel module dependencies command.  This is used during installation of
kernel modules to a running kernel to remove old modules.  By default,
@command{configure} will search for this tool.

@item LSMOD
List kernel modules command.  This is used during installation of kernel modules
to a running kernel to detect old modules for removal.  By default,
@command{configure} will search for this tool.

@item LSOF
List open files command.  This is used during installation of kernel modules to
a running kernel to detect old modules for removal.  Processes owning the old
kernel modules will be killed and the module removed.  If the process restarts,
the new module will be demand loaded.  By default, @command{configure} will
search for this tool.

@item GENKSYMS
Generate kernel symbols command.  This is used for generating module symbol
versions during build.  By default, @command{configure} will search for this
tool.

@item KGENKSYMS
Linux 2.6 generate kernel symbols command.  This is used for generating module
symbol version during build.  By default, @command{configure} will search for
this tool.

@item OBJDUMP
Object dumping command.  This is used for listing information about object
files.  By default, @command{configure} will search for this tool.

@item NM
Object symbol listing command.  This is used for listing information about
object files.
By default, @command{configure} will search for this tool.

@item MODPOST_CACHE
Cache file for modpost.  The version of the @command{modpost.sh} script that
ships with each package can cache information to a cache file to speed multiple
builds.  This environment variable is used to specify a cache file.

@item AUTOM4TE
Autom4te command.
This is the executable used by autotest for pre- and post-installation checks.
By default, @command{configure} will search for this tool.

@item AUTOTEST
Autotest macro build command.
This is the executable used by autotest for pre- and post-installation checks.
By default, @command{configure} will search for this tool.
@end vtable

@node Old LiS Installation Instructions
@section Old LiS Installation Instructions

@strong{WARNING}: the folowing procedures are for installing the Gcom
release.  These installation procedures are not applicable to the OpenSS7
release.

Installation of LiS is performed using a configuration script and then
running "make".  If you run "make" with no configuration file present, the
makefile will run the configuration script automatically.

For the installation to proceed to its conclusion you must be logged in as
"root".  However, you can install LiS using a non-privileged user id.  In
this case the compilation of LiS will proceed but the installation of the
resulting module will likely fail due to permission problems.

The easiest way to install LiS is to proceed as follows.

@example
% cd /usr/src/LiS-2.16 (Or wherever you installed the files)
% make
% make install
@end example

The version number in the above example is used for illustrative purposes
only.  Use the version number of the package that you downloaded.

The makefile will automatically run the LiS Configure script.  You will be
asked a series of questions by the configuration script and then the build
will proceed.  If your intent is to install and run LiS on your currently
running Linux kernel then you are safe in answering all questions by
hitting the Enter key, that is, using default answers.

The configuration script will make a symbolic link from @file{/usr/src/LiS} to
whatever directory the Configure script was run from.  This makes it easy
to refer to the directory containing the latest installed version of LiS.
This symbolic link will only be made if the Configure script (or initial
"make") is run under "root".
@pgindex /usr/src/LiS

Once the "make" is complete, enter make install to install the LiS utility
programs in their proper places on your system.

If you want to uninstall LiS, enter make very-clean.  When it completes
you can then do @samp{rm -rf /usr/src/LiS-2.16} (or whatever version of LiS you
are removing).  For more information about uninstalling LiS,
@xref{Removal of LiS}.

@subheading Configuration

The configuration is extremely simple for the most common case of using
LiS.  This case occurs when you intend to run LiS as a loadable module
installed in the directory @file{/lib/modules/@var{kernel-version}/misc} and your
kernel source resides in the directory @file{/usr/src/linux}.  For this case you
can simply hit Enter/Return to select the default answer for each question
and proceed quickly to the compilation phase.
@pgindex /lib/modules/@var{kernel-version}/misc
@pgindex /usr/src/linux

If at any time you think that the configuration process has taken a wrong
turn, you can terminate it by typing Ctrl-C (or your equivalent "intr"
character).  You can then start over from the beginning.

@subheading Re-Configuration

You can re-configure LiS by running the Configure script again at any
time.  The defaults for a re-configuration are the settings arrived at by
the most recent previous run of Configure.

If you get your configuration hopelessly out of whack, just remove the
file config.in and run Configure (or make).  This will start over just as
for a fresh installation.

When you change the configuration parameters it is a good idea to do a
"make clean" before doing a "make".

@subheading Making LiS

You can make LiS by typing "make; make install" in the LiS installation
directory.

The following make targets are defined.

@table @code
@item Default target
Compile LiS plus binary drivers into @file{streams.o}.  Copy to modules directory
if configured to do so.  Compile utility programs.
@pgindex streams.o

@item install
Makes the LiS library routines and utilities.  Installs utilities in their
proper directories.  Runs strmakenodes to make @file{/dev} entries for STREAMS
drivers.
@pgindex /dev

@item uninstall
Removes the STREAMS utility programs and the files created in the @file{/dev}
directory.
@pgindex /dev

@item clean
Remove all object code and utility programs.  Leave configuration file in
place.

@item realclean
Like "clean" except remove configuration files as well.  very-clean This
is equivalent to "make uninstall clean realclean".

@item dep
Make dependencies.  Done automatically by default target.  all Like
default target except skip steps requiring root login.
@end table

@subheading Utility Programs Made

@pgindex streams.o
In addition to the file @file{streams.o}, which contains LiS and any
STREAMS drivers linked with it, the build procedure also makes the
following utility programs.  These programs are copied to the indicated
directory if the "make" uses the default make target and if you are logged
in as "root".  These programs are documented separately, (see @pxref{LiS
User Commands}).

@table @file
@pgindex streams
@item /usr/sbin/streams
Prints out statistics from running LiS.  Sets debug mask for LiS.
@pgindex /usr/sbin/streams

@pgindex strconf
@item /usr/sbin/strconf
Interprets STREAMS driver @file{Config} file and generates corresponding
@file{config.h} and @file{makenodes.c} files.
@pgindex /usr/sbin/strconf
@pgindex makenodes.c
@pgindex Config
@pgindex config.h

@pgindex strmakenodes
@item /usr/sbin/strmakenodes
Program to make /dev entries for STREAMS drivers.  The result of compiling
@file{makenodes.c}.
@pgindex /usr/sbin/strmakenodes
@pgindex makenodes.c

@pgindex strtst
@item /usr/local/bin/strtst
A comprehensive test program for STREAMS.
@pgindex /usr/local/bin/strtst

@pgindex timetst
@item /usr/local/bin/timetst
Times round-trip delay from user application to STREAMS loopback driver.
@pgindex /usr/local/bin/timetst
@end table

Of these programs, only strmakenodes and strconf are essential to the
operation of LiS.  Strmakenodes must be run prior to attempting to use any
STREAMS application programs to make the proper entries in the @file{/dev}
directory for STREAMS files.
@pgindex /dev

The strconf program is needed for the build of LiS itself.  However, the
LiS build executes the program from the local LiS installation directory.
Thus it is not necessary to copy this program to @file{/usr/sbin} in order to
make @file{streams.o}.
@pgindex /usr/sbin
@pgindex streams.o

@subheading Configuration Procedure

The following sections describe the steps of the Configure script.

@subsubheading User or Kernel

The first question posed by the Configure script is the type of environment
that LiS is to run in.  The default is to build LiS to run in the Linux kernel.
You can also build a user-space version of LiS that can be used for
"laboratory" testing.  The QNX alternative is not useful.

@subsubheading Kernel Source Location

Configure asks you for the location of your kernel source tree.  The default is
@file{/usr/src/linux} and likely suffices for the vast majority of cases.  Once
Configure has this information it can determine the version of the kernel for
which you are compiling LiS.
@pgindex /usr/src/linux

Kernel version 2.0.x is no longer supported and the LiS installation will fail
if Configure detects this kernel version.

If your kernel source has not had "menuconfig" run on it yet, Configure will
propose doing so at this time automatically.

Likewise, if you have not done a "make dep" on your kernel source yet,
Configure will propose doing so at this time automatically.

@subsubheading Kernel Version Verification

The LiS Configure script discovers the version of your kernel by looking in
several places in your kernel source directory.  If it cannot determine your
kernel version the LiS configuration will terminate.  The Configure script
cannot proceed without this information.

The Configure script then asks for your verification of the kernel version for
which LiS is to be compiled.  Note, that the kernel for which you are compiling
LiS does not have to be the kernel version on which your system is running.  If
you gave Configure a pathname to your intended kernel source version in the
previous step this could be a different kernel version than the one that is
running on your machine.

You can also enter a kernel version other than the one found in version.h at
this time.  However, entering such a version may cause the subsequent "make" to
make unverified assumptions about your kernel version.  So be careful about
answering this question with anything other than an Enter/Return.

If the kernel version displayed does not match your idea of the version of the
kernel that resides at the indicated location on disk, it is probably best to
terminate the Configure program at this point and investigate rather than end
up compilation or module loading errors.

@subsubheading Kernel Option Verification

The Configure script will ask you if you intend to run LiS on the same kernel
that is running on the installation machine.  This is the most common case of
installing LiS, so the default answer is "yes."

If you answer "yes" to this question then the Configure script will verify
that the kernel version in you kernel source directory matches the stated
version of your running kernel.  It will also verify that the kernel options of
SMP and module versions are the same between the two kernel locations.  If any
discrepencies are found the installation of LiS will terminate.

It is important for the correct operation of LiS, and the STREAMS drivers that
utilize LiS, that these options be in agreement between the running kernel and
the kernel source.  If they are not, the consequences can be anything from
unresolved externals when attempting to load LiS all the way to system hangs
on multi-CPU systems because of having the SMP option set incorrectly.

Therefore, it is important that you correct these problems and bring the
kernel source and running kernel into agreement before installing LiS.

One common source of error is to recompile your kernel in @file{/usr/src/linux} and
run lilo, but fail to copy the kernel executable to one of the kernel
locations specified in @file{/etc/lilo.conf}.  In this case you may think that you
have successfully compiled and booted a new kernel when, in fact, you are
running on your old kernel.
@pgindex /usr/src/linux
@pgindex /etc/lilo.conf

@subsubheading LiS Module Location

You will be asked whether or not you wish the "make" to copy the resulting
@file{streams.o} file to the modules directory associated with your
selected kernel version.  The alternative is to have "make" build
@file{streams.o} in the LiS directory and simply leave it there for manual
copying later.
@pgindex streams.o

If you are intending to run LiS on the machine that you are using for the
compilation you will probably want to answer this question with a "y".  If you
are intending to compile on this machine and copy the result to another
machine for testing, then "n" is the appropriate answer here.

@subsubheading Debugging

If you intend to link LiS directly into the kernel and use GDB for kernel
level debugging then you will likely want LiS to be compiled using the -g
option.  Configure asks you about this so that you can control whether to
compile using -g or not.

@subsubheading Parameter Passing Conventions

The 2.6 Linux kernel can be compiled in a manner that causes parameters to
subroutines to be passed in registers instead of the stack.  Some distributions
build around 2.6 are compiled this way by default.

If your driver calls kernel routines directly it must be compiled in the same
manner as the kernel, either register parameters or stack parameters.  A
mismatch will almost certainly lead to system crashes.

When the kernel is compiled for register passing the C compiler command line
option "-mregparm=3" is included by the kernel makefiles.  Omitting this option
yields the default stack passing code.

When the LiS Configure script is run, usually implicitly via the internal
@command{make}, it senses how the kernel was compiled and sets upt the LiS
compilation to include the @samp{regparm} option, or not.

To preserve STREAMS driver interface compatibility across different versions of
the Linux kernel, LiS declares all functions that are called across the
LiS/driver interface to use either stack parameter passing (the default) or
register passing (see below) regardless of the conventions used by the kernel.

Thus, to take the default case, the kernel can use register parameters but LiS
will have all of its driver interface routines compiled so as to use stack
parameters.  This means that your STREAMS driver can be compiled to stack
passing and can run with either convention in the kernel, without recompiling
your driver.

You can use register passing conentions in your driver as well, if you like.  As
of this writing this feature is untested.  To do so, run the Configure script
and pass the following options:
@example
Configure --regparm=3
@end example

This sets the LiS/STREAMS-driver parameter passing interface independently of
that used by the kernel.  If you do this, be sure to compile your STREAMS driver
using @samp{-mregparm=3}.

The STREAMS driver instance routines that are called by LIS are:

@itemize @bullet
@item open, close, put and service routines called using the queue structures
@item timeout and bufcall call-back routines
@item driver initialization and termination routines
@item driver interrupt service routines registered using LiS
@end itemize

The functions in LiS that are called by STREAMS drivers, and which also conform
to the selected parameter passing conventions, are all enumerated in the LiS
file @file{exports.c}.

@subsubheading Choice of Compiler

The LiS @command{Configure} script checks to see which compiler version was used
to compile your kernel.  It then attempts to locate a C compiler of the same
version to use for compiling LiS.  The script will print a message if it cannot
find such a compiler.

A common situation, during the transition to the 2.6 kernel, is to run a 2.6
kernel on top of a 2.4 distribution such as Red Hat 9.  The 2.6 kernel needs
@command{gcc} version 3.3.3 to compile it and that compiler is not part of the
RH9 distribution.  Thus, to properly compile the 2.6 kernel, you also need to
download the correct C compiler, compile and install it on your system.


@node Removal of LiS
@chapter Removal of LiS

@menu
* Removing the Binary RPMs::		The easiest method.
* Removing the Source RPM::		The next best method.
* Removing the Tar Ball::		The final resort method.
* Old LiS Removal Instructions::	Don't do this.
@end menu

@node Removing the Binary RPMs
@section Removing the Binary RPMs

To remove an installed version of the binary RPMs (whether obtained from
the OpenSS7 binary RPM releases, or whether created by the source RPM),
execute the following command:

@example
% rpm -ev `rpm -qa | grep '^\<LiS'`
@end example

See rpm(8) for additional information.

@node Removing the Source RPM
@section Removing the Source RPM

To remove an installed version built from the source RPM, remove the
installed binaries with (see rpm(8) for more information):

@example
% rpm -ev `rpm -qa | grep '^\<LiS'`
@end example

Then remove the rpms with a command such as

@example
% find / -name "LiS-*.rpm" -type f -print0 | xargs --null rm -f
@end example


@node Removing the Tar Ball
@section Removing the Tar Ball

To remove an installed version, change to the build directory and use the
@code{uninstall} make target as follows:

@example
% cd /usr/src/LiS-2.16.18-22
% make uninstall
% cd ..
% rm -rf LiS-2.16.18-22
% rm -f LiS-2.16.18-22.tar.gz
% rm -f LiS-2.16.18-22.tar.bz2
@end example

If you have removed the build directory and, therefore, no longer have a
configured directory from which to execute @code{make uninstall}, perform all
of the steps for configuration and installation (@pxref{Installing the Tar
Ball}) except the final installation and then perform the steps above.

@node Old LiS Removal Instructions

@section Old LiS Removal Instructions

@strong{WARNING}: These instructions are not applicable to the OpenSS7 RPM
release of LiS.  For instructions, @xref{Removal of
LiS}.@footnote{@strong{WARNING}: These instructions are not applicable to
the OpenSS7 RPM release of LiS.  For instructions, @xref{Removal of LiS}.}

You can remove LiS from your system by following this procedure.

In your LiS installation directory do a "make very-clean".  This will remove
any character special files in @file{/dev} that were created by an earlier "make
install" plus any patches that were placed into the kernel source tree.  It
will also remove STREAMS utilities that were installed in @file{/usr/sbin} and
@file{/usr/local/bin}.  Note: for kernel version 2.0.36 and later there will be no
patches in the kernel source tree unless you requested direct linking of LiS
with the kernel at LiS installation time.
@pgindex /dev
@pgindex /usr/local/bin
@pgindex /usr/sbin

Then, in the directory above, enter "rm -r LiS-2.12".  Substitute whatever the
version of LiS is that you are removing.  Then do @samp{rm /usr/src/LiS} to remove
the symbolic link to the LiS installation directory.

If you were linking LiS directly into the kernel, you need to rebuild your
kernel.

@heading Problems Removing LiS (obsolete)

If the automatic removal if LiS does not seem to go well you can delete the
STREAMS oriented patches from your kernel source by hand just by editing a few
files.

In your kernel source directory, edit the file init/main.c.  Scan for lines
containing the word "STREAMS".  Delete all such line and save the file.

Now edit the file @file{drivers/char/Makefile}.  Scan for lines containing the word
"STREAMS".  Before deleting all such lines, examine the first such line in
context to see if it looks like the following:

@pgindex Makefile

@example
L_OBJS := tty_io.o n_tty.o tty_ioctl.o mem.o random.o \
        /usr/src/LiS-1.25/streams.o   # STREAMS
@end example

If so then delete the backslash from the first line as well as the line
containing the word "STREAMS".  Then delete all other lines in this file
containing the word "STREAMS".

@heading Alternate Method (obsolete)

If LiS is the only patch that you have applied to the files init/main.c and
@file{drivers/char/Makefile} then you can do the following.

@pgindex Makefile

Change to the directory ./init in your kernel source tree and do the
following.

@example
% mv main.c main.c.streams
% mv main.c.orig main.c
@end example

Then change to the directory drivers/char (cd ../drivers/char) and do the
following.

@example
% mv Makefile Makefile.streams
% mv Makefile.orig Makefile
@end example

@pgindex Makefile

@node Loading LiS
@chapter Loading LiS

@strong{WARNING}: this section does not apply to the OpenSS7 rpm release
of LiS.  The OpenSS7 rpm release will always demand
load.@footnote{@strong{WARNING}: this section does not apply to the
OpenSS7 rpm release of LiS.  The OpenSS7 rpm release will always demand
load.}

Once you have built LiS you need to load it into memory in order to execute
STREAMS drivers.  What you do at this point depends upon whether you built LiS
as a loadable module or linked it into the kernel.

@section LiS as Loadable Module

The build process should have copied the file @file{streams.o} to the
directory @file{/lib/modules/@var{kernel-version}/misc}.  Where
@var{kernel-version} is something like 2.4.2.
@pgindex lib/modules/@var{kernel-version}/misc
@pgindex streams.o

This means that to load LiS you simply type in @samp{modprobe streams}.
However, the recommended method for starting LiS is to use the streams
utility program.  @samp{streams start} loads LiS and @samp{streams stop}
unloads it.
@pgindex modprobe
@pgindex streams

When LiS loads it will print a series of messages showing the names and
major device numbers of all STREAMS drivers and pushable modules loaded
with it.  It will also print some version information about itself,
including the version of the kernel for which it has been compiled.

@section LiS and kerneld

If your kernel has been built using the kerneld construct then LiS will
automatically load as soon as any STREAMS file is opened.  After installing
LiS, simply type in the command @samp{streams -s} just to test this
mechanism.  LiS should automatically load, with messages on the console
displaying version information and drivers registered.  Then the streams
command should run and print out a summary of STREAMS activity.  You can
unload LiS via @samp{streams stop}.
@pgindex streams

@section LiS Compiled into Kernel (obsolete)

If you have compiled LiS into the kernel then you need to make your new kernel
executable and reboot your system.

You should always be careful when booting a new kernel.  If you have not done
so already, you should set up your @file{/etc/lilo.conf} file so that you have a
trusted backup kernel that you can always boot in case a newly-built kernel
crashes at boot time.
@pgindex /etc/lilo.conf

From your kernel source tree, copy the file arch/i386/boot/bzImage (or zImage)
to the global file that you want to boot from.  This is usually either @file{/vmlinuz}
or @file{/boot/vmlinuz} depending upon your distribution of Linux.
@pgindex /boot/vmlinuz
@pgindex /vmlinuz

Having done that, enter "lilo" to run the lilo utility on your newly copied
kernel.  You should see some messages from lilo telling you that your new
kernel is configured for booting.

Now just reboot your computer.

As the kernel comes up, LiS's initialization routine will be run and it will
print out the same driver registration and version information as for the
loadable module case, above.

@section Making @file{/dev} Entries
@pgindex /dev

A "normal" LiS build will have made a program named "makenodes" and copied it
to @file{/usr/sbin/strmakenodes}.  Before you can use any of your STREAMS drivers you
must run that program.  Simply enter "/usr/sbin/strmakenodes" and the program
will make all of the STREAMS related entries in the @file{/dev} directory.
@pgindex /dev
@pgindex /usr/sbin/strmakenodes

You do not need to do this every time you rebuild LiS.  This only needs to
be done if you add "node" entries to the STREAMS @file{Config} file or if
you do something that would cause the major device numbers of STREAMS
files to change.
@pgindex Config

The "make install" target of LiS runs strmakenodes automatically and is the
recommended method of making the @file{/dev} entries.
@pgindex /dev

It is now possible for STREAMS drivers to make their own device nodes by calling
the routine @command{lis_mknod()}.
@findex lis_mknod
This useful for loadable STREAMS drivers.


@node Coding LiS Drivers
@chapter Coding LiS Drivers

This document is concerned with the include files and compilation techniques
for STREAMS drivers.  It is not intended to be a tutorial on the subject of
writing STREAMS drivers.  Additional resources are available, (see
@pxref{Other Resources}), for reference material.  Please consult the
Driver/Kernel Interface section (@pxref{LiS Driver/Kernel Interface}) for
information about how drivers interact with LiS and the Linux kernel for
system services.

@section Header Files

In your C language source file for a STREAMS driver, you should place the
following line of code.

@example
#include <sys/stream.h>
@end example

This line will include all of the additional header files and function
prototypes needed to code a STREAMS driver.

If your STREAMS driver needs to decode the flush bits in @code{M_FLUSH}
messages then also include the following.
@vrindex M_FLUSH

@example
#include <sys/stropts.h>
@end example
@pgindex stropts.h

If your driver uses some of the portable Driver Kernel Interface (DKI)
(@pxref{LiS Driver/Kernel Interface}) features of LiS you may need to
include some additional header files.

@section Compilation Options

When you compile your STREAMS driver, put the following compiler option on the
gcc (cc) command line for each C language file that contains one or the other
of the above include lines.

@example
-I/usr/src/LiS/include -D__KERNEL__ -DLINUX
@end example

This directive assumes that you used standard installation procedures for LiS
so that the name @file{/usr/src/LiS} is a symbolic link to the LiS installation
directory.@footnote{OpenSS7 autoconf/rpm release also place a copy of the LiS
header files in the normal include directory, so the include directive can be
@code{-I/usr/include/LiS} instead of @code{-I/usr/src/LiS/include}} The -D's are
necessary to give your driver the kernel's view of the header files and to get
the Linux version in those cases where alternatives exist.
@pgindex /usr/src/LiS
@pgindex /usr/src/LiS/include
@pgindex /usr/include/LiS

@section Driver Prefix

Choose a short prefix to put on the front of all your identifier names and
routine names.  For example, "xylo_".  Thus, the main streamtab entry for your
driver would be:

@tpindex struct streamtab
@smallexample
struct streamtab xylo_info = @{
        &xylo_rinit,                    /* read queue */
        &xylo_winit,                    /* write queue */
        NULL,                           /* mux read queue */
        NULL                            /* mux write queue */
@};
@end smallexample

The open routine would be called "xylo_open(....)" and so on.

The role of this prefix is to allow the LiS configuration process
(@pxref{The strconf Utility}) to build some tables that reference certain
symbols within your driver.  Just to take one example, the "prefixinfo"
structure's name must be known to LiS so that it can build the queue
structures that are passed to your driver at open time.

@section Driver Open Routine

It is important that you get the declaration of your driver open routine
correct.  There was a different prototype for the open routine in SVR 3 versus
SVR 4.  The Linux STREAMS package uses the SVR 4 style only.  The prototype for
your open routine should be as follows:

@smallexample
int xylo_open(queue_t *q, dev_t *dev, int oflag, int sflag, cred_t *cred_p);
@end smallexample

These prototypes can be found in the DDI/DKI or consult the LiS include file
include/sys/LiS/queue.h.  Look for the definition of the structure qinit_t.

@section Driver Registration

Your driver will be automatically registered with the Linux kernel as a
character mode special device driver if it is linked in with LiS.  The LiS
configuration process builds tables that allow LiS to perform this
registration function on behalf of your driver.  Thus, your STREAMS drivers
should not contain any code to register itself as a Linux driver.

If your driver is to be loaded separately (@pxref{Loadable
Specification}) there are some special considerations that apply.



@node Configuration
@chapter Configuration

When LiS is built, its makefiles gather configuration information about
the STREAMS drivers that are to be linked in with LiS.  This information
comes from several ASCII files within the LiS directory tree.

Once all of the configuration information is consolidated into a single
file, the file is processed by a utility program strconf to produce
several output files, which, in turn, are input to the final stages of the
LiS build process.

This chapter describes this process and the strconf program itself.

@menu
* Config Files::			Configuration files.
* SVR4 Compatibility::			Compatibility with Sys V.
* Loadable STREAMS Modules::		Loadable modules.
* The strconf Utility::			Configuration utilities.
* Configuration File Syntax::		The driver config file format.
* Driver Specification::		Specifying a driver.
* Module Specification::		Specifying a module.
* Node Specification::			Node specification.
* Device Specifications::		Device specification.
* Initialization Specification::	Driver initialization.
* Termination Specification::		Driver termination.
* Interrupt Specification::		Driver interrupts.
* Object Name Specification::		Module object name.
* Loadable Specification::		Loadable module specification.
* Autopush Specification::		Autopush specification.
* Tunable Parameter Specification::	Tunable parameters.
* Queue Locking Specification::		Queue locking.
* The Space.c File::			The optional Space.c file.
* A Simple Example::			Examples.
* Installing Your Driver::		Installation.
@end menu

@node Config Files
@section Config Files
@pgindex Config

There are several locations in the LiS directory tree in which a file by
the special name @file{Config} appears.  Each @file{Config} file describes
configuration information for one or more STREAMS drivers.  These
@file{Config} files are all concatenated together for processing by the
strconf utility program.
@pgindex Config

Drivers that are built into LiS are located in the directory
@file{/usr/src/LiS/drivers/str}.  This directory contains a @file{Config} file
which describes these drivers for the strconf program.  In this case a
single @file{Config} file describes multiple drivers.
@pgindex /usr/src/LiS/drivers/str
@pgindex Config

Drivers that are added to LiS in binary form at build time reside in
subdirectories of the directory @file{/usr/src/LiS/pkg}.  Each subdirectory
contains a @file{Config} file for its own driver.  All such @file{Config}
files are concatenated into the directory @file{/usr/src/LiS/pkg} into a file
named @file{config.pkg}.
@pgindex /usr/src/LiS/pkg
@pgindex Config
@pgindex config.pkg

During the LiS build procedure, in the directory @file{/usr/src/LiS}, the
@file{Config} file from the drivers/str directory is concatenated with the
config.pkg file into a file named @file{Config.master}.  This file is
processed by the strconf utility to produce the files @file{config.h},
@file{modconf.c} and @file{makenodes.c}.
@pgindex /usr/src/LiS
@pgindex modconf.c
@pgindex makenodes.c

@pgindex Config
@pgindex Config.master
@pgindex config.h

The @file{config.h} file is available to be included in the compilation of
individual @file{Space.c} files which appear in the
@file{/usr/src/LiS/pkg} subdirectories.  The contents of the
@file{config.h} file summarize the information contained in the
@file{Config} files in C language @code{#define}s which can be used for
building driver configuration tables.  It is placed in the directory
@file{/usr/src/LiS/include/sys/LiS}.
@pgindex /usr/src/LiS/include/sys/LiS
@pgindex /usr/src/LiS/pkg
@pgindex Config
@pgindex config.h
@pgindex Space.c

The @file{modconf.c} file is compiled as a component of LiS.  It contains initialized
tables for all of the STREAMS drivers and pushable modules that LiS is
configured to manage.
@pgindex modconf.c

The @file{makenodes.c} file is compiled into a utility program, makenodes,
which will create all of the entries for STREAMS drivers in the
@file{/dev} directory.
@pgindex makenodes.c
@pgindex /dev

@node SVR4 Compatibility
@section SVR4 Compatibility
@pgindex Config

Configuration of drivers in LiS is similar in flavor to the method used in
SVR4, but is different in almost all details.  Included with LiS is a PERL
script (nodeconfig.pl) that can be used to process an SVR4 Node(4dsp) file
into an LiS @file{Config} file.  This is an unsupported contribution from an LiS user.
@pgindex Config

@node Loadable STREAMS Modules
@section Loadable STREAMS Drivers and Modules

In order to support loadable STREAMS drivers and modules, the LiS
configuration file language contains keywords to support the notion of object
files.

An object file contains one or more drivers or modules.  It is typically a file
with suffix ".o" containing linkable object code built by compiling C language
source with the "-c" option.

By default, object files are linked with LiS at compile time, but you can use
the "loadable" keyword (@pxref{Loadable Specification}) in a @file{Config} file
to specify that an object file should be considered a kernel loadable
module.  This allows individual STREAMS drivers or modules to have the
status of Linux loadable modules.
@pgindex Config

@ignore
For an example of this observe how the "ldl" driver is built and installed as
a part of the LiS package itself.  The driver source resides in
drivers/str/linux.  The @file{Config} file that contains enties for "ldl" is in
drivers/str.  You can observe the LiS build process to see how the driver is
named and copied to the appropriate subdirectory of @file{/lib/modules}.
@pgindex /lib/modules
@pgindex Config
@end ignore

You can place a @file{Config} file in a subdirectory of the pkg directory without
placing any driver object code there.  This is sufficient for LiS to process
your @file{Config} file entries and make proper preparations for your loadable
driver, such as assigning it a major device number.  For more information
on this process, @xref{Installing Pre-Compiled Drivers}.
@pgindex Config

If the kernel is configured with support for kerneld(8), a loadable module
will be demand loaded (@pxref{Demand Loading LiS Modules}).  All kernel
module names defined within LiS begin with the prefix "streams" to avoid
name clashes with other Linux kernel modules.

For a non-clone device, the kernel will demand load the module under the name
"char-major-nn".  This will cause kerneld(8) to autoload a Linux kernel module
using the aliases in @file{/etc/conf.modules} (or @file{/etc/modules.conf}).  If
@file{/etc/conf.modules} contains an alias for a STREAMS driver then the driver can
be autoloaded via this mechanism.  To the kernel a loadable STREAMS driver is
just a character driver known by its major device number.
@pgindex /etc/conf.modules
@pgindex /etc/modules.conf

When the clone device is opened for a major configured in a loadable object
file "myobj" (for example), LiS will ask kerneld(8) to load "streams-myobj".
If this fails, LiS tries to demand load a module named "char-major-nn".  If
this also fails, an error is logged and the open fails.

When the name of a STREAMS module "mymod" configured in a loadable object file
"myobj" is used for I_PUSH, LiS demand loads a kernel module named
"streams-myobj".  If this fails, LiS will try to demand load a kernel module
named "streams-mymod".  If this also fails, an error is logged and the I_PUSH
fails.

When an unknown module name "mymod" is used for I_PUSH, LiS tries to demand
load a kernel module named "streams-mymod".

The strconf utility will emit a file with the aliases needed for kerneld(8)
support.  This file can be incorporated into the file @file{/etc/conf.modules}.  Refer
to the "-L" option for the strconf utility, below.
@pgindex /etc/conf.modules

@node The strconf Utility
@section The strconf Utility

In order to construct a @file{Config} file, it is useful to know the
syntax of the contents of the file.  The strconf utility is used to
process a @file{Config} file and generate the output files mentioned
above.
@pgindex Config

@subsubheading Command Line Syntax

@example
@dfn{strconf} [@var{options}] @var{input-file}
@dfn{strconf} -?, --help
@dfn{strconf} -V, --version
@end example

The options for strconf consist of zero or more of the following.

@table @code
@item -b, --basemajor=[@var{number}]
Set the base major number for automatic assignment of major device numbers.
The LiS Configure script, run from the top level "make", uses the value of the
environment variable LIS_MAJOR_BASE to set this parameter, or a default value
if this variable is not defined.  By defining this symbol in your environment
you can override the default base for major device numbers.

@item -h, --hconfig=[@var{file}]
Set the output header file name to something other than the default,
@file{config.h}.
@pgindex config.h

@item -l, --driverconf=[@var{file}]
Set the output driver configuration makefile include file name to something
other than the default "drvrconf.mk".

@item -L, --confmodules=[@var{file}]
Set the output Linux loadable module configuration file name to something
other than the default "conf.modules".

@item -m, --makenodes=[@var{file}]
Set the output file name for the program that will make the nodes to something
other than @file{makenodes.c}.  This program is compiled and then run to create all
the @file{/dev} entries for the STREAMS drivers.
@pgindex makenodes.c
@pgindex /dev

@item -M, -r, --functionname=[@var{name}]
The name of the mknod() routine to call in the @file{makenodes.c} program.  The
default is "mknod".
@pgindex makenodes.c

@item -o, --modconf=[@var{file}]
Set the output file name to something other than the default name @file{modconf.c}.
This is the file that must be linked in with STREAMS.
@pgindex modconf.c

@item -p, --permission=[@var{perm}]
Set default permissions to something other than 0666 for @file{/dev} entries created
by the @file{makenodes.c} program.
@pgindex makenodes.c
@pgindex /dev

@item -r, --functionname=[@var{name}]
The name of the routine to build in @file{makenodes.c}.  The default is "main".
@pgindex makenodes.c

@item -s, --strmknods=[@var{makedevices}]

@item -V, --version
Display the program version and exit.

@item -?, --help
Display a ussage and option summary and exit.
@end table

The @var{input-file} parameter is the name of the file containing the
configuration information in ASCII.

@subsubheading Example:

@example
strconf -b51 config.master
@end example

This command bases the major device numbers for STREAMS drivers at 51 and
outputs files to the standard places.

@node Configuration File Syntax
@section Configuration File Syntax

The input to the strconf program is informally referred to as a
@file{Config} file.  This file consists of lines of ASCII text which is
interpreted by the strconf program.
@pgindex Config

Blank lines are ignored.  The "#" serves as a comment symbol, terminating any
line on which it appears.

Input to strconf consists of a series of tokens, which are strings of ASCII
characters with no embedded white space.  Some tokens are keywords known to
strconf; some are numbers in C language syntax; some are identifiers supplied by
the user to give names to drivers, etc.  Tokens are separated from one another
by white space.

Each line in the file is self-contained.  That is, a construct consisting of a
keyword followed by its arguments must all appear on the same line of the file.

Strconf processes lines for the following constructs.

@node Driver Specification
@section Driver Specification

@kindex driver

@example
driver @var{driver-name} @var{prefix} @var{major} @var{minors}
@end example

@table @var
@item driver-name
is the name of the STREAMS driver (not pushable module), for example
loop-around.  It is any string of characters not including "white space"
characters.

@item prefix
is alphanumeric, plus underscore, and will be prefixed to any table
entries referencing variables within this driver.  For example, the prefix
loop_ will be used to derive the reference to the streamtab entry
loop_info.  The driver must have a variable declared within it by the name
prefixinfo of type struct streamtab.
@tpindex struct streamtab

@item major
specifies the major device number that will be assigned to the device.
The character "*" means that the config program will choose the major
number (@pxref{The strconf Utility}).  A numeric value is used as it is
given.

@item minors
is the number of minors the device has.  If this field is omitted, the
number 1 will be used.  The value of this field is not used for anything
except to generate a @code{#define} in the @file{config.h} output file.
@pgindex config.h
@end table

Example:

@example
driver loop-around loop_ *
@end example

This declares a driver which has the name @dfn{loop-around} for reference
purposes within the strconf program.  Its prefix is @samp{loop_}, and the
strconf program is to assign its major device number.

@node Module Specification
@section Module Specification

@kindex module

@example
module @var{name} @var{prefix}
@end example

@table @var
@item name
is the name of the module, for example relay-mod.  It is any string of
characters not including "white space" characters.

@item prefix
is alphanumeric, plus underscore, and will be prefixed to any table
entries referencing variables within this module.  For example, the prefix
relay_ will be used to derive the reference to the streamtab entry
relay_info.  The module must have a variable declared within it by the
name prefixinfo of type struct streamtab.
@tpindex struct streamtab
@end table

Example:

@example
module relay-mod relay_
@end example

This example declares a pushable module to be referred to internally as
@dfn{relay-mod}.  Its prefix is @samp{relay_}.

@node Node Specification
@section Node Specification

@kindex node

@example
node @var{dev-name} @var{type} @var{perm} @var{major} @var{minor}
@end example

The keyword @dfn{node} introduces this entry.

@table @var
@item dev-name
is the full path name of the device file to be created, for example,
@file{/dev/loop}.

@item type
is the type of file to create.  This consists of a single letter as
follows:

@table @code
@item b
block special device (S_IFBLK)
@item c
character special device (S_IFCHR)
@item p
pipe device (S_IFIFO)
@end table

@item perm
is the device permissions to use, 0666 gives everyone permission to use
the device.  perm can be "*" in which case default permissions are
supplied (see -p command line option).

@item major
is the major device number to assign to this entry.  It can be a number,
but is usually the name of the associated driver entry.  The [50]major
specified for the named driver is then used.

@item minor
is the minor device number to assign to this entry.  It can be a number or
the name of another driver.  If the name form is used then the major
number of the other driver is used as the minor number of the device being
created.
@end table

Example:

@example
node /dev/loop c * loop-around 1

node /dev/loop_clone c * clone-drvr loop-around
@end example

The first example defines a device @file{/dev/loop} as a character special
device with default permissions as minor device 1 of the @dfn{loop-around}
driver.

The second example defines a device @file{/dev/loop_clone} as a character
device with default permissions with major device number equal to that
assigned to the driver named @dfn{clone-drvr} and minor device number
equal to that assigned to the driver named @dfn{loop-around}.

@node Device Specifications
@section Device Specifications 

@kindex device

These entries are used to describe the configuration of each physical
device or port of a multi-port device on the system.  Those familiar with
the Unix sdevice file format will see some similarity to this format.  The
syntax for this type of entry is as follows:

@example
device @var{driver-name} @var{unit} @var{port} @var{nports} @var{irq-share} @var{irq} @var{mem} @var{mem-size} @var{dma1} @var{dma2}
@end example

All 11 fields must be on the same line.  Only the @dfn{device} keyword and
@var{driver-name} fields are mandatory.

@table @var
@item driver-name
is the name of the driver that handles the device.  It must match the name of a
declared driver in this file.

@item unit
is the unit number of the device being declared.  A unit number means anything
that the driver writer wants it to.  It is assumed to be a small integer that
will index a configuration table that is built from @code{#define}s generated by
running this program.  If this field is missing it is set to -1.

@item port
is the I/O port that the device uses.  Set to -1 if the device does not use any
I/O ports.  If this field is missing it is set to -1.

@item nports
is the number of consecutive I/O ports used by the driver.  If ports is -1 then
@var{nports} can be any value, zero is suggested.  If this field is missing it is set
to zero.

@item irq-share
is a letter-coded field as follows:

@table @code
@item n
No sharing of IRQ
@item s
Sharing of IRQ
@item S
Sharing of IRQ but only with the same driver
@item x
Don't care, the device does not use an IRQ
@end table

If the @var{irq-share} field is missing it is defaulted to the value
corresponding to "x".

@item irq
is the interrupt number for the device.  The value -1 is used when the device
does not have an interrupt.  If this value is specified then it is assumed that
there exists a routine with the name prefixintr, where prefix is the driver
prefix specified in the driver section.  If this field is missing it is set to
-1.

@item mem
is the shared-memory address used by this device, if any.  Set to 0 if the device
does not use shared memory.  If this field is missing it is set to zero.

@item 
mem-size
is the amount of shared memory used, in bytes.  If this field is missing it is
set to zero.

@item dma1
@itemx dma2
specify up to two DMA channels used by this device.  Set to -1 if no DMA channels
are being used.  If either of these fields is missing it is set to -1.
@end table

The device entry causes a set of @code{#define}s to be generated into the
file @file{config.h}.  This file may be @code{#include}d into a driver
configuration file to load tables, etc.  The form of the @code{#define}s
in the @file{config.h} file is compatible with the form used by Unix SVR4.  Thus,
if you are porting a STREAMS driver from SVR4 you can use a variant of
your System file entries as the device entries and use the resulting
@file{config.h} file in your existing @file{Space.c} file.

@pgindex config.h
@pgindex Space.c

The present implementation of LiS does not dispatch interrupts for STREAMS
drivers.  It is possible that some future version will do so, in which
case the IRQ specifications will be more meaningful.  At present these
specifications only cause entries to be generated in the @file{config.h}
file.  You can utilize this information in a @file{Space.c} file to build
a table that your driver uses to attach its IRQ from its initialization
routine.

@pgindex config.h
@pgindex Space.c

Example:

@example
device cdip 0 0x310 8 S 10 0xD0000 0x4000
@end example

This example declares a device entry for the driver named @dfn{cdip}.  Its
unit number field is zero.  It has eight I/O ports starting at port
address @code{0x310}.  The device can share IRQ10 with other devices of
the same driver.  It has shared memory based at @code{0xD0000} which is
16K bytes (@code{0x4000}) in size.  It does not use any DMA channels.

@node Initialization Specification
@section Driver Initialization Specification

@kindex initialize

@example
initialize @var{driver-name}
@end example

@table @var
@item driver-name
is the name of the driver whose @samp{init} routine is to be called.  The
driver must supply a routine such as the following:
@end table

@example
void prefixinit(void)
@{
@}
@end example

Example:

@example
initialize loop-around
@end example

This leads to a call to the routine @dfn{loop_init()} since @samp{loop_}
is the associated prefix for the @dfn{loop-around} driver.  This routine
is called by LiS when LiS is initialized.  If LiS is linked with the
kernel then this call occurs at system boot time.  If it is loaded as a
module then the call occurs at module initialization time for LiS.

@node Termination Specification
@section Driver Termination Specification

@kindex terminate

@example
terminate @var{driver-name}
@end example

@table @var
@item driver-name
The @var{driver-name} is the name of the driver whose @dfn{term} routine
is to be called.
@end table

The driver must supply a routine such as the following:

@example
void prefixterm(void)
@{
@}
@end example

Example:

@example
terminate loop-around
@end example

This leads to a call to the routine @dfn{loop_term()} since @samp{loop_}
is the associated prefix for the @dfn{loop-around} driver.  This routine
is called by LiS when LiS is terminating.  If LiS is linked with the
kernel then this call never occurs because LiS is never terminated.  If
LiS is loaded as a module then the call occurs at module termination time
for LiS.  This occurs just prior to unloading LiS from memory.

@node Interrupt Specification
@section Driver Interrupt Specification

@kindex interrupt

@example
interrupt @var{driver-name}
@end example

@table @var
@item driver-name
The @var{driver-name} is the name of the driver whose @dfn{intr} routine
is to be attached.
@end table

The driver must supply a routine such as the following:

@example
void prefixintr(void)
@{
@}
@end example

Example:

@example
interrupt loop-around
@end example

This causes LiS to register the driver's interrupt routine for each of the
IRQs used in the driver's device specifications.  This occurs at module
init time within LiS.  The routine is unregistered when LiS is unloaded.

@node Object Name Specification
@section Object Name Specification

@kindex objname

@example
objname @var{type} @var{name} @var{object-name}
@end example

The keyword @dfn{objname} specifies the base name of the object code file
for a driver or module.  Several drivers and modules may reside in the
same object file.  If an @var{object-name} is never specified for a driver
or module, the @var{object-name} defaults to the name of the driver or
module.

@table @var
@item type
is either @code{driver} for a streams driver or @code{module} for a
streams module.

@item name
is the name of the driver or module.

@item object-name
is the base name of the object code file used for this driver or module.
@end table

The purpose of this keyword is twofold:

@enumerate
@item It specifies to the drivers/str make process the names of the object files
that need to be compiled.  These names need not be the same as the configuration
names.

@item If name is also specified as loadable and the Linux kernel is compiled
with kerneld(8) support, LiS will demand load name by asking kerneld(8) for
"streams-object-name".
@end enumerate

Example:

@example
objname driver loop-around loop
@end example

@node Loadable Specification
@section Loadable Specification

@kindex loadable

@example
loadable @var{object-name}
@end example

The keyword @dfn{loadable} specifies that an object code file (as
specified by the @dfn{objname} keyword) is a Linux kernel loadable module.
If the kernel is compiled with kerneld(8) support, LiS will ask kerneld(8)
to [57]load the module on demand.

Please note that you will have to explicitly declare @var{object-name}
with the @dfn{objname} keyword first.  Default @var{object-name}s will not
do for this keyword, as they may be changed later in the configuration
file.

@table @var
@item object-name
is the base name of the object code file.
@end table

Example:

@example
loadable loop
@end example

@node Autopush Specification
@section Autopush Specification

@kindex autopush

@example
autopush @var{driver-name} @var{minor} @var{last-minor} @var{module-list}
@end example

The keyword @dfn{autopush} specifies a list of modules that should be
pushed onto a stream when it is opened.

@table @var
@item driver-name
is the name of a driver.  The autopush specification only applies to this
driver.

@item minor
specifies the first minor device number that this autopush specification
applies to.  If @var{minor} is -1, @var{last-minor} is ignored and the
autopush applies to all minors of this driver.

@item last-minor
specifies the last minor in a range that this autopush specification
applies to.  If @var{last-minor} is 0, this autopush specification applies
only to the single minor device number @var{minor}, otherwise
@var{last-minor} must be greater than @var{minor} and the autopush applies
to all minor devices of the named driver from @var{minor} to @var{last-minor}
inclusively.

@item module-list
is a list of one or more STREAMS modules that should be pushed onto the
stream when it is opened.  The leftmost module is pushed first.
@end table

@strong{WARNING}: Autopush status is currently "complete, untested".

Example:

@example
autopush loop-around 8 15 relay
@end example

@node Tunable Parameter Specification
@section Tunable Parameter Specification

@kindex define
@pgindex config.h

This type of entry allows you to insert define text into the output file
(@file{config.h} default).  These values can be used as parameters for
drivers or the streams package itself.

The syntax is:

@example
define @var{name} @var{value}
@end example

@table @var
@item name
The @var{name} is the identifier that is being defined.  It must be constructed of
characters that comprise a legal C language identifier.

@item value
The @var{value} is any text up to the end of the line.
@end table

The output for this entry is of the form:

@example
#define name value
@end example

Example:

@example
define MAX_PORTS 16
@end example

Generates the following in the output file:

@example
#define MAX_PORTS 16
@end example

@node Queue Locking Specification
@section Queue Locking Specification

@kindex qlock
@pgindex config.h

This statement specifies the locking style to be used for the named driver or
module (pushable).  There are four different styles of locking specified
numerically from 0 through 3.

The locking that is performed involves the acquisition of a sempahore prior to
calling the driver's put or service procedure.  Thus, it controls entry into the
driver.

The locking styles are as follows:

@table @code
@item 0 (LIS_QLOCK_NONE)
No locking is performed.  If the driver needs protection from multiple
simultaneous entries of its put and service procedures it must provide the
protection itself.

@item 1 (LIS_QLOCK_QUEUE)
The read and write halves of the queue are locked separately.  Thus a read
function (put/srv) can be entered simultaneously with a write function
(put/srv).  This is the default and is the way that LiS operated prior to the
introduction of this option.

@item 2 (LIS_QLOCK_QUEUE_PAIR)
The read and write halves of the queue are locked together.  Thus only one of
the read/write put/srv procedures can be entered at a time.

@item 3 (LIS_QLOCK_GLOBAL)
A global sempahore is used to lock both halves of the queue.  The same global
lock is used for all drivers and all streams.  Thus any collection of drivers
using this style of locking will be mutually single threaded.
@end table

The utility of using locking style 0 has to do with acheiving higher throughput
in multiple CPU environments.  If all put and service procedures can be entered
simultaneously, then the put procedure can be calling putq() on one CPU while
the service procedure is calling getq() and processing messages on another,
setting up a pipeline execution effect.  Experiments have shown significant
throughput improvements when this style of locking can be used.

In such a circumstance the driver service procedure needs to maintain some kind
of running flag, manipulated under a spin lock control, to assure single
threaded execution of the messages removed from the queue.  Such flag
manipulation is good practice even though LiS will not naturally tend to enter a
driver's service procedure for the same queue on multiple CPUs simultaneously.

@node The Space.c File
@section The Space.c File

The @file{Space.c} file plays a role in LiS configuration similar to the
file of the same name in Unix SVR4.  It is a file associated with each
driver package which contains configuration information for the driver.
It is compiled during the LiS build phase.

@pgindex Space.c
@pgindex Config

The @file{Space.c} file can utilize information obtained by processing the
@file{Config} files using strconf.  This processing is automatic and is a
part of the LiS build procedure.  The strconf utility is run prior to
compiling the @file{Space.c} file for each driver package.

@pgindex Space.c
@pgindex Config

The @file{Space.c} file can include the file @file{config.h} which
contains @code{#define}s for the information gleaned from the
@file{Config} files.  This allows the @file{Space.c} file for a particular
driver to capture this information in a table that the driver can consult
during initialization.  The LiS build procedure supplies the proper "-I"
command line option to make the @file{config.h} file visible when
compiling the @file{Space.c} files.

@pgindex config.h
@pgindex Space.c

The @code{#define}s generated by strconf are of the following form.

For each driver:

@example
#define prefix 1
#define prefix_CTLS Nr-device-entries
#define prefix_UNITS minors
#define prefix_CMAJORS majors
#define prefix_CMAJOR_0 assigned-major-device-number
#define prefix_TYPE -1
@end example

For each declared device:

@example
#define prefix_unit 1
#define prefix_unit_SIOA port
#define prefix_unit_EIOA port+nports-1
#define prefix_unit_VECT irq
#define prefix_unit_SCMA mem
#define prefix_unit_ECMA mem+mem-size-1
#define prefix_unit_CHAN dma1
#define prefix_unit_CHAN dma2
@end example

@node A Simple Example
@section A Simple Example

Let us suppose that you have a STREAMS driver for which you have chosen the
prefix "xylo_".  You need to make a @file{Config} file to go with your driver.  In the
@file{Config} file you need to declare the existence of your driver as follows.
@pgindex Config

@example
driver mydrvr xylo_ *
@end example

By doing this you are declaring that you have a driver named "mydrvr"
which uses the symbol-name prefix "xylo_" and you don't care what its
major device number is.  The "mydrvr" is a name that you make up that is
not used anywhere but in the @file{Config} file to refer to this driver.
The "xylo_" is the prefix that you used in coding your driver.  It is used
to synthesize the name "xylo_info", the main streamtab structure for your
driver.  The "*" says that you don't care what [62]major number your
driver is assigned.  The "n-minors" field is a place to say how many minor
devices your driver handles, but it is not used anywhere, and thus is left
empty.
@pgindex Config

Use the "driver" declaration for hardware drivers and STREAMS multiplexor
drivers.

If your driver had been a pushable module rather than an actual driver then you
would have used, something like the following.

@example
module mydrvr xylo_
@end example

You will probably want some @file{/dev} entries made so that you can access your driver
via the stream head and the file system.  Do that by including a "node" section
of the @file{Config} file.  For example:
@pgindex /dev

@example
# name  type perm major  minor
node /dev/xylo  c * mydrvr  0
node /dev/xylo_clone c * clone-drvr mydrvr
@end example

In this case we have added an entry that opens minor device zero (/dev/xylo) and
a clone entry that will open your driver via the STREAMS clone driver
(/dev/xylo_clone).  The name "clone-drvr" is always present when LiS processes
your @file{Config} file.

The clone driver is a special feature of STREAMS.  You can read all about it in
the [63]reference documents, or the [64]drivers page of the LiS documentation,
but the gist of the idea is to make it easy for an application program to open a
file to the STREAM and always get an available minor device.  In the case of a
non-clone device, the application has to "guess" as to which minor device
numbers are unused.  For a clone device, the driver itself assigns the minor
device number and always picks one that is unused for the newly opened file.

The mechanism for the clone device involves the use of a special driver, the
clone driver.  It is declared in a @file{Config} file just like any other STREAMS driver
under the name "clone-drvr".  The clone driver has a specified major device
number.  It also has minor devices that are opened via directed (non-clone)
opens.  The minor device numbers of the clone driver are the major device numbers
of another STREAMS driver.  The clone driver's open routine calls the open
routine of the second STREAMS driver by using the minor device number of the
open to @file{/dev/clone_drvr} as the major device number of the driver whose open
routine is to be called.
@pgindex /dev/clone_drvr

This is why the entry in the "node" section of the @file{Config} file for a clone
device has the name of the clone driver in the major number field and the name
of the driver which eventually gets the open call in its minor number field.

Note that the cflag parameter to the driver open routine will indicate a clone
open if the open has passed through the clone driver.  This allows your driver to
distinguish between directed (non-clone) opens and clone opens.

@node Installing Your Driver
@section Installing Your Driver
@pgindex Config

To install your driver so that it is linked with LiS when LiS is built you need
to do the following.

Go to the directory @file{/usr/src/LiS/pkg}.  Make a subdirectory for your driver.  For
example, mkdir xylo.
@pgindex /usr/src/LiS/pkg

Then copy the object code (.o) file for your driver into that directory.  Also
copy your driver's @file{Config} file to that directory.  For a loadable driver, do not
copy your driver's object code file to the pkg/xylo subdirectory, instead, copy
it to @file{/lib/modules/@var{kernel-version}/misc/streams-xylo.o}.  There are special
considerations for [66]demand loadable drivers.
@pgindex /lib/modules/@var{kernel-version}/misc/streams-xylo.o

If your driver needs to build any tables for configuration based on the
@file{config.h} file that is generated from running the LiS strconf
utility then you need to create a file named @file{Space.c} and copy it to
the pkg/xylo directory.

@pgindex config.h
@pgindex Space.c

You also need to create a @file{Makefile} for your pkg/xylo directory.  If
you do not have a @file{Space.c} file then your @file{Makefile} can
consist of just the following.

@pgindex Makefile
@pgindex Space.c

@example
nothing:
@end example

If you have a @file{Space.c} file then your @file{Makefile} can consist of
this.

@pgindex Makefile
@pgindex Space.c

@example
include ../proto/Makefile
@end example

@pgindex Makefile

The @file{../proto/Makefile} contains a rule to compile your
@file{Space.c} file into @file{Space.o}.

@pgindex Makefile
@pgindex Space.c
@pgindex Space.o

That is all you have to do.  The LiS build will concatenate your @file{Config} file with
the LiS built-in @file{Config} file and produce a @file{config.h} file.  It will
enter your directory and perform a "make".  It will then link in all files
ending in ".o" from your directory into the @file{streams.o} file.  The @file{streams.o}
file is the file that is loaded when the command insmod streams is
executed.
@pgindex streams.o

@pgindex config.h



@node Demand Loading LiS Modules
@chapter Demand Loading LiS Modules and Drivers

The LiS demand load system supports both the old kerneld and the new kmod
mechanisms for demand loading kernel modules.

The convention for LiS kernel loadable object files is:
@itemize @bullet
@item Their name start with "streams-".
@item They are placed in @file{/lib/modules/@var{<kver>}/misc/}, where @var{<kver>} is the kernel version.
@pgindex /lib/modules/@var{<kver>}/misc/
@end itemize

@section Kernel Version Differences

For 2.4 kernels you can install your loadable module simply by copying the "o"
file for our module to the directory @file{/lib/modules/@value{_kversion}/misc/}.

For 2.6 the procedure involves an additional step.  Loadable modules in 2.6 are
@samp{.ko} files instead of @samp{.o} files.  The mechanism to turn a
@file{driver.o} into a @file{driver.ko} is non-trivial.  To do this, copy your
@file{driver.o} file to @file{/usr/src/LiS/modules}.  Then do @samp{make install}
in the LiS directory.  LiS will turn all @samp{.o} files in its modules
subdirectory into @samp{.ko} files and copy the resultant files to the proper
subdirectory of @file{/lib/modules}.

@section Unconfigured drivers and modules

An unconfigured driver or module is a driver or module that LiS does not have
any special information about.  Even in this case, you can take advantage of
demand loading.

@section Modules

Module demand loading is simple.  When a user does an I_PUSH requesting that
module mymod be pushed onto a stream, LiS will check if mymod is already
registered.  If not, LiS asks the kernel to load streams-mymod.

A security related implication of this is that any user capable of doing an
I_PUSH can provoke loading of any module that has the streams- prefix.

Demand loading also works when autopushing modules, but you should be aware that
when a module is unloaded, it is silently removed from all autopush lists.

You can have more than one module in a single kernel loadable module, but for
demand loading to work with modules whose object names are not derived from the
module name, you have to set up alias lines in @file{/etc/conf.modules}.
@pgindex /etc/conf.modules

For example, if you have modules mymod and mymod2 in the kernel loadable object
file @file{streams-mymod.o}, you have to add the line
@example
alias streams-mymod2 streams-mymod
@end example
in your @file{/etc/conf.modules} for demand loading to work properly when pushing
mymod2.
@pgindex /etc/conf.modules

@section Drivers

Demand loading drivers is slightly more complicated.  When a device special node
with major device number major is opened, the kernel checks if device major is
registered in the kernel.  If not, the kernel will try to load
"char-major-major".

If a clone open is done LiS will check if the driver is registered.  If not, LiS
will ask the kernel to load char-major-minor, where minor is the minor device
number of the clone device opened.  In this case the value of minor is the major
device number of the driver that needs to be loaded and opened.

Kernel loadable modules generally do not have names of the form
char-major-number, so a mapping to the correct name is needed.  This is done with
alias lines in @file{/etc/conf.modules}, or, on newer systems, @file{/etc/modules.conf}.  If
your driver has major device number 123 and is in the kernel loadable object
file @file{streams-mydriver.o}, you should have the line
@pgindex /etc/conf.modules
@pgindex /etc/modules.conf
@example
alias char-major-123 streams-mydriver
@end example
in your @file{/etc/conf.modules}.
@pgindex /etc/conf.modules

If you also have the line
@example
alias char-major-240 streams
@end example
in your @file{/etc/conf.modules} and the clone driver major is 240, both LiS and your
driver will be demand loaded when you do a clone open of your driver.
@pgindex /etc/conf.modules

You can configure autopush on an unconfigured driver, but you should be aware
that when the driver is unloaded, all its autopush lists are silently removed.

You can have more than one driver in a single kernel loadable module, but you
should set up a separate alias line for each driver.

@section Configured drivers and modules

When drivers and modules are added to the [17]LiS configuration files, you can
specify the object name that will be used for requesting a demand load of the
driver or module.  If demand loading of the configured object name fails, LiS
will revert to the procedure for demand loading an unconfigured driver or
module.

The advantage of configured drivers and modules is that the LiS installation
procedure takes care of adding the needed alias lines to @file{/etc/conf.modules}.
Also, the autopush configuration is not changed when a configured driver or
module is unloaded.
@pgindex /etc/conf.modules

@section Writing kernel loadable modules for LiS

It takes little extra effort to make LiS modules and drivers loadable.  In most
cases, all you have to do is to add the special Linux module functions
init_module() and cleanup_module() and some lines to maintain the usage count of
the loadable module.

The init_module() function id used for initializing the loadable module, and can
be as simple as:
@example
int init_module(void)
@{
        return lis_register_strmod(&mymod_info, "mymod");
@}
@end example
for a module, or
@example
int init_module(void)
@{
        return lis_register_strdev(123, &mydrv_info, 10, "mydrv");
@}
@end example
for a driver.

In this example, the driver's major device number is assumed to be 123.  You must
know this major device number ahead of time so that you can make the entry in
the @file{/dev} directory that will cause your driver to autoload.  The major number in
your @file{/dev} entry and in your call to lis_register_strdev must match.
@pgindex /dev

The cleanup_module() function is called by the kernel just before a loadable
module is unloaded.  This function has to unregister the drivers and/or modules
registered in the init_module() function.

The cleanup_module() function can be as simple as:
@example
void cleanup_module(void)
@{
        lis_unregister_strmod(&mymod_info);
@}
@end example
for a module, or
@example
void cleanup_module(void)
@{
        lis_unregister_strdev(123);
@}
@end example
for a driver.

To avoid that the loadable module is unloaded while somebody is still using it,
a usage count has to be maintained.  This is done using the macros
MOD_INC_USE_COUNT and MOD_DEC_USE_COUNT.  MOD_INC_USE_COUNT is used in the open
routines, but be careful not to call it if your open fails.  MOD_DEC_USE_COUNT is
used in the close routines.

@ignore
For a complete example, see the [18]ldl driver in drivers/str/linux/ldl.c.
@end ignore

@section Queue Locking in Loadable Modules

Declared modules can use the @command{strconf} @samp{qlock} option to control
the locking style for entering the driver's put and service procedures.  A
loadable module can call one of the following routines, most likely at module
load time.
@example
int lis_register_driver_qlock_option(major_t major, int qlock_option);
int lis_register_module_qlock_option(modID_t id, int qlock_option);
@end example

The parameters @samp{major} and @samp{id} are obtained from the driver and
module registration functions described above.

The @samp{qlock_option} parameter is one of the following:
@example
LIS_QLOCK_NONE
LIS_QLOCK_QUEUE
LIS_QLOCK_QUEUE_PAIR
LIS_QLOCK_GLOBAL
@end example

@node Installing Pre-Compiled Drivers
@chapter Installing Pre-Compiled Drivers

LiS makes provision for you to add your own STREAMS drivers to the build of LiS.
You drivers are built outside the LiS source code tree.  The object code and
configuration information pertaining to your driver must be copied into the LiS
source code tree in order to be incorporated into LiS.

@section The LiS pkg Directory

The directory @file{/usr/src/LiS/pkg} is the directory where pre-compiled drivers are
to be copied.  This directory contains subdirectories, one for each driver to be
linked in with LiS when LiS is built.
@pgindex /usr/src/LiS/pkg

If you have a driver named foo then you need to do a mkdir @file{/usr/src/LiS/pkg/foo}
to create the directory that will contain the components of your driver.
@pgindex /usr/src/LiS/pkg/foo

@section Driver Components

You need to copy the following files into your package directory
(/usr/src/LiS/pkg/foo).

@subsection Component Description
@table @code
@item Makefile
A make file to do anything that needs to be done just prior to linking your
driver's object code file into LiS.  If there is nothing to be done then just
provide a dummy default target.  The @file{Makefile} has to be present for
the LiS build procedure to function properly.

@pgindex Makefile

@pgindex Driver.o
@item Driver.o
Any number of object files with suffix ".o" will do.  These files can be
copied into this directory from elsewhere, they do not have to be built by
the @file{Makefile}.  Alternatively, the @file{Makefile} can copy in
updated driver object files as needed.  Which style you use is entirely up
to you.

@pgindex Makefile

@item Space.c
This is optional.  If you want to incorporate configuration information
from your @file{Config} file into your driver at link time, then place a file by
this name into your driver's package directory.  Your @file{Makefile}
should contain an include @file{../proto/Makefile} to incorporate a rule
to make this file into an object file.  Your @file{Space.c} file should
include the file @file{config.h} in it.  See the section on
[17]Configuration for more details about @file{Space.c} and
@file{config.h}.

@pgindex config.h
@pgindex Makefile
@pgindex Space.c
@pgindex Config

@item Config
This is the STREAMS configuration file for your driver.  It is combined with
other @file{Config} files for other drivers to produce a master @file{Config} file.  This
master @file{Config} file is then processed by the LiS strconf utility to
produce, among other things, the file @file{config.h}.  See the section on
[18]Configuration for more information about the @file{Config} file.
@pgindex config.h
@pgindex Config
@end table

@section Dynamically Loadable STREAMS Drivers

You can also compile your STREAMS driver as a loadable module and load it
dynamically either [19]on demand or using the insmod command.

In order to do this you need to inform the Linux kernel that your driver
depends upon the LiS STREAMS driver.  You do this by placing an entry into
the file @file{/etc/conf.modules} (on newer distributions of Linux this file has
been renamed to @file{/etc/modules.conf}) .  In order to code this entry
correctly, you need to know the major device number that is to be assigned
to your driver.  One way to find this out is to make a directory for your
driver in the LiS pkg directory and include a [20]@file{Config} file but no
object code.  You can then use the resulting @file{config.h} file (located
in the directory @file{/usr/src/LiS/include/sys/LiS} and left behind by the LiS
build process) to determine your driver's major device number.
@pgindex /usr/src/LiS/include/sys/LiS
@pgindex /etc/conf.modules
@pgindex /etc/modules.conf
@pgindex config.h
@pgindex Config

When your driver loads and you register it, you need to ask for this major
device number.

The entry in the @file{/etc/conf.modules} file looks like the following:
@pgindex /etc/conf.modules

@example
alias char-major-maj streams
@end example

This entry tells the kernel that a driver with major device number maj is
dependent upon the module named "streams," the module name for LiS.  The LiS
strconf utility program contains constructs which support this process.  See the
[21]Configuration section for more information.

Tip: Be sure not to include your driver's ".o" file in the LiS pkg directory.
Instead you will need to copy it to the appropriate subdirectory of
@file{/lib/modules}.
@pgindex /lib/modules


@node Coding STREAMS Applications
@chapter Coding STREAMS Applications

This document is concerned with the include files and compilation techniques for
STREAMS application programs.  It is not intended to be a tutorial on the subject
of writing STREAMS applications.  Additional resources are available [17]here for
reference material.

@section Header Files

In your STREAMS application program C language source, use the following line to
include LiS header files.

@example
#include <sys/stropts.h>
@end example
@pgindex stropts.h

This will include all of the STREAMS related information that you need for a
user level program.

If your application program uses the poll system call then you need to include
one or the other of the following lines depending upon the kernel version that
the application is intended to run on.  For kernel versions in the 2.0 group, use
the following in order to include the poll.h from LiS.

@example
#include <sys/poll.h>
@end example

For kernel versions in the 2.2 group, use the following in order to include
poll.h from the kernel's source tree.

@example
#include <linux/poll.h>
@end example

@section Compilation Options

When you compile your STREAMS application, put the following compiler option on
the gcc (cc) command line for each C language file that contains any of the
above include lines.

@example
-I/usr/src/LiS/include
@end example

This directive assumes that you used standard installation procedures for LiS so
that the name @file{/usr/src/LiS} is a symbolic link to the LiS installation directory.
@pgindex /usr/src/LiS

@section Linking Options

When you perform the final link of your application using cc or gcc, add the
following to the end of your list of files and libraries to be linked.  This
links in the system call interface routines for LiS.

@example
-lLiS
@end example

This library includes the STREAMS based version of the pipe system call.  If you
want to use the standard STREAMS library routines, such as getmsg and putmsg,
but you want to use the standard Linux pipe system call, use the following
instead.

@example
-lpLiS
@end example

@section Other STREAMS Resources

Click [18]here for a list of other locations that you can consult for general
information concerning writing STREAMS applications.


@node LiS SMP Implementation
@chapter LiS SMP Implementation

Beginning with LiS-2.12, LiS makes aggressive use of multiple CPUs in SMP
kernels.  It is useful for the STREAMS programmer to have some insight
into this design in order to know whether, or which, locking techniques
must be used in driver code.

@menu
* CPU Scheduling::
* Queue Locking::
* Service Procedure Context::
* Scheduling Statistics::
@end menu

@node CPU Scheduling
@section CPU Scheduling

LiS starts up a kernel thread for each CPU on the system.  In the output
of a ps display each thread will show as a process with a name such as
"LiS-2.12:0".  This notation means that an LiS kernel thread is running
and is bound to CPU 0 (":0").

LiS maintains a single global list of queues whose service procedures need
to be run.  A queue is place into this list by calling the function
qenable, whether directly or indirectly.  A given queue can only be in
this list once.  The read queue and write queue of a queue-pair are
considered two different queues for scheduling purposes and both can be
scheduled simultaneously.

At "certain points in time" LiS performs an operation that makes a
decision concerning the manner in which service procedures are to be
invoked via the list of scheduled queues.  There are several factors which
influence this decision.

@itemize @bullet
@item If the decision is being made just prior to LiS exiting back to user
mode from a system call, if the LiS kernel thread for this CPU is inactive
and if there are few enough entries in the list of scheduled queues then
LiS calls the routine that processes queues directly without waking up any
of its kernel threads.

@item If the decision is being made from an interrupt routine then the
queue processing routine is not to be called directly.

@item If the decision is being made from a call on the routine qenable
then the queue processing routine is not to be called directly.

@item The number of queues in the scheduling list affects the decision
making process.

@item The number of LiS kernel threads running affects the decision making
process.

@item Whether or not LiS is executing a system call affects the decision
making process.  In this case LiS may defer any queue processing action
until the system call is about to exit.
@end itemize

In the case that the queue processing routine does not get called
directly, LiS needs to decide whether to wake up a kernel thread process
or whether to defer queue processing until an LiS system call is about to
exit.

LiS tries to enlist one CPU for every four queues that are scheduled.
This number is based on considerations of CPU loading and average queue
lengths from queueing theory.  If the number of CPUs currently processing
queues is not enough to meet this target then the scheduling process seeks
to enlist more CPUs until the number of CPUs is sufficient to meet this
target value.  Of course, sometimes there are simply too may queues
schedule for processing for the number of available CPUs.  In that case,
all available CPUs run their queue processing threads.

When making the decision as to whether or not to wake up a kernel thread,
LiS gives precedence to the CPU that it is running on.  If the scheduling
algorithm is called from a point just prior to executing back to the user,
and if the kernel thread for the active CPU is sleeping, then LiS will
simply call the queue processing routine without waking up the kernel
thread.  This saves the wakeup and context switch overhead.

The routine that actually runs the queues removes one element at a time
from the list of scheduled queues and calls the service procedure pointed
to by the queue.  The routine continues until the list of scheduled queues
is empty.  Thus, when a kernel thread is actively processing queues, and
if the number of scheduled queues does not exceed the estimated capacity
of the running threads, it is quite efficient to simply add a queue to the
list and let the already running threads process them in due course.

@node Queue Locking
@section Queue Locking

The queue_t structure in LiS contains a spin lock that is used by LiS to
ensure that service procedures are not reentered for the same queue.  This
lock is not to be used by driver code.

When the LiS queue running routine removes a queue from the list of
scheduled queues it acquires this lock prior to calling the service
procedure.

LiS also acquires this lock when calling the put procedure associated with
a queue.  Thus, execution of the put and service procedure are excluded
for the same queue.

In a multi-CPU environment, it can happen that one CPU is calling the put
procedure while a second CPU is calling the service procedure for the same
queue.  In this case, one or the other spins until the first CPU finishes
the operation and releases the spin lock.

When LiS is about to call the put procedure of a queue from the put or
service procedure of a neighboring queue (because the driver called the
putnext function), it continues to hold the lock for the calling queue
while acquiring the lock for the destination queue.  The locks are
acquired sequentially as the chain of putnext calls traverse the stream.
The locks are released in reverse order as the put procedures return.
This has the effect of incrementally locking the entire stream as messages
are passed from one module to another.

This behavior is only of interest when modules are I_PUSHed on top of a
driver.  Otherwise, it is just the stream head write queue and the driver
write queue that need to be locked (or other pairwise combinations such as
the driver read queue and stream head read queue, or queues involving
multiplexors).

The lock that LiS uses has the effect of excluding multiple entries from
different threads into the put or service procedure for a given queue.
The other queue in the queue pair is unaffected by this locking.
Therefore, if there are data structures shared between the read and write
put and service procedures of a driver or module, it is up to the driver
writer to protect these structures with spin locks.

@node Service Procedure Context
@section Service Procedure Context

Due to the manner in which service procedures are called, sometimes from
the LiS queue runner threads and sometimes from a "borrowed" system call,
service procedures may or may not have some user context present when they
run.  Service procedures should always assume that there is no user
context.  Even in the cases where there is some user context, the identity
of the user process is unpredictable.

LiS does, however, maintain a copy of the credentials of the process that
opened the stream when it calls service procedures on the stream.  LiS
saves the user and group identifiers plus the capability masks
(credentials) of the running process in the stream head structure at the
time that the STREAMS file is opened.  These identifiers are restored to
the task structure before calling a service procedure on that stream.

When calling put procedures, however, no such identity restoration occurs.
So the credentials in place when a driver or module put procedure is
invoked are those of the invoking entity.  Because the queue runner theads
always begin driver entry with a call to the service procedure, entries
into the put procedures of subsequent drivers will have the credentials of
the stream whose service procedure was called in the first instance.  When
a driver's put procedure is entered from a system call the credentials
will be that of the user process which issued the system call.

@node Scheduling Statistics
@section Scheduling Statistics

LiS gathers statistics on its queue scheduling algorithm.  They can be
printed out with the command streams -S.  The output looks like the
following.

@smallexample
N-CPUs N-Qrunners N-Running N-Requested
     2          2         0          0

CPU   Qsched-Cnts Qsched-ISR Svc-Q-Cnts Qrun-Cnts Active Thread-PID
  0     540752204  175753842  459587537 239611835      0        857
  1     540683832  175833424  459150290 239672683      0        858
@end smallexample

The fields have the following meanings.
@table @samp
@item N-CPUs
Number of CPUs on the system.

@item N-Qrunners
Number of queue runner kernel threads.  These are the processes that
appear as LiS-2.12:0 in a ps display.

@item N-Running
Number of qeuue runner threads that are currently active.

@item N-Requested
The number of queues that are in the list of scheduled queues.
@end table

@table @samp
@item CPU
The remainder of the statistics are kept on a per-CPU basis.

@item Qsched-Cnts
This is the number times the routine (lis_setqsched) that decides whether
or not to wake up a queue runner process or to directly process scheduled
queues has been called.  This routine is called whenever a queue is added
to the scheduling list.  The counter reflects which CPU made the call to
the routine.

@item Qsched-ISR
The number of times lis_setqsched was called from an interrupt routine and
from which CPU.

@item Svc-Q-Cnts
The number of callouts to service procedures on a per-CPU basis.

@item Qrun-Cnts
The number of times the routine (queurun) that removes queues from the
schedule list was called.  This routine does not return until the queue
scheduling list is empty.  It can be running on multiple CPUs
simultaneously.  It is typically called from the queue runner threads but
can also be called from an LiS system call either just prior to returning
to the user or just prior to sleeping on some event such as the arrival of
messages at the stream head.

@item Active
Displays as 0 or 1 depending upon whether there is a queue runner thread
running on the particular CPU at the time that the statistics were
sampled.

@item Thread-PID
The process id of the queue runner thread assaigned to eachCPU.
@end table



@node Other Resources
@chapter Other Resources

Information about writing STREAMS drivers and applications is available from
other sites on the Internet.  The following links may prove useful.  Keep in mind
that these links are to Unix documentation.  Therefore, these documents cover
many more kernel routines and services than appear in LiS.

@itemize @bullet
@item @uref{http://www.amazon.com/, Amazon.com}

This link goes to Amazon.com.  Search for the string "Unix streams".  From
there you can order a hard copy of the official Unix System V Release 4:
Programmer's Guide: Streams.  This is the reference for LiS STREAMS.

@item @uref{http://www.unix-systems.org/online.html, Open Group}

You will need to register (free) to view the documentation.  This is
official SVR4 documentation.  It only covers user level, not driver level
interfaces.  Once you have registered, do a search on "STREAMS".  There is
also a DLPI specification available there.

@item @uref{http://docs.sun.com/ab2/@@DSCBrowse?driver=1, Sun Solaris
Documentation}

Documentation on Sun style STREAMS drivers.  Very close to SVR4.  Ignore
information about multi-threaded drivers.  The man pages for section 9 are
especially helpful.

@item @uref{http://uw7doc.sco.com/, UnixWare 7 Documentation}

Start by scrolling the left panel down to "Hardware and Driver
Development".  Man page lookups work well, also.  Ignore information about
multi-threaded drivers and execution context.

@item @uref{http://www5.sco.com/cgi-bin/ssl_getmanpage, UnixWare 2
Documentation}

Look for "SCO UnixWare Application Server Release 2" and then select man
page section "3D".  UW7 docs are easier to browse.

@item @uref{http://www2.linuxjournal.com/lj-issues/issue61/3086.html,
Linux Journal}

Linux Journal #61, May 1999, LiS: Linux STREAMS by Fransisco Ballesteros,
Denis Froschauer, David Grothe and Graham Wheeler.  Not available online.
Gives an overview of Linux STREAMS.
@auindex Grothe, David
@auindex Froschauer, Denis
@auindex Ballesteros, Francisco J.
@auindex Wheeler, Graham

@item @uref{http://www.gcom.com/, Gcom web site}

LiS documentation is available online and can be searched using the search
engine on the home page.  A
@uref{http://www.gcom.com/home/products/why_streams.html, white paper} on the
history of STREAMS is also available.

@item @uref{http://citeseer.nj.nec.com/roca97demultiplexed.html,
Demultiplexed Architectures: A Solution for Efficient STREAMS Based
Communication Stacks (1997)}

Abstract: This paper analyzes the efficiency of various high performance
implementation techniques for the communication system of UNIX
workstations.  Using an Open System implies that a certain compatibility
level is required from the protocol, user interface, and implementation
framework.  These constraints limit the opportunities to design a high
performance communication system.  We have designed an experimental
platform around the TCP/IP protocol suite, using the STREAMS environment.
A BSD TCP/IP stack and a classic STREAMS based TCP/IP stack serve as
reference implementations for performance comparisons.  We explain why the
efficiency of some high performance implementation techniques we
applied...

@item @uref{http://www.komunikasi.org/pdf/neteng/approaches-to-improving-performance-of-streams-based-protocol-stacks.pdf,
Approaches to Improving Performance of STREAMS-Based Protocol Stacks}

New approaches to improved efficiency in STREAMS based protocol stacks.
Document in PDF format.

@item @uref{http://www.cs.wustl.edu/%7Eschmidt/PDF/JPDC-96.pdf, The
Performance of Alternative Threading Architectures for Parallel
Communication Subsystems}

Threading architectures for protocol stacks.  Document in PDF format.

@item @uref{http://citeseer.nj.nec.com/8894.html, Multiprocessor Streams
for Plan 9 (1993)}

Abstract: This paper describes an implementation of Streams for the Plan 9
kernel, a multithreaded, multiprocessor kernel with a system call
interface reminiscent of UNIX.  Rather than port Dennis Ritchie's Streams
to Plan 9, we changed the abstraction to fit more naturally into the new
environment.  The result is a mechanism that has similar performance and
is internally easier to program.

@item @uref{http://citeseer.nj.nec.com/ahlgren96integrated.html,
Integrated Layer Processing Can Be Hazardous to Your Performance (1996)}

Abstract: Integrated Layer Processing (ILP) has been presented as an
implementation technique to improve communication protocol performance by
reducing the number of memory references.  Previous research has however
not pointed out that in some circumstances ILP can significantly increase
the number of memory references, resulting in lower communication
throughput.  We explore the performance effects of applying ILP to data
manipulation functions with varying characteristics.  The functions are
generated from a set of parameters including input and output block size,
state size and number of instructions.  We present experimental data for
varying function state sizes, number of integrated functions and
instruction counts.
@end itemize



@node LiS User Commands
@chapter LiS User Commands

The Linux STREAMS (LiS) package contains some user level commands that are
used to manage the package and assist the user with STREAMS functions.

These commands are installed in @file{/usr/bin} or @file{/usr/sbin}.  They are referred
to a "global commands."
@pgindex /usr/bin
@pgindex /usr/sbin

A second group is built in the LiS installation directory and left there.
This second group is oriented more towards testing of LiS than towards its
operation.  These commands remain undocumented since they are primarily
intended for the use of the authors of the modules that they test.

These are the commands that are installed in @file{/usr/bin} or @file{/usr/sbin}, and
are thus globally accessible to any user with those directories in his/her
path.
@pgindex /usr/bin
@pgindex /usr/sbin

@menu
* fattach::				Attach a file to a stream.
* fdetach::				Detach a file from a stream.
@ignore
* ldlconfig::				Configure the Linux DL driver.
* ldltest::				Test the Linux DL driver.
@end ignore
* polltst::				Test poll.
* streams::				Control LiS.
* strmakenodes::			Make fundamental devices.
* strtst::				Test LiS.
* timetst::				Test timers.
@end menu

@page
@node fattach
@section fattach

@example
/usr/sbin/fattach [-v] [-m|-u|-M mode] [-p|STREAMS-path] path ...
/usr/sbin/fattach -?
@end example
@pgindex /usr/sbin/fattach

@unnumberedsubsec Description

The fattach program provides a command-line interface to the
underlying fattach(3) function.  If the -p and/or the -c option is
specified, a STREAMS-based pipe is created and its two ends are
alternately attached to the path names given.  In this mode of
usage, at least two path names are required, but there need not be an
even number of path names (i.e., the pipe ends need not be attached
to the same number of paths).

If the -p and -c options are not specified, the first path name given
must identify a STREAMS-based file.  That file will be opened, and it
will be attached to each of the path names subsequently specified
(of which there must be at least one).

@unnumberedsubsec Options

@table @asis
@item -p
Create a STREAMS-based pipe, to which to attach the subsequently specified
path names.  The first path will be attached to the first pipe end, the second
to the second pipe end, the third to the first pipe end, etc., until the list
of path names is exhausted.

By default, the umask (see umask(2)) is also applied to each end of the pipe
after attaching.  (See fattach(3)).

@item -c
Like -p (both may be given), but additionally pushes the connld module onto
the first end of the pipe.  This conveniently creates a free-standing
pipe-serving pipe (see connld(9), and below).

@item -m
Apply the mode of the last-specified path(s) to the attached STREAMS-based
file(s) after attaching.  (See fattach(3).

@item -u
Apply the umask (see umask(2)) of the STREAMS-based file after attaching.  (See
fattach(3)).  This is done by default when a pipe is created via -p.

@item -M @var{mode}
Apply the given @var{mode} to the STREAMS-based file(s) after attaching.
(See fattach(3)).

@item -v
Operate in a "verbose" manner.  This causes fattach to report its progress via
message output to stdout or stderr.

@item -?
Provide a usage summary.
@end table

@unnumberedsubsec Return Value

Upon successful completion, i.e., if all given path names are
attached to, fattach returns 0.  Upon failure, fattach returns 1.
However, the failure of one more attachments does not otherwise affect
those that succeed, and the user is responsible for detaching any
that may have succeeded if that is the desired behavior in the event
of any failures.

@unnumberedsubsec Application Usage

The -p and -c options provide a convenient means for creating
free-standing mounted pipes.  The openers of the paths attached via
-p will share a single pipe, while the openers of the paths attached
via -c will have access to a pipe-serving pipe.  I.e., each open
of the first end (e.g., the client end) will generate a new pipe,
one end of which will be given to the opener, and the other end of
which will be passed as if by the I_SENDFD ioctl to the path attached
to the other end (e.g., the server end).  Each opener of the server
path could poll(2) for input, receive a new pipe end using the
I_RECVFD ioctl, and then close the server path, therefter using the
new pipe end to communicate with the corresponding opener of the
client path (note that the sense of client and server will in fact
depend on the application - users of the two paths need only be aware
of whether or not an I_RECVFD ioctl must be performed).

@unnumberedsubsec See Also

connld(9), fattach(3), fdetach(3), fdetach(8), STREAMS(4), umask(2)

@unnumberedsubsec History

An fattach function has been provided for various STREAMS
implementations based on SVR4 STREAMS.  Not all of these have provided
a corresponding utility program of this sort.

@unnumberedsubsec Author

John Boyd, protologos LLC @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@page
@node fdetach
@section fdetach

@example
/usr/sbin/fdetach [-v] path ...
/usr/sbin/fdetach -a
/usr/sbin/fdetach -?
@end example
@pgindex /usr/sbin/fdetach

@unnumberedsubsec Description

The fdetach program provides a command-line interface to the
underlying fdetach(3) function.

It is thus intended to provide a convenient means to dismantle
so-called mounted STREAMS.

If the -a option is specified, all currently attached STREAMS-based
files are detached.  If the -a option is not specified, the path names
given are taken to identify paths to which STREAMS-based files are
currently attached.  Those files will be detached from these paths.

@unnumberedsubsec Options

@table @asis
@item -a
Undo all attachments currently in effect.

@item -v
Operate in a "verbose" manner.  This causes fdetach to report its progress via
message output to stdout or stderr.

@item -?
Provide a usage summary.
@end table

@unnumberedsubsec Return Value

Upon successful completion, i.e., if all given path names identify
mounted STREAMS and these are all successfully detached, fdetach
returns 0.  Upon failure, fdetach returns 1.

Note, however, that a failure indication does not mean that no action
is taken; i.e., those detachments that succeed are not affected by
those that fail.

@unnumberedsubsec Warnings

It should be noted that although the fdetach program implements the -a
option, by passing "*" to the fdetach function, this is not at all
equivalent to specifying "*" on the command line when executing the
program.  Normally, "*" specified on the command line will be
converted by a shell into a list of all files in the current working
directory.  By contrast, the -a option causes the fdetach operation
to operate not with respect to path names at all, but with respect to
STREAMS devices currently active within the STREAMS subsystem.  I.e.,
each active stream head is examined for attachments, and any
attachments found are dismantled.

The intended use for the -a option is thus to undo all attachments,
e.g., in preparation for unloading the STREAMS subsystem.

@unnumberedsubsec See Also

fdetach(3), fattach(8), STREAMS(4)

@unnumberedsubsec History

An fdetach function has been provided for various STREAMS
implementations based on SVR4 STREAMS.  Not all of these have provided
a corresponding utility program of this sort.

@unnumberedsubsec Author

John Boyd, protologos LLC @email{jaboydjr@@netwalk.com}
@auindex Boyd, John


@ignore
@page
@node ldlconfig
@section ldlconfig

@example
/usr/sbin/ldlconfig Options
/usr/sbin/ldlconfig -h
@end example
@pgindex /usr/sbin/ldlconfig

@unnumberedsubsec Description

@dfn{ldlconfig()} is used to configure the ldl STREAMS driver as a client of a
standard Linux network driver.  Once configured other STREAMS drivers
can be pushed or I_LINKed on top of the ldl driver, thus giving
STREAMS drivers access to Linux network drivers.

@unnumberedsubsec Options

@table @asis
@item -a @var{name}
The name of the network driver interface to attach.  For example, "-aeth0"
attaches to the eth0 network driver.

@item -b @var{sap}
The SAP to bind.  The interpretation of the SAP depends upon the mode (-p) and
framing (-F) being used.

@item -d @var{filed}
Instead of opening @file{/dev/ldl}, use the given file descriptor number.  This
allows an external program to open @file{/dev/ldl}, use @dfn{ldlconfig()} to configure the
STREAM, and then continue to use the open file descriptor for further
operations.
@pgindex /dev/ldl

@item -f @var{flag}
Flag to set with ioctl.  Mnemonic values for flag are PEDANTIC_STANDARD and
RAW.

@item -F @var{framing}
The type of framing to use in interactions with the network driver.  Mnemonic
values for framing are EII, 802.2, SNAP, 802.3 and RAWLLC.

@item -h
Print a command usage synopsis.

@item -p @var{mode}
Set promiscuous mode.  Mnemonic values for mode are PHYS, SAP or MULTI.

@item -v @var{mask}
Set verbose mask.
@end table

@unnumberedsubsec Operation

@dfn{ldlconfig()} opens the clone device @file{/dev/ldl}, or accepts a file
descriptor to a file already opened to that device.  It performs a
DLPI Attach Request based upon the -a parameter.  This attaches the
file to a Linux network device.
@pgindex /dev/ldl

It then sets operational options based upon the -f and -p options, if
any were specified.

If the -b option is specified it also performs a DLPI Bind Request on
the stream.

The resulting stream connects to the ldl driver which acts as a DLPI
Provider and translates between the DLPI STREAMS protocol from above
to the Linux network driver interface below.  The effect is to present
a DLPI interface to a Linux network driver.

The type of network driver (Ethernet, Token Ring, FDDI, HDLC) is
compared with the requested framing type (is option) and RAW flag (is
option).  If the given driver does not support the requested framing
type then the @dfn{ldlconfig()} command will fail.  All drivers support the
RAW frame interface.

Depending upon the driver type and framing type, the ldl driver will
set up to decode incoming "frames" according to the framing type.
This has an effect on where the driver looks in the incoming "frame"
to find the SAP to match against the requested SAP in the DLPI Bind
Request to ldl (-b option).  The framing type of RAWLLC generally
means that the entire frame is passed upstream.  This allows the
upstream client driver to interpret the LLC information within the
frame.

@vrindex DL_UNITDATA_IND
Frame types other than RAWLLC generally mean that the LLC header will
be stripped from received frames passing just the payload portion to
the upstream client.  The received frame is passed upstream in a
@code{DL_UNITDATA_IND} @code{M_PROTO} message and the address carried by this frame
will be set to the source MAC address from the frame header.
@vrindex M_PROTO

In the transmit direction, a frame type of RAWLLC means that the
formatting of the frame to be sent to the medium is under the control
of the upstream client.

For other types of framing, the ldl driver will build the LLC header
according to the framing type.  The address in the @code{DL_UNITDATA_REQ} is
used to develop the destination MAC address.

For any given frame type and driver type, it is often necessary to
consult the driver source code in order to understand the fine details
of the frame processing involved.

@unnumberedsubsec Return Value

@dfn{ldlconfig()} returns 0 upon success and 1 if any indicated operation
failed.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole

@page
@node ldltest
@section ldltest

@example
/usr/sbin/ldltest Options Driver Local-IP
@end example
@pgindex /usr/sbin/ldltest

@unnumberedsubsec Description

ldltest is used to test the ldl STREAMS driver by using one of the
existing standard Linux network drivers to send a "ping" to another
host on the network.  The command line parameters specify the local-IP
and remote-IP addresses and the name of the Driver to use when sending
the ping.

ldltest is also used to obtain statistics from the ldl STREAMS driver
and to set debugging masks.

@unnumberedsubsec Options

@table @asis
@item -a
Respond to received ARP queries.

@item -s
Respond to received pings.  Also enables LLC TEST/XID echo mode.

@item -S @var{dsap:ssap}
Set the DSAP and SSAP to use when sending an LLC TEST or XID.

@item -r @var{remote-IP}
The remote IP address to which the ping is to be directed.

@item -R @var{remote-MAC}
The remote MAC address for sending LLC TEST/XID frames.

@item -c @var{packet-cnt}
The number of ping packets to send.  Default is 1.

@item -v @var{number}
Set verbosity level.

@item -f @var{framing}
Set framing style to EII (default), RAW or SNAP.

@item -d @var{mask}
Set debug mask for the ldl driver to mask.

@item -H
Print out the values for the debug mask bits.

@item -g
Print out global statistics obtained from the ldl driver.

@item -T
Send LLC TEST command.

@item -X
Send LLC XID command
@end table

@unnumberedsubsec Operation

In test mode, ldltest constructs a ping packet from the parameters
given and sends it to the remote host.  It awaits the response and
prints out the round trip time when it receives the response.  If the
-c option is used it sends the ping repeatedly and prints out the
round-trip time every 1,000 packets.

With the -s (lower case) option, ldltest listens for received frames
from the indicated interface driver.  If the framing is specified as
RAW then it will receive LLC frames from the driver.  Other types of
framing result in non-LLC Ethernet types of frames such as IP packets
and ARP messages.  Thus, the setting of the -f option conditions the
type of messages that can be received from the interface.  When an ICMP
ping is received, it is responded to.  When an LLC TEST or XID command
is received it is responded to with the corresponding response frame.

With the -g option, ldltest obtains statistics maintained by the ldl
driver and prints them out.  This is useful for troubleshooting
protocol stack configuration since you can see whether packets
entering ldl from either above or below was forwarded to the
neighboring module.

By setting debug bits via the -d option, you can cause the ldl driver
to print the contents of packets flowing into it and out of it.

@unnumberedsubsec Examples

ldltest -r 192.168.1.1 eth0 192.168.1.117

Sends a ping to 192.168.1.1.  The local host address is
192.168.1.117 (obtainable from the ifconfig command).

ldltest -S 0x00:0x0C -T -R 00:00:C0:D7:54:F8 eth0

Sends an LLC TEST command to the remote system with Ethernet
address 00:00:C0:D7:54:F8, DSAP 0x00 and SSAP 0x0C.  Await the
response.

ldltest -s -f RAW eth0 192.168.1.47

Listens for RAW LLC frames addressed to the local machine whose IP
address is 192.168.1.47.  Send responses to TEST and XID commands.

ldltest -d 0x0f

Sets the debug mask in the ldl driver.

ldltest -H

Prints the values assigned to the debug mask bits as follows:

0x00000001 dump raw frame from net driver

0x00000002 dump UNITDATA_IND upstream

0x00000004 dump UNITDATA_REQ downstream

0x00000008 dump Tx to net driver

0x00000010 dump full buffer, not just header

@vrindex DL_ATTACH
0x00000020 debug info for @code{DL_ATTACH}

@vrindex DL_BIND
0x00000040 debug info for @code{DL_BIND}

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@end ignore

@page
@node polltst
@section polltst

@example
/usr/bin/polltst
@end example
@pgindex /usr/bin/polltst

@unnumberedsubsec Description

polltst is a simple test program for the poll system call.  Using
poll, it reads keystrokes from stdin, writes them to one end of the
LiS loopback driver, reads them from the other end and then writes
them back to stdout.

While performing this operation it configures stdin for "no echo"
mode, so the appearance of "echoed" characters is evidence of the
operation of poll involving both a STREAMS and a non-STREAMS file.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node streams
@section streams

@example
/usr/sbin/streams Options
@end example
@pgindex /usr/sbin/streams

@unnumberedsubsec Description

The streams program is used to perform several different management
functions for the LiS package, including starting and stopping the LiS
subsystem.

@unnumberedsubsec Options

@table @asis
@item @samp{start}
Start the LiS subsystem.  This amounts to performing the command "modprobe
streams".

@item @samp{stop}
Stop the LiS subsystem.  This amounts to performing the command "modprobe -r
streams".

@item @samp{status}
Reports on the status of the LiS subsystem.

@item -c @var{Kbytes}
Print or set the maximum message memory usage for LiS.  The value 0 (default)
means unlimited.

@item -C @var{Kbytes}
Print or set the maximum total memory usage for LiS.  The value 0 (default)
means unlimited.

@item -d @var{mask}
Set the debug mask for LiS.  See below for details.

@item -D @var{mask}
Set an additional debug mask for LiS.  See below for details.

@item -s
Print STREAMS memory usage statistics.

@item -L
Print out lock contention statistics.  Use debug bit
@code{DEBUG_LOCK_CONTENTION} to enable the lock contention statistics gathering.

@item -m
Print STREAMS memory allocation to the system messages file (from kernel).
This option should be used only for debugging and only when LiS is in a
quiescent state.  Unpredictable results can occur if this option is used while
LiS memory allocations are changing dynamically.

@item -p
Print the LiS lock trace buffer to the system messages file (from kernel).
Used in conjunction with the @code{DEBUG_SPL_TRACE} debug option.

@item -q
Print all STREAMS queues to the system messages file (from kernel).  This
option should be used only for debugging and only when LiS is in a quiescent
state.  Unpredictable results can occur if this option is used while LiS queue
allocations are changing dynamically.

@item -S
Print out STREAMS queue-runner thread statistics.

@item -t
Print STREAMS timing statistics.  Used inconjunction with the
@code{DEBUG_MEAS_TIME} debug option.

@item -T
Print the LiS semaphore latency histogram.  Use debug bit @code{DEBUG_SEMTIME}
to enable the statistics collection.

@item -h
Print a command synopsis.

@item -H
Print a command synopsis including the debug mask mnemonics.
@end table

@unnumberedsubsubsec Debug Options

The value that is used with the -d option consists of the logical "or" of the
following single bit options.

@table @asis
@item -d @var{Options}
@smallexample
DEBUG_OPEN             0x00000001
DEBUG_CLOSE            0x00000002
DEBUG_READ             0x00000004
DEBUG_WRITE            0x00000008
DEBUG_IOCTL            0x00000010
DEBUG_PUTNEXT          0x00000020
DEBUG_STRRPUT          0x00000040
DEBUG_SIG              0x00000080
DEBUG_PUTMSG           0x00000100
DEBUG_GETMSG           0x00000200
DEBUG_POLL             0x00000400
DEBUG_LINK             0x00000800
DEBUG_MEAS_TIME        0x00001000
DEBUG_MEM_LEAK         0x00002000
DEBUG_FLUSH            0x00004000
DEBUG_FATTACH          0x00008000
DEBUG_SAFE             0x00010000
DEBUG_TRCE_MSG         0x00020000
DEBUG_CLEAN_MSG        0x00040000
DEBUG_SPL_TRACE        0x00080000
DEBUG_MP_ALLOC         0x00100000
DEBUG_MP_FREEMSG       0x00200000
DEBUG_MALLOC           0x00400000
DEBUG_MONITOR_MEM      0x00800000
DEBUG_DMP_QUEUE        0x01000000
DEBUG_DMP_MBLK         0x02000000
DEBUG_DMP_DBLK         0x04000000
DEBUG_DMP_STRHD        0x08000000
DEBUG_ADDRS            0x80000000
@end smallexample

@item -D @var{Options}
@smallexample
DEBUG_SNDFD            0x00000001
DEBUG_CP	       0x00000002
DEBUG_CACHE	       0x00000004
DEBUG_LOCK_CONTENTION  0x00000008
DEBUG_REFCNTS          0x00000010
DEBUG_SEMTIME          0x00000020
@end smallexample
@end table

Most of these options are intuitive as to their operation from the mnemonics.

The @code{DEBUG_MEAS_TIME} option causes LiS to use a high precision timer to
calculate the execution time of several operations within itself.  These
timings include the time spent in STREAMS drivers.  Thus, under controlled
circumstances this option can be used to time STREAMS driver code.  It is used
in conjunction with the -t option to print out the timing statistics.

The @code{DEBUG_SAFE} option causes LiS to carefully check for NULL pointers
when performing message passing and queueing operations such as putq and
putnext.

The @code{DEBUG_CLEAN_MSG} option causes LiS to clear message data buffers to
zero when they are allocated.  It is useful for tracking down driver problems
relating to using uninitialized areas of messages.

The @code{DEBUG_SPL_TRACE} option causes LiS to maintain a trace table of all
LiS locking operations.  It is used in conjunction with the -p option to print
out the lock trace table.  The locking operations that are traced include calls
on the LiS locking primitives from STREAMS drivers.

The options @code{DEBUG_DMP_QUEUE}, @code{DEBUG_DMP_MBLK} and
@code{DEBUG_DMP_DBLK} control the verbosity of the printing out of LiS memory
areas via the -m option.  With these debug mask bits set, LiS will print out
the contents of these structures as well as the headers indicating that such a
structure was allocated.

The @code{DEBUG_ADDRS} option causes the -m option to print out the addresses
of structures as well as their memory tags and/or contents.

The @code{DEBUG_MONITOR_MEM} option causes LiS to monitor the guard words
surrounding allocated memory areas in an attempt to catch overwriting of these
words in a timely fashion.  This option comes at a fairly substantial CPU time
penalty.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node strmakenodes
@section strmakenodes

@example
/usr/sbin/strmakenodes
@end example
@pgindex /usr/sbin/strmakenodes

@unnumberedsubsec Description

strmakenodes makes all of the @file{/dev} entries that are associated with
LiS as a result of the LiS build process.  All of the @file{Config} files
that contributed to the LiS build are scanned for their "node"
declarations.  strmakenodes performs a mknod system call for each
specified "node".
@pgindex /dev
@pgindex Config

This command must be run before LiS can operate correctly after it is
installed.  This command is run automatically as a result of the "make
install" operation of LiS.

This command accepts the option "-r" to mean remove nodes instead of
making them.  The command is run with this option as a result of the
"make uninstall" operation.

The source code for this command is generated automatically as a
side-effect of running the strconf utility.

@page
@node strtst
@section strtst

@example
/usr/bin/strtst
@end example
@pgindex /usr/bin/strtst

@unnumberedsubsec Description

strtst is a test program which tests the core functionality of LiS.
It is a user level program which uses the built-in drivers that are
installed by default with LiS.  It performs numerous STREAMS
operations and checks the results for correctness.  It prints out a
voluminous log file whose output is routed to the "messages" file
(kernel informational messages).

The output of strtst can be compared to earlier "reference" outputs to
see if the behavior of LiS has changed as a result of modifications to
the code.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node timetst
@section timetst

@example
/usr/bin/timetst [Iterations]
@end example
@pgindex /usr/bin/timetst

@unnumberedsubsec Description

timetst peforms a timing test using the LiS loopback driver.  It
writes short messages downstream under several different LiS options
and measures the round trip time for the messages.  The Iterations
parameter specified the number of iterations that timetst uses in its
timing loop, the default being 100,000.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David



@page
@node LiS Driver/Kernel Interface
@chapter LiS Driver/Kernel Interface

Linux STREAMS (LiS) provides for an interface between STREAMS drivers and
the surrounding kernel environment.  This interface has grown over time
and is likely to expand in the future.

In the Linux kernel, much of the interface between drivers and other
kernel modules and the core kernel services, such as memory allocation and
synchronization primitives, is implemented in macros and inline functions
declared in kernel header files.  This technique was used (probably) out
of considerations of efficiency (defined as execution speed) and a
consideration that there were no version problems with such constructs
because one could always recompile one's drivers in the context of the new
kernel.  The only "kernel primitives" compatibility that has been
attempted from one kernel release to the next is source code
compatibility.

The real world of paying customers is quite different.  And, as it
happens, the world of paying customers seems to impinge upon LiS
considerably.

In this world, the customers do not want to rebuild the kernel.  They
don't want to build the kernel at all.  They want to install a
distribution with a binary kernel that was configured only at install
time.  They then want to install add-on binary packages, and they expect
these packages to operate correctly with their kernel.

When these add-on packages consist of STREAMS based protocol drivers, LiS
is usually the only piece of code that is recompiled from source upon
installation into the customer's environment.  The STREAMS drivers
themselves are typically distributed in binary and linked in with LiS.
The resulting module is then typically loaded using "modprobe" or some
equivalent command.

In these circumstances it is highly desirable for LiS to "buffer" the
interface between the STREAMS drivers and the kernel environment.  This
allows the STREAMS driver writers to deliver smaller binary packages to
their customers and minimizes the number of different versions of those
packages that must be maintained by the STREAMS driver writers.  Ideally,
LiS would be able to present a uniform DKI that would support one version
of a user's STREAMS driver across all versions of the Linux kernel.

This ultimate goal is probably not achievable, but it is possible to
insulate STREAMS drivers from the Linux kernel to a considerable extent.
This is possible in part due to the implied DKI of a STREAMS driver.  A
STREAMS driver most likely will confine itself to the SVR4 types of DKI
calls which have syntax and semantics that do not change over time.  The
main challenges come from the use of constructs, such as PCI configuration
and interrupt service routines, that go outside the SVR4 DKI and must use
services of the Linux kernel more-or-less directly.

In general, LiS attempts to replace inline functions and macros with
actual subroutine calls to perform kernel operations.  This allows the
STREAMS driver to be compiled once with references to these routines, with
the routines themselves being compiled in the context of the specific
kernel version at package installation time.  Thus, the STREAMS drivers do
not have to be sensitive to differences in kernel versions.


@menu
* Operating System Interface::		OS interface functions.
* PCI BIOS Interface::			PCI BIOS interface functions.
* PCI Interface::			PCI interface functions.
* IRQ Interface::			IRQ interface functions.
* I/O Memory Mapping::			I/O memory mapping functions.
* I/O Port Access::			I/O port access functions.
* Memory Allocation::			Memory allocation functions.
* DMA Routines::			DMA functions.
* Delay Routines::			Delay functions.
* Printing Routines::			Printing functions.
* Timer Routines::			Timer functions.
* Sleep and Wakeup Routines::		Sleep and wakeup functions.
* Thread Creation::			Thread creation functions.
* Major/Minor Device Numbering::	Device numbering functions.
* LiS Memory Allocation::		LiS memory allocation.
* LiS malloc and free Equivalents::	LiS memory allocation.
* LiS Kernel Memory Allocators::	LiS memory allocation.
* LiS Page Allocator::			LiS memory allocation.
* LiS PCI Interface::			LiS PCI interface.
* The LiS PCI Device Structure::	LiS PCI interface.
* LiS PCI Search Routines::		LiS PCI interface.
* LiS PCI Configuration Space Routines:: LiS PCI interface.
* LiS PCI DMA Routines::		LiS PCI interface.
* LiS Atomic Functions::		LiS atomic functions.
* LiS Locks::				LiS locking functions.
* LiS Spin Locks::			LiS locking functions.
* Lock Nesting::			LiS locking functions.
* LiS Read/Write Locks::		LiS locking functions.
* LiS Interrupt Enable/Disable::	LiS interrupt functions.
* LiS Semaphores::			LiS semaphores.
* Debugging Spin Locks::		Debugging locks.
* Lock Semaphore and Queue Contention::	Lock contention.
* Debugging Semaphores::		Debugging sempahores.
* STREAMS Utility Routines::		STREAMS utility functions.
* Flushing Queue Bands::		Flushing queues.
* Freezing Streams::			Freezing streams.
* Utility Prototypes::			STREAMS utility prototypes.
* System Calls from within the Kernel::	Linux system calls.
@end menu

@node Operating System Interface
@section Operating System Interface Routines

In the file <sys/osif.h>, LiS provides insulation routines for a number of
commonly used kernel functions.  These functions are used with their Linux kernel
names, but those names are redefined in <sys/osif.h> to be subroutine calls on
functions that are actually defined in the file osif.c within LiS.  The osif.c
file is compiled at LiS installation time and is sensitive to kernel version
information.

In order to use this interface, you include the header files that you would
normally include to use the kernel functions, and then include <sys/osif.h>
after all of the kernel include files.  This allows for the redefinition of the
names.

The kernel functions provided via <sys/osif.h> are as follows, grouped by type
of function.

@node PCI BIOS Interface
@section PCI BIOS Interface

These are routines that utilize or simulate the original PCI BIOS interface of
the 2.0 series of kernels.  The names of these routines are changed via defines.
Use them as if the prototypes were as follows.  You can use these routines on 2.2
kernels even though they represent the 2.0 style of inteface.

@smallexample
#if LINUX_VERSION_CODE < 0x020100       /* 2.0 kernel */
unsigned long pcibios_init(unsigned long memory_start,
                           unsigned long memory_end);
#else   /* 2.1 or 2.2 kernel * /
void pcibios_init(void) ;
#endif
int pcibios_find_class(unsigned int class_code, unsigned short index,
                       unsigned char *bus, unsigned char *dev_fn);
int pcibios_find_device(unsigned short vendor, unsigned short dev_id,
                        unsigned short index, unsigned char *bus,
                        unsigned char *dev_fn);
int pcibios_read_config_byte(unsigned char bus, unsigned char dev_fn,
                             unsigned char where, unsigned char *val);
int pcibios_read_config_word(unsigned char bus, unsigned char dev_fn,
                             unsigned char where, unsigned short *val);
int pcibios_read_config_dword(unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned int *val);
int pcibios_write_config_byte(unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned char val);
int pcibios_write_config_word(unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned short val);
int pcibios_write_config_dword(unsigned char bus, unsigned char dev_fn,
                               unsigned char where, unsigned int val);
const char *pcibios_strerror(int error) ;
@end smallexample

@node PCI Interface
@section PCI Interface

These routines constitute the PCI interface as implemented in the 2.2 series of
kernels.  Please note that these are filtered calls to the operating system and
still depend directly upon the kernel structure "struct pci_dev".  LiS provides a
more abstract interface to PCI that does not depend upon the direct definition
kernel structures.  The [61]LiS PCI interface is to be preferred since it
provides more insulation against changes in the kernel.
@tpindex struct pci_dev

@smallexample
struct pci_dev *pci_find_device(unsigned int vendor, unsigned int device,
                                struct pci_dev *from);
struct pci_dev *pci_find_class(unsigned int class, struct pci_dev *from);
struct pci_dev *pci_find_slot(unsigned int bus, unsigned int devfn);
int pci_read_config_byte(struct pci_dev *dev, u8 where, u8 * val);
int pci_read_config_word(struct pci_dev *dev, u8 where, u16 * val);
int pci_read_config_dword(struct pci_dev *dev, u8 where, u32 * val);
int pci_write_config_byte(struct pci_dev *dev, u8 where, u8 val);
int pci_write_config_word(struct pci_dev *dev, u8 where, u16 val);
int pci_write_config_dword(struct pci_dev *dev, u8 where, u32 val);
void pci_set_master(struct pci_dev *dev);
@end smallexample

@node IRQ Interface
@section IRQ Interface

These are the routines that are used to attach and detach interrupt service
routines to hardware interrupts.

@smallexample
int request_irq(unsigned int irq,
void (*handler) ((int, void *, void *), unsigned long flags, const char *device,
                 void *dev_id);
void free_irq(unsigned int irq, void *dev_id);
void disable_irq(unsigned int irq);
void enable_irq(unsigned int irq);
@end smallexample

@node I/O Memory Mapping
@section I/O Memory Mapping

These are the routines that are typically used to map PCI bus or physical
addresses to CPU virtual addresses.  LiS includes some backward compatibility
here to older kernel versions.

@smallexample
void *ioremap_nocache(unsigned long offset, unsigned long size);
void iounmap(void *addr);
void *vremap(unsigned long offset, unsigned long size);
unsigned long virt_to_phys(volatile void *addr);
void *phys_to_virt(unsigned long addr);
@end smallexample

@node I/O Port Access
@section I/O Port Access

These are the routines that allow a driver to register I/O ports.

@smallexample
int check_region(unsigned int from, unsigned int extent);
void request_region(unsigned int from, unsigned int extent, const char *name);
void release_region(unsigned int from, unsigned int extent);
@end smallexample

@node Memory Allocation
@section Memory Allocation

These are the kernel routines that can be used to allocate memory.  LiS also has
a more insulated abstraction for kernel memory allocation.  It is recommended
that you use the [66]LiS memory allocator versions rather than the direct kernel
versions.

@smallexample
void *kmalloc(size_t nbytes, int type);
void kfree(const void *ptr);
void *vmalloc(unsigned long size);
void vfree(void *ptr);
@end smallexample

@node DMA Routines
@section DMA Routines

These are the routines that are used to allocate a main-board old-style DMA
channel for use by your driver.  These are not much used anymore.
See below for a more elaborate abstraction of DMA routines.

@smallexample
int request_dma(unsigned int dma_nr, const char *device_id);
void free_dma(unsigned int dma_nr);
@end smallexample

@node Delay Routines
@section Delay Routines

This is the routine that simply spins the CPU for a given number of
microseconds.  LiS also redefines the symbol "jiffies" to a subroutine call to
help insulate STREAMS drivers from changes in the way the kernel keeps track of
time.  Remember, the redefinition is accomplished using C language defines, so
the following declarations describe the effective usage of these symbols, not
their literal definition.

@smallexample
void udelay(long micro_secs);
unsigned long jiffies;
@end smallexample

@node Printing Routines
@section Printing Routines

These are the most commonly used printf-like routines in the kernel.  STREAMS
drivers would be more portable if they used the cmn_err routine instead of
printk.

@smallexample
int printk(const char *fmt, ...);
int sprintf(char *bfr, const char *fmt, ...);
int vsprintf(char *bfr, const char *fmt, va_list args);
@end smallexample

@node Timer Routines
@section Timer Routines

These are the the routines that start and stop kernel timers.  STREAMS drivers
would be more portable if they used the standard "[71]timeout" routine.

@smallexample
void add_timer(struct timer_list *timer);
int del_timer(struct timer_list *timer);
@end smallexample
@tpindex struct timer_list

The following routine converts time in micro seconds to system "ticks".  The
"ticks" value is suitable for use with the timeout routine.  Note that if the
micro_sec parameter is less than the number of micro seconds in a system tick
then the routine returns zero.

@smallexample
unsigned lis_usectohz(unsigned micro_sec);
@end smallexample

The following routine is an LiS abstraction of the C library routine
gettimeofday.  Note the absence of the time zone parameter.

@smallexample
void lis_gettimeofday(struct timeval *tv);
@end smallexample
@tpindex struct timeval

The following two kernel routines are called via the LiS osif.c code.

@smallexample
void do_gettimeofday(struct timeval *tp);
void do_settimeofday(struct timeval *tp);
@end smallexample
@tpindex struct timeval

@node Sleep and Wakeup Routines
@section Sleep and Wakeup Routines

These are the kernel routines for sleeping using wait queues.  STREAMS drivers
should not be using these since only "open" and "close" routines are allowed to
sleep, and for those cases, [73]LiS semaphores would provide better insulation
from the kernel.  STREAMS "put" and "service" routines should use [74]LiS spin
locks for mutual exclusion.

@smallexample
void sleep_on(OSIF_WAIT_Q_ARG);
void interruptible_sleep_on(OSIF_WAIT_Q_ARG);
void wake_up(OSIF_WAIT_Q_ARG);
void wake_up_interruptible(OSIF_WAIT_Q_ARG);
@end smallexample

@node Thread Creation
@section Thread Creation

A STREAMS driver in LiS can create kernel threads if it so chooses.  The
following routine simplifies this task.  It consolidates all of the kernel
manipulations involved with the creation of a kernel thread into one place, thus
removing references to these kernel functions from STREAMS driver code.

@subsection Prototype

@smallexample
pid_t lis_thread_start(int (*fcn) (void *), void *arg, const char *name);
int lis_thread_stop(pid_t pid);
@end smallexample

Arguments

fcn

The function that is to be used as the entry point for the thread.

arg

The argument passed to the function.

name

An ASCII name associated with the thread.  This name should be less than 16
characters in length.  It will be the name of the thread that displays in a ps
listing.

@subsection Operation

lis_thread_start creates a new thread, performs some operations prior to
entering the fcn, and then calls fcn which acts as the "main" routine for the
thread.  The arg parameter is passed to fcn.

Before fcn is entered, the newly created thread will have shed all user space
files and mapped memory.  Thus, it is a kernel-only thread.

All signals are still enabled.  Note that when the kernel goes down for reboot
all processes are first sent a SIGTERM.  Once those have been processed, all
processes are then sent a SIGKILL.  It is the implementor's choice which of these
it pays attention to in order to exit prior to a reboot.

The fcn is entered with the "big kernel lock" NOT held, just as it would be for
calling the "kernel_thread" function directly.  On 2.2 kernels, the fcn should
get this lock so that it can utilize kernel services safely.

The user's fcn returns a value when it exits and that value is returned to the
kernel.  It is not clear that anything actually pays any attention to this
returned value.  It particular, it is not visible to the thread that started the
new thread.

lis_thread_start itself returns the process id of the new thread, or a negative
error number.  This value can be used to kill the thread.

lis_thread_stop kills a thread started by lis_thread_start.  It returns 0 for
success or a negative error number for failure.

@node Major/Minor Device Numbering
@section Major/Minor Device Numbering

Please note that LiS-2.17 changed the internal representation of the major and
minor device numbers within the 32 bit @code{dev_t} structure.  The following
documents the new format and usage conventions.
@tpindex dev_t

In STREAMS the dev_t structure is used to combine a major device number and a
minor device number into a single integer length quantity.  The Linux kernel
restricts these numbers to the range 0 to 255 (8-bit values).

@tpindex dev_t
LiS provides a typedef for @code{dev_t} that results in an unsigned integer
quantity.  Internal to LiS the high order 12 bits are used for major device
number and the low order 20 bits are used for minor device number.

@ignore
The Linux kernel, on the other hand, defines a structure of type kdev_t that it
uses internally for this same purpose.  The kdev_t type is an actual structure,
and not an integer.  Furthermore, the kernel defines a routine named makedevice
that generates one of these structures, given the major and minor numbers as
integers.  It appears that eventually the kernel will use this structure
exclusively and will expand the numbering space for both major and minor device
numbers.

This has caused LiS to use non-standard nomenclature for handling its dev_t
structures, since the routine makedevice is not compatible with the LiS dev_t
structure.

LiS now provides the following operations on dev_t structures.  Most of these
functions are provided by macros, so the following are "virtual" prototypes.

@table @code
@findex MAJOR
@item int MAJOR(dev_t dev);
Extracts the major device number

@findex MINOR
@item int MINOR(dev_t dev);
Extracts the minor device number

@findex MKDEV
@item dev_t MKDEV(int maj, int min);
Combines a major and minor device number into a dev_t

@findex DEV_SAME
@item int DEV_SAME(dev_t d1, dev_t d2);
True if the two devices are the same

@findex DEV_TO_INT
@item int DEV_TO_INT(dev_t dev);
Converts dev_t to an int
@end table
@end ignore

STREAMS drivers include the file @file{<sys/stream.h>} that causes the view of
@code{dev_t}
@tpindex dev_t
to change from the kernel's 8/8 view to the LiS 12/20 view.  To ensure proper
operation, STREAMS drivers should use the following functions to manipulate
@code{dev_t} variables.  These functions are SVR4 compatible.

@table @code
@findex getmajor
@item int getmajor(dev_t dev);
Extracts the major device number

@findex getminor
@item int getminor(dev_t dev);
Extracts the minor device number

@findex makedevice
@item dev_t makedevice(int maj, int min);
Combines a major and minor device number into a dev_t

@findex DEV_SAME
@item int DEV_SAME(dev_t d1, dev_t d2);
True if the two devices are the same

@findex DEV_TO_INT
@item int DEV_TO_INT(dev_t dev);
Converts dev_t to an int
@end table

The sample drivers that come with LiS now use these constructs to manipulate
device structures and can serve as examples for their usage.

Within a STREAMS driver it is occasionally necessary to make a @code{dev_t}
@tpindex dev_t
value in the external 8/8 format.  This is required, for example, when a driver
is using the @command{lis_mknod()}
@findex lis_mknode
function to create a device node at driver initialization time.  LiS provides
the function @command{UMKDEV(major, minor)} for this purpose.
@findex UMKDEV

@node LiS Memory Allocation
@section LiS Memory Allocation

LiS provides for several different styles of memory allocation, all of them
insulated from the Linux kernel.  These routines allow your driver to allocate
memory in several different ways while still maintaining compatibility with
different versions of the Linux kernel, with no driver recompilation required.

To use the LiS memory allocation routines include the file <sys/lismem.h> in
your STREAMS driver source code.

@node LiS malloc and free Equivalents
@section LiS malloc and free Equivalents

The first group of memory allocation routines are the routines that play the
role of "malloc" and "free." These routines keep a master linked list of all
allocated memory areas.  This list can be printed out via an ioctl to LiS.  Each
allocated area is tagged with the file name and line number of the code that
caused it to be allocated.  Each area contains a guard word at the front and back
to enable the allocator to detect "off by one" accesses outside the allocated
area.

LiS uses this allocator internally for allocating queues, messages and other
internal data structures.  This would be the allocator of choice for STREAMS
drivers to use to allocate instance structures.

Memory allocated in this manner is ultimately allocated by the kernel routine
"kmalloc".  As such, it is not guaranteed to be DMA-able (in the old style), or
to occupy physically contiguous memory locations.  [78]See below for routines
that can be used to allocate these types of memory areas.

The routines are as follows:

@example
void *ALLOC(int nbytes);
void *ALLOCF(int nbytes, char *tag);
void FREE(void *ptr);
@end example

The ALLOC and FREE routines are analogous to "malloc" and "free".  The ALLOCF
routine includes a character string which is prepended to the file name stored
as the location from which the allocation occurred.  It can serve as a tag for
the type of memory being allocated.

Usage examples:

@example
ptr = ALLOC(456);
FREE(ptr);
ptr = ALLOCF(578, "Instance: ");
FREE(ptr);
@end example

@node LiS Kernel Memory Allocators
@section LiS Kernel Memory Allocators

These routines use the LiS malloc/free internal routines to allow for more
flexibility in the options used when calling the kernel allocator.  These
routines all lead to a call on "kmalloc" with appropriate options.  It is worth
noting that the numerical value of the constants used in calling the kernel's
"kmalloc" routine changed between the 2.2 and 2.4 versions of the kernel.  Thus,
drivers which called the kernel's "kmalloc" directly have to be recompiled to
run in a 2.4 kernel.  STREAMS drivers using the memory allocation interface
defined here could run without modification and without a recompilation on both
kernels, assuming that the drivers otherwise did not use any direct kernel
functions.

@example
void *lis_alloc_atomic(int nbytes);
void *lis_alloc_kernel(int nbytes);
void *lis_alloc_dma(int nbytes);
void *lis_free_mem(void *mem_area);
@end example

These routines pass the allocation options GFP_ATOMIC, GFP_KERNEL, and GFP_DMA,
respectively, to "kmalloc" when allocating the memory.  LiS takes care of passing
the proper values to the kernel routine so that driver code can remain portable.

The routine lis_free_mem returns a NULL pointer for the convenience of the
caller.

The kernel's kmalloc is restricted as to the number of bytes that it will
allocate.  The LiS routines do not have this restriction.  If the number of
requested bytes is larger than 16K the LiS allocation routines will call the
page allocator to allocate the memory.  The lis_free_mem routine knows whether to
free pages or to use the kernel's kfree routine.

Usage Examples:

@example
ptr = lis_alloc_kernel(sizeof(structure));
ptr = lis_free_mem(ptr);        /* returns NULL pointer */
@end example

@node LiS Page Allocator
@section LiS Page Allocator

These routines allow a STREAMS driver to allocate memory directly from the
kernel's page allocator.  Memory allocated in this manner occupies physically
contiguous locations and is suitable for use with bus master DMA PCI devices.

Unlike the kernel's page allocator, the size that is specified when calling the
LiS page allocator is in bytes, not "order", or other encoding of page size.  LiS
calculates the number of pages based upon the requested size.

Also, LiS does not require you to pass the size of the area when freeing the
page.

The routines are as follows:

@example
void *lis_get_free_pages(int nbytes);
void *lis_free_pages(void *ptr);
@end example

The lis_free_pages routine returns a NULL pointer for the convenience of the
caller.

Usage Examples:

@example
ptr = lis_get_free_pages(1024 * kbytes);
ptr = lis_free_pages(ptr);
@end example

@node LiS PCI Interface
@section LiS PCI Interface

In order to assist in the portability of STREAMS drivers across different
versions of the Linux kernel, LiS provides an abstraction of the PCI
configuration interface.  It defines a data structure that is used to describe a
PCI device and a set of routines that perform operations on PCI configuration
space.

Using these abstractions, a STREAMS driver can be portable from the 2.2 kernel
to the 2.4 kernel with no recompilation required.  The LiS structures completely
hide the kernel data structures and PCI configuration space operations from the
STREAMS driver.

To use this interface include the file <sys/lispci.h> in your STREAMS driver
source code.

@node The LiS PCI Device Structure
@section The LiS PCI Device Structure

This structure is distinct from a similar structure which is defined by the
Linux kernel, but which differs significantly between the 2.2 and 2.4 kernels.
The LiS version of this structure is oriented towards providing just enough
information to allow a driver to operate the PCI device, without being concerned
about the details of PCI bus topology.

This structure is used to return information to the STREAMS driver concerning
devices that meet certain criteria, such as device class or manufacturer devide
identification.

@smallexample
#define LIS_PCI_MEM_CNT 12      /* # mem addrs */
typedef struct lis_pci_dev @{
        unsigned bus;                   /* bus number */
        unsigned dev_fcn;               /* device/function code */
        unsigned vendor;                /* vendor id */
        unsigned device;                /* device id */
        unsigned class;                 /* class type */
        unsigned hdr_type;              /* PCI header type */
        unsigned irq;                   /* IRQ number */
        unsigned long mem_addrs[LIS_PCI_MEM_CNT];
        void *user_ptr;                 /* private for user */
@} lis_pci_dev_t;
@end smallexample
@tpindex struct lis_pci_dev

The bus field contains the bus number on which the device is located.  LiS
obtains this information from the kernel.

The dev_fcn field contains an encoding of the device number on the bus and the
function number within the device that this particular structure pertains to.
The pair bus and dev_fcn uniquely identifies a device in the PCI subsystem.
Devices can be searched for on the PCI bus by bus number and dev_fcn value (see
below).

Given a dev_fcn value, a pair of macros will extract the "device" portion and
the "function number" portion from it.

@table @code
@findex LIS_PCI_DEV
@item #define LIS_PCI_DEV(devfcn)
Extracts the "device" portion

@findex LIS_PCI_FCN
@item #define LIS_PCI_FCN(devfcn)
Extracts the "function number" portion

@findex LIS_MK_PCI_DEV_FCN
@item #define LIS_MK_DEV_FCN(dev,fcn)
Put dev and fcn together

Given a device number and a function number, this macro will synthesize a
dev_fcn value suitable for use in searching the bus.
@end table

The vendor and device fields contain the vendor id (manuracturer code) and the
vendor's device identifier for the device.  Devices can be searched for on the
PCI bus by vendor and device identifier (see below).

The class field contains the class code associated with the device.  Devices can
be searched for on the PCI bus by class code (see below).

The hdr_type field gives the type information for the PCI configuration space
header.

The irq field gives the IRQ number that is assigned to this device.  This is the
number that is used to attach an interrupt service routine to the device.

The mem_addrs field contains a list of addresses associated with the device.
These are raw PCI bus addresses and are not mapped into the address space of the
processor.  Empty slots contain the value zero.

@node LiS PCI Search Routines
@section LiS PCI Search Routines

These routines allow the STREAMS driver to find devices on the PCI bus and
obtain a pointer to the lis_pci_dev_t structure for the device.

@subsection @code{lis_pci_dev_t *lis_pci_find_device(unsigned vendor, unsigned device, lis_pci_dev_t *previous_struct);}

Find the device by vendor identification and vendor device identification.  By
passing in the pointer to the previous structure returned it is possible to find
all devices of a given type.

The routine returns NULL if there are no (more) devices for the given vender and
device identifiers.

Usage example:

@smallexample
lis_pci_dev_t *pcip = NULL;
while ((pcip = lis_pci_find_device(0x109e, 0x8474, pcip)) != NULL) @{
        pcip points to a unique device from this vendor
@}
@end smallexample

@subsection @code{lis_pci_dev_t *lis_pci_find_class(unsigned class, lis_pci_dev_t *previous_struct);}

Find the device by class.  The usage is similar to lis_pci_find_device in that
you can use a pointer to loop through all devices of a given class.

The function returns NULL if there are no (more) devices of the given class.

@subsection @code{lis_pci_dev_t *lis_pci_find_slot(unsigned bus, unsigned dev_fcn);}

Find the device by slot number.  If you know the bus number (zero for most simple
Intel PC systems) and the dev_fcn, you can obtain the PCI configuration
information for that particular "slot".  Use the LIS_MK_DEV_FCN macro to
synthesize the dev_fcn value from the "device" (slot) number and the function
number.

The function returns NULL if there is no device in that slot.

Note that this routine only returns one structure since it is not meaningful to
process a list of devices for the same slot.

@node LiS PCI Configuration Space Routines
@section LiS PCI Configuration Space Routines

The following routines are used to read and write PCI configuration space for a
particular device.  Configuration space can be accessed by byte, word (16 bit) or
dword (32 bit).

Each routine takes a pointer to an lis_pci_dev_t structure as an argument.  It
also takes an index value which is the byte offset from the base of the
configuration space for the device at which the given byte/word/dword is to be
read or written.

Care should be exercised when writing to configuration space since many of these
values are determined by the PCI BIOS at system boot time.

The lis_pci_set_master routine sets the "bus master DMA" bit for the given
device.  This is used for devices that perform bus master DMA.

The routines are as follows:

@smallexample
int lis_pci_read_config_byte(lis_pci_dev_t *dev, unsigned index,
                             unsigned char *rtn_val);
int lis_pci_read_config_word(lis_pci_dev_t *dev, unsigned index,
                             unsigned short *rtn_val);
int lis_pci_read_config_dword(lis_pci_dev_t *dev, unsigned index,
                              unsigned long *rtn_val);
int lis_pci_write_config_byte(lis_pci_dev_t *dev, unsigned index,
                              unsigned char val);
int lis_pci_write_config_word(lis_pci_dev_t *dev, unsigned index,
                              unsigned short val);
int lis_pci_write_config_dword(lis_pci_dev_t *dev, unsigned index,
                               unsigned long val);
void lis_pci_set_master(lis_pci_dev_t *dev);
@end smallexample

@node LiS PCI DMA Routines
@section LiS PCI DMA Routines

These routines are used to allocate memory suitable for use with PCI bus master
DMA devices or to map page-allocated memory for those purposes.

In order to understand what these routines do, please refer to the file
@file{/usr/src/linux/Documentation/DMA-mapping.txt} in a fairly recent 2.4 kernel
source tree.  The kernel provides more functionality than is provided in LiS, so
there are more routines documented there than are found in this interface.
@pgindex /usr/src/linux/Documentation/DMA-mapping.txt

You can use these routines in 2.2 kernels but the functions perfomed are simply
approximations of the 2.4 semantics and may not work in all cases.

Note that the LiS routines have simplified the kernel interface involving "DMA
handles" in such a way as to make these constructs easier to use and less error
prone.

The following routines are used to allocate memory which the hardware keeps
consistent between CPU access and DMA access.

@smallexample
void *lis_pci_alloc_consistent(lis_pci_dev_t *dev, size_t size,
                               lis_dma_addr_t * dma_handle);
void *lis_pci_free_consistent(lis_dma_addr_t * dma_handle);
@end smallexample

The following routines are used to obtain a DMA address from a returned DMA
handle.  You need to know whether or not your hardware environment is using
32-bit or 64-bit DMA addresses.

@smallexample
u32 lis_pci_dma_handle_to_32(lis_dma_addr_t * dma_handle);
u64 lis_pci_dma_handle_to_64(lis_dma_addr_t * dma_handle);
@end smallexample

The following routines are usd to map page-allocated memory for DMA purposes.
The direction indicator of LIS_SYNC_FOR_CPU means that you intend to use the
memory for DMA transfers into memory.  The direction indicator of
LIS_SYNC_FOR_DMA means that you intend to use the memory for DMA transfers out
of memory.  If the DMA operation goes both ways then use LIS_SYNC_FOR_BOTH.

@smallexample
void lis_pci_map_single(lis_pci_dev_t *dev, void *ptr, size_t size,
                        lis_dma_addr_t * dma_handle, int direction);
void *lis_pci_unmap_single(lis_dma_addr_t * dma_handle);
int lis_osif_pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
			int nents, int direction);
void lis_osif_pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
			int nents, int direction);
@end smallexample

The direction indicators are as follows:

@smallexample
LIS_SYNC_FOR_CPU
LIS_SYNC_FOR_DMA
LIS_SYNC_FOR_BOTH
@end smallexample

With mapped memory, i.e., non-consistent memory, you need to synchronize the
memory whenever the CPU writes into it and the DMA needs to read it, or when the
DMA has written into it and the CPU needs to read it.  The following routine is
used for that purpose.

@smallexample
void lis_pci_dma_sync_single(lis_dma_addr_t * dma_handle, size_t size,
                             int direction);
void lis_osif_pci_dma_sync_sg(struct pci_dev *hwdev,
			      struct scatterlist *sg,
			      int nelems, int direction);
@end smallexample

The following routines can be used at driver initialization time to discover and
control the addressing boundary restrictions of a device.

@smallexample
int lis_pci_dma_supported(lis_pci_dev_t *dev, u64 mask);
int lis_pci_set_dma_mask(lis_pci_dev_t *dev, u64 mask);
@end smallexample

Please consult the file @file{<sys/osif.h>} for additional routines that may be
present for DMA support.

@node LiS Atomic Functions
@section LiS Atomic Functions

LiS provides for atomic integers implemented in a portable fashion.  To declare
an LiS portable atomic integer use the following declaration syntax:

@smallexample
lis_atomic_t myatom;
@end smallexample

LiS then provides the following operations on variables of this type.

@smallexample
void lis_atomic_set(lis_atomic_t *atomic_addr, int valu);
int lis_atomic_read(lis_atomic_t *atomic_addr);
void lis_atomic_add(lis_atomic_t *atomic_addr, int amt);
void lis_atomic_sub(lis_atomic_t *atomic_addr, int amt);
void lis_atomic_inc(lis_atomic_t *atomic_addr);
void lis_atomic_dec(lis_atomic_t *atomic_addr);
int lis_atomic_dec_and_test(lis_atomic_t *atomic_addr);
@end smallexample

Of these, only lis_atomic_dec_and_test needs any explanation.  This routine
performs an atomic_dec on the variable and returns true if the counter reached
zero via that decrement operation.  Note that by the time the routine returns
some other CPU with access to the same variable may have changed its value.  So
the return reports only on the instantaneous value of the variable.

@node LiS Locks
@section LiS Locks

LiS provides an abstraction and an insulated interface to the Linux kernel for
spin locks, interrupt disabling and semaphores.  If you use this interface in
your STREAMS driver you can utilize these kernel services on different versions
of the Linux kernel without the necessity of recompiling your driver for each
version of the kernel.

The LiS locks are especially useful in consideration of Linux kernels compiled
with and without the SMP option set.  The spin locks and semaphores of the Linux
kernel are implemented using external inline functions.  These functions are
coded in assembly language and generate different sequences of instructions
depending upon the compile time setting of the SMP option.  Spin locks and
semaphores compiled with SMP reset will not function properly on a multi-CPU
system running an SMP kernel.

The LiS locks mechanism solves this problem by abstracting the locking
primitives into actual subroutines, not inlines, defined within LiS.  Since LiS
is compiled from source code when it is installed the subroutines in LiS have
the correct setting of SMP for the locking primitives.  This allows the STREAMS
driver code to be compiled once and the object code reused for multiple
installations with varying options.

The following sections document the spin locks, interrupt disabling and
semaphore mechanisms offered by LiS.  To use these mechanisms include the file
<sys/lislocks.h> in your STREAMS driver source code.

In choosing the appropriate type of lock to use, one must bear in mind that
STREAMS drivers are not allowed to "sleep" in "put" and "service" procedures,
only in "open" and "close" routines.  That means that spin locks are the mutual
exclusion mechanism of choice for "put" and "service" procedures.  It is
reasonable to use sleeping semaphores in "open" and "close" routines.

The simple interrupt exclusion mechanism can be used to exclude only interrupt
routine execution for a section of code.  However, this mechanism does not
exclude other "put" or "service" procedures that may be executed on other CPUs.
This may not be much of a consideration since LiS acquires a lock in the queue
structure before executing the "put" or "service" procedure pointed to by that
queue.

However, it could happen that the "read put/service" and "write put/service"
procedures get executed simultaneously since there are two different locks in
the STREAMS queues, one in the read queue and one in the write queue.  In this
case, the STREAMS driver code would need to use spin locks to protect data
structures shared between the read and write "put" or "service" procedures.
See the @samp{qlock} option for @command{strconf} for more information about LiS
implicit use of locks to protect put and service procedure entries.

@node LiS Spin Locks
@section LiS Spin Locks

LiS provides an implementation of spin locks that utilizes the Linux kernel's
spin lock mechanism to perform the actual locking functions.  The LiS
implementation adds features to the kernel spin locks such as the following:

@itemize @bullet
@item LiS spin locks are nestable.  The same thread can acquire the same lock and
release it in nested fashion.

@item LiS spin locks are more debuggable.  The LiS lock structure contains an
ASCII name for the lock which makes it easier to identify in debugging
situations.

@item LiS maintains a lock trace table.  A debugging option for LiS causes it to
log all spin lock operations to a trace table which can be printed out via an
option to the streams command.

@item LiS spin locks are portable.  A STREAMS driver can utilize the same LiS
lock mechanism across different versions of the Linux kernel.  This pushes the
kernel differences into LiS and out of the STREAMS driver code.

@item LiS spin locks are documented.  You don't have to read the kernel source
code to figure out how to use them.
@end itemize

For these reasons I highly recommend that STREAMS drivers use the LiS spin lock
implementation in place of the direct kernel spin locks.  The portability aspect
of LiS spin locks cannot be overemphasized.  Different Linux kernel compile-time
options can lead to a proliferation of STREAMS driver code versions, or the
necessity of always compiling the driver from source when it is installed.  LiS
spin locks allow a STREAMS driver to be compiled independently of kernel options
with only the binary needed at driver installation time.

To declare a spin lock, use the typedef lis_spin_lock_t, as in the following:

@tpindex lis_spin_lock_t

@smallexample
lis_spin_lock_t mylock;
@end smallexample


LiS spin locks must be initialized before they are used.  There is one
initialization routine no matter which style of locking you intend to use.

void lis_spin_lock_init(lis_spin_lock_t *lock, const char *name) ;

This routine initializes the spin lock and associates an ASCII string name with
it.  The pointer name is saved in the lock structure for later use in printing
out the lock trace table.  It is the caller's responsibility to ensure that the
name resides in memory that will persist for the duration of the existence of
the lock.

You can also use dynamically allocated spin locks.  This technique allows your
STREAMS driver to be completely immune from changes in kernel version regarding
the size of a spin lock since your driver only has to store a pointer to the
allocated lock.  The allocation and deallocation routines are as follows.

@smallexample
lis_spin_lock_t *lis_spin_lock_alloc(const char *name);
lis_spin_lock_t *lis_spin_lock_free(lis_spin_lock_t *lock, const char *name);
@end smallexample

The allocation function returns a pointer to the spin lock, or NULL if the
memory could not be allocated.  The free function returns a NULL pointer for the
convenience of the caller.

For further information on spin locks, see the section on [89]debugging spin
locks.

To lock and unlock a spinlock, use any of the following pairs of routines.  If
you use the first routine to lock the spin lock then be sure to use its
companion unlock routine.  For nesting considerations, [91]see below.

@smallexample
void lis_spin_lock(lis_spin_lock_t *lock);
void lis_spin_unlock(lis_spin_lock_t *lock);
int lis_spin_trylock(lis_spin_lock_t *lock);
@end smallexample

These routines are to be called only from background processing to lock and
unlock a spin lock.  The trylock routine locks the spin lock if it is available,
returning "true", or leaves it unlocked if it is unavailable, returning "false".

Background processing means any STREAMS driver processing that does not occur at
interrupt time.  These routines lock the lock but do not exclude interrupt
routines from execution.  Thus, your interrupt service routine can still be
called whether or not your driver is holding a spin lock that was locked with
one of these routines.

You can nest pairs of calls to these routines from the same thread of execution.
[92]See below for more information on lock nesting.

Usage example:

@smallexample
lis_spin_lock(&mylock);
...
lis_spin_unlock(&mylock);
@end smallexample

@smallexample
void lis_spin_lock_irq(lis_spin_lock_t *lock);
void lis_spin_unlock_irq(lis_spin_lock_t *lock);
@end smallexample

This pair of routines locks the spin lock with interrupts disabled for the
duration of the holding of the lock.  The routine lis_spin_lock_irq re-enables
interrupts after unlocking the lock.

You can use this technique to exclude interrupt routine execution.  However, it
is not advisable for interrupt routines themselves, or any routines called from
an interrupt routine, to use this mechanism since the unlock primitive
unconditionally enables interrupts, which may not be desirable from inside an
interrupt routine.

These routines may be used in nested fashion.  Only the outermost unlock routine
will actually enable interrupts.  [94]See below for more information about lock
nesting.

Usage example:

@smallexample
lis_spin_lock_irq(&mylock);
...
lis_spin_unlock_irq(&mylock);
@end smallexample

@smallexample
void lis_spin_lock_irqsave(lis_spin_lock_t *lock, int *flags);
void lis_spin_unlock_irqrestore(lis_spin_lock_t *lock, int *flags);
@end smallexample

This pair of routines is similar to the "spin_lock_irq" routines in that the
locking routine disables interrupts.  However, it saves the interrupt state in
the integer argument whose pointer is passed to the locking routine.  The unlock
routine then restores the interrupt state after unlocking the lock.

These routines are suitable for use by routines that are called both from
interrupt level and from background.  They also have the effect, when used in an
interrupt routine, of excluding multiple execution of an interrupt routine on
multiple CPUs in an SMP system.

These routines may be used in nested fashion.  Only the outermost unlock routine
will actually restore the interrupt state.  [96]See below for more information
about lock nesting.

Usage example:

@smallexample
lis_spin_lock_t mylock;
int flags;
lis_spin_lock_irqsave(&mylock, &flags);
...
lis_spin_unlock_irqrestore(&mylock, &flags);
@end smallexample

Note that the unlock routine is passed the address of the flags just as in
calling the lock routine.

@node Lock Nesting
@section Lock Nesting

LiS spin locks can be locked and unlocked in nested fashion.  When doing so, it
is always best to use the same pair of lock and unlock routines at all levels of
nesting for the same lock.  Mixing different types of locking can lead to
unexpected results and non-portable behavior.

LiS allows a single thread to lock spin locks in nested fashion.  That is, the
second and subsequent calls to the lock routine from a single thread will not
spin on the lock because of finding it in a locked state from the first call.
Also, every unlock call except the last one, the one that balances the first
locking call, does not unlock the lock.  Only the outermost unlock call causes
the lock to be unlocked.

If the nesting is via lis_spin_lock_irq, then only the outermost unlock call
enables interrupts.  If the nesting is via lis_spin_lock_irqsave, then only the
outermost unlock call restores the interrupt state.

When two or more threads attempt to lock a spin lock "simultaneously" only one
thread is allowed to proceed at a time.  The other threads "spin", that is, the
CPUs executing the other threads are executing a loop that tests the lock
repeatedly until it becomes available.  Consequently, it is advisable to use
locks to protect the execution of fairly short pieces of code if there is any
likelihood of contention for the lock.  While one thread is holding the lock,
other CPUs may be idling waiting for it.

In the context of locking, "simultaneously" means any time from the moment of
the first thread locking the spin lock until that thread unlocks the lock.  If
another thread attempts to lock the spin lock at any point in that interval then
it will "spin."

When multiple threads use multiple spin locks to protect multiple resources, it
is always a good idea if all threads execute "lock" operations on the multiple
spin locks in the same order.  It is also highly recommended that they execute
"unlock" operations in the exact reverse order as the "lock" operations.  This
avoids so-called "deadly embrace" situations in which process A acquires spin
lock A, process B acquires spin lock B, and then process A waits on B while
process B waits on A.

@node LiS Read/Write Locks
@section LiS Read/Write Locks

LiS offers an abstraction of the kernel's read/write locks.  The LiS abstractions
allow STREAMS drivers to use these locks without concern for changes that occur
from one version of the kernel to the next.

A read/write lock is declared as a special data object of type lis_rw_lock_t.
There are two types of routines to manipulate these locks.  One set operates on
the lock as a "read" lock.  The other set operates on the lock as a "write" lock.

There can be multiple threads owning the lock in read mode.  There can only be
one thread that owns the lock in write mode.  Furthermore, in order to acquire
the lock in write mode, all the owners of the read mode lock must give it up.

The locks are used in the obvious way.  If you only need to read the protected
structure you use the read lock routine.  If you need to change the structure you
use the write lock routine.

Note that once you have a read lock you must give it up in order to get the same
lock as a write lock.

The lock manipulation routines also allow for "regular", "irq" and "irqsave"
manipulations of the read/write locks, just as with spin locks.

You must initialize your lock before using it, just as with spin locks.  And in
parallel to spin locks LiS provides two initialization routines.  One operates
directly on the read/write lock, and the other allocates memory dynamically for
the lock.  You can deallocate the dynamically allocated lock by calling the
"free" routine.

The following is a listing of the read/write lock routines in LiS.  The
prototypes are in the file <sys/lislocks.h>.

@smallexample
void lis_rw_read_lock(lis_rw_lock_t *lock);
void lis_rw_write_lock(lis_rw_lock_t *lock);
void lis_rw_read_unlock(lis_rw_lock_t *lock);
void lis_rw_write_unlock(lis_rw_lock_t *lock);

void lis_rw_read_lock_irq(lis_rw_lock_t *lock);
void lis_rw_write_lock_irq(lis_rw_lock_t *lock);
void lis_rw_read_unlock_irq(lis_rw_lock_t *lock);
void lis_rw_write_unlock_irq(lis_rw_lock_t *lock);

void lis_rw_read_lock_irqsave(lis_rw_lock_t *lock, int *flags);
void lis_rw_write_lock_irqsave(lis_rw_lock_t *lock, int *flags);
void lis_rw_read_unlock_irqrestore(lis_rw_lock_t *lock, int *flags);
void lis_rw_write_unlock_irqrestore(lis_rw_lock_t *lock, int *flags);

void lis_rw_lock_init(lis_rw_lock_t *lock, const char *name);
lis_rw_lock_t *lis_rw_lock_alloc(const char *name);
lis_rw_lock_t *lis_rw_lock_free(lis_rw_lock_t *lock, const char *name);
@end smallexample

@node LiS Interrupt Enable/Disable
@section LiS Interrupt Enable/Disable

LiS provides primitives for enabling and disabling interrupts modelled after the
SVR4 SPL mechanism.  There is one routine that is used to disable interrupts and
another one for enabling interrupts.  The routines are as follows:

@smallexample
int lis_splstr(void);
void lis_splx(int x);
@end smallexample

The lis_splstr routine is used to disable interrupts.  It returns a value that
must be passed to lis_splx when it it desired to restore the interrupt level to
its previous state.  These two routines are implemented using the primitives
lis_spin_lock_irqsave and lis_spin_unlock_irqrestore.

These routines can be used from background code ("put" and "service" procedures,
or "open" and "close" routines), or from interrupt level.  LiS itself uses these
routines to protect STREAMS structures from ill-timed modification by interrupt
routines.  Many LiS utility routines, such as putq, getq and qenable, call these
routines within themselves.

It is safe, and occurs frequently, to use these routines in a nested fashion.
When using these routines in a nested fashion be sure that the value returned by
the call to lis_splstr at level n is the value passed back to lis_splx at level
n.  The nesting rules for these routines are otherwise the same as for the pair
lis_spin_lock_irqsave and lis_spin_unlock_irqrestore.

Usage examples:

@smallexample
int x, y;
x = lis_splstr();
...
y = lis_splstr();
...
lis_splx(y);
...
lis_splx(x);
@end smallexample

For further information on these routines see the section on [100]debugging spin
locks.

@node LiS Semaphores
@section LiS Semaphores

LiS provides an implementation of semaphores that is built upon the Linux
kernel's semaphores.  The LiS implementation adds features to the kernel
semaphores such as the following:

@itemize @bullet
@item LiS semaphores are more debuggable.  The LiS semaphore structure contains
fields that save the file name and line number of the semaphore owner.  This
makes it easier to debug drivers which utilize semaphores.

@item LiS semaphores retain error information.  When a "down" operation fails,
LiS saves the error number in the semaphore structure for post mortem analysis.

@item LiS semaphores are portable.  A STREAMS driver can utilize the same LiS
semaphore mechanism across different versions of the Linux kernel.  This pushes
the kernel differences into LiS and out of the STREAMS driver code.

@item LiS semaphores can be easily allocated dynamically so your driver is
completely immune from Linux kernel version considerations.

@item LiS semaphores are documented.  You don't have to read the kernel source
code to figure out how to use them.
@end itemize

For these reasons I highly recommend that STREAMS drivers use the LiS semaphore
implementation in place of the direct kernel semaphores.  The portability aspect
of LiS semaphores cannot be overemphasized.  Different Linux kernel compile-time
options can lead to a proliferation of STREAMS driver code versions, or the
necessity of always compiling the driver from source when it is installed.  LiS
semaphores allow a STREAMS driver to be compiled independently of kernel options
with only the binary needed at driver installation time.

To declare an LiS semaphore, use a declaration similar to the following:

@smallexample
lis_semaphore_t mysem;
@end smallexample

LiS semaphores must be initialized before they are used.  Use the following
routine to initialize a declared semaphore.

@smallexample
void lis_sem_init(lis_semaphore_t *, int);
@end smallexample

If you initialize the semaphore to 0, then the first "down" operation on the
semaphore will wait.  If you initialize it to 1, then the first "down" operation
will not wait.  If you initialize it to n, then the first n "down" operations
will not wait.

You can also allocate semaphores dynamically using the following routine.

@smallexample
lis_semaphore_t *lis_sem_alloc(int);
@end smallexample

This routine uses the kernel's memory allocator to allocate space for the
semaphore.  The lis_sem_destroy routine will deallocate it for you.  The
advantage of using this routine is that your STREAMS driver only has to have a
pointer to the semaphore, not a semaphore structure itself.  This adds an extra
level of protection of your driver from kernel version considerations.

You can use the semaphore value to manage a pool of resources by initializing a
semaphore to the number of items in the resource and having a driver open
routine perform a "down" operation on the semaphore.  This causes the open
operations to be queued until the resource is available.

LiS semaphores should be explicitly destroyed when they are no longer needed,
typically from your STREAMS driver close routine.  This operation is accomplished
via the following routine.

@smallexample
lis_semaphore_t *lis_sem_destroy(lis_semaphore_t *,int);
@end smallexample

This routine returns a NULL pointer for the convenience of the caller.

For further information on semaphores, see the section on [102]debugging
semaphores.

The following two routines are used to acquire and release a semaphore.

@smallexample
int lis_down(lis_semaphore_t *sem);
void lis_down_nosig(lis_semaphore_t *lsem);
void lis_up(lis_semaphore_t *sem);
@end smallexample

The routine @command{lis_down}
@findex lis_down
returns 0 for success and a negative error code for failure.  The caller has not
acquired the semaphore unless the routine returns zero.

One reason for a negative return could be that the calling task was signalled
while waiting for the semaphore to become available.  If this has occurred the
return code will be set to -EINTR.

The function @command{lis_down_nosig}
@findex lis_down_nosig
waits for the sempahore with signals blocked.  It is useful in driver close
routines that must use a semaphore to control access to the structures that need
to be deallocated.  It is common for the driver close routine to be called from
a process that has been signalled -- for example a process that was killed with
a @key{Ctrl-C} from the keyboard.  In this case, @command{lis_down} will return
immediately with @code{-EINTR}, an undesirable situation.  using
@command{lis_down_nosig} in this situation blocks signals so that the close
routine can wait on the semaphore even if the process has been signalled.

Semaphores cannot be used in nested fashion.  Care must be exercised that a
single thread only performs one "down" operation on a given semaphore.

When multiple threads use multiple semaphores to protect multiple resources, it
is always a good idea if all threads execute "down" operations on the multiple
semaphores in the same order.  It is also highly recommended that they execute
"up" operations in the exact reverse order as the "down" operations.  This avoids
so-called "deadly embrace" situations in which process A acquires semaphore A,
process B acquires semaphore B, and then process A waits on B while process B
waits on A.

Semaphores should be used only in STREAMS driver "open" and "close" routines.
STREAMS driver "put" and "service" procedures are not allowed to sleep.  They
should use spin locks instead of semaphores.

Usage example:

@smallexample
if (lis_down(&mysem) == 0) @{
        ...
        lis_up(&mysem);
@}
@end smallexample

@node Debugging Spin Locks
@section Debugging Spin Locks

LiS spin lock structures contain fields that assist in the debugging of
spin-lock related problems.  The LiS spin lock structure contains the following
fields.

Field Description

spin_lock_mem An opaque memory area that contains the kernel's spin lock
structure.

name

Pointer to an ASCII name for the lock.  This allows one to readily identify the
function of the lock (assuming that it is aptly named).

taskp

A (void *) which is really a (struct task_struct *) pointer.  It points to the
task that originally acquired the lock, or is NULL if no task has acquired the
lock.
@tpindex struct task_struct

spinner_file, spinner_line

File and line number of the most recent call to one of the lis_spin_lock
functions.  This tells which line of code most recently tried to get the lock.

owner_file, owner_line

File and line number of the call to one of the lis_spin_lock functions that
first acquired the lock.  These fields are set at the same time as the taskp
field.

unlocker_file, unlocker_line

File and line number of the call to one of the lis_spin_unlock functions that
performed the final unlock on the lock, thus making it available for another
thread.  These fields are set at the same time as the taskp field is set to NULL.

If a thread owns the lock then its value of the current task pointer will be in
taskp.  If there is no other thread spinning on the lock, and if the lock has not
been acquired in a nested fashion, then the spinner and owner fields will
indicate the same file and line number.

If the spinner and owner fields are different and if the taskp is non-NULL then
if the thread that most recently called one of the lis_spin_lock routines is
different from the task that owns the lock, then that other task is spinning on
the lock.  By examination of the lock you can see which task owns the lock and
where in the code it was acquired.  This is often enough information to figure
out why a deadlock is occurring.

A "deadly embrace" occurs when two threads each need to acquire two spin locks
but they acquire them in the opposite order from each other.  Under circumstances
of contention each process owns the lock that the other is spinning on and will
not release the lock until it acquires the other lock.  Thus, both threads spin
forever.

Note that the LiS splstr and splx functions are written in terms of LiS spin
locks.  LiS does not use these routines internally.  They are provided to the user
for backwards compatibility.  However, it is important to know that these
routines are spin locks in disguise.  This means that the order of use of these
functions mixed in with explicit spin lock manipulations may also lead to deadly
embraces.

An effective technique for troubleshooting these kinds of problems is to use the
two-machine kernel debugger, [105]kgdb.  With this setup you can break into the
target machine and look at memory using high level debugging techniques,
including printing out of structures.  Using kgdb you can find out where each CPU
is executing, look at the corresponding source code lines, observe the locks
that are involved, and then print out the lis_spin_lock_t structures for the
specific locks.  Oftentimes the information contained in the two locks will
immediately reveal the nature of the deadly embrace.

It is also possible to have LiS trace all lock and semaphore operations.  One of
the LiS debug bits enables this function.  To set this debug bit use the
following command.

@example
streams -d0x0x80000
@end example

This causes LiS to make entries in a global trace buffer named lis_spl_track.
The global pointer lis_spl_track_ptr indicates the next location in the table
into which an entry is to be placed, which means that it points to the oldest
entry in the buffer.  Entries in the buffer are of type spl_track_t.

The fields of this structure are as follows.
Field Description
type
The type of entry as follows.

                                         Value

Meaning

                                                1

splstr

                                                2

splx

                                                3

spin lock

                                                4

spin unlock

                                                5

semaphore down

                                                6

semaphore up

cpu

The cpu number of the processor which made this entry.  addr The address of the
spin lock or semaphore involved in the operation.

tskp
The task pointer for the task that made this entry.  state Nesting value for
spin locks, count field of the semaphore.

file, line

File and line number of the call to the LiS locking or semaphore routine that
caused this entry to be made.

The trace buffer contains 4096 of these entries, maintained in a circular
fashion.  By printing out these entries you can see the history of lock
manipulation within LiS.  The command streams -p causes LiS to print out this
table from within the kernel.  The resulting output can be found in
@file{/var/log/messages} (typically).  However, in practice the system is usually hung
when you need this information so you end up printing it from within the
debugger.
@pgindex /var/log/messages

@node Lock Semaphore and Queue Contention
@section Lock Semaphore and Queue Contention

The @command{streams} command can be used to enable the tracking of contetion
for locks, semaphores and STREAMS queues.  Use the command @samp{streams -D0x08}
to enable the contention tracking.  The command @samp{streams -L} then causes
the contention tables to be printed out.

Locks and semaphores are in contention when a thread goes to spin on a lock or
perform a @command{down} function on a sempahore, and the thread has to wait
because the lock or semaphore is owned by another thread.  LiS counts such
occurences on a per-lock basis and reports the results with the @samp{streams -L}
command.

Queues are in contention when the semaphore that controls access to the queue is
in contention.  However, there are options that affect which semaphore is used
to control access to a queue and these options will also have an effect on the
reporting of queue contention.

@node Debugging Semaphores
@section Debugging Semaphores

LiS semaphore structures contain fields that assist in the debugging of
semaphore related problems.  The LiS semaphore structure contains the following
fields.

Field Description

sem_mem
An opaque memory area that contains the kernel's semaphore structure.

taskp

A (void *) which is really a (struct task_struct *) pointer.  It points to the
task that most recently acquired the semaphore, or is NULL if no task has
acquired the semaphore.  The taskp is set to NULL just prior to calling the
kernel's up routine on the semaphore.  Thus it stays NULL if no other task is
pending on the semaphore.
@tpindex struct task_struct

downer_file, downer_line
File and line number of the most recent call to the lis_down function.  This
tells which line of code most recently tried to get the semaphore.

owner_file, owner_line
File and line number of the call to the lis_down function that acquired the
semaphore.  These fields are set at the same time as the taskp field.

upper_file, upper_line
File and line number of the call to the lis_up function.  These fields are set at
the same time as the taskp field is set to NULL.

If the taskp field is non-NULL then the semaphore is owned by the task so
indicated.  If it is NULL then the semaphore is unowned.  The upper fields show
where the semaphore was last released.

If the downer and owner fields both indicate the same file and line number then
that is an indication that the semaphore was acquired at that location in the
program.  If they are different, and if the taskp is non-NULL, that is an
indication that there is a task waiting on the semaphore at the downer location.
The owner fields show where the semaphore was acquired.

Bear in mind that semaphore acquisitions do not nest as is the case with spin
locks.  Therefore, if the same thread calls lis_down without calling lis_up on
the same semaphore then the thread will be deadlocked.  The downer and owner
fields will usually offer a clue to this type of deadlock.

You can also use the LiS [107]lock trace buffer mechanism to assist in debugging
semaphore usage.

@node STREAMS Utility Routines
@section STREAMS Utility Routines

The following routines are available to LiS STREAMS drivers.  These are standard
AT&T SVR4 utility routines.  They (hopefully) have the same semantics in LiS as
they do in SVR4 STREAMS.

These routines are presented here in alphabetical order with no description.
Please refer to the [109]AT&T SVR4 STREAMS documentation for the descriptions of
these routines.

@node Freezing Streams
@section Freezing Streams

There are two sets of routines that can be used to @samp{freeze} a stream.  They
are used in slightly different ways and have slightly different semantics.  One
set uses the routines
@command{freezestr()}
@findex freezestr
and @command{unfreezestr()};
@findex unfreezestr
the other set uses the routines
@command{qprocesoff()}
@findex qprocesoff
and @command{qprocson()}.
@findex qprocson

@subsection Freezestr and Unfreezestr

@example
void freezestr(queue_t *q);
void unfreezestr(queue_t *q);
@end example

These routines operate on the entire stream of which the queue is a member.  The
stream is found by traversing the chain of queues in both directions until
encountering a queue that is not linked to another queue.  As a simple example
it includes all queues from the stream head down through any pushed modules to
the driver queue in which one of those queues is the one passed as the parameter
to either of these routines.

The process of freezing the stream is to place it into a state such that
messages will not flow up and down the stream.  That is @command{put} and
@command{service} procedures will not be called.  It @command{putnext()}
@findex putnext
is called on a queue within a frozen stream the passed message is placed into a
special deferred message list.  Messages are removed from this list and passed
to the @command{put} procedure when the stream is later unfrozen.

Drivers that have frozen a stream should refrain from performing queuing
operations on queues within the stream, such as @command{getq} and
@command{putq}.  LiS does not enforce this so one must exercise some care when
using these routines.

SVR4 STREAMS specification says that the driver's close routine will not be
called if the stream is frozen.  LiS does not implement this rule and will close
a frozen stream.

LiS uses these routines internally at stream close time to stop message flow
when the stream is being dismantled.  It also uses them during @code{I_PUSH} and
@code{I_POP} processing to inhibit message flow while replumbing the stream.

Drivers should use these routines with some caution.  Because the stream is
frozen the driver cannot receive any messages from above or below, including
@code{M_IOCTL}.  This may make it tricky deciding when to unfreeze a stream.

@subsection Qprocsoff and Qprocson

@example
void qprocson(queue_t *rdq);
void qprocsoff(queue_t *rdq);
@end example

These routines are conventionally used in a driver open (@command{qprocson}) and
close (@command{qprocsoff}) routine.  In some STREAMS implementations
@command{qprocson} must be called to enable messages to flow into the queue once
open processing has completed.  This is not necessary in LiS.

In LiS it does no harm to call @command{qprocson} in the driver open routine and
@command{qprocsoff} in the driver close routine, though it is not necessary to
do so.

The effect of @command{qprocsoff} is similar to that of @command{freezestr}
except that it applies just to the single queue rather than to the entire
stream.  Once significant difference is that if a pushable modules is in a
@samp{qprocsoff} condition and a message flows into the module, STREAMS will
route the message to the next module or driver in the chain of queues, looking
for one that is enabled.  If no such module or driver exists, the messag will be
placed into the deferred message list of the queue at the far end of the chain
of queues.  The messages will be presented to the driver put routine when
@command{qprocon} is called.

It is best to use these routines only at open and close time since that seems to
have been the intent of the STREAMS designers.

@node Flushing Queue Bands
@section Flushing Queue Bands

A special note on flushing queue bands is in order.  The rules for flushing
queues are a bit complex, so we wish to review them here in some detail.

@vrindex M_DATA
@vrindex M_PROTO
@vrindex M_PCPROTO
@vrindex M_DELAY

First some definitions and some things that affect all queue flushing.  The
term "data message" in the context of queue flushing means messages of type
@code{M_DATA}, @code{M_PROTO}, @code{M_PCPROTO} or @code{M_DELAY}.  All other
message types are considered "non-data messages".  You may find it less than
intuitive that @code{M_PCPROTO} is considered a "data message".

@vrindex M_DATA
@vrindex M_PROTO
@vrindex M_BREAK
@vrindex M_CTL
@vrindex M_DELAY
@vrindex M_IOCTL
@vrindex M_PASSFP
@vrindex M_RSE
@vrindex M_SETOPTS
@vrindex M_SIG
@vrindex M_PCPROTO

The term "ordinary message" in the context of queue flushing means messages of
type @code{M_DATA}, @code{M_PROTO}, @code{M_BREAK}, @code{M_CTL},
@code{M_DELAY}, @code{M_IOCTL}, @code{M_PASSFP}, @code{M_RSE},
@code{M_SETOPTS} or @code{M_SIG}.  Please note that @code{M_PCPROTO} is not on
this list.

The flag argument of FLUSHDATA means that only "data messages" are to be
flushed.  The flag argument of FLUSHALL means that "all" messages are to be
flushed.  As we shall see, in flushing queue bands whether a message gets flushed
or not depends upon what the meaning of the word "all" is.

First, let's take the case of the routine flushq(q,flag).  If flag is set to
FLUSHDATA then all "data messages" in the entire queue, including all queue
bands, are flushed.  If the flag is set to FLUSHALL then the entire queue is
flushed.

The case of the routine flushband(q,band,flag) is more complicated.

If the band argument is zero then special rules apply.  In this case, only
"ordinary" messages are flushed from the queue.  The value of the flag parameter
does not influence the operation.  In Solaris STREAMS this behavior does not
occur.  They flush either "data messages" or "all" messages on band zero.
Comments in the Solaris 8 source code indicate that the author of the flush code
was somewhat confused on this point.

If the band argument is non-zero then the specific band of the queue is flushed
in a manner similar to that of flushq.  That is, the flag argument of FLUSHDATA
means just flush "data messages" and the value of FLUSHALL means flush "all"
messages from the specific band.

@vrindex M_PCPROTO
One further item needs some attention.  Whenever an @code{M_PCPROTO} (or other
"high priority") message is inserted into a STREAMS queue it is queued ahead
of all messages in any queue band.  This means that an @code{M_PCPROTO} cannot
be directed to a queue band.  It also means that flushband can never flush an
@code{M_PCPROTO}, or any other "high priority" message from the queue.  In
order to flush @code{M_PCPROTO}s you must call flushq and flush the entire
queue of either "data messages" or "all" messages.


@node Utility Prototypes
@section Utility Prototypes

@smallexample
int adjmsg(mblk_t *mp, int length);
struct msgb *allocb(int size, unsigned int priority);
@tpindex struct msgb
__________________________________________

queue_t *backq(queue_t *q);
int bcanput(queue_t *q, unsigned char band);
int bcanputnext(queue_t *q, unsigned char band);
void bcopy(void *src, void *dst, int nbytes);
int bufcall(unsigned size, int priority, void (*function) (long), long arg);
void bzero(void *addr, int nbytes);
__________________________________________

int canput(queue_t *q);
int canputnext(queue_t *q);
void cmn_err(int err_lvl, char *fmt, ...);
mblk_t *copyb(mblk_t *mp);
mblk_t *copymsg(mblk_t *mp);
__________________________________________

#define datamsg(type) -- true if msg->b_datap->db_type is data
mblk_t *dupb(mblk_t *mp);
mblk_t *dupmsg(mblk_t *mp);
__________________________________________

void enableok(queue_t *q);
mblk_t *esballoc(unsigned char *base, int size, int priority, frtn_t *freeinfo);
int esbbcall(int priority, void (*function) (long), long arg);
__________________________________________

void flushband(queue_t *q, unsigned char band, int flag);
void flushq(queue_t *q, int flag);
void freeb(mblk_t *bp);
void freemsg(mblk_t *mp);
void freezestr(queue_t *q);
void unfreezestr(queue_t *q);
__________________________________________

int getmajor(dev_t dev);
int getminor(dev_t dev);
mblk_t *getq(queue_t *q);
__________________________________________

int insq(queue_t *q, mblk_t *emp, mblk_t *mp);
__________________________________________

void *kmem_alloc(int siz, int wait_code);
void *kmem_zalloc(int siz, int wait_code);
void kmem_free(void *ptr, int siz);
__________________________________________

void linkb(mblk_t *mp1, mblk_t *mp2);
__________________________________________

int msgdsize(mblk_t *mp);
mblk_t *msgpullup(mblk_t *mp, int length);
int msgsize(mblk_t *mp);
__________________________________________

void noenable(queue_t *q);
__________________________________________

queue_t *OTHERQ(queue_t *q);
__________________________________________

int pullupmsg(mblk_t *mp, int length);
int putbq(queue_t *q, mblk_t *mp);
int putctl(queue_t *q, int type);
int putctl1(queue_t *q, int type, int param);
void putnext(queue_t *q, mblk_t *mp);
int putnextctl(queue_t *q, int type);
int putnextctl1(queue_t *q, int type, int param);
int putq(queue_t *q, mblk_t *mp);
__________________________________________

void qenable(queue_t *q);
void qreply(queue_t *q, mblk_t *mp);
int qsize(queue_t *q);
void qprocsoff(queue_t *rdq);
void qprocson(queue_t *rdq);
__________________________________________

queue_t *RD(queue_t *q);
queue_t *WR(queue_t *q);
queue_t *OTHERQ(queue_t *q);
mblk_t *rmvb(mblk_t *mp, mblk_t *bp);
void rmvq(queue_t *q, mblk_t *mp);
__________________________________________

int SAMESTR(queue_t *q);
int strqget(queue_t *q, qfields_t what, unsigned char band, long *val);
int strqset(queue_t *q, qfields_t what, unsigned char band, long val);
__________________________________________

int testb(int size, unsigned int priority);
__________________________________________

#define HZ -- ticks per second
typedef void timo_fcn_t (caddr_t arg);
@tpindex timeo_fcn_t
toid_t timeout(timo_fcn_t *timo_fcn, caddr_t arg, long ticks);
toid_t lis_untimeout(toid_t id);
__________________________________________

void unbufcall(int bcid);
mblk_t *unlinkb(mblk_t *mp);
int untimeout(int id);
__________________________________________

queue_t *WR(queue_t *q);
__________________________________________

int xmsgsize(mblk_t *mp);
@end smallexample

@node System Calls from within the Kernel
@section System Calls from within the Kernel

LiS provides STREAMS drivers with a few system calls that can be made from
within the kernel.  These calls are intended to allow STREAMS drivers to manage
their device special files through which the drivers are accessed.  For example,
by using the @dfn{lis_mknod} function a dynamically loaded driver can register itself
with LiS, obtain a major device number and make its "/dev" entries at module
load time.  Using the lis_unlink function it can remove these "/dev" entries when
the module unloads.

The semantics of the following routines are exactly the same as the user level
routines of the same names without the "lis_" prefix.  This is so because these
routines are really just wrappers on a kernel system call.  We list the function
prototypes here but leave the detailed documentation to "man pages" and other
documentation.

The following function prototypes exist in the file <sys/dki.h>.

@smallexample
int lis_mknod(char *name, int mode, dev_t dev);
int lis_unlink(char *name);
int lis_mount(char *dev_name, char *dir_name, char *fstype,
              unsigned long rwfla g, void *data);
int lis_umount(char *file, int flags);
@end smallexample


@node LiS Library Routines
@chapter LiS Library Routines

During the installation process of Linux STREAMS (LiS) a subroutine
library is built and installed on your system.  Three versions of the
library are built and installed.  They are as follows.

@table @file
@item libLiS.a
Interface routines to LiS in static library form.
@item libLiS.so
Interface routines to LiS in dynamic library form.
@item libpLiS.so
Like libLiS.so but omits the "pipe" system call.
@end table

These three libraries are copied to the directory @file{/usr/lib} when LiS is
installed.
@pgindex /usr/lib

In addition, the utility program ldconfig is run during the LiS make
install.  This causes this library to be linked, or searched, ahead of the
standard C library.  This is necessary because the standard C library
contains dummy routines for the STREAMS interface functions, or most of
them in the best case.  If these dummy routines preempt the LiS versions
then STREAMS applications will always perceive error returns from such
routines as getmsg and putmsg.

@menu
* Library Routines::			STREAMS library routines.
* Using the Library::			STREAMS library routines.
@end menu

@node Library Routines
@section Library Routines

The following routines are present in the libraries libLiS.a and libLiS.so.  The
library libpLiS.so omits the "pipe" routine.

The routines in these libraries are standard STREAMS interface routines.  As such
we do not offer detailed descriptions of the functions of these routines.
Instead we refer the reader to the [21]AT&T SVR4 STREAMS documentation.

@smallexample
int fattach(int fd, const char *path);
int fdetach(const char *path);
int getmsg(int fd, void *ctlptr, void *dataptr, int *flagsp);
int getpmsg(int fd, void *ctlptr, void *dataptr, int *bandp, int *flagsp);
int isastream(int fd);
int pipe(int *fd);
int poll(void *pollfds, long nfds, int timeout);
int putmsg(int fd, void *ctlptr, void *dataptr, int flags);
int putpmsg(int fd, void *ctlptr, void *dataptr, int *bandp, int *flagsp);
@end smallexample

These routines are all very small pieces of code.  Most of them simply pass their
parameters to LiS via a system call.  The fattach and fdetach routines use ioctls
to LiS if there is no system call available to call directly.

The poll routine simply executes the poll system call.  It is present for
backward compatibility to 2.0 kernels, in which LiS provided the poll system
call.

The pipe routine has the same semantics as the standard C library routine.  It
uses STREAMS FIFOs to implement the pipe instead of the standard Linux pipes.

The libpLiS.so library, the one that preempts the standard C library, omits the
STREAMS pipe routine so that standard Linux pipes are used unless the user
explicitly links in libLiS.

@node Using the Library
@section Using the Library

In order to use one of the LiS libraries you should include the file
@file{<sys/stropts.h>} in you program source code.  On you compiler command line you can
add the option "-I/usr/src/LiS/include" to include the version of @file{stropts.h} that
is distributed with LiS, or omit the option to include the system standard
header file.  The two header files are believed to be compatible enough that it
does not matter which one you include in your program.
@pgindex stropts.h

When linking your program, or performing a final "cc" to build your executable,
include one of the following options on your command line.

@table @code
@item /usr/lib/libLiS.a
Use @file{libLiS.a} (static, includes "pipe")
@pgindex /usr/lib/libLiS.a
@pgindex libLiS.a
@item -lLiS
Use @file{libLiS.so} (dynamic, includes "pipe")
@pgindex libLiS.so
@item -lpLiS
Use @file{libpLiS.so} (dynamic, omits "pipe")
@pgindex libpLiS.so
@end table

Omit any options

As of libc-2.2.1 the LiS STREAMS interface routines will be used automatically
via libpLiS.so.



@node LiS Drivers
@chapter LiS Drivers

The LiS package comes with a number of STREAMS drivers and pushable
modules in source code form.  A number of these drivers and modules are
small entities that are used in the testing of LiS.  They are included so
as to make it easy for any user to run the LiS tests for themselves.

Other drivers are used to
@ignore
interface between STREAMS and the Linux
networking subsystem (link-drvr, ip_strms).  Still others are used to
@end ignore
implement STREAMS based pipes and FIFOs.

@menu
* STREAMS Drivers::			LiS STREAMS drivers.
* Pushable Modules::			LiS STREAMS modules.
@end menu

@menu
----- detailed node listing -----

STREAMS Drivers:

* clone-drvr::				The clone driver.
* fifo::				STREAMS-based FIFOs.
@ignore
* link-drvr::				Linux DL driver.
@end ignore
* loop-around::				Loop-around test driver.
* mini-mux::				Mini multiplexing driver.
* printk::				Print test driver.
* sad::					STREAMS Administrative Driver.

Pushable Modules:

* connld::				Connection listening daemon.
@ignore
* ip_strms::				IP streams driver.
@end ignore
* pipemod::				STREAMS-based Pipes.
* relay relay2::			Relay test driver.
@ignore
* timod::				XTI/TLI library module.
* tirdwr::				XTI/TLI read/write module.
@end ignore
@end menu

@node STREAMS Drivers
@section STREAMS Drivers

A driver in STREAMS has a major and minor device number associated with it and
an entry in the @file{/dev} directory.  The driver is opened and closed just like any
file.
@pgindex /dev

@menu
* clone-drvr::				The clone driver.
* fifo::				STREAMS-based FIFOs.
@ignore
* link-drvr::				Linux DL driver.
@end ignore
* loop-around::				Loop-around test driver.
* mini-mux::				Mini multiplexing driver.
* printk::				Print test driver.
* sad::					STREAMS Administrative Driver.
@end menu

@page
@node clone-drvr
@subsection clone-drvr

@unnumberedsubsec Device Name

@example
/dev/clone_drvr
@end example
@pgindex /dev/clone_drvr

@unnumberedsubsec Description

This driver is used to assist LiS in implementing the "clone" open
function.  It appears under its own name as @file{/dev/clone_drvr}.  By
convention, it is allocated the first major number of all the STREAMS
drivers.
@pgindex /dev/clone_drvr

In order to implement clone opens, one creates a node in the @file{/dev}
directory for a device whose major number is set to that of the clone
driver, and whose minor number is the major number of the driver to
which the clone open is to be directed.
@pgindex /dev

The clone driver's open routine forwards the open call to the target
driver, passing a unique flag that informs the driver that a clone
open is being requested.  The target driver then allocated a minor
device number to uniquely associate with this instance of the open
operation.  The clone driver synthesizes a new major/minor "device id"
to pass back to LiS.  LiS recognizes the change of major/minor from
the original open and takes steps to allocate control structures
unique to this open.

The "clone open" operation is intended to make is easy to open one
device from a pool of devices, such as pseudo ttys or logical
connections.  It saves application programs from having to scan a list
of device mnemonics issuing trial opens until one is found that
succeeds.

Note that the driver is named @file{/dev/clone_drvr} instead of the more
traditional SVR4 @file{/dev/clone}.  This is to avoid a conflict with
another driver named @file{/dev/clone} on Linux systems.
@pgindex /dev/clone
@pgindex /dev/clone_drvr

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node fifo
@subsection fifo

@unnumberedsubsec Device Name

@example
/dev/fifo @r{}(clone device)
/dev/fifo.0
@end example
@pgindex /dev/fifo
@pgindex /dev/fifo.0

@unnumberedsubsec Description

The fifo pseudo-driver (which is internal to LiS) provides
STREAMS-based fifos as single character special files, and
STREAMS-based pipes as pairs of character special files which are
interconnected (see pipe(3)).

STREAMS-based fifos differ from typical STREAMS-based character
special files in that there are not separate stream head and driver
queue pair within the STREAMS-based file.  Instead, a fifo is created
with only a single queue pair for the stream head.  Moreover, in a
typical driver queue pair, the write queue is not connected to a next
queue.  In a fifo, the write queue is directed to the read queue of the
pair.  A pipe comprises a pair of fifos, with the write queue of each
pair directed to the read queue of the other.  The two fifos comprising
a pipe are referred to as peers, and each somewhat represents a driver
to the other.  As a degenerate case, a fifo is its own peer.

STREAMS modules may be pushed onto fifos and pipes, but should not
expect a driver below them; instead, the SAMESTR() function should be
used from the write queue of a pair to determine if the module is the
lowest in the STREAMS-based file (this is called the midpoint).  The
structure of a fifo or pipe is preserved when modules are pushed (and
popped); i.e., the write queue at the midpoint will always be directed
at the read queue of the peer.

Input and output are handled at a fifo stream head as they would
normally be handled at a stream head.  In LiS, an fifo open() entry
point exists to assign minor device numbers to new opens under the
fifo major device number, and a close() entry point is used
correspondingly to release them.  These functions are kept in a
streamtab data struc ture (as they would normally be for any STREAMS
driver or module) which is private to the LiS implementation.

@unnumberedsubsec Application Usage

In the current Linux kernels, character special major numbers are
limited to 16 bits, and major and minor device numbers to 8 bits each.
This limits a system to 256 total major device numbers and 256 total
minor devices per major device number.  This is a rather severe
limitation where mechanisms like fifos and pipes are concerned.

However, a driver may handle more than one major device number.  The
fifo pseudo-driver uses this to overcome this limitation, by
supporting the automatic allocation and use of multiple major device
numbers for fifos and pipes.  Specifying more than 256 minor devices
is done in the usual manner, i.e., by specifying the number of "units"
in the appropriate @file{Config} file.  Enough major device numbers will be
allocated to cover the requested number of minor devices (if
available, else an error will occur in strconf(8)).  The number
allocated will include one minor device per major number to be used as
a fifo-specific clone minor device (specifically, minor number 0),
which exhibits special behavior.
@pgindex Config

Normally, when cloning is done via the clone pseudo-driver, the clone
major device number is used, along with the desired actual major
number as the minor device num ber.  When an open() is performed on
such a device, the clone open() routine in turn calls the appropriate
driver's open(), with the sflag parameter set to CLONEOPEN.  The
driver's open() is expected in this case to allocate an unused minor
device number, and return it via an entirely new device number in the
devp parameter.  In this way, a driver can change the device number to
be used for a STREAMS-based file.  When minor device 0 for a specified
for a fifo major device, the driver will also clone a new minor device
number.  However, LiS opens fifo devices differently; specifically,
when an already-opened fifo-specific clone minor device is reopened,
the new and subsequent opens will use the already-opened clone.  Thus,
using minor device 0 for a fifo when creating a file sys tem node will
ensure that all concurrent opens of the associated path name will use
the same STREAMS-based file; at the same time, opens of different file
system nodes via different paths will open their respectively
different STREAMS-based files.  This is essentially how kernel-based
fifos behave -applications and users of STREAMS-based fifos don't have
to keep track of minor numbers to achieve this same behavior when it
is desired.

It is in fact recommended that only two forms of file sys tem nodes be
used for STREAMS-based fifos: the clone major number as major number
with a fifo major number as minor number, to be used when every open
of the associated path must clone a new fifo, and a fifo major number
as major number with 0 as the minor number, to be used when new opens
are to clone a new fifo but subsequent concurrent opens are to use the
already opened fifo.  These are represented by two device special file
paths created when LiS is installed: @file{/dev/fifo} for the former, and
@file{/dev/fifo.0} for the latter.  It is recommended that these be used,
possibly along with the equivalent of stat(2) to determine appropriate
major device numbers for the clone and fifo pseudo-drivers, which are
also determined when LiS is installed.  It can be noted that pipes are
actually created as instances of the former, after which the write
queues are peer-connected.
@pgindex /dev/fifo
@pgindex /dev/fifo.0

The fifo pseudo-driver allocates minor devices in round-robin fashion;
i.e., a list of available minor devices is kept, and once a minor
number is finally closed, it is put at the end of this list.  Thus, a
fifo minor device which is opened and closed will not be immediately
reused.

@unnumberedsubsec Warnings

Because STREAMS-based fifos and pipes are implemented as character
special devices, they do not appear as pipe devices when examined with
stat(2) or the equivalent (e.g., ls(1)); i.e.  the S_IFIFO indication
is not set in the mode - S_IFCHR is set instead, and the actual device
number is indicated in the st_rdev field of the stat data structure.

Because of the potential use of multiple major numbers, applications
should not depend on a fifo or pipe having a specific major device
number, nor should an application depend on all fifos and pipes having
the same major device number.

@unnumberedsubsec See Also

clone(9), connld(9), fifo(4), ls(1), pipe(3), pipemod(9), STREAMS(4),
stat(2), strconf(8)

@unnumberedsubsec Author

John Boyd, protologos LLC.  @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@ignore
@page
@node link-drvr
@subsection link-drvr

@unnumberedsubsec Device Name

@example
/dev/ldl @r{}(clone device)
@end example
@pgindex /dev/ldl

@unnumberedsubsec Description

The LDL driver provides an interface between STREAMS drivers and Linux
network drivers.  It registers itself as a client of a Linux network
driver and then presents a DLPI Provider interface to STREAMS drivers,
which may be pushed or linked above LDL.

The LDL is controlled by DLPI primitives from its upstream client.
The DLPI primitives understood by this driver are as follows.  DLPI
mnemonics come from the file <sys/dlpi.h>.  LDL mnemonics come from
the file <sys/ldl.h>.

@unnumberedsubsec @code{DL_INFO_REQ}

@vrindex DL_INFO_ACK
Causes LDL to return a @code{DL_INFO_ACK}.  If the stream has not been
attached to a device then the returned values will consist of default
values.  If the stream has been attached then information will be
returned that pertains the the underlying Linux network device.

@unnumberedsubsec @code{DL_PHYS_ADDR_REQ}

@vrindex DL_PHYS_ADDR_REQ
@vrindex DL_ERROR_ACK
Causes LDL to return a @code{DL_PHYS_ADDR_ACK} (or @code{DL_ERROR_ACK}).  The
response will contain the current physical address of the Linux
network device.  The option to retrieve the factory address is not
implemented and will always produce a @code{DL_ERROR_ACK} response.

@unnumberedsubsec @code{DL_ATTACH_REQ}

@vrindex DL_ATTACH_REQ
@vrindex DL_UNATTACHED
The stream must be in the @code{DL_UNATTACHED} state for this primitive to
succeed.

The dl_ppa field specifies the device number of the Linux network
device to attach in its low order bits.  In the LDL_FRAME_MASK bits,
the dl_ppa specifies the framing type to use with the device.  The
valid framing types are: LDL_FRAME_EII, LDL_FRAME_802_2,
LDL_FRAME_802_3, LDL_FRAME_SNAP and LDL_FRAME_RAW_LLC.

@vrindex DL_ATTACH_REQ
The device number is usually obtained by issuing an LDL_FINDPPA
ioctl.  This ioctl takes a network device mnemonic, such as "etho", as
an argument and produces a number suitable for use as the dl_ppa value
in a @code{DL_ATTACH_REQ}.

@vrindex DL_OK_ACK
@vrindex DL_UNBOUND
@vrindex DL_ERROR_ACK
If the attach succeeds, LDL returns a @code{DL_OK_ACK} and sets the state of
the stream to @code{DL_UNBOUND}.  It returns a @code{DL_ERROR_ACK} if it fails.

@unnumberedsubsec @code{DL_DETACH_REQ}

@vrindex DL_DETACH_REQ
Causes LDL to detach from the Linux network device.  The stream must
be in the @code{DL_UNBOUND} state for this primitive to be valid.

If the detach succeeds, LDL returns a @code{DL_OK_ACK} and sets the state of
the stream to @code{DL_UNATTACHED}.  It returns a @code{DL_ERROR_ACK} if it fails.

@unnumberedsubsec @code{DL_BIND_REQ}

@vrindex DL_BIND_REQ
Causes LDL to bind an address to the stream.  The stream must be in
the @code{DL_UNBOUND} state for this primitive to succeed.

The bound address is used in demultiplexing frames received from the
Linux network driver.  The SAP conveyed in the @code{DL_BIND_REQ} is used to
select those received frames that are sent upstream on a particular
stream.

@vrindex DL_IDLE
If the bind succeeds LDL returns a @code{DL_OK_ACK} and sets the state of the
stream to @code{DL_IDLE}.  If it fails then a @code{DL_ERROR_ACK} is sent upstream.

@unnumberedsubsec @code{DL_UNBIND_REQ}

@vrindex DL_UNBIND_REQ
Causes LDL to unbind all SAPs from the stream.  The stream must be in
the @code{DL_IDLE} state for this primitive to succeed.

@vrindex DL_UNBOUND
If the unbind succeeds, LDL returns a @code{DL_OK_ACK} and sets the state of
the stream to @code{DL_UNBOUND}.  If it fails then a @code{DL_ERROR_ACK} is sent
upstream.

@unnumberedsubsec @code{DL_SUBS_BIND_REQ}

@vrindex DL_SUBS_BIND_REQ
Causes LDL to add an additional SAP to the list of SAPs associated
with the stream.  The stream must be in the @code{DL_IDLE} state for this
primitive to succeed.

If the subs-bind succeeds, LDL returns a @code{DL_SUBS_BIND_ACK}.  If it
fails then a @code{DL_ERROR_ACK} is sent upstream.

@unnumberedsubsec @code{DL_SUBS_UNBIND_REQ}

@vrindex DL_SUBS_UNBIND_REQ
Causes LDL to remove the given SAP from the list of SAPs associated
with the stream.  The stream must be in the @code{DL_IDLE} state for this
primitive to succeed.

If the subs-unbind succeeds, LDL returns a @code{DL_OK_ACK}.  If it fails
then a @code{DL_ERROR_ACK} is sent upstream.  The state of the stream is left
in the @code{DL_IDLE} state in either case.

@unnumberedsubsec @code{DL_PROMISCON_REQ}

@vrindex DL_PROMISCON_REQ
The intent of this primitive is to set the Linux network device into
the so-called "promiscuous" mode of operation.  However, it is
unimplemented.

@unnumberedsubsec @code{DL_PROMISCOFF_REQ}

@vrindex DL_PROMISCOFF_REQ
This primitive would undo the effect of a @code{DL_PROMISCON_REQ}.  However,
it is unimplemented.

@unnumberedsubsec @code{DL_UNITDATA_REQ}

@vrindex DL_UNITDATA_REQ
This primitive is used to send data to the Linux network driver.  The
destination address is used to set the physical address of the
receiver of the data.  The stream must be in the @code{DL_IDLE} state for
this primitive to succeed.

If the stream is operating in raw mode then the address field is
ignored and it is assumed that the client has completely formatted the
frame for transmission by the Linux network driver.

@vrindex DL_UDERROR_IND
If this primitive fails, a @code{DL_UDERROR_IND} is sent upstream.  There is
no response in the case of success.

@unnumberedsubsec @code{M_DATA}

@vrindex M_DATA
@vrindex DL_UNITDATA_REQ
An @code{M_DATA} is an acceptable alternative to a @code{DL_UNITDATA_REQ} for
sending data on a raw-mode stream.

If the data transmission operation fails, a @code{DL_UDERROR_IND} is sent
upstream.  There is no response in the case of success.

@vrindex DL_UNITDATA_IND
For data received from the Linux network driver, LDL forwards a copy
of the received data in a @code{DL_UNITDATA_IND} DLPI message to each client
whose stream is attached to the particular network driver and who has
a SAP bound to the stream that matches the SAP information in the
received frame.  Note that for non-raw frame operations that the MAC
header is stripped from the received frame prior to forwarding it to
the client.  The address of the sender is retained in the address
field of the @code{DL_UNITDATA_IND} primitive.

@unnumberedsubsec Driver ioctls

The LDL driver implements the following ioctls.  The user codes these
ioctls as type I_STR and passes a structure of type struct strioctl to
the driver.  The ic_cmd field of this structure is decoded according
to the following table.  the ic_dp and ic_len fields delimit an
argument structure which is also passed to the driver.  The argument
structure differs for each type of ic_cmd.
@tpindex struct strioctl


@multitable @columnfractions .25 .25 .50
@item ic_cmd value @tab Argument Structure @tab Description

@item LDL_SETFLAGS @tab IN/OUT: struct ldl_flags_ioctl @tab Used to set
internal option flags for the open stream.  See ldl.c source for details.
@tpindex struct ldl_flags_ioctl

@item LDL_FINDPPA @tab IN: char[] OUT: long @tab The agrument is an ASCII
string representing a network device mnemonic such as "eth0." If such a
device can be found then the argument is overwritten with a long word
whose numerical value can be used as the dl_ppa field of a
@code{DL_ATTACH_REQ}.  @vrindex DL_ATTACH_REQ

@item LDL_GETNAME @tab IN: None OUT: char[] @tab This ioctl returns the
ASCII string form of the network device mnemonic for the stream.
@end multitable

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@end ignore

@page
@node loop-around
@subsection loop-around

@unnumberedsubsec Device Name

@example
/dev/loop_clone @r{}(clone device)
/dev/loop.1
/dev/loop.2
@end example
@pgindex /dev/loop_clone
@pgindex /dev/loop.1
@pgindex /dev/loop.2

@unnumberedsubsec Description

This driver is used by LiS and the strtst utility to assist in the
regression testing of LiS.  It connects two streams together in a
manner similar to that of a pipe.  Messages written into one stream
can be read back from the other.

The driver can be operated as a clone device with the two streams
being connected via ioctls.  A number of ioctls exist that tailor the
operation of the driver.  The user codes these ioctls as type I_STR
and passes a structure of type struct strioctl to the driver.  The
ic_cmd field of this structure is decoded according to the following
table.  the ic_dp and ic_len fields delimit an argument structure
which is also passed to the driver.  The argument structure differs
for each type of ic_cmd.
@tpindex struct strioctl

@multitable @columnfractions .25 .15 .60
@item ic_cmd value @tab Argument Structure @tab Description

@item LOOP_SET @tab IN: int @tab Argument is the minor device number of
the loop device to use for the other end of the connection.  If the
loop-around device had been opened by a directed open, such as to
@file{/dev/loop.1}, then the minor device number is known from the device
node.  If it was opened via the @file{/dev/loop_clone} device then the
minor device can be discovered via the LOOP_GET_DEV ioctl.
@pgindex /dev/loop_clone
@pgindex /dev/loop.1

@item LOOP_PUTNXT @tab None @tab Set the driver into a mode in which it
will perform a direct putnext call on the other stream rather than the
default behavior of using the service queue to forward the message.

@item LOOP_MSGLVL @tab IN: int @tab Set to the number of messages to queue
in the service queue before forwarding to the other stream.  Zero means
forward immediately.

@item LOOP_TIMR @tab IN: int @tab Set the number of "ticks" to hold
messages before forwarding them to the other stream.

@item LOOP_MARK @tab IN: int @tab Set the MSGMARK flag for each of the
next n messages before forwarding them to the other stream.

@item LOOP_GET_DEV @tab OUT: int @tab Return the minor device number of
this stream.  Useful for finding out the minor number of a clone device.

@item LOOP_BUFCALL @tab None @tab Use the bufcall mechanism to allocate a
buffer for copying the next message.

@item LOOP_CONCAT @tab IN: int @tab Concatenate this many messages into a
single message and then forward on the other stream.  One concatenation
resets this value to zero and the ioctl needs to be issued again to repeat
the behavior.

@item LOOP_COPY @tab None @tab From this point on, copy messages rather
than passing them through to the other stream.
@end multitable

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com} plus others originally.
@auindex Grothe, David


@page
@node mini-mux
@subsection mini-mux

@unnumberedsubsec Device Name

@example
/dev/mux_clone @r{}(clone device)
/dev/minimux.1
/dev/minimux.2
@end example
@pgindex /dev/mux_clone
@pgindex /dev/minimux.1
@pgindex /dev/minimux.2

@unnumberedsubsec Description

This driver is used by LiS in its testing procedures.  It is a small
multiplexing driver that allows cascaded multiplexors to be built and
torn down.  The driver uses a pair of ioctls to establish connectivity
between upper streams and lower streams.  This allows control over how
data flows through the multiplexor.

Both of these ioctls are coded as type I_STR and pass a structure of
type struct strioctl to the driver.  The ic_cmd field of this
structure is decoded according to the following table.  the ic_dp and
ic_len fields delimit an argument structure which is also passed to
the driver.  The argument structure may differ for each type of
ic_cmd.
@tpindex struct strioctl

@multitable @columnfractions .25 .15 .60
@item ic_cmd value @tab Argument Structure @tab Description

@item MINIMUX_UP @tab IN: int @tab The argument is a muxid that was
returned from an I_LINK ioctl.  This ioctl causes the lower stream
indicated by the muxid to be connected to this stream.  This is
unidirectional linkage and only affects the upstream flow of messages.

@item MINIMUX_DOWN @tab IN: int @tab The argument is a muxid that was
returned from an I_LINK ioctl.  This ioctl causes this stream to be
connected to the lower stream indicated by the muxid.  This is
unidirectional linkage and only affects the downstream flow of messages.
@end multitable

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David


@page
@node printk
@subsection printk

@unnumberedsubsec Device Name

@example
/dev/printk
@end example
@pgindex /dev/printk

@unnumberedsubsec Description

This driver accepts messages written to it and prints them from the
kernel using the kernel's printk function.  It is used by the LiS test
software to keep messages from LiS and messages from the test program
in sequence.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node sad
@subsection sad

@unnumberedsubsec Device Name

@example
/dev/sad
@end example
@pgindex /dev/sad

@unnumberedsubsec Description

The STREAMS Administrative Driver manages the autopush function of
LiS.  Using ioctls the system administrator can provide a list of
modules that are to be automatically pushed onto a given device when
that device is opened.  The controls are specified via the strapush
structure which is defined in <sys/sad.h>.

The ioctl used by the user is of the form:

ioctl(fd, command, arg)

Where fd is the file descriptor of the file that is open to the sad
driver, command and arg are described in the following table.

@multitable @columnfractions .15 .3 .55
@item Command @tab Argument @tab Description
@item
@item SAD_SAP @tab struct strapush * @tab Set the list of autopushed
modules according to the sap_cmd and other arguments contained within the
strapush structure.
@tpindex struct strapush
@item
@item SAD_GAP @tab struct strapush * @tab Get the list of configured
autopushed modules associated with the indicated major and minor device
number.  The sad driver fills in this structure with the names of the
modules and the applicable range of minor device numbers.
@tpindex struct strapush
@item
@item SAD_VML @tab struct str_list * @tab Validates a list of pushable
module names to verify that they are installed in LiS.  The str_list
structure is defined in the file @file{<sys/stropts.h>}.
@tpindex struct str_list
@pgindex stropts.h
@end multitable

The @dfn{strapush} structure used by the SAD_SAP and SAD_GAP ioctls
contains the following fields.
@tpindex strapush

@table @code
@item unsigned sap_cmd
This is the autopush command to be executed.  The values are as follows.

@table @code
@item SAP_ONE
Configure one minor device of the driver indicated by sap_major.

@item SAP_RANGE
Configure a range of minor devices of the driver indicated by sap_major.
The range runs from sap_minor to sap_lastminor, inclusively.

@item SAP_ALL
Configure all minor devices of the driver indicated by sap_major.

@item SAP_CLEAR
Undo all autopush configuration for the driver indicated by sap_major.
@end table

@item major_t sap_major
The major device number of the driver which is being configured for
autopush.

@item minor_t sap_minor
The minor device being configured, or the first of a range.

@item minor_t sap_lastminor
The last minor device of a range to be configured.

@item unsigned sap_npush
Number of modules to be pushed when the indicated device is opened.

@item char sap_list[MAXAPUSH][FMNAMESZ+1]
List of module names to be pushed, or list of modules names returned to
user.
@end table


The ioctl function call returns zero upon success or -1 on failure.
Upon failure errno is set to the error number describing the failure,
usually either EFAULT or EINVAL.

Note that the sad driver is a standard AT&T STREAMS function.  More
comprehensive documentation for this driver can be found in the
[40]SVR4 Programmer's Guide: STREAMS.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole

@node Pushable Modules
@section Pushable Modules

A pushable module in STREAMS is an entity that is added to an existing STREAMS
file via the I_PUSH ioctl.  These modules are known to LiS by mnemonic name,
given as an argument to the I_PUSH ioctl.  There are no major and minor device
numbers or @file{/dev} entries associated with pushable modules.
@pgindex /dev

This document is broken down into two sections.  The STREAMS drivers and pushable
modules are documented separately.  The driver names used in this document are
the declared names that appear in the LiS @file{Config} file for the particular driver.
@pgindex Config

@menu
* connld::				Connection listening daemon.
@ignore
* ip_strms::				IP streams driver.
@end ignore
* pipemod::				STREAMS-based Pipes.
* relay relay2::			Relay test driver.
@ignore
* timod::				XTI/TLI library module.
* tirdwr::				XTI/TLI read/write module.
@end ignore
@end menu

@page
@node connld
@subsection connld

@unnumberedsubsec Module Name

connld

@unnumberedsubsec Description

The connld module provides a means to generate multiple unique STREAMS-based
pipes from a single existing pipe end.  connld may only be pushed (via the
STREAMS I_PUSH ioctl) onto a STREAMS-based pipe.  When first pushed, connld
does nothing; on each subsequent open(2), connld will generate a unique
STREAMS-based pipe.  One end of each new pipe replaces the original pipe end
from the perspective of the open call.  The other end of each new pipe is sent,
effectively as if by the I_SENDFD ioctl, to the other end of the original
pipe, ostensibly to be received by a subsequent I_RECVFD ioctl operation.

@unnumberedsubsec Application Usage

The intent of connld is to provide a means to generate unique pipes which
separately and independently connect client processes to a server process.  The
point of access for such clients is expected to be a path name known to all
such clients and to which a pipe end may be connected (via fattach(3)) by the
server process.  The server establishes the original pipe, pushes connld onto
the client end, and then listens via I_RECVFD for new connections on the
server end.  A client wishing to connect to the server will open(2) the path
name representing the client end, and can determine via isastream(3) whether
or not the server process is active and attached.  If it is, the open() call
returns one end of a unique new pipe that thus connects the client to the
server.

Such a server is responsible both for accepting new connections via I_RECVFD
on the original pipe, and for communicating with clients so connected via the
received pipe ends.  It would also be reasonable for such a server process to
invalidate the point of access by calling fdetach(3) before terminating.

@vrindex M_PASSFP
It should be noted that the poll(2) primitive may be used to indicate when an
@code{M_PASSFP} representing a newly passed file is available on the original server
pipe end.  This is reflected by the POLLIN status setting in the events and
revents fields of a pollfd structure.  Moreover, any attempt to read an
@code{M_PASSFP} message via the data-receiving primitives (i.e., read(2), getmsg(3),
and getpmsg(3)) will fail with errno(3) returning an EBADMSG indication
without discarding the message.

Even so, it should be reasonable to expect only @code{M_PASSFP} messages will be
received on the original server pipe end, since it is not possible to carry on
normal data traffic which has connld on one end, since connld does not support
such traffic.

The use of connld can be made entirely free-standing by attaching well-known
paths to both ends of the original pipe.  The relevant capabilities are
implemented in LiS so that the original creator of the pipe can close both
ends after attaching paths to them, and the process of passing file
descriptors can still be carried out via new open()'s as long as both ends
remain attached.

@unnumberedsubsec See Also

fattach(3), fattach(8), fdetach(3), fifo(4), fifo(9),

pipe(3), STREAMS(4)

@unnumberedsubsec History

Unix System V Release 4 (SVR4)

@unnumberedsubsec Author

John Boyd, protologos LLC.  @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@ignore
@page
@node ip_strms
@subsection ip_strms

@unnumberedsubsec Module Name

ip_strms

@unnumberedsubsec Description

This module is pushed onto an open stream to a driver which implements the
DLPI STREAMS protocol.  It provides an interface between the DLPI driver below
and the Linux IP module above.  The effect is to be able to use a STREAMS DLPI
driver as a network interface below Linux TCP/IP.

The ip_strms module monitors DLPI primitives sent from above on the stream
file and shuttles them between the process which pushed the module onto the
stream and the DLPI driver below.  The ip_strms module will also allow data to
be exchanged between the stream user and the DLPI driver until such time as
the stream is logically attached to IP as a network driver.

@vrindex M_DATA
@vrindex DL_UNITDATA_REQ
@vrindex DL_UNITDATA_IND
In order to attach the stream to IP, the user process issues an ioctl of type
SIOCSIFNAME.  This ioctl causes ip_strms to register itself as a network driver
of the given name.  From that point onward data, in the form of @code{M_DATA} messages
or of @code{DL_UNITDATA_IND} messages, are forwarded upstream to IP rather than to
the stream user.  Likewise, data messages received from IP are forwarded
downstream to the DLPI driver as @code{DL_UNITDATA_REQ} messages.  Downstream messages
are completely formatted for the transmission medium and should be processed
accordingly by the DLPI driver below.

After attaching to IP, the stream user must continue to remain in execution,
holding the stream open.  If the stream closes then ip_strms will detach from
IP.  Also, if the stream user sends a SIOCSIFNAME ioctl with an empty name then
ip_strms will detach from IP.

The interfaces attached to IP will appear in the output of the netstat and
ifconfig commands.  An "ifconfig" down operation on the interface will also
cause a detach from IP.

@unnumberedsubsec Application Processing

The application level program which manages the connection between a DLPI
driver and TCP/IP should be coded to implement the following steps.

@itemize @bullet
@item Open a stream to the DLPI driver.  This can be a clone open.
@item Execute an I_PUSH ioctl on "ip_strms."
@item Send the DLPI attach and bind primitives downstream.
@item Execute an SIOCSIFNAME ioctl with the desired interface name.  After this
succeeds the DLPI driver will be connected to TCP/IP as a network driver via the
ip_strms module.
@item Perform any needed ifconfig or route commands for the interface.
@item Sleep indefinitely keeping the stream open.  Killing the process will cause
the stream to be detached from IP.
@end itemize

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David
@end ignore

@page
@node pipemod
@subsection pipemod

@unnumberedsubsec Module Name

pipemod

@unnumberedsubsec Description

@vrindex M_FLUSH
The pipemod module has the relatively simple task of reversing the sense of
the FLUSH flag bits in @code{M_FLUSH} messages sent in STREAMS-based fifos and pipes.
This must happen at the midpoint of a fifo or pipe, so that FLUSHR becomes
FLUSHW, and FLUSHW becomes FLUSHR.  pipemod does this, and has no other
function.

To be used appropriately, then, pipemod must be the first module pushed onto a
pipe end or a fifo, but it is only necessary on one end of a pipe.

pipemod is not needed if flush handling need not be supported, or if its
function is supported by other means.

@unnumberedsubsec See Also

fifo(9), pipe(3), fifo(4), STREAMS(4)

@unnumberedsubsec History

Unix System V Release 4 (SVR4)

@unnumberedsubsec Author

John Boyd, protologos LLC.  @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@page
@node relay relay2
@subsection relay, relay2

@unnumberedsubsec Module Name

relay
relay2

@unnumberedsubsec Description

These are two names for the same module.  All the module does is forward
STREAMS messages along on the stream using putnext.  These modules are used in
the testing of LiS but are not otherwise useful.  One could use the source
code as a starting point for coding a pushable STREAMS module.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@ignore
@page
@node timod
@subsection timod

@unnumberedsubsec Module Name

timod

@unnumberedsubsec Description

This is a primitive version of the standard AT&T SVR4 timod module.  Its
function is to convert user level ioctls to TLI primitives downstream.

Since there is no TLI Provider code within LiS, the timod module could be
considered to be well ahead of its time.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole


@page
@node tirdwr
@subsection tirdwr

@unnumberedsubsec Module Name

tirdwr

@unnumberedsubsec Description

This is a primitive version of the standard AT&T SVR4 tirdwr module.  Its
function is to convert user level reads and writes to appropriate TLI protocol
downstream.

Since there is no TLI Provider code within LiS, the tirdwr module could be
considered to be well ahead of its time.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@end ignore


@page
@node Licenses
@unnumbered Licenses

@include texi/gpl.texi
@page
@include texi/lesser.texi
@page
@include texi/fdl.texi

@page
@node Author Index
@unnumbered Author Index
@printindex au

@page
@node Concept Index
@unnumbered Concept Index
@printindex cp

@page
@node Function and Macro Index
@unnumbered Function and Macro Index
@printindex fn

@page
@node Variable and Constant Macro Index
@unnumbered Variable and Constant Macro Index
@printindex vr

@page
@node Data Type Index
@unnumbered Data Type Index
@printindex tp

@page
@node Program and File Index
@unnumbered Program and File Index
@printindex pg

@page
@node Configuration Keyword Index
@unnumbered Configuration Keyword Index
@printindex ky


@page
@shortcontents
@page
@contents
@bye
