% -*- texinfo -*- vim: ft=texinfo
% =========================================================================
%
% @(#) $Id: LiS.texi,v 1.1.6.5 2005/03/15 12:06:37 brian Exp $
%
% =========================================================================
%
% Copyright (C) 2001-2005  OpenSS7 Corporation <www.openss7.com>
% Copyright (C) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any success
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2005/03/15 12:06:37 $ by $Author: brian $
%
% =========================================================================

\input texinfo
@setfilename LiS.info
@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE Installation and Reference Manual
@settitle @value{MANUAL_TITLE}

@dircategory Kernel
@direntry
* Linux STREAMS: (LiS).                         Sys V STREAMS for Linux.
@end direntry

@defindex op

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE Installation and Reference Manual

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file provides the @value{MANUAL_TYPE} for @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of the
@cite{@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
Release @value{PACKAGE_RELEASE}.

Copyright @copyright{} 2001-2005  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

All Rights Reserved.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through Tex and print the results,
provided the printed document carries copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE @value{PACKAGE_TITLE}
@set MANUAL_TYPE Installation and Reference Manual

@ignore
@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@end ignore
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Package @value{PACKAGE}-@value{VERSION}
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2005  OpenSS7 Corporation <@uref{http://www.openss7.com/}> @*
Copyright @copyright{} 1997-2000  Brian F. G. Bidulock <@email{bidulock@@openss7.org}> @*
All Rights Reserved. @*

@noindent
Published by OpenSS7 Corporation @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
This is texinfo edition @value{PACKAGE_RELEASE} of the @value{MANUAL_TITLE}
documentation, and is consistent with @value{PACKAGE_NAME} @value{PACKAGE_VERSION}.
This manual was developed under the @uref{http://www.openss7.org/, OpenSS7
Project} and was funded in part by
@uref{http://www.hob.de/, HOB International}.

@noindent
Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@noindent
Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.

@noindent
Permission is granted to copy and distribute translations of this manual into
another language, under the same conditions as for modified versions.

@vskip 0pt
@end titlepage
@page

@c Define an index of authors.
@defindex au

@c Define an index of configure output variables.
@c @defcodeindex ov

@c Define an index of configure variables.
@c @defcodeindex cv

@c Define an index of options.
@c @defcodeindex op

@c Define an index of targets.
@c @defcodeindex tr

@c Define an index of commands.
@c @defcodeindex cm

@c Put the macros and variables into their own index.
@c @syncodeindex fn cp
@c @syncodeindex ov vr
@c @syncodeindex cv vr
@c @syncodeindex fn vr

@c Put everything else into one index (arbitrarily chosen to be the concept index).
@c @syncodeindex op cp
@c @syncodeindex tr cp
@c @syncodeindex cm cp

@ifnottex
@node Top
@top @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@unnumbered About This Manual
This is Edition @value{PACKAGE_RELEASE}, last updated @value{PACKAGE_DATE}, of @cite{The
@value{MANUAL_TITLE} @value{MANUAL_TYPE}}, for Version @value{PACKAGE_VERSION}
release @value{PACKAGE_RELEASE} of the @value{PACKAGE_TITLE} package.
@end ifnottex

@menu
* Acknowledgements::		Sponsors and Contributors
* Introduction::		Introduction to the package
* Objective::			Objective of the package
* Reference::			Contents of the package
* Conformance::			Conformance of the package
* Releases::			Releases of the package
* Installation::		Installation of the package
* Copying::			Copying information for this Software
* Documentation License::	Copying information for this Manual
* Indices::			Indices
@end menu

@c --------------------------------------------------------------------------

@node Acknowledgements
@unnumbered Acknowledgements
@cindex credits

@menu
* Sponsors::			Sponsors
* Contributors::		Contributors
@end menu

@node Sponsors
@section Sponsors
@cindex sponsors

Funding for maintenance of the @value{PACKAGE_TITLE} package was provided in
part by:

@itemize
@item OpenSS7 Corporation
@end itemize

@node Contributors
@section Contributors
@cindex contributors

The current maintainer of the @value{PACKAGE_TITLE} package is
@email{bidulock@@openss7.org, Brian F. G. Bidulock}.
@ignore
The following is a list of significant contributors to the project:
@end ignore

@subsection Authors

Linux STREAMS, termed LiS, is an SVR4 compatible STREAMS executive which runs in
the Linux Kernel as a loadable module.  It is the product of a joint effort
among the following authors.

@itemize @asis
@item Francisco J. Ballesteros @email{nemo@@gsyc.escet.urjc.es}
@auindex Ballesteros, Francisco J.
@item John Boyd @email{jaboydjr@@netwalk.com}
@auindex Boyd, John
@item Denis Froschauer @email{Denis.Froschauer@@hol.fr}
@auindex Froschauer, Denis
@item David Grothe @email{dave@@gcom.com}
@auindex Grothe, David
@item Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@item Jürgen Magin @email{juergen.magin@@octogon.de}
@auindex Magin, Jürgen
@item Graham Wheeler @email{gram@@cdsec.com}
@auindex Wheeler, Graham
@item G Yeganjaiah @email{yegag@@hclt.com}
@auindex Yeganjaiah, G
@item Brian Bidulock @email{bidulock@@openss7.org}
@auindex Bidulock, Brian F. G.
@end itemize

Brian Bidulock is the principal active maintainer of LiS, so please direct
questions to him rather than the others.@footnote{David Grothe was the previous
maintainer of the LiS-2.18 releases; however, David is no longer maintaining any
version of LiS.  Please do not direct maintenance requests at David.}
@ignore
David Grothe is the principal active supporter of LiS, so please direct
questions to him rather than to the others.
@end ignore
Ole Husgaard
@ignore
is responsible for the ldl driver and
@end ignore
has contributed to the kerneld support and installation procedures.  Jürgen
Magin contributed patches for Linux SPARC.  G Yeganjaiah added interrupt routine
support.  John Boyd implemented fattach and STREAMS pipes and FIFOs.  Brian
Bidulock developed a complete set of manual pages for LiS, converted the build
process to autoconf, wrapped the source RPMS, updated this manual for texinfo
and currently maintains and the package.

See @ref{Author Index}, for a complete listing and cross-index of authors to
sections of this document.

Francisco Ballesteros still maintains an LiS mailing list.  Click Here to
Subscribe to the LiS mailing list
@auindex Grothe, David
@auindex Husgaard, Ole
@auindex Boyd, John
@auindex Ballesteros, Francisco J.
@auindex Magin, Jürgen
@auindex Yeganjaiah, G
@auindex Bidulock, Brian F. G.

You can mail to the group by addressing email to
@email{linux-streams@@gsyc.escet.urjc.es}.

You can view the archives at
@uref{http://gsyc.escet.urjc.es/mailarchive/linux-streams}.

@node Introduction
@chapter Introduction
@cindex introduction

This manual documents the design, implementation, installation, operation and
future development schedule of the @value{PACKAGE_TITLE} package.

@c ----------------------------------------------------------------------------

@menu
* Notice::			Notice
* Overview::			Overview
* Organization::		Organization
* Conventions::			Conventions
@end menu

@node Notice
@section Notice
@cindex notice
@cindex licensing

This package is released and distributed under the @cite{GNU General Public
License} (@pxref{Copying}).  Please note, however, that there are different
licensing terms for the manual pages and some of the documentation (derived from
X/Open publications and other sources).  Consult the permission notices
contained in the documentation for more information.  This document, is released
under the @cite{GNU Free Documentation License} (@pxref{Documentation License})
with all sections invariant.

@node Overview
@section Overview
@cindex overview

This manual documents the design, implementation, installation, operation and
future development of the @value{PACKAGE_TITLE} package.

LiS is a software package that comprises an implementation of SVR4 compatible
STREAMS for Linux.  It takes the form of a loadable module for the Linux kernel.
LiS installs in any directory on your system, not in the kernel source tree.
(@pxref{Installation})

@ignore
When it is built it is possible to link pre-compiled STREAMS drivers with it so
that when LiS loads into the kernel it brings "application" drivers with it.
(@pxref{Installing Pre-Compiled Drivers}) Alternatively, STREAMS drivers can be
coded as loadable Linux drivers which depend upon LiS.  (@pxref{Demand Loading
LiS Modules}) In this way, individual STREAMS drivers can be loaded and unloaded
dynamically.
@end ignore

@ignore
LiS includes two adapter drivers to assist in interfacing STREAMS drivers to the
Linux Kernel's TCP/IP protocols.  One driver, @dfn{ip_strm_mod}
(@pxref{ip_strms}), acts as an IP interface driver.  It fits below IP using
standard ifconfig procedures.  It, in turn, communicates downstream with any
STREAMS driver using the DLPI protocol in a fashion similar to the manner in
which IP on Unix systems interfaces to lower interface drivers.  This allows a
DLPI STREAMS driver to act as an interface driver to Linux TCP/IP.

A second driver, @dfn{ldl} (@pxref{link-drvr}), sits on top of any existing
Linux IP interface driver and presents a DLPI interface to STREAMS drivers
above.  This allows any STREAMS driver that communicates downstream using DLPI
to utilize the services of existing Linux drivers for Ethernet, token ring, etc.
@end ignore

LiS-2.12 and beyond utilizes aggressive multi-tasking in multiple CPU SMP
environments.  For further information concerning this implementation,
@pxref{LiS SMP Implementation}.

@ignore
LiS is licensed using the GNU General Public Library License.
@@ignore
(except for ldl, which is licensed under the standard GNU Public License).
@@end ignore
This means that you can link proprietary STREAMS drivers with LiS and load the
entirety into the Linux kernel without violating license restrictions.  This
licensing arrangement is intended to encourage commercial software vendors to
port STREAMS based driver packages to Linux.
@end ignore

@strong{WARNING:} This autoconf/RPM release of Linux STREAMS is distributed
under the terms of the GNU Public License (GPL) and @emph{not} the GNU Lesser
Public License (LGPL).

This means that you @emph{cannot} link proprietary STREAMS drivers with LiS and
load the entirety into the Linux kernel without violating license restrictions.
OpenSS7 Corporation can remove this restriction for subscribers and sponsors of
the OpenSS7 Project.

@ignore
@section LiS Documentation

These documentation pages are included in the LiS distribution.  You can also
access the original documentation release from Gcom's home page at
@uref{http://www.gcom.com}.  Gcom's site offers a search capability that allows
you to search the LiS documentation.  Just use the search mechanism on the home
page and restrict the search to the Linux portion of the site.
@end ignore

@node Organization
@section Organization of this Document
@cindex organization

This document is organized (loosely) into several sections as follows:

@ifnottex
@menu
  Introduction::		This introduction
* Objective::			Objective of the package
* Reference::			Contents of the package
* Conformance::			Conformance of the package
* Releases::			Releases of the package
* Installation::		Installation of the package
@end menu
@end ifnottex
@iftex
@multitable @columnfractions .50 .50
@item @ref{Introduction}.
@tab This introduction
@item @ref{Objective}.
@tab Objective of the package
@item @ref{Reference}.
@tab Contents of the package
@item @ref{Conformance}.
@tab Conformance of the package
@item @ref{Releases}.
@tab Releases of the package
@item @ref{Installation}.
@tab Installation of the package
@end multitable
@end iftex
@ifinfo
@multitable @columnfractions .50 .50
@item @ref{Introduction}.
@tab This introduction
@item @ref{Objective}.
@tab Objective of the package
@item @ref{Reference}.
@tab Contents of the package
@item @ref{Conformance}.
@tab Conformance of the package
@item @ref{Releases}.
@tab Releases of the package
@item @ref{Installation}.
@tab Installation of the package
@end multitable
@end ifinfo

@node Conventions
@section Conventions and Definitions
@cindex conventions
@cindex definitions

This manual uses @cite{texinfo} typographic conventions.

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Objective
@chapter Objective
@cindex objective

@c ----------------------------------------------------------------------------

@node Reference
@chapter Reference
@cindex reference

@menu
* Files::			Files included in the package
* Drivers::			Drivers included in the package
* Modules::			Modules included in the package
* Libraries::			Libraries included in the package
* Utilities::			Utilities included in the package
* Development::			Development against the package
@end menu

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Files
@section Files
@cindex headers

@include tree.texi

@table @file
@item specfs.o
@pgindex specfs.o
@item streams.o
@pgindex streams.o
@item streams-aixcompat.o
@pgindex streams-aixcompat.o
@item streams-hpuxcompat.o
@pgindex streams-hpuxcompat.o
@item streams-liscompat.o
@pgindex streams-liscompat.o
@item streams-osfcompat.o
@pgindex streams-osfcompat.o
@item streams-suncompat.o
@pgindex streams-suncompat.o
@item streams-svr4compat.o
@pgindex streams-svr4compat.o
@item streams-uw7compat.o
@pgindex streams-uw7compat.o
@end table

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Drivers
@section Drivers
@cindex drivers

The LiS package comes with a number of STREAMS drivers and pushable modules in
source code form.  A number of these drivers and modules are small entities that
are used in the testing of LiS.  They are included so as to make it easy for any
user to run the LiS tests for themselves.

Other drivers are used to
@ignore
interface between STREAMS and the Linux networking subsystem (link-drvr,
ip_strms).  Still others are used to
@end ignore
implement STREAMS based pipes and FIFOs.

A driver in STREAMS has a major and minor device number associated with it and
an entry in the @file{/dev} directory.  The driver is opened and closed just
like any file.
@pgindex /dev

The driver names used in this document are the declared names that appear in the
LiS @file{Config} file for the particular driver.
@pgindex Config

@ignore
@table @file
@item streams-mtdrv.o
@pgindex streams-mtdrv.o
Multithreaded test driver.
@@ignore
@item streams-clone.o
@pgindex streams-clone.o
Clone device driver.
@item streams-echo.o
@pgindex streams-echo.o
Echo (loopback) device driver.
@item streams-fifo.o
@pgindex streams-fifo.o
FIFO (Named Pipe) driver.
@item streams-log.o
@pgindex streams-log.o
STREAMS log driver.
@item streams-nsdev.o
@pgindex streams-nsdev.o
Named STREAMS device driver.
@item streams-nuls.o
@pgindex streams-nuls.o
Null stream driver.
@item streams-pipe.o
@pgindex streams-pipe.o
Pipe driver.
@item streams-sad.o
@pgindex streams-sad.o
STREAMS Administrative Driver.
@@end ignore
@end table
@end ignore

@menu
* clone-drvr::				The clone driver.
* fifo::				STREAMS-based FIFOs.
@ignore
* link-drvr::				Linux DL driver.
@end ignore
* loop-around::				Loop-around test driver.
* mini-mux::				Mini multiplexing driver.
* printk::				Print test driver.
* sad::					STREAMS Administrative Driver.
@end menu

@page
@node clone-drvr
@subsection clone-drvr

@unnumberedsubsec Device Name

@example
/dev/clone_drvr
@end example
@pgindex /dev/clone_drvr

@unnumberedsubsec Description

This driver is used to assist LiS in implementing the "clone" open
function.  It appears under its own name as @file{/dev/clone_drvr}.  By
convention, it is allocated the first major number of all the STREAMS
drivers.
@pgindex /dev/clone_drvr

In order to implement clone opens, one creates a node in the @file{/dev}
directory for a device whose major number is set to that of the clone
driver, and whose minor number is the major number of the driver to
which the clone open is to be directed.
@pgindex /dev

The clone driver's open routine forwards the open call to the target
driver, passing a unique flag that informs the driver that a clone
open is being requested.  The target driver then allocated a minor
device number to uniquely associate with this instance of the open
operation.  The clone driver synthesizes a new major/minor "device id"
to pass back to LiS.  LiS recognizes the change of major/minor from
the original open and takes steps to allocate control structures
unique to this open.

The "clone open" operation is intended to make is easy to open one
device from a pool of devices, such as pseudo ttys or logical
connections.  It saves application programs from having to scan a list
of device mnemonics issuing trial opens until one is found that
succeeds.

Note that the driver is named @file{/dev/clone_drvr} instead of the more
traditional SVR4 @file{/dev/clone}.  This is to avoid a conflict with
another driver named @file{/dev/clone} on Linux systems.
@pgindex /dev/clone
@pgindex /dev/clone_drvr

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node fifo
@subsection fifo

@unnumberedsubsec Device Name

@example
/dev/fifo @r{}(clone device)
/dev/fifo.0
@end example
@pgindex /dev/fifo
@pgindex /dev/fifo.0

@unnumberedsubsec Description

The fifo pseudo-driver (which is internal to LiS) provides
STREAMS-based fifos as single character special files, and
STREAMS-based pipes as pairs of character special files which are
interconnected (see pipe(3)).

STREAMS-based fifos differ from typical STREAMS-based character
special files in that there are not separate stream head and driver
queue pair within the STREAMS-based file.  Instead, a fifo is created
with only a single queue pair for the stream head.  Moreover, in a
typical driver queue pair, the write queue is not connected to a next
queue.  In a fifo, the write queue is directed to the read queue of the
pair.  A pipe comprises a pair of fifos, with the write queue of each
pair directed to the read queue of the other.  The two fifos comprising
a pipe are referred to as peers, and each somewhat represents a driver
to the other.  As a degenerate case, a fifo is its own peer.

STREAMS modules may be pushed onto fifos and pipes, but should not
expect a driver below them; instead, the SAMESTR() function should be
used from the write queue of a pair to determine if the module is the
lowest in the STREAMS-based file (this is called the midpoint).  The
structure of a fifo or pipe is preserved when modules are pushed (and
popped); i.e., the write queue at the midpoint will always be directed
at the read queue of the peer.

Input and output are handled at a fifo stream head as they would
normally be handled at a stream head.  In LiS, an fifo open() entry
point exists to assign minor device numbers to new opens under the
fifo major device number, and a close() entry point is used
correspondingly to release them.  These functions are kept in a
streamtab data struc ture (as they would normally be for any STREAMS
driver or module) which is private to the LiS implementation.

@unnumberedsubsec Application Usage

In the current Linux kernels, character special major numbers are
limited to 16 bits, and major and minor device numbers to 8 bits each.
This limits a system to 256 total major device numbers and 256 total
minor devices per major device number.  This is a rather severe
limitation where mechanisms like fifos and pipes are concerned.

However, a driver may handle more than one major device number.  The
fifo pseudo-driver uses this to overcome this limitation, by
supporting the automatic allocation and use of multiple major device
numbers for fifos and pipes.  Specifying more than 256 minor devices
is done in the usual manner, i.e., by specifying the number of "units"
in the appropriate @file{Config} file.  Enough major device numbers will be
allocated to cover the requested number of minor devices (if
available, else an error will occur in strconf(8)).  The number
allocated will include one minor device per major number to be used as
a fifo-specific clone minor device (specifically, minor number 0),
which exhibits special behavior.
@pgindex Config

Normally, when cloning is done via the clone pseudo-driver, the clone
major device number is used, along with the desired actual major
number as the minor device num ber.  When an open() is performed on
such a device, the clone open() routine in turn calls the appropriate
driver's open(), with the sflag parameter set to CLONEOPEN.  The
driver's open() is expected in this case to allocate an unused minor
device number, and return it via an entirely new device number in the
devp parameter.  In this way, a driver can change the device number to
be used for a STREAMS-based file.  When minor device 0 for a specified
for a fifo major device, the driver will also clone a new minor device
number.  However, LiS opens fifo devices differently; specifically,
when an already-opened fifo-specific clone minor device is reopened,
the new and subsequent opens will use the already-opened clone.  Thus,
using minor device 0 for a fifo when creating a file sys tem node will
ensure that all concurrent opens of the associated path name will use
the same STREAMS-based file; at the same time, opens of different file
system nodes via different paths will open their respectively
different STREAMS-based files.  This is essentially how kernel-based
fifos behave -applications and users of STREAMS-based fifos don't have
to keep track of minor numbers to achieve this same behavior when it
is desired.

It is in fact recommended that only two forms of file sys tem nodes be
used for STREAMS-based fifos: the clone major number as major number
with a fifo major number as minor number, to be used when every open
of the associated path must clone a new fifo, and a fifo major number
as major number with 0 as the minor number, to be used when new opens
are to clone a new fifo but subsequent concurrent opens are to use the
already opened fifo.  These are represented by two device special file
paths created when LiS is installed: @file{/dev/fifo} for the former, and
@file{/dev/fifo.0} for the latter.  It is recommended that these be used,
possibly along with the equivalent of stat(2) to determine appropriate
major device numbers for the clone and fifo pseudo-drivers, which are
also determined when LiS is installed.  It can be noted that pipes are
actually created as instances of the former, after which the write
queues are peer-connected.
@pgindex /dev/fifo
@pgindex /dev/fifo.0

The fifo pseudo-driver allocates minor devices in round-robin fashion;
i.e., a list of available minor devices is kept, and once a minor
number is finally closed, it is put at the end of this list.  Thus, a
fifo minor device which is opened and closed will not be immediately
reused.

@unnumberedsubsec Warnings

Because STREAMS-based fifos and pipes are implemented as character
special devices, they do not appear as pipe devices when examined with
stat(2) or the equivalent (e.g., ls(1)); i.e.  the S_IFIFO indication
is not set in the mode - S_IFCHR is set instead, and the actual device
number is indicated in the st_rdev field of the stat data structure.

Because of the potential use of multiple major numbers, applications
should not depend on a fifo or pipe having a specific major device
number, nor should an application depend on all fifos and pipes having
the same major device number.

@unnumberedsubsec See Also

clone(9), connld(9), fifo(4), ls(1), pipe(3), pipemod(9), STREAMS(4),
stat(2), strconf(8)

@unnumberedsubsec Author

John Boyd, protologos LLC.  @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@ignore
@page
@node link-drvr
@subsection link-drvr

@unnumberedsubsec Device Name

@example
/dev/ldl @r{}(clone device)
@end example
@pgindex /dev/ldl

@unnumberedsubsec Description

The LDL driver provides an interface between STREAMS drivers and Linux
network drivers.  It registers itself as a client of a Linux network
driver and then presents a DLPI Provider interface to STREAMS drivers,
which may be pushed or linked above LDL.

The LDL is controlled by DLPI primitives from its upstream client.
The DLPI primitives understood by this driver are as follows.  DLPI
mnemonics come from the file <sys/dlpi.h>.  LDL mnemonics come from
the file <sys/ldl.h>.

@unnumberedsubsec @code{DL_INFO_REQ}

@vrindex DL_INFO_ACK
Causes LDL to return a @code{DL_INFO_ACK}.  If the stream has not been
attached to a device then the returned values will consist of default
values.  If the stream has been attached then information will be
returned that pertains the the underlying Linux network device.

@unnumberedsubsec @code{DL_PHYS_ADDR_REQ}

@vrindex DL_PHYS_ADDR_REQ
@vrindex DL_ERROR_ACK
Causes LDL to return a @code{DL_PHYS_ADDR_ACK} (or @code{DL_ERROR_ACK}).  The
response will contain the current physical address of the Linux
network device.  The option to retrieve the factory address is not
implemented and will always produce a @code{DL_ERROR_ACK} response.

@unnumberedsubsec @code{DL_ATTACH_REQ}

@vrindex DL_ATTACH_REQ
@vrindex DL_UNATTACHED
The stream must be in the @code{DL_UNATTACHED} state for this primitive to
succeed.

The dl_ppa field specifies the device number of the Linux network
device to attach in its low order bits.  In the LDL_FRAME_MASK bits,
the dl_ppa specifies the framing type to use with the device.  The
valid framing types are: LDL_FRAME_EII, LDL_FRAME_802_2,
LDL_FRAME_802_3, LDL_FRAME_SNAP and LDL_FRAME_RAW_LLC.

@vrindex DL_ATTACH_REQ
The device number is usually obtained by issuing an LDL_FINDPPA
ioctl.  This ioctl takes a network device mnemonic, such as "etho", as
an argument and produces a number suitable for use as the dl_ppa value
in a @code{DL_ATTACH_REQ}.

@vrindex DL_OK_ACK
@vrindex DL_UNBOUND
@vrindex DL_ERROR_ACK
If the attach succeeds, LDL returns a @code{DL_OK_ACK} and sets the state of
the stream to @code{DL_UNBOUND}.  It returns a @code{DL_ERROR_ACK} if it fails.

@unnumberedsubsec @code{DL_DETACH_REQ}

@vrindex DL_DETACH_REQ
Causes LDL to detach from the Linux network device.  The stream must
be in the @code{DL_UNBOUND} state for this primitive to be valid.

If the detach succeeds, LDL returns a @code{DL_OK_ACK} and sets the state of
the stream to @code{DL_UNATTACHED}.  It returns a @code{DL_ERROR_ACK} if it fails.

@unnumberedsubsec @code{DL_BIND_REQ}

@vrindex DL_BIND_REQ
Causes LDL to bind an address to the stream.  The stream must be in
the @code{DL_UNBOUND} state for this primitive to succeed.

The bound address is used in demultiplexing frames received from the
Linux network driver.  The SAP conveyed in the @code{DL_BIND_REQ} is used to
select those received frames that are sent upstream on a particular
stream.

@vrindex DL_IDLE
If the bind succeeds LDL returns a @code{DL_OK_ACK} and sets the state of the
stream to @code{DL_IDLE}.  If it fails then a @code{DL_ERROR_ACK} is sent upstream.

@unnumberedsubsec @code{DL_UNBIND_REQ}

@vrindex DL_UNBIND_REQ
Causes LDL to unbind all SAPs from the stream.  The stream must be in
the @code{DL_IDLE} state for this primitive to succeed.

@vrindex DL_UNBOUND
If the unbind succeeds, LDL returns a @code{DL_OK_ACK} and sets the state of
the stream to @code{DL_UNBOUND}.  If it fails then a @code{DL_ERROR_ACK} is sent
upstream.

@unnumberedsubsec @code{DL_SUBS_BIND_REQ}

@vrindex DL_SUBS_BIND_REQ
Causes LDL to add an additional SAP to the list of SAPs associated
with the stream.  The stream must be in the @code{DL_IDLE} state for this
primitive to succeed.

If the subs-bind succeeds, LDL returns a @code{DL_SUBS_BIND_ACK}.  If it
fails then a @code{DL_ERROR_ACK} is sent upstream.

@unnumberedsubsec @code{DL_SUBS_UNBIND_REQ}

@vrindex DL_SUBS_UNBIND_REQ
Causes LDL to remove the given SAP from the list of SAPs associated
with the stream.  The stream must be in the @code{DL_IDLE} state for this
primitive to succeed.

If the subs-unbind succeeds, LDL returns a @code{DL_OK_ACK}.  If it fails
then a @code{DL_ERROR_ACK} is sent upstream.  The state of the stream is left
in the @code{DL_IDLE} state in either case.

@unnumberedsubsec @code{DL_PROMISCON_REQ}

@vrindex DL_PROMISCON_REQ
The intent of this primitive is to set the Linux network device into
the so-called "promiscuous" mode of operation.  However, it is
unimplemented.

@unnumberedsubsec @code{DL_PROMISCOFF_REQ}

@vrindex DL_PROMISCOFF_REQ
This primitive would undo the effect of a @code{DL_PROMISCON_REQ}.  However,
it is unimplemented.

@unnumberedsubsec @code{DL_UNITDATA_REQ}

@vrindex DL_UNITDATA_REQ
This primitive is used to send data to the Linux network driver.  The
destination address is used to set the physical address of the
receiver of the data.  The stream must be in the @code{DL_IDLE} state for
this primitive to succeed.

If the stream is operating in raw mode then the address field is
ignored and it is assumed that the client has completely formatted the
frame for transmission by the Linux network driver.

@vrindex DL_UDERROR_IND
If this primitive fails, a @code{DL_UDERROR_IND} is sent upstream.  There is
no response in the case of success.

@unnumberedsubsec @code{M_DATA}

@vrindex M_DATA
@vrindex DL_UNITDATA_REQ
An @code{M_DATA} is an acceptable alternative to a @code{DL_UNITDATA_REQ} for
sending data on a raw-mode stream.

If the data transmission operation fails, a @code{DL_UDERROR_IND} is sent
upstream.  There is no response in the case of success.

@vrindex DL_UNITDATA_IND
For data received from the Linux network driver, LDL forwards a copy
of the received data in a @code{DL_UNITDATA_IND} DLPI message to each client
whose stream is attached to the particular network driver and who has
a SAP bound to the stream that matches the SAP information in the
received frame.  Note that for non-raw frame operations that the MAC
header is stripped from the received frame prior to forwarding it to
the client.  The address of the sender is retained in the address
field of the @code{DL_UNITDATA_IND} primitive.

@unnumberedsubsec Driver ioctls

The LDL driver implements the following ioctls.  The user codes these
ioctls as type I_STR and passes a structure of type struct strioctl to
the driver.  The ic_cmd field of this structure is decoded according
to the following table.  the ic_dp and ic_len fields delimit an
argument structure which is also passed to the driver.  The argument
structure differs for each type of ic_cmd.
@tpindex struct strioctl


@multitable @columnfractions .25 .25 .50
@item ic_cmd value @tab Argument Structure @tab Description

@item LDL_SETFLAGS @tab IN/OUT: struct ldl_flags_ioctl @tab Used to set
internal option flags for the open stream.  See ldl.c source for details.
@tpindex struct ldl_flags_ioctl

@item LDL_FINDPPA @tab IN: char[] OUT: long @tab The agrument is an ASCII
string representing a network device mnemonic such as "eth0." If such a
device can be found then the argument is overwritten with a long word
whose numerical value can be used as the dl_ppa field of a
@code{DL_ATTACH_REQ}.  @vrindex DL_ATTACH_REQ

@item LDL_GETNAME @tab IN: None OUT: char[] @tab This ioctl returns the
ASCII string form of the network device mnemonic for the stream.
@end multitable

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@end ignore

@page
@node loop-around
@subsection loop-around

@unnumberedsubsec Device Name

@example
/dev/loop_clone @r{}(clone device)
/dev/loop.1
/dev/loop.2
@end example
@pgindex /dev/loop_clone
@pgindex /dev/loop.1
@pgindex /dev/loop.2

@unnumberedsubsec Description

This driver is used by LiS and the strtst utility to assist in the
regression testing of LiS.  It connects two streams together in a
manner similar to that of a pipe.  Messages written into one stream
can be read back from the other.

The driver can be operated as a clone device with the two streams
being connected via ioctls.  A number of ioctls exist that tailor the
operation of the driver.  The user codes these ioctls as type I_STR
and passes a structure of type struct strioctl to the driver.  The
ic_cmd field of this structure is decoded according to the following
table.  the ic_dp and ic_len fields delimit an argument structure
which is also passed to the driver.  The argument structure differs
for each type of ic_cmd.
@tpindex struct strioctl

@multitable @columnfractions .25 .15 .60
@item ic_cmd value @tab Argument Structure @tab Description

@item LOOP_SET @tab IN: int @tab Argument is the minor device number of
the loop device to use for the other end of the connection.  If the
loop-around device had been opened by a directed open, such as to
@file{/dev/loop.1}, then the minor device number is known from the device
node.  If it was opened via the @file{/dev/loop_clone} device then the
minor device can be discovered via the LOOP_GET_DEV ioctl.
@pgindex /dev/loop_clone
@pgindex /dev/loop.1

@item LOOP_PUTNXT @tab None @tab Set the driver into a mode in which it
will perform a direct putnext call on the other stream rather than the
default behavior of using the service queue to forward the message.

@item LOOP_MSGLVL @tab IN: int @tab Set to the number of messages to queue
in the service queue before forwarding to the other stream.  Zero means
forward immediately.

@item LOOP_TIMR @tab IN: int @tab Set the number of "ticks" to hold
messages before forwarding them to the other stream.

@item LOOP_MARK @tab IN: int @tab Set the MSGMARK flag for each of the
next n messages before forwarding them to the other stream.

@item LOOP_GET_DEV @tab OUT: int @tab Return the minor device number of
this stream.  Useful for finding out the minor number of a clone device.

@item LOOP_BUFCALL @tab None @tab Use the bufcall mechanism to allocate a
buffer for copying the next message.

@item LOOP_CONCAT @tab IN: int @tab Concatenate this many messages into a
single message and then forward on the other stream.  One concatenation
resets this value to zero and the ioctl needs to be issued again to repeat
the behavior.

@item LOOP_COPY @tab None @tab From this point on, copy messages rather
than passing them through to the other stream.
@end multitable

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com} plus others originally.
@auindex Grothe, David


@page
@node mini-mux
@subsection mini-mux

@unnumberedsubsec Device Name

@example
/dev/mux_clone @r{}(clone device)
/dev/minimux.1
/dev/minimux.2
@end example
@pgindex /dev/mux_clone
@pgindex /dev/minimux.1
@pgindex /dev/minimux.2

@unnumberedsubsec Description

This driver is used by LiS in its testing procedures.  It is a small
multiplexing driver that allows cascaded multiplexors to be built and
torn down.  The driver uses a pair of ioctls to establish connectivity
between upper streams and lower streams.  This allows control over how
data flows through the multiplexor.

Both of these ioctls are coded as type I_STR and pass a structure of
type struct strioctl to the driver.  The ic_cmd field of this
structure is decoded according to the following table.  the ic_dp and
ic_len fields delimit an argument structure which is also passed to
the driver.  The argument structure may differ for each type of
ic_cmd.
@tpindex struct strioctl

@multitable @columnfractions .25 .15 .60
@item ic_cmd value @tab Argument Structure @tab Description

@item MINIMUX_UP @tab IN: int @tab The argument is a muxid that was
returned from an I_LINK ioctl.  This ioctl causes the lower stream
indicated by the muxid to be connected to this stream.  This is
unidirectional linkage and only affects the upstream flow of messages.

@item MINIMUX_DOWN @tab IN: int @tab The argument is a muxid that was
returned from an I_LINK ioctl.  This ioctl causes this stream to be
connected to the lower stream indicated by the muxid.  This is
unidirectional linkage and only affects the downstream flow of messages.
@end multitable

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David


@page
@node printk
@subsection printk

@unnumberedsubsec Device Name

@example
/dev/printk
@end example
@pgindex /dev/printk

@unnumberedsubsec Description

This driver accepts messages written to it and prints them from the
kernel using the kernel's printk function.  It is used by the LiS test
software to keep messages from LiS and messages from the test program
in sequence.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node sad
@subsection sad

@unnumberedsubsec Device Name

@example
/dev/sad
@end example
@pgindex /dev/sad

@unnumberedsubsec Description

The STREAMS Administrative Driver manages the autopush function of
LiS.  Using ioctls the system administrator can provide a list of
modules that are to be automatically pushed onto a given device when
that device is opened.  The controls are specified via the strapush
structure which is defined in <sys/sad.h>.

The ioctl used by the user is of the form:

ioctl(fd, command, arg)

Where fd is the file descriptor of the file that is open to the sad
driver, command and arg are described in the following table.

@multitable @columnfractions .15 .3 .55
@item Command @tab Argument @tab Description
@item
@item SAD_SAP @tab struct strapush * @tab Set the list of autopushed
modules according to the sap_cmd and other arguments contained within the
strapush structure.
@tpindex struct strapush
@item
@item SAD_GAP @tab struct strapush * @tab Get the list of configured
autopushed modules associated with the indicated major and minor device
number.  The sad driver fills in this structure with the names of the
modules and the applicable range of minor device numbers.
@tpindex struct strapush
@item
@item SAD_VML @tab struct str_list * @tab Validates a list of pushable
module names to verify that they are installed in LiS.  The str_list
structure is defined in the file @file{<sys/stropts.h>}.
@tpindex struct str_list
@pgindex stropts.h
@end multitable

The @dfn{strapush} structure used by the SAD_SAP and SAD_GAP ioctls
contains the following fields.
@tpindex strapush

@table @code
@item unsigned sap_cmd
This is the autopush command to be executed.  The values are as follows.

@table @code
@item SAP_ONE
Configure one minor device of the driver indicated by sap_major.

@item SAP_RANGE
Configure a range of minor devices of the driver indicated by sap_major.
The range runs from sap_minor to sap_lastminor, inclusively.

@item SAP_ALL
Configure all minor devices of the driver indicated by sap_major.

@item SAP_CLEAR
Undo all autopush configuration for the driver indicated by sap_major.
@end table

@item major_t sap_major
The major device number of the driver which is being configured for
autopush.

@item minor_t sap_minor
The minor device being configured, or the first of a range.

@item minor_t sap_lastminor
The last minor device of a range to be configured.

@item unsigned sap_npush
Number of modules to be pushed when the indicated device is opened.

@item char sap_list[MAXAPUSH][FMNAMESZ+1]
List of module names to be pushed, or list of modules names returned to
user.
@end table


The ioctl function call returns zero upon success or -1 on failure.
Upon failure errno is set to the error number describing the failure,
usually either EFAULT or EINVAL.

Note that the sad driver is a standard AT&T STREAMS function.  More
comprehensive documentation for this driver can be found in the
[40]SVR4 Programmer's Guide: STREAMS.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Modules
@section Modules
@cindex modules

@table @file
@item streams-connld.o
@pgindex streams-connld.o
Connld module.
@item streams-pipemod.o
@pgindex streams-pipemod.o
Pipe module.
@item streams-sc.o
@pgindex streams-sc.o
STREAMS configuration module.
@item streams-sth.o
@pgindex streams-sth.o
Stream Head module.
@end table

The LiS package comes with a number of STREAMS drivers and pushable modules in
source code form.  A number of these drivers and modules are small entities that
are used in the testing of LiS.  They are included so as to make it easy for any
user to run the LiS tests for themselves.

A pushable module in STREAMS is an entity that is added to an existing STREAMS
file via the I_PUSH ioctl.  These modules are known to LiS by mnemonic name,
given as an argument to the I_PUSH ioctl.  There are no major and minor device
numbers or @file{/dev} entries associated with pushable modules.
@pgindex /dev

@menu
* connld::				Connection listening daemon.
@ignore
* ip_strms::				IP streams driver.
@end ignore
* pipemod::				STREAMS-based Pipes.
* relay relay2::			Relay test driver.
@ignore
* timod::				XTI/TLI library module.
* tirdwr::				XTI/TLI read/write module.
@end ignore
@end menu

@page
@node connld
@subsection connld

@unnumberedsubsec Module Name

connld

@unnumberedsubsec Description

The connld module provides a means to generate multiple unique STREAMS-based
pipes from a single existing pipe end.  connld may only be pushed (via the
STREAMS I_PUSH ioctl) onto a STREAMS-based pipe.  When first pushed, connld
does nothing; on each subsequent open(2), connld will generate a unique
STREAMS-based pipe.  One end of each new pipe replaces the original pipe end
from the perspective of the open call.  The other end of each new pipe is sent,
effectively as if by the I_SENDFD ioctl, to the other end of the original
pipe, ostensibly to be received by a subsequent I_RECVFD ioctl operation.

@unnumberedsubsec Application Usage

The intent of connld is to provide a means to generate unique pipes which
separately and independently connect client processes to a server process.  The
point of access for such clients is expected to be a path name known to all
such clients and to which a pipe end may be connected (via fattach(3)) by the
server process.  The server establishes the original pipe, pushes connld onto
the client end, and then listens via I_RECVFD for new connections on the
server end.  A client wishing to connect to the server will open(2) the path
name representing the client end, and can determine via isastream(3) whether
or not the server process is active and attached.  If it is, the open() call
returns one end of a unique new pipe that thus connects the client to the
server.

Such a server is responsible both for accepting new connections via I_RECVFD
on the original pipe, and for communicating with clients so connected via the
received pipe ends.  It would also be reasonable for such a server process to
invalidate the point of access by calling fdetach(3) before terminating.

@vrindex M_PASSFP
It should be noted that the poll(2) primitive may be used to indicate when an
@code{M_PASSFP} representing a newly passed file is available on the original server
pipe end.  This is reflected by the POLLIN status setting in the events and
revents fields of a pollfd structure.  Moreover, any attempt to read an
@code{M_PASSFP} message via the data-receiving primitives (i.e., read(2), getmsg(3),
and getpmsg(3)) will fail with errno(3) returning an EBADMSG indication
without discarding the message.

Even so, it should be reasonable to expect only @code{M_PASSFP} messages will be
received on the original server pipe end, since it is not possible to carry on
normal data traffic which has connld on one end, since connld does not support
such traffic.

The use of connld can be made entirely free-standing by attaching well-known
paths to both ends of the original pipe.  The relevant capabilities are
implemented in LiS so that the original creator of the pipe can close both
ends after attaching paths to them, and the process of passing file
descriptors can still be carried out via new open()'s as long as both ends
remain attached.

@unnumberedsubsec See Also

fattach(3), fattach(8), fdetach(3), fifo(4), fifo(9),

pipe(3), STREAMS(4)

@unnumberedsubsec History

Unix System V Release 4 (SVR4)

@unnumberedsubsec Author

John Boyd, protologos LLC.  @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@ignore
@page
@node ip_strms
@subsection ip_strms

@unnumberedsubsec Module Name

ip_strms

@unnumberedsubsec Description

This module is pushed onto an open stream to a driver which implements the
DLPI STREAMS protocol.  It provides an interface between the DLPI driver below
and the Linux IP module above.  The effect is to be able to use a STREAMS DLPI
driver as a network interface below Linux TCP/IP.

The ip_strms module monitors DLPI primitives sent from above on the stream
file and shuttles them between the process which pushed the module onto the
stream and the DLPI driver below.  The ip_strms module will also allow data to
be exchanged between the stream user and the DLPI driver until such time as
the stream is logically attached to IP as a network driver.

@vrindex M_DATA
@vrindex DL_UNITDATA_REQ
@vrindex DL_UNITDATA_IND
In order to attach the stream to IP, the user process issues an ioctl of type
SIOCSIFNAME.  This ioctl causes ip_strms to register itself as a network driver
of the given name.  From that point onward data, in the form of @code{M_DATA} messages
or of @code{DL_UNITDATA_IND} messages, are forwarded upstream to IP rather than to
the stream user.  Likewise, data messages received from IP are forwarded
downstream to the DLPI driver as @code{DL_UNITDATA_REQ} messages.  Downstream messages
are completely formatted for the transmission medium and should be processed
accordingly by the DLPI driver below.

After attaching to IP, the stream user must continue to remain in execution,
holding the stream open.  If the stream closes then ip_strms will detach from
IP.  Also, if the stream user sends a SIOCSIFNAME ioctl with an empty name then
ip_strms will detach from IP.

The interfaces attached to IP will appear in the output of the netstat and
ifconfig commands.  An "ifconfig" down operation on the interface will also
cause a detach from IP.

@unnumberedsubsec Application Processing

The application level program which manages the connection between a DLPI
driver and TCP/IP should be coded to implement the following steps.

@itemize @bullet
@item Open a stream to the DLPI driver.  This can be a clone open.
@item Execute an I_PUSH ioctl on "ip_strms."
@item Send the DLPI attach and bind primitives downstream.
@item Execute an SIOCSIFNAME ioctl with the desired interface name.  After this
succeeds the DLPI driver will be connected to TCP/IP as a network driver via the
ip_strms module.
@item Perform any needed ifconfig or route commands for the interface.
@item Sleep indefinitely keeping the stream open.  Killing the process will cause
the stream to be detached from IP.
@end itemize

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David
@end ignore

@page
@node pipemod
@subsection pipemod

@unnumberedsubsec Module Name

pipemod

@unnumberedsubsec Description

@vrindex M_FLUSH
The pipemod module has the relatively simple task of reversing the sense of
the FLUSH flag bits in @code{M_FLUSH} messages sent in STREAMS-based fifos and pipes.
This must happen at the midpoint of a fifo or pipe, so that FLUSHR becomes
FLUSHW, and FLUSHW becomes FLUSHR.  pipemod does this, and has no other
function.

To be used appropriately, then, pipemod must be the first module pushed onto a
pipe end or a fifo, but it is only necessary on one end of a pipe.

pipemod is not needed if flush handling need not be supported, or if its
function is supported by other means.

@unnumberedsubsec See Also

fifo(9), pipe(3), fifo(4), STREAMS(4)

@unnumberedsubsec History

Unix System V Release 4 (SVR4)

@unnumberedsubsec Author

John Boyd, protologos LLC.  @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@page
@node relay relay2
@subsection relay, relay2

@unnumberedsubsec Module Name

relay
relay2

@unnumberedsubsec Description

These are two names for the same module.  All the module does is forward
STREAMS messages along on the stream using putnext.  These modules are used in
the testing of LiS but are not otherwise useful.  One could use the source
code as a starting point for coding a pushable STREAMS module.

@unnumberedsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@ignore
@page
@node timod
@subsection timod

@unnumberedsubsec Module Name

timod

@unnumberedsubsec Description

This is a primitive version of the standard AT&T SVR4 timod module.  Its
function is to convert user level ioctls to TLI primitives downstream.

Since there is no TLI Provider code within LiS, the timod module could be
considered to be well ahead of its time.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole


@page
@node tirdwr
@subsection tirdwr

@unnumberedsubsec Module Name

tirdwr

@unnumberedsubsec Description

This is a primitive version of the standard AT&T SVR4 tirdwr module.  Its
function is to convert user level reads and writes to appropriate TLI protocol
downstream.

Since there is no TLI Provider code within LiS, the tirdwr module could be
considered to be well ahead of its time.

@unnumberedsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@end ignore

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Libraries
@section Libraries
@cindex libraries

During the installation process of Linux STREAMS (LiS) a subroutine library is
built and installed on your system.  Three versions of the library are built and
installed.  They are as follows.

@table @file
@item libLiS.a
Interface routines to LiS in static library form.
@item libLiS.so
Interface routines to LiS in dynamic library form.
@item libpLiS.so
Like libLiS.so but omits the "pipe" system call.
@end table

These three libraries are copied to the directory @file{/usr/lib} when LiS is
installed.
@pgindex /usr/lib

In addition, the utility program @command{ldconfig} is run during the LiS make
install.  This causes this library to be linked, or searched, ahead of the
standard C library.  This is necessary because the standard C library contains
dummy routines for the STREAMS interface functions, or most of them in the best
case.  If these dummy routines preempt the LiS versions then STREAMS
applications will always perceive error returns from such routines as
@iftex
@b{getmsg}(2)
@end iftex
@ifnottex
@inforef{getmsg(2), , *manpages*}
@end ifnottex
and
@iftex
@b{putmsg}(2).
@end iftex
@ifnottex
@inforef{putmsg(2), , *manpages*}.
@end ifnottex

@menu
* Library Routines::			STREAMS library routines.
* Using the Library::			STREAMS library routines.
@end menu

@node Library Routines
@subsection Library Routines

The following routines are present in the libraries @file{libLiS.a} and
@file{libLiS.so}.  The library @file{libpLiS.so} omits the "pipe" routine.

The routines in these libraries are standard STREAMS interface routines.  As
such we do not offer detailed descriptions of the functions of these routines.
Instead we refer the reader to the AT&T SVR4 STREAMS documentation.

@smallexample
int fattach(int fd, const char *path);
int fdetach(const char *path);
int getmsg(int fd, void *ctlptr, void *dataptr, int *flagsp);
int getpmsg(int fd, void *ctlptr, void *dataptr, int *bandp, int *flagsp);
int isastream(int fd);
int pipe(int *fd);
int poll(void *pollfds, long nfds, int timeout);
int putmsg(int fd, void *ctlptr, void *dataptr, int flags);
int putpmsg(int fd, void *ctlptr, void *dataptr, int *bandp, int *flagsp);
@end smallexample

@table @code
@item int fattach(int fd, const char *path);
@iftex
@b{fattach}(3)
@end iftex
@ifnottex
@inforef{fattach(3), , *manpages*}
@end ifnottex
@item int fdetach(const char *path);
@iftex
@b{detach}(3)
@end iftex
@ifnottex
@inforef{detach(3), , *manpages*}
@end ifnottex
@item int getmsg(int fd, void *ctlptr, void *dataptr, int *flagsp);
@iftex
@b{getmsg}(2)
@end iftex
@ifnottex
@inforef{getmsg(2), , *manpages*}
@end ifnottex
@item int getpmsg(int fd, void *ctlptr, void *dataptr, int *bandp, int *flagsp);
@iftex
@b{getpmsg}(2s)
@end iftex
@ifnottex
@inforef{getpmsg(2s), , *manpages*}
@end ifnottex
@item int isastream(int fd);
@iftex
@b{isastream}(3)
@end iftex
@ifnottex
@inforef{isastream(3), , *manpages*}
@end ifnottex
@item int pipe(int *fd);
@iftex
@b{pipe}(2s)
@end iftex
@ifnottex
@inforef{pipe(2s), , *manpages*}
@end ifnottex
@item int poll(void *pollfds, long nfds, int timeout);
@iftex
@b{poll}(2s)
@end iftex
@ifnottex
@inforef{poll(2s), , *manpages*}
@end ifnottex
@item int putmsg(int fd, void *ctlptr, void *dataptr, int flags);
@iftex
@b{putmsg}(2)
@end iftex
@ifnottex
@inforef{putmsg(2), , *manpages*}
@end ifnottex
@item int putpmsg(int fd, void *ctlptr, void *dataptr, int *bandp, int *flagsp);
@iftex
@b{putpmsg}(2s)
@end iftex
@ifnottex
@inforef{putpmsg(2s), , *manpages*}
@end ifnottex
@end table

These routines are all very small pieces of code.  Most of them simply pass
their parameters to LiS via a system call.  The
@iftex
@b{fattach}(3)
@end iftex
@ifnottex
@inforef{fattach(3), , *manpages*}
@end ifnottex
and fdetach
@iftex
@b{fdetach}(3)
@end iftex
@ifnottex
@inforef{fdetach(3), , *manpages*}
@end ifnottex
routines use ioctls to LiS if there is no system call available to call
directly.

The poll
@iftex
@b{poll}(2s)
@end iftex
@ifnottex
@inforef{poll(2s), , *manpages*}
@end ifnottex
routine simply executes the poll system call.  It is present for
backward compatibility to 2.0 kernels, in which LiS provided the poll system
call.

The
@iftex
@b{pipe}(2s)
@end iftex
@ifnottex
@inforef{pipe(2s), , *manpages*}
@end ifnottex
routine has the same semantics as the standard C library routine.  It
uses STREAMS FIFOs to implement the pipe instead of the standard Linux pipes.

The @file{libpLiS.so} library, the one that preempts the standard C library,
omits the STREAMS pipe routine so that standard Linux pipes are used unless the
user explicitly links in @file{libLiS}.

@node Using the Library
@subsection Using the Library

To use one of the LiS libraries you can include the file @file{<sys/stropts.h>}
in your program source code.  On your compiler command line you can add the
option @samp{-I/usr/include/LiS} to include the version of @file{stropts.h} that
is distributed with LiS, or omit the option to include the system standard
header file.  The two header files are believed to be compatible enough that it
does not matter which one you include in your program.
@pgindex stropts.h
@pgindex /usr/include
@pgindex /usr/include/stropts.h
@pgindex /usr/include/LiS/stropts.h

When linking your program, or performing a final @command{cc} to build your
executable, include one of the following options on your command line.

@table @code
@item /usr/lib/libLiS.a
Use @file{libLiS.a} (static, includes "pipe")
@pgindex /usr/lib
@pgindex /usr/lib/libLiS.a
@pgindex libLiS.a
@item -lLiS
Use @file{libLiS.so} (dynamic, includes "pipe")
@pgindex /usr/lib
@pgindex /usr/lib/libLiS.so
@pgindex libLiS.so
@item -lpLiS
Use @file{libpLiS.so} (dynamic, omits "pipe")
@pgindex /usr/lib
@pgindex /usr/lib/libpLiS.so
@pgindex libpLiS.so
@end table

Omit any options

As of @file{libc-2.2.1} the LiS STREAMS interface routines will be used
automatically via @file{libpLiS.so}.

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Utilities
@section Utilities
@cindex utilities

The Linux STREAMS (LiS) package contains some user level commands that are used
to manage the package and assist the user with STREAMS functions.

These commands are installed in @file{/usr/bin} or @file{/usr/sbin}.  They are
referred to a "global commands."
@pgindex /usr/bin
@pgindex /usr/sbin

A second group is built in the LiS installation directory and left there.  This
second group is oriented more towards testing of LiS than towards its operation.
These commands remain undocumented since they are primarily intended for the use
of the authors of the modules that they test.

These are the commands that are installed in @file{/usr/bin} or
@file{/usr/sbin}, and are thus globally accessible to any user with those
directories in his/her path.
@pgindex /usr/bin
@pgindex /usr/sbin

@menu
* fattach::				Attach a file to a stream.
* fdetach::				Detach a file from a stream.
@ignore
* ldlconfig::				Configure the Linux DL driver.
* ldltest::				Test the Linux DL driver.
@end ignore
* polltst::				Test poll.
* streams::				Control LiS.
* strmakenodes::			Make fundamental devices.
* strtst::				Test LiS.
* timetst::				Test timers.
@end menu

@page
@node fattach
@subsection fattach

@example
/usr/sbin/fattach [-v] [-m|-u|-M mode] [-p|STREAMS-path] path ...
/usr/sbin/fattach -?
@end example
@pgindex /usr/sbin/fattach

@unnumberedsubsubsec Description

The fattach program provides a command-line interface to the
underlying fattach(3) function.  If the -p and/or the -c option is
specified, a STREAMS-based pipe is created and its two ends are
alternately attached to the path names given.  In this mode of
usage, at least two path names are required, but there need not be an
even number of path names (i.e., the pipe ends need not be attached
to the same number of paths).

If the -p and -c options are not specified, the first path name given
must identify a STREAMS-based file.  That file will be opened, and it
will be attached to each of the path names subsequently specified
(of which there must be at least one).

@unnumberedsubsubsec Options

@table @asis
@item -p
Create a STREAMS-based pipe, to which to attach the subsequently specified
path names.  The first path will be attached to the first pipe end, the second
to the second pipe end, the third to the first pipe end, etc., until the list
of path names is exhausted.

By default, the umask (see umask(2)) is also applied to each end of the pipe
after attaching.  (See fattach(3)).

@item -c
Like -p (both may be given), but additionally pushes the connld module onto
the first end of the pipe.  This conveniently creates a free-standing
pipe-serving pipe (see connld(9), and below).

@item -m
Apply the mode of the last-specified path(s) to the attached STREAMS-based
file(s) after attaching.  (See fattach(3).

@item -u
Apply the umask (see umask(2)) of the STREAMS-based file after attaching.  (See
fattach(3)).  This is done by default when a pipe is created via -p.

@item -M @var{mode}
Apply the given @var{mode} to the STREAMS-based file(s) after attaching.
(See fattach(3)).

@item -v
Operate in a "verbose" manner.  This causes fattach to report its progress via
message output to stdout or stderr.

@item -?
Provide a usage summary.
@end table

@unnumberedsubsubsec Return Value

Upon successful completion, i.e., if all given path names are
attached to, fattach returns 0.  Upon failure, fattach returns 1.
However, the failure of one more attachments does not otherwise affect
those that succeed, and the user is responsible for detaching any
that may have succeeded if that is the desired behavior in the event
of any failures.

@unnumberedsubsubsec Application Usage

The -p and -c options provide a convenient means for creating
free-standing mounted pipes.  The openers of the paths attached via
-p will share a single pipe, while the openers of the paths attached
via -c will have access to a pipe-serving pipe.  I.e., each open
of the first end (e.g., the client end) will generate a new pipe,
one end of which will be given to the opener, and the other end of
which will be passed as if by the I_SENDFD ioctl to the path attached
to the other end (e.g., the server end).  Each opener of the server
path could poll(2) for input, receive a new pipe end using the
I_RECVFD ioctl, and then close the server path, therefter using the
new pipe end to communicate with the corresponding opener of the
client path (note that the sense of client and server will in fact
depend on the application - users of the two paths need only be aware
of whether or not an I_RECVFD ioctl must be performed).

@unnumberedsubsubsec See Also

connld(9), fattach(3), fdetach(3), fdetach(8), STREAMS(4), umask(2)

@unnumberedsubsubsec History

An fattach function has been provided for various STREAMS
implementations based on SVR4 STREAMS.  Not all of these have provided
a corresponding utility program of this sort.

@unnumberedsubsubsec Author

John Boyd, protologos LLC @email{jaboydjr@@netwalk.com}
@auindex Boyd, John

@page
@node fdetach
@subsection fdetach

@example
/usr/sbin/fdetach [-v] path ...
/usr/sbin/fdetach -a
/usr/sbin/fdetach -?
@end example
@pgindex /usr/sbin/fdetach

@unnumberedsubsubsec Description

The fdetach program provides a command-line interface to the
underlying fdetach(3) function.

It is thus intended to provide a convenient means to dismantle
so-called mounted STREAMS.

If the -a option is specified, all currently attached STREAMS-based
files are detached.  If the -a option is not specified, the path names
given are taken to identify paths to which STREAMS-based files are
currently attached.  Those files will be detached from these paths.

@unnumberedsubsubsec Options

@table @asis
@item -a
Undo all attachments currently in effect.

@item -v
Operate in a "verbose" manner.  This causes fdetach to report its progress via
message output to stdout or stderr.

@item -?
Provide a usage summary.
@end table

@unnumberedsubsubsec Return Value

Upon successful completion, i.e., if all given path names identify
mounted STREAMS and these are all successfully detached, fdetach
returns 0.  Upon failure, fdetach returns 1.

Note, however, that a failure indication does not mean that no action
is taken; i.e., those detachments that succeed are not affected by
those that fail.

@unnumberedsubsubsec Warnings

It should be noted that although the fdetach program implements the -a
option, by passing "*" to the fdetach function, this is not at all
equivalent to specifying "*" on the command line when executing the
program.  Normally, "*" specified on the command line will be
converted by a shell into a list of all files in the current working
directory.  By contrast, the -a option causes the fdetach operation
to operate not with respect to path names at all, but with respect to
STREAMS devices currently active within the STREAMS subsystem.  I.e.,
each active stream head is examined for attachments, and any
attachments found are dismantled.

The intended use for the -a option is thus to undo all attachments,
e.g., in preparation for unloading the STREAMS subsystem.

@unnumberedsubsubsec See Also

fdetach(3), fattach(8), STREAMS(4)

@unnumberedsubsubsec History

An fdetach function has been provided for various STREAMS
implementations based on SVR4 STREAMS.  Not all of these have provided
a corresponding utility program of this sort.

@unnumberedsubsubsec Author

John Boyd, protologos LLC @email{jaboydjr@@netwalk.com}
@auindex Boyd, John


@ignore
@page
@node ldlconfig
@subsection ldlconfig

@example
/usr/sbin/ldlconfig Options
/usr/sbin/ldlconfig -h
@end example
@pgindex /usr/sbin/ldlconfig

@unnumberedsubsubsec Description

@dfn{ldlconfig()} is used to configure the ldl STREAMS driver as a client of a
standard Linux network driver.  Once configured other STREAMS drivers
can be pushed or I_LINKed on top of the ldl driver, thus giving
STREAMS drivers access to Linux network drivers.

@unnumberedsubsubsec Options

@table @asis
@item -a @var{name}
The name of the network driver interface to attach.  For example, "-aeth0"
attaches to the eth0 network driver.

@item -b @var{sap}
The SAP to bind.  The interpretation of the SAP depends upon the mode (-p) and
framing (-F) being used.

@item -d @var{filed}
Instead of opening @file{/dev/ldl}, use the given file descriptor number.  This
allows an external program to open @file{/dev/ldl}, use @dfn{ldlconfig()} to configure the
STREAM, and then continue to use the open file descriptor for further
operations.
@pgindex /dev/ldl

@item -f @var{flag}
Flag to set with ioctl.  Mnemonic values for flag are PEDANTIC_STANDARD and
RAW.

@item -F @var{framing}
The type of framing to use in interactions with the network driver.  Mnemonic
values for framing are EII, 802.2, SNAP, 802.3 and RAWLLC.

@item -h
Print a command usage synopsis.

@item -p @var{mode}
Set promiscuous mode.  Mnemonic values for mode are PHYS, SAP or MULTI.

@item -v @var{mask}
Set verbose mask.
@end table

@unnumberedsubsubsec Operation

@dfn{ldlconfig()} opens the clone device @file{/dev/ldl}, or accepts a file
descriptor to a file already opened to that device.  It performs a
DLPI Attach Request based upon the -a parameter.  This attaches the
file to a Linux network device.
@pgindex /dev/ldl

It then sets operational options based upon the -f and -p options, if
any were specified.

If the -b option is specified it also performs a DLPI Bind Request on
the stream.

The resulting stream connects to the ldl driver which acts as a DLPI
Provider and translates between the DLPI STREAMS protocol from above
to the Linux network driver interface below.  The effect is to present
a DLPI interface to a Linux network driver.

The type of network driver (Ethernet, Token Ring, FDDI, HDLC) is
compared with the requested framing type (is option) and RAW flag (is
option).  If the given driver does not support the requested framing
type then the @dfn{ldlconfig()} command will fail.  All drivers support the
RAW frame interface.

Depending upon the driver type and framing type, the ldl driver will
set up to decode incoming "frames" according to the framing type.
This has an effect on where the driver looks in the incoming "frame"
to find the SAP to match against the requested SAP in the DLPI Bind
Request to ldl (-b option).  The framing type of RAWLLC generally
means that the entire frame is passed upstream.  This allows the
upstream client driver to interpret the LLC information within the
frame.

@vrindex DL_UNITDATA_IND
Frame types other than RAWLLC generally mean that the LLC header will
be stripped from received frames passing just the payload portion to
the upstream client.  The received frame is passed upstream in a
@code{DL_UNITDATA_IND} @code{M_PROTO} message and the address carried by this frame
will be set to the source MAC address from the frame header.
@vrindex M_PROTO

In the transmit direction, a frame type of RAWLLC means that the
formatting of the frame to be sent to the medium is under the control
of the upstream client.

For other types of framing, the ldl driver will build the LLC header
according to the framing type.  The address in the @code{DL_UNITDATA_REQ} is
used to develop the destination MAC address.

For any given frame type and driver type, it is often necessary to
consult the driver source code in order to understand the fine details
of the frame processing involved.

@unnumberedsubsubsec Return Value

@dfn{ldlconfig()} returns 0 upon success and 1 if any indicated operation
failed.

@unnumberedsubsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole

@page
@node ldltest
@subsection ldltest

@example
/usr/sbin/ldltest Options Driver Local-IP
@end example
@pgindex /usr/sbin/ldltest

@unnumberedsubsubsec Description

ldltest is used to test the ldl STREAMS driver by using one of the
existing standard Linux network drivers to send a "ping" to another
host on the network.  The command line parameters specify the local-IP
and remote-IP addresses and the name of the Driver to use when sending
the ping.

ldltest is also used to obtain statistics from the ldl STREAMS driver
and to set debugging masks.

@unnumberedsubsubsec Options

@table @asis
@item -a
Respond to received ARP queries.

@item -s
Respond to received pings.  Also enables LLC TEST/XID echo mode.

@item -S @var{dsap:ssap}
Set the DSAP and SSAP to use when sending an LLC TEST or XID.

@item -r @var{remote-IP}
The remote IP address to which the ping is to be directed.

@item -R @var{remote-MAC}
The remote MAC address for sending LLC TEST/XID frames.

@item -c @var{packet-cnt}
The number of ping packets to send.  Default is 1.

@item -v @var{number}
Set verbosity level.

@item -f @var{framing}
Set framing style to EII (default), RAW or SNAP.

@item -d @var{mask}
Set debug mask for the ldl driver to mask.

@item -H
Print out the values for the debug mask bits.

@item -g
Print out global statistics obtained from the ldl driver.

@item -T
Send LLC TEST command.

@item -X
Send LLC XID command
@end table

@unnumberedsubsubsec Operation

In test mode, ldltest constructs a ping packet from the parameters
given and sends it to the remote host.  It awaits the response and
prints out the round trip time when it receives the response.  If the
-c option is used it sends the ping repeatedly and prints out the
round-trip time every 1,000 packets.

With the -s (lower case) option, ldltest listens for received frames
from the indicated interface driver.  If the framing is specified as
RAW then it will receive LLC frames from the driver.  Other types of
framing result in non-LLC Ethernet types of frames such as IP packets
and ARP messages.  Thus, the setting of the -f option conditions the
type of messages that can be received from the interface.  When an ICMP
ping is received, it is responded to.  When an LLC TEST or XID command
is received it is responded to with the corresponding response frame.

With the -g option, ldltest obtains statistics maintained by the ldl
driver and prints them out.  This is useful for troubleshooting
protocol stack configuration since you can see whether packets
entering ldl from either above or below was forwarded to the
neighboring module.

By setting debug bits via the -d option, you can cause the ldl driver
to print the contents of packets flowing into it and out of it.

@unnumberedsubsubsec Examples

ldltest -r 192.168.1.1 eth0 192.168.1.117

Sends a ping to 192.168.1.1.  The local host address is
192.168.1.117 (obtainable from the ifconfig command).

ldltest -S 0x00:0x0C -T -R 00:00:C0:D7:54:F8 eth0

Sends an LLC TEST command to the remote system with Ethernet
address 00:00:C0:D7:54:F8, DSAP 0x00 and SSAP 0x0C.  Await the
response.

ldltest -s -f RAW eth0 192.168.1.47

Listens for RAW LLC frames addressed to the local machine whose IP
address is 192.168.1.47.  Send responses to TEST and XID commands.

ldltest -d 0x0f

Sets the debug mask in the ldl driver.

ldltest -H

Prints the values assigned to the debug mask bits as follows:

0x00000001 dump raw frame from net driver

0x00000002 dump UNITDATA_IND upstream

0x00000004 dump UNITDATA_REQ downstream

0x00000008 dump Tx to net driver

0x00000010 dump full buffer, not just header

@vrindex DL_ATTACH
0x00000020 debug info for @code{DL_ATTACH}

@vrindex DL_BIND
0x00000040 debug info for @code{DL_BIND}

@unnumberedsubsubsec Author

Ole Husgaard @email{sparre@@login.dknet.dk}
@auindex Husgaard, Ole
@end ignore

@page
@node polltst
@subsection polltst

@example
/usr/bin/polltst
@end example
@pgindex /usr/bin/polltst

@unnumberedsubsubsec Description

polltst is a simple test program for the poll system call.  Using
poll, it reads keystrokes from stdin, writes them to one end of the
LiS loopback driver, reads them from the other end and then writes
them back to stdout.

While performing this operation it configures stdin for "no echo"
mode, so the appearance of "echoed" characters is evidence of the
operation of poll involving both a STREAMS and a non-STREAMS file.

@unnumberedsubsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node streams
@subsection streams

@example
/usr/sbin/streams Options
@end example
@pgindex /usr/sbin/streams

@unnumberedsubsubsec Description

The streams program is used to perform several different management
functions for the LiS package, including starting and stopping the LiS
subsystem.

@unnumberedsubsubsec Options

@table @asis
@item @samp{start}
Start the LiS subsystem.  This amounts to performing the command "modprobe
streams".

@item @samp{stop}
Stop the LiS subsystem.  This amounts to performing the command "modprobe -r
streams".

@item @samp{status}
Reports on the status of the LiS subsystem.

@item -c @var{Kbytes}
Print or set the maximum message memory usage for LiS.  The value 0 (default)
means unlimited.

@item -C @var{Kbytes}
Print or set the maximum total memory usage for LiS.  The value 0 (default)
means unlimited.

@item -d @var{mask}
Set the debug mask for LiS.  See below for details.

@item -D @var{mask}
Set an additional debug mask for LiS.  See below for details.

@item -s
Print STREAMS memory usage statistics.

@item -L
Print out lock contention statistics.  Use debug bit
@code{DEBUG_LOCK_CONTENTION} to enable the lock contention statistics gathering.

@item -m
Print STREAMS memory allocation to the system messages file (from kernel).
This option should be used only for debugging and only when LiS is in a
quiescent state.  Unpredictable results can occur if this option is used while
LiS memory allocations are changing dynamically.

@item -p
Print the LiS lock trace buffer to the system messages file (from kernel).
Used in conjunction with the @code{DEBUG_SPL_TRACE} debug option.

@item -q
Print all STREAMS queues to the system messages file (from kernel).  This
option should be used only for debugging and only when LiS is in a quiescent
state.  Unpredictable results can occur if this option is used while LiS queue
allocations are changing dynamically.

@item -S
Print out STREAMS queue-runner thread statistics.

@item -t
Print STREAMS timing statistics.  Used inconjunction with the
@code{DEBUG_MEAS_TIME} debug option.

@item -T
Print the LiS semaphore latency histogram.  Use debug bit @code{DEBUG_SEMTIME}
to enable the statistics collection.

@item -h
Print a command synopsis.

@item -H
Print a command synopsis including the debug mask mnemonics.
@end table

@unnumberedsubsubsec Debug Options

The value that is used with the -d option consists of the logical "or" of the
following single bit options.

@table @asis
@item -d @var{Options}
@smallexample
DEBUG_OPEN             0x00000001
DEBUG_CLOSE            0x00000002
DEBUG_READ             0x00000004
DEBUG_WRITE            0x00000008
DEBUG_IOCTL            0x00000010
DEBUG_PUTNEXT          0x00000020
DEBUG_STRRPUT          0x00000040
DEBUG_SIG              0x00000080
DEBUG_PUTMSG           0x00000100
DEBUG_GETMSG           0x00000200
DEBUG_POLL             0x00000400
DEBUG_LINK             0x00000800
DEBUG_MEAS_TIME        0x00001000
DEBUG_MEM_LEAK         0x00002000
DEBUG_FLUSH            0x00004000
DEBUG_FATTACH          0x00008000
DEBUG_SAFE             0x00010000
DEBUG_TRCE_MSG         0x00020000
DEBUG_CLEAN_MSG        0x00040000
DEBUG_SPL_TRACE        0x00080000
DEBUG_MP_ALLOC         0x00100000
DEBUG_MP_FREEMSG       0x00200000
DEBUG_MALLOC           0x00400000
DEBUG_MONITOR_MEM      0x00800000
DEBUG_DMP_QUEUE        0x01000000
DEBUG_DMP_MBLK         0x02000000
DEBUG_DMP_DBLK         0x04000000
DEBUG_DMP_STRHD        0x08000000
DEBUG_ADDRS            0x80000000
@end smallexample

@item -D @var{Options}
@smallexample
DEBUG_SNDFD            0x00000001
DEBUG_CP	       0x00000002
DEBUG_CACHE	       0x00000004
DEBUG_LOCK_CONTENTION  0x00000008
DEBUG_REFCNTS          0x00000010
DEBUG_SEMTIME          0x00000020
@end smallexample
@end table

Most of these options are intuitive as to their operation from the mnemonics.

The @code{DEBUG_MEAS_TIME} option causes LiS to use a high precision timer to
calculate the execution time of several operations within itself.  These
timings include the time spent in STREAMS drivers.  Thus, under controlled
circumstances this option can be used to time STREAMS driver code.  It is used
in conjunction with the -t option to print out the timing statistics.

The @code{DEBUG_SAFE} option causes LiS to carefully check for NULL pointers
when performing message passing and queueing operations such as putq and
putnext.

The @code{DEBUG_CLEAN_MSG} option causes LiS to clear message data buffers to
zero when they are allocated.  It is useful for tracking down driver problems
relating to using uninitialized areas of messages.

The @code{DEBUG_SPL_TRACE} option causes LiS to maintain a trace table of all
LiS locking operations.  It is used in conjunction with the -p option to print
out the lock trace table.  The locking operations that are traced include calls
on the LiS locking primitives from STREAMS drivers.

The options @code{DEBUG_DMP_QUEUE}, @code{DEBUG_DMP_MBLK} and
@code{DEBUG_DMP_DBLK} control the verbosity of the printing out of LiS memory
areas via the -m option.  With these debug mask bits set, LiS will print out
the contents of these structures as well as the headers indicating that such a
structure was allocated.

The @code{DEBUG_ADDRS} option causes the -m option to print out the addresses
of structures as well as their memory tags and/or contents.

The @code{DEBUG_MONITOR_MEM} option causes LiS to monitor the guard words
surrounding allocated memory areas in an attempt to catch overwriting of these
words in a timely fashion.  This option comes at a fairly substantial CPU time
penalty.

@unnumberedsubsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node strmakenodes
@subsection strmakenodes

@example
/usr/sbin/strmakenodes
@end example
@pgindex /usr/sbin/strmakenodes

@unnumberedsubsubsec Description

strmakenodes makes all of the @file{/dev} entries that are associated with
LiS as a result of the LiS build process.  All of the @file{Config} files
that contributed to the LiS build are scanned for their "node"
declarations.  strmakenodes performs a mknod system call for each
specified "node".
@pgindex /dev
@pgindex Config

This command must be run before LiS can operate correctly after it is
installed.  This command is run automatically as a result of the "make
install" operation of LiS.

This command accepts the option "-r" to mean remove nodes instead of
making them.  The command is run with this option as a result of the
"make uninstall" operation.

The source code for this command is generated automatically as a
side-effect of running the strconf utility.

@page
@node strtst
@subsection strtst

@example
/usr/bin/strtst
@end example
@pgindex /usr/bin/strtst

@unnumberedsubsubsec Description

strtst is a test program which tests the core functionality of LiS.
It is a user level program which uses the built-in drivers that are
installed by default with LiS.  It performs numerous STREAMS
operations and checks the results for correctness.  It prints out a
voluminous log file whose output is routed to the "messages" file
(kernel informational messages).

The output of strtst can be compared to earlier "reference" outputs to
see if the behavior of LiS has changed as a result of modifications to
the code.

@unnumberedsubsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David

@page
@node timetst
@subsection timetst

@example
/usr/bin/timetst [Iterations]
@end example
@pgindex /usr/bin/timetst

@unnumberedsubsubsec Description

timetst peforms a timing test using the LiS loopback driver.  It
writes short messages downstream under several different LiS options
and measures the round trip time for the messages.  The Iterations
parameter specified the number of iterations that timetst uses in its
timing loop, the default being 100,000.

@unnumberedsubsubsec Author

David Grothe @email{dave@@gcom.com}
@auindex Grothe, David


@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Development
@section Development
@cindex developing

@ignore
For development using the @cite{@value{PACKAGE_NAME}} package, @xref{Top, About
This Manual, About This Manual, LiSSPG, STREAMS Programmer's Guide}.
@end ignore

Linux STREAMS (LiS) provides for an interface between STREAMS drivers and the
surrounding kernel environment.  This interface has grown over time and is
likely to expand in the future.

In the Linux kernel, much of the interface between drivers and other kernel
modules and the core kernel services, such as memory allocation and
synchronization primitives, is implemented in macros and inline functions
declared in kernel header files.  This technique was used (probably) out of
considerations of efficiency (defined as execution speed) and a consideration
that there were no version problems with such constructs because one could
always recompile one's drivers in the context of the new kernel.  The only
"kernel primitives" compatibility that has been attempted from one kernel
release to the next is source code compatibility.

The real world of paying customers is quite different.  And, as it happens, the
world of paying customers seems to impinge upon LiS considerably.

In this world, the customers do not want to rebuild the kernel.  They don't want
to build the kernel at all.  They want to install a distribution with a binary
kernel that was configured only at install time.  They then want to install
add-on binary packages, and they expect these packages to operate correctly with
their kernel.

When these add-on packages consist of STREAMS based protocol drivers, LiS is
usually the only piece of code that is recompiled from source upon installation
into the customer's environment.  The STREAMS drivers themselves are typically
distributed in binary and linked in with LiS.  The resulting module is then
typically loaded using "modprobe" or some equivalent command.

In these circumstances it is highly desirable for LiS to "buffer" the interface
between the STREAMS drivers and the kernel environment.  This allows the STREAMS
driver writers to deliver smaller binary packages to their customers and
minimizes the number of different versions of those packages that must be
maintained by the STREAMS driver writers.  Ideally, LiS would be able to present
a uniform DKI that would support one version of a user's STREAMS driver across
all versions of the Linux kernel.

This ultimate goal is probably not achievable, but it is possible to insulate
STREAMS drivers from the Linux kernel to a considerable extent.  This is
possible in part due to the implied DKI of a STREAMS driver.  A STREAMS driver
most likely will confine itself to the SVR4 types of DKI calls which have syntax
and semantics that do not change over time.  The main challenges come from the
use of constructs, such as PCI configuration and interrupt service routines,
that go outside the SVR4 DKI and must use services of the Linux kernel
more-or-less directly.

In general, LiS attempts to replace inline functions and macros with actual
subroutine calls to perform kernel operations.  This allows the STREAMS driver
to be compiled once with references to these routines, with the routines
themselves being compiled in the context of the specific kernel version at
package installation time.  Thus, the STREAMS drivers do not have to be
sensitive to differences in kernel versions.

@menu
* Coding STREAMS Applications::		General development.
* LiS SMP Implementation::		SMP considrations.
* Operating System Interface::		OS interface functions.
* PCI BIOS Interface::			PCI BIOS interface functions.
* PCI Interface::			PCI interface functions.
* IRQ Interface::			IRQ interface functions.
* I/O Memory Mapping::			I/O memory mapping functions.
* I/O Port Access::			I/O port access functions.
* Memory Allocation::			Memory allocation functions.
* DMA Routines::			DMA functions.
* Delay Routines::			Delay functions.
* Printing Routines::			Printing functions.
* Timer Routines::			Timer functions.
* Sleep and Wakeup Routines::		Sleep and wakeup functions.
* Thread Creation::			Thread creation functions.
* Major/Minor Device Numbering::	Device numbering functions.
* LiS Memory Allocation::		LiS memory allocation.
* LiS malloc and free Equivalents::	LiS memory allocation.
* LiS Kernel Memory Allocators::	LiS memory allocation.
* LiS Page Allocator::			LiS memory allocation.
* LiS PCI Interface::			LiS PCI interface.
* The LiS PCI Device Structure::	LiS PCI interface.
* LiS PCI Search Routines::		LiS PCI interface.
* LiS PCI Configuration Space Routines:: LiS PCI interface.
* LiS PCI DMA Routines::		LiS PCI interface.
* LiS Atomic Functions::		LiS atomic functions.
* LiS Locks::				LiS locking functions.
* LiS Spin Locks::			LiS locking functions.
* Lock Nesting::			LiS locking functions.
* LiS Read/Write Locks::		LiS locking functions.
* LiS Interrupt Enable/Disable::	LiS interrupt functions.
* LiS Semaphores::			LiS semaphores.
* Debugging Spin Locks::		Debugging locks.
* Lock Semaphore and Queue Contention::	Lock contention.
* Debugging Semaphores::		Debugging sempahores.
* STREAMS Utility Routines::		STREAMS utility functions.
* Flushing Queue Bands::		Flushing queues.
* Freezing Streams::			Freezing streams.
* Utility Prototypes::			STREAMS utility prototypes.
* System Calls from within the Kernel::	Linux system calls.
@end menu

@node Coding STREAMS Applications
@subsection Coding STREAMS Applications

This document is concerned with the include files and compilation techniques for
STREAMS application programs.  It is not intended to be a tutorial on the subject
of writing STREAMS applications.  Additional resources are available [17]here for
reference material.

@subsubsection Header Files

In your STREAMS application program C language source, use the following line to
include LiS header files.

@example
#include <sys/stropts.h>
@end example
@pgindex stropts.h

This will include all of the STREAMS related information that you need for a
user level program.

If your application program uses the poll system call then you need to include
one or the other of the following lines depending upon the kernel version that
the application is intended to run on.  For kernel versions in the 2.0 group, use
the following in order to include the poll.h from LiS.

@example
#include <sys/poll.h>
@end example

For kernel versions in the 2.2 group, use the following in order to include
poll.h from the kernel's source tree.

@example
#include <linux/poll.h>
@end example

@subsubsection Compilation Options

When you compile your STREAMS application, put the following compiler option on
the gcc (cc) command line for each C language file that contains any of the
above include lines.

@example
-I/usr/src/LiS/include
@end example

This directive assumes that you used standard installation procedures for LiS so
that the name @file{/usr/src/LiS} is a symbolic link to the LiS installation directory.
@pgindex /usr/src/LiS

@subsubsection Linking Options

When you perform the final link of your application using cc or gcc, add the
following to the end of your list of files and libraries to be linked.  This
links in the system call interface routines for LiS.

@example
-lLiS
@end example

This library includes the STREAMS based version of the pipe system call.  If you
want to use the standard STREAMS library routines, such as getmsg and putmsg,
but you want to use the standard Linux pipe system call, use the following
instead.

@example
-lpLiS
@end example

@subsubsection Other STREAMS Resources

Click [18]here for a list of other locations that you can consult for general
information concerning writing STREAMS applications.


@node LiS SMP Implementation
@subsection LiS SMP Implementation

Beginning with LiS-2.12, LiS makes aggressive use of multiple CPUs in SMP
kernels.  It is useful for the STREAMS programmer to have some insight
into this design in order to know whether, or which, locking techniques
must be used in driver code.

@menu
* CPU Scheduling::
* Queue Locking::
* Service Procedure Context::
* Scheduling Statistics::
@end menu

@node CPU Scheduling
@subsubsection CPU Scheduling

LiS starts up a kernel thread for each CPU on the system.  In the output
of a ps display each thread will show as a process with a name such as
"LiS-2.12:0".  This notation means that an LiS kernel thread is running
and is bound to CPU 0 (":0").

LiS maintains a single global list of queues whose service procedures need
to be run.  A queue is place into this list by calling the function
qenable, whether directly or indirectly.  A given queue can only be in
this list once.  The read queue and write queue of a queue-pair are
considered two different queues for scheduling purposes and both can be
scheduled simultaneously.

At "certain points in time" LiS performs an operation that makes a
decision concerning the manner in which service procedures are to be
invoked via the list of scheduled queues.  There are several factors which
influence this decision.

@itemize @bullet
@item If the decision is being made just prior to LiS exiting back to user
mode from a system call, if the LiS kernel thread for this CPU is inactive
and if there are few enough entries in the list of scheduled queues then
LiS calls the routine that processes queues directly without waking up any
of its kernel threads.

@item If the decision is being made from an interrupt routine then the
queue processing routine is not to be called directly.

@item If the decision is being made from a call on the routine qenable
then the queue processing routine is not to be called directly.

@item The number of queues in the scheduling list affects the decision
making process.

@item The number of LiS kernel threads running affects the decision making
process.

@item Whether or not LiS is executing a system call affects the decision
making process.  In this case LiS may defer any queue processing action
until the system call is about to exit.
@end itemize

In the case that the queue processing routine does not get called
directly, LiS needs to decide whether to wake up a kernel thread process
or whether to defer queue processing until an LiS system call is about to
exit.

LiS tries to enlist one CPU for every four queues that are scheduled.
This number is based on considerations of CPU loading and average queue
lengths from queueing theory.  If the number of CPUs currently processing
queues is not enough to meet this target then the scheduling process seeks
to enlist more CPUs until the number of CPUs is sufficient to meet this
target value.  Of course, sometimes there are simply too may queues
schedule for processing for the number of available CPUs.  In that case,
all available CPUs run their queue processing threads.

When making the decision as to whether or not to wake up a kernel thread,
LiS gives precedence to the CPU that it is running on.  If the scheduling
algorithm is called from a point just prior to executing back to the user,
and if the kernel thread for the active CPU is sleeping, then LiS will
simply call the queue processing routine without waking up the kernel
thread.  This saves the wakeup and context switch overhead.

The routine that actually runs the queues removes one element at a time
from the list of scheduled queues and calls the service procedure pointed
to by the queue.  The routine continues until the list of scheduled queues
is empty.  Thus, when a kernel thread is actively processing queues, and
if the number of scheduled queues does not exceed the estimated capacity
of the running threads, it is quite efficient to simply add a queue to the
list and let the already running threads process them in due course.

@node Queue Locking
@subsubsection Queue Locking

The queue_t structure in LiS contains a spin lock that is used by LiS to
ensure that service procedures are not reentered for the same queue.  This
lock is not to be used by driver code.

When the LiS queue running routine removes a queue from the list of
scheduled queues it acquires this lock prior to calling the service
procedure.

LiS also acquires this lock when calling the put procedure associated with
a queue.  Thus, execution of the put and service procedure are excluded
for the same queue.

In a multi-CPU environment, it can happen that one CPU is calling the put
procedure while a second CPU is calling the service procedure for the same
queue.  In this case, one or the other spins until the first CPU finishes
the operation and releases the spin lock.

When LiS is about to call the put procedure of a queue from the put or
service procedure of a neighboring queue (because the driver called the
putnext function), it continues to hold the lock for the calling queue
while acquiring the lock for the destination queue.  The locks are
acquired sequentially as the chain of putnext calls traverse the stream.
The locks are released in reverse order as the put procedures return.
This has the effect of incrementally locking the entire stream as messages
are passed from one module to another.

This behavior is only of interest when modules are I_PUSHed on top of a
driver.  Otherwise, it is just the stream head write queue and the driver
write queue that need to be locked (or other pairwise combinations such as
the driver read queue and stream head read queue, or queues involving
multiplexors).

The lock that LiS uses has the effect of excluding multiple entries from
different threads into the put or service procedure for a given queue.
The other queue in the queue pair is unaffected by this locking.
Therefore, if there are data structures shared between the read and write
put and service procedures of a driver or module, it is up to the driver
writer to protect these structures with spin locks.

@node Service Procedure Context
@subsubsection Service Procedure Context

Due to the manner in which service procedures are called, sometimes from
the LiS queue runner threads and sometimes from a "borrowed" system call,
service procedures may or may not have some user context present when they
run.  Service procedures should always assume that there is no user
context.  Even in the cases where there is some user context, the identity
of the user process is unpredictable.

LiS does, however, maintain a copy of the credentials of the process that
opened the stream when it calls service procedures on the stream.  LiS
saves the user and group identifiers plus the capability masks
(credentials) of the running process in the stream head structure at the
time that the STREAMS file is opened.  These identifiers are restored to
the task structure before calling a service procedure on that stream.

When calling put procedures, however, no such identity restoration occurs.
So the credentials in place when a driver or module put procedure is
invoked are those of the invoking entity.  Because the queue runner theads
always begin driver entry with a call to the service procedure, entries
into the put procedures of subsequent drivers will have the credentials of
the stream whose service procedure was called in the first instance.  When
a driver's put procedure is entered from a system call the credentials
will be that of the user process which issued the system call.

@node Scheduling Statistics
@subsubsection Scheduling Statistics

LiS gathers statistics on its queue scheduling algorithm.  They can be
printed out with the command streams -S.  The output looks like the
following.

@smallexample
N-CPUs N-Qrunners N-Running N-Requested
     2          2         0          0

CPU   Qsched-Cnts Qsched-ISR Svc-Q-Cnts Qrun-Cnts Active Thread-PID
  0     540752204  175753842  459587537 239611835      0        857
  1     540683832  175833424  459150290 239672683      0        858
@end smallexample

The fields have the following meanings.
@table @samp
@item N-CPUs
Number of CPUs on the system.

@item N-Qrunners
Number of queue runner kernel threads.  These are the processes that
appear as LiS-2.12:0 in a ps display.

@item N-Running
Number of qeuue runner threads that are currently active.

@item N-Requested
The number of queues that are in the list of scheduled queues.
@end table

@table @samp
@item CPU
The remainder of the statistics are kept on a per-CPU basis.

@item Qsched-Cnts
This is the number times the routine (lis_setqsched) that decides whether
or not to wake up a queue runner process or to directly process scheduled
queues has been called.  This routine is called whenever a queue is added
to the scheduling list.  The counter reflects which CPU made the call to
the routine.

@item Qsched-ISR
The number of times lis_setqsched was called from an interrupt routine and
from which CPU.

@item Svc-Q-Cnts
The number of callouts to service procedures on a per-CPU basis.

@item Qrun-Cnts
The number of times the routine (queurun) that removes queues from the
schedule list was called.  This routine does not return until the queue
scheduling list is empty.  It can be running on multiple CPUs
simultaneously.  It is typically called from the queue runner threads but
can also be called from an LiS system call either just prior to returning
to the user or just prior to sleeping on some event such as the arrival of
messages at the stream head.

@item Active
Displays as 0 or 1 depending upon whether there is a queue runner thread
running on the particular CPU at the time that the statistics were
sampled.

@item Thread-PID
The process id of the queue runner thread assaigned to eachCPU.
@end table

@node Operating System Interface
@subsection Operating System Interface Routines

In the file <sys/osif.h>, LiS provides insulation routines for a number of
commonly used kernel functions.  These functions are used with their Linux kernel
names, but those names are redefined in <sys/osif.h> to be subroutine calls on
functions that are actually defined in the file osif.c within LiS.  The osif.c
file is compiled at LiS installation time and is sensitive to kernel version
information.

To use this interface, you include the header files that you would
normally include to use the kernel functions, and then include <sys/osif.h>
after all of the kernel include files.  This allows for the redefinition of the
names.

The kernel functions provided via <sys/osif.h> are as follows, grouped by type
of function.

@node PCI BIOS Interface
@subsection PCI BIOS Interface

These are routines that utilize or simulate the original PCI BIOS interface of
the 2.0 series of kernels.  The names of these routines are changed via defines.
Use them as if the prototypes were as follows.  You can use these routines on 2.2
kernels even though they represent the 2.0 style of inteface.

@smallexample
#if LINUX_VERSION_CODE < 0x020100       /* 2.0 kernel */
unsigned long pcibios_init(unsigned long memory_start,
                           unsigned long memory_end);
#else   /* 2.1 or 2.2 kernel * /
void pcibios_init(void) ;
#endif
int pcibios_find_class(unsigned int class_code, unsigned short index,
                       unsigned char *bus, unsigned char *dev_fn);
int pcibios_find_device(unsigned short vendor, unsigned short dev_id,
                        unsigned short index, unsigned char *bus,
                        unsigned char *dev_fn);
int pcibios_read_config_byte(unsigned char bus, unsigned char dev_fn,
                             unsigned char where, unsigned char *val);
int pcibios_read_config_word(unsigned char bus, unsigned char dev_fn,
                             unsigned char where, unsigned short *val);
int pcibios_read_config_dword(unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned int *val);
int pcibios_write_config_byte(unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned char val);
int pcibios_write_config_word(unsigned char bus, unsigned char dev_fn,
                              unsigned char where, unsigned short val);
int pcibios_write_config_dword(unsigned char bus, unsigned char dev_fn,
                               unsigned char where, unsigned int val);
const char *pcibios_strerror(int error) ;
@end smallexample

@node PCI Interface
@subsection PCI Interface

These routines constitute the PCI interface as implemented in the 2.2 series of
kernels.  Please note that these are filtered calls to the operating system and
still depend directly upon the kernel structure "struct pci_dev".  LiS provides a
more abstract interface to PCI that does not depend upon the direct definition
kernel structures.  The [61]LiS PCI interface is to be preferred since it
provides more insulation against changes in the kernel.
@tpindex struct pci_dev

@smallexample
struct pci_dev *pci_find_device(unsigned int vendor, unsigned int device,
                                struct pci_dev *from);
struct pci_dev *pci_find_class(unsigned int class, struct pci_dev *from);
struct pci_dev *pci_find_slot(unsigned int bus, unsigned int devfn);
int pci_read_config_byte(struct pci_dev *dev, u8 where, u8 * val);
int pci_read_config_word(struct pci_dev *dev, u8 where, u16 * val);
int pci_read_config_dword(struct pci_dev *dev, u8 where, u32 * val);
int pci_write_config_byte(struct pci_dev *dev, u8 where, u8 val);
int pci_write_config_word(struct pci_dev *dev, u8 where, u16 val);
int pci_write_config_dword(struct pci_dev *dev, u8 where, u32 val);
void pci_set_master(struct pci_dev *dev);
@end smallexample

@node IRQ Interface
@subsection IRQ Interface

These are the routines that are used to attach and detach interrupt service
routines to hardware interrupts.

@smallexample
int request_irq(unsigned int irq,
void (*handler) ((int, void *, void *), unsigned long flags, const char *device,
                 void *dev_id);
void free_irq(unsigned int irq, void *dev_id);
void disable_irq(unsigned int irq);
void enable_irq(unsigned int irq);
@end smallexample

@node I/O Memory Mapping
@subsection I/O Memory Mapping

These are the routines that are typically used to map PCI bus or physical
addresses to CPU virtual addresses.  LiS includes some backward compatibility
here to older kernel versions.

@smallexample
void *ioremap_nocache(unsigned long offset, unsigned long size);
void iounmap(void *addr);
void *vremap(unsigned long offset, unsigned long size);
unsigned long virt_to_phys(volatile void *addr);
void *phys_to_virt(unsigned long addr);
@end smallexample

@node I/O Port Access
@subsection I/O Port Access

These are the routines that allow a driver to register I/O ports.

@smallexample
int check_region(unsigned int from, unsigned int extent);
void request_region(unsigned int from, unsigned int extent, const char *name);
void release_region(unsigned int from, unsigned int extent);
@end smallexample

@node Memory Allocation
@subsection Memory Allocation

These are the kernel routines that can be used to allocate memory.  LiS also has
a more insulated abstraction for kernel memory allocation.  It is recommended
that you use the [66]LiS memory allocator versions rather than the direct kernel
versions.

@smallexample
void *kmalloc(size_t nbytes, int type);
void kfree(const void *ptr);
void *vmalloc(unsigned long size);
void vfree(void *ptr);
@end smallexample

@node DMA Routines
@subsection DMA Routines

These are the routines that are used to allocate a main-board old-style DMA
channel for use by your driver.  These are not much used anymore.
See below for a more elaborate abstraction of DMA routines.

@smallexample
int request_dma(unsigned int dma_nr, const char *device_id);
void free_dma(unsigned int dma_nr);
@end smallexample

@node Delay Routines
@subsection Delay Routines

This is the routine that simply spins the CPU for a given number of
microseconds.  LiS also redefines the symbol "jiffies" to a subroutine call to
help insulate STREAMS drivers from changes in the way the kernel keeps track of
time.  Remember, the redefinition is accomplished using C language defines, so
the following declarations describe the effective usage of these symbols, not
their literal definition.

@smallexample
void udelay(long micro_secs);
unsigned long jiffies;
@end smallexample

@node Printing Routines
@subsection Printing Routines

These are the most commonly used printf-like routines in the kernel.  STREAMS
drivers would be more portable if they used the cmn_err routine instead of
printk.

@smallexample
int printk(const char *fmt, ...);
int sprintf(char *bfr, const char *fmt, ...);
int vsprintf(char *bfr, const char *fmt, va_list args);
@end smallexample

@node Timer Routines
@subsection Timer Routines

These are the the routines that start and stop kernel timers.  STREAMS drivers
would be more portable if they used the standard "[71]timeout" routine.

@smallexample
void add_timer(struct timer_list *timer);
int del_timer(struct timer_list *timer);
@end smallexample
@tpindex struct timer_list

The following routine converts time in micro seconds to system "ticks".  The
"ticks" value is suitable for use with the timeout routine.  Note that if the
micro_sec parameter is less than the number of micro seconds in a system tick
then the routine returns zero.

@smallexample
unsigned lis_usectohz(unsigned micro_sec);
@end smallexample

The following routine is an LiS abstraction of the C library routine
gettimeofday.  Note the absence of the time zone parameter.

@smallexample
void lis_gettimeofday(struct timeval *tv);
@end smallexample
@tpindex struct timeval

The following two kernel routines are called via the LiS osif.c code.

@smallexample
void do_gettimeofday(struct timeval *tp);
void do_settimeofday(struct timeval *tp);
@end smallexample
@tpindex struct timeval

@node Sleep and Wakeup Routines
@subsection Sleep and Wakeup Routines

These are the kernel routines for sleeping using wait queues.  STREAMS drivers
should not be using these since only "open" and "close" routines are allowed to
sleep, and for those cases, [73]LiS semaphores would provide better insulation
from the kernel.  STREAMS "put" and "service" routines should use [74]LiS spin
locks for mutual exclusion.

@smallexample
void sleep_on(OSIF_WAIT_Q_ARG);
void interruptible_sleep_on(OSIF_WAIT_Q_ARG);
void wake_up(OSIF_WAIT_Q_ARG);
void wake_up_interruptible(OSIF_WAIT_Q_ARG);
@end smallexample

@node Thread Creation
@subsection Thread Creation

A STREAMS driver in LiS can create kernel threads if it so chooses.  The
following routine simplifies this task.  It consolidates all of the kernel
manipulations involved with the creation of a kernel thread into one place, thus
removing references to these kernel functions from STREAMS driver code.

@subsubsection Prototype

@smallexample
pid_t lis_thread_start(int (*fcn) (void *), void *arg, const char *name);
int lis_thread_stop(pid_t pid);
@end smallexample

Arguments

fcn

The function that is to be used as the entry point for the thread.

arg

The argument passed to the function.

name

An ASCII name associated with the thread.  This name should be less than 16
characters in length.  It will be the name of the thread that displays in a ps
listing.

@subsubsection Operation

lis_thread_start creates a new thread, performs some operations prior to
entering the fcn, and then calls fcn which acts as the "main" routine for the
thread.  The arg parameter is passed to fcn.

Before fcn is entered, the newly created thread will have shed all user space
files and mapped memory.  Thus, it is a kernel-only thread.

All signals are still enabled.  Note that when the kernel goes down for reboot
all processes are first sent a SIGTERM.  Once those have been processed, all
processes are then sent a SIGKILL.  It is the implementor's choice which of these
it pays attention to in order to exit prior to a reboot.

The fcn is entered with the "big kernel lock" NOT held, just as it would be for
calling the "kernel_thread" function directly.  On 2.2 kernels, the fcn should
get this lock so that it can utilize kernel services safely.

The user's fcn returns a value when it exits and that value is returned to the
kernel.  It is not clear that anything actually pays any attention to this
returned value.  It particular, it is not visible to the thread that started the
new thread.

lis_thread_start itself returns the process id of the new thread, or a negative
error number.  This value can be used to kill the thread.

lis_thread_stop kills a thread started by lis_thread_start.  It returns 0 for
success or a negative error number for failure.

@node Major/Minor Device Numbering
@subsection Major/Minor Device Numbering

Please note that LiS-2.17 changed the internal representation of the major and
minor device numbers within the 32 bit @code{dev_t} structure.  The following
documents the new format and usage conventions.
@tpindex dev_t

In STREAMS the dev_t structure is used to combine a major device number and a
minor device number into a single integer length quantity.  The Linux kernel
restricts these numbers to the range 0 to 255 (8-bit values).

@tpindex dev_t
LiS provides a typedef for @code{dev_t} that results in an unsigned integer
quantity.  Internal to LiS the high order 12 bits are used for major device
number and the low order 20 bits are used for minor device number.

@ignore
The Linux kernel, on the other hand, defines a structure of type kdev_t that it
uses internally for this same purpose.  The kdev_t type is an actual structure,
and not an integer.  Furthermore, the kernel defines a routine named makedevice
that generates one of these structures, given the major and minor numbers as
integers.  It appears that eventually the kernel will use this structure
exclusively and will expand the numbering space for both major and minor device
numbers.

This has caused LiS to use non-standard nomenclature for handling its dev_t
structures, since the routine makedevice is not compatible with the LiS dev_t
structure.

LiS now provides the following operations on dev_t structures.  Most of these
functions are provided by macros, so the following are "virtual" prototypes.

@table @code
@findex MAJOR
@item int MAJOR(dev_t dev);
Extracts the major device number

@findex MINOR
@item int MINOR(dev_t dev);
Extracts the minor device number

@findex MKDEV
@item dev_t MKDEV(int maj, int min);
Combines a major and minor device number into a dev_t

@findex DEV_SAME
@item int DEV_SAME(dev_t d1, dev_t d2);
True if the two devices are the same

@findex DEV_TO_INT
@item int DEV_TO_INT(dev_t dev);
Converts dev_t to an int
@end table
@end ignore

STREAMS drivers include the file @file{<sys/stream.h>} that causes the view of
@code{dev_t}
@tpindex dev_t
to change from the kernel's 8/8 view to the LiS 12/20 view.  To ensure proper
operation, STREAMS drivers should use the following functions to manipulate
@code{dev_t} variables.  These functions are SVR4 compatible.

@table @code
@findex getmajor
@item int getmajor(dev_t dev);
Extracts the major device number

@findex getminor
@item int getminor(dev_t dev);
Extracts the minor device number

@findex makedevice
@item dev_t makedevice(int maj, int min);
Combines a major and minor device number into a dev_t

@findex DEV_SAME
@item int DEV_SAME(dev_t d1, dev_t d2);
True if the two devices are the same

@findex DEV_TO_INT
@item int DEV_TO_INT(dev_t dev);
Converts dev_t to an int
@end table

The sample drivers that come with LiS now use these constructs to manipulate
device structures and can serve as examples for their usage.

Within a STREAMS driver it is occasionally necessary to make a @code{dev_t}
@tpindex dev_t
value in the external 8/8 format.  This is required, for example, when a driver
is using the @command{lis_mknod()}
@findex lis_mknode
function to create a device node at driver initialization time.  LiS provides
the function @command{UMKDEV(major, minor)} for this purpose.
@findex UMKDEV

@node LiS Memory Allocation
@subsection LiS Memory Allocation

LiS provides for several different styles of memory allocation, all of them
insulated from the Linux kernel.  These routines allow your driver to allocate
memory in several different ways while still maintaining compatibility with
different versions of the Linux kernel, with no driver recompilation required.

To use the LiS memory allocation routines include the file <sys/lismem.h> in
your STREAMS driver source code.

@node LiS malloc and free Equivalents
@subsection LiS malloc and free Equivalents

The first group of memory allocation routines are the routines that play the
role of "malloc" and "free." These routines keep a master linked list of all
allocated memory areas.  This list can be printed out via an ioctl to LiS.  Each
allocated area is tagged with the file name and line number of the code that
caused it to be allocated.  Each area contains a guard word at the front and back
to enable the allocator to detect "off by one" accesses outside the allocated
area.

LiS uses this allocator internally for allocating queues, messages and other
internal data structures.  This would be the allocator of choice for STREAMS
drivers to use to allocate instance structures.

Memory allocated in this manner is ultimately allocated by the kernel routine
"kmalloc".  As such, it is not guaranteed to be DMA-able (in the old style), or
to occupy physically contiguous memory locations.  [78]See below for routines
that can be used to allocate these types of memory areas.

The routines are as follows:

@example
void *ALLOC(int nbytes);
void *ALLOCF(int nbytes, char *tag);
void FREE(void *ptr);
@end example

The ALLOC and FREE routines are analogous to "malloc" and "free".  The ALLOCF
routine includes a character string which is prepended to the file name stored
as the location from which the allocation occurred.  It can serve as a tag for
the type of memory being allocated.

Usage examples:

@example
ptr = ALLOC(456);
FREE(ptr);
ptr = ALLOCF(578, "Instance: ");
FREE(ptr);
@end example

@node LiS Kernel Memory Allocators
@subsection LiS Kernel Memory Allocators

These routines use the LiS malloc/free internal routines to allow for more
flexibility in the options used when calling the kernel allocator.  These
routines all lead to a call on "kmalloc" with appropriate options.  It is worth
noting that the numerical value of the constants used in calling the kernel's
"kmalloc" routine changed between the 2.2 and 2.4 versions of the kernel.  Thus,
drivers which called the kernel's "kmalloc" directly have to be recompiled to
run in a 2.4 kernel.  STREAMS drivers using the memory allocation interface
defined here could run without modification and without a recompilation on both
kernels, assuming that the drivers otherwise did not use any direct kernel
functions.

@example
void *lis_alloc_atomic(int nbytes);
void *lis_alloc_kernel(int nbytes);
void *lis_alloc_dma(int nbytes);
void *lis_free_mem(void *mem_area);
@end example

These routines pass the allocation options GFP_@-ATOMIC, GFP_@-KERNEL, and
GFP_@-DMA, respectively, to "kmalloc" when allocating the memory.  LiS takes
care of passing the proper values to the kernel routine so that driver code can
remain portable.

The routine lis_free_mem returns a NULL pointer for the convenience of the
caller.

The kernel's kmalloc is restricted as to the number of bytes that it will
allocate.  The LiS routines do not have this restriction.  If the number of
requested bytes is larger than 16K the LiS allocation routines will call the
page allocator to allocate the memory.  The lis_free_mem routine knows whether to
free pages or to use the kernel's kfree routine.

Usage Examples:

@example
ptr = lis_alloc_kernel(sizeof(structure));
ptr = lis_free_mem(ptr);        /* returns NULL pointer */
@end example

@node LiS Page Allocator
@subsection LiS Page Allocator

These routines allow a STREAMS driver to allocate memory directly from the
kernel's page allocator.  Memory allocated in this manner occupies physically
contiguous locations and is suitable for use with bus master DMA PCI devices.

Unlike the kernel's page allocator, the size that is specified when calling the
LiS page allocator is in bytes, not "order", or other encoding of page size.  LiS
calculates the number of pages based upon the requested size.

Also, LiS does not require you to pass the size of the area when freeing the
page.

The routines are as follows:

@example
void *lis_get_free_pages(int nbytes);
void *lis_free_pages(void *ptr);
@end example

The lis_free_pages routine returns a NULL pointer for the convenience of the
caller.

Usage Examples:

@example
ptr = lis_get_free_pages(1024 * kbytes);
ptr = lis_free_pages(ptr);
@end example

@node LiS PCI Interface
@subsection LiS PCI Interface

To assist in the portability of STREAMS drivers across different
versions of the Linux kernel, LiS provides an abstraction of the PCI
configuration interface.  It defines a data structure that is used to describe a
PCI device and a set of routines that perform operations on PCI configuration
space.

Using these abstractions, a STREAMS driver can be portable from the 2.2 kernel
to the 2.4 kernel with no recompilation required.  The LiS structures completely
hide the kernel data structures and PCI configuration space operations from the
STREAMS driver.

To use this interface include the file <sys/lispci.h> in your STREAMS driver
source code.

@node The LiS PCI Device Structure
@subsection The LiS PCI Device Structure

This structure is distinct from a similar structure which is defined by the
Linux kernel, but which differs significantly between the 2.2 and 2.4 kernels.
The LiS version of this structure is oriented towards providing just enough
information to allow a driver to operate the PCI device, without being concerned
about the details of PCI bus topology.

This structure is used to return information to the STREAMS driver concerning
devices that meet certain criteria, such as device class or manufacturer devide
identification.

@smallexample
#define LIS_PCI_MEM_CNT 12      /* # mem addrs */
typedef struct lis_pci_dev @{
        unsigned bus;                   /* bus number */
        unsigned dev_fcn;               /* device/function code */
        unsigned vendor;                /* vendor id */
        unsigned device;                /* device id */
        unsigned class;                 /* class type */
        unsigned hdr_type;              /* PCI header type */
        unsigned irq;                   /* IRQ number */
        unsigned long mem_addrs[LIS_PCI_MEM_CNT];
        void *user_ptr;                 /* private for user */
@} lis_pci_dev_t;
@end smallexample
@tpindex struct lis_pci_dev

The bus field contains the bus number on which the device is located.  LiS
obtains this information from the kernel.

The dev_fcn field contains an encoding of the device number on the bus and the
function number within the device that this particular structure pertains to.
The pair bus and dev_fcn uniquely identifies a device in the PCI subsystem.
Devices can be searched for on the PCI bus by bus number and dev_fcn value (see
below).

Given a dev_fcn value, a pair of macros will extract the "device" portion and
the "function number" portion from it.

@table @code
@findex LIS_PCI_DEV
@item #define LIS_PCI_DEV(devfcn)
Extracts the "device" portion

@findex LIS_PCI_FCN
@item #define LIS_PCI_FCN(devfcn)
Extracts the "function number" portion

@findex LIS_MK_PCI_DEV_FCN
@item #define LIS_MK_DEV_FCN(dev,fcn)
Put dev and fcn together

Given a device number and a function number, this macro will synthesize a
dev_fcn value suitable for use in searching the bus.
@end table

The vendor and device fields contain the vendor id (manuracturer code) and the
vendor's device identifier for the device.  Devices can be searched for on the
PCI bus by vendor and device identifier (see below).

The class field contains the class code associated with the device.  Devices can
be searched for on the PCI bus by class code (see below).

The hdr_type field gives the type information for the PCI configuration space
header.

The irq field gives the IRQ number that is assigned to this device.  This is the
number that is used to attach an interrupt service routine to the device.

The mem_addrs field contains a list of addresses associated with the device.
These are raw PCI bus addresses and are not mapped into the address space of the
processor.  Empty slots contain the value zero.

@node LiS PCI Search Routines
@subsection LiS PCI Search Routines

These routines allow the STREAMS driver to find devices on the PCI bus and
obtain a pointer to the lis_pci_dev_t structure for the device.

@subsubsection @code{lis_pci_dev_t *lis_pci_find_device(unsigned vendor, unsigned device, lis_pci_dev_t *previous_struct);}

Find the device by vendor identification and vendor device identification.  By
passing in the pointer to the previous structure returned it is possible to find
all devices of a given type.

The routine returns NULL if there are no (more) devices for the given vender and
device identifiers.

Usage example:

@smallexample
lis_pci_dev_t *pcip = NULL;
while ((pcip = lis_pci_find_device(0x109e, 0x8474, pcip)) != NULL) @{
        pcip points to a unique device from this vendor
@}
@end smallexample

@subsubsection @code{lis_pci_dev_t *lis_pci_find_class(unsigned class, lis_pci_dev_t *previous_struct);}

Find the device by class.  The usage is similar to lis_pci_find_device in that
you can use a pointer to loop through all devices of a given class.

The function returns NULL if there are no (more) devices of the given class.

@subsubsection @code{lis_pci_dev_t *lis_pci_find_slot(unsigned bus, unsigned dev_fcn);}

Find the device by slot number.  If you know the bus number (zero for most simple
Intel PC systems) and the dev_fcn, you can obtain the PCI configuration
information for that particular "slot".  Use the LIS_MK_DEV_FCN macro to
synthesize the dev_fcn value from the "device" (slot) number and the function
number.

The function returns NULL if there is no device in that slot.

Note that this routine only returns one structure since it is not meaningful to
process a list of devices for the same slot.

@node LiS PCI Configuration Space Routines
@subsection LiS PCI Configuration Space Routines

The following routines are used to read and write PCI configuration space for a
particular device.  Configuration space can be accessed by byte, word (16 bit) or
dword (32 bit).

Each routine takes a pointer to an lis_pci_dev_t structure as an argument.  It
also takes an index value which is the byte offset from the base of the
configuration space for the device at which the given byte/word/dword is to be
read or written.

Care should be exercised when writing to configuration space since many of these
values are determined by the PCI BIOS at system boot time.

The lis_pci_set_master routine sets the "bus master DMA" bit for the given
device.  This is used for devices that perform bus master DMA.

The routines are as follows:

@smallexample
int lis_pci_read_config_byte(lis_pci_dev_t *dev, unsigned index,
                             unsigned char *rtn_val);
int lis_pci_read_config_word(lis_pci_dev_t *dev, unsigned index,
                             unsigned short *rtn_val);
int lis_pci_read_config_dword(lis_pci_dev_t *dev, unsigned index,
                              unsigned long *rtn_val);
int lis_pci_write_config_byte(lis_pci_dev_t *dev, unsigned index,
                              unsigned char val);
int lis_pci_write_config_word(lis_pci_dev_t *dev, unsigned index,
                              unsigned short val);
int lis_pci_write_config_dword(lis_pci_dev_t *dev, unsigned index,
                               unsigned long val);
void lis_pci_set_master(lis_pci_dev_t *dev);
@end smallexample

@node LiS PCI DMA Routines
@subsection LiS PCI DMA Routines

These routines are used to allocate memory suitable for use with PCI bus master
DMA devices or to map page-allocated memory for those purposes.

To understand what these routines do, please refer to the file
@file{/usr@-/src@-/linux@-/Documentation@-/DMA-mapping.txt} in a fairly recent 2.4 kernel
source tree.  The kernel provides more functionality than is provided in LiS, so
there are more routines documented there than are found in this interface.
@pgindex /usr/src/linux/Documentation/DMA-mapping.txt

You can use these routines in 2.2 kernels but the functions perfomed are simply
approximations of the 2.4 semantics and may not work in all cases.

Note that the LiS routines have simplified the kernel interface involving "DMA
handles" in such a way as to make these constructs easier to use and less error
prone.

The following routines are used to allocate memory which the hardware keeps
consistent between CPU access and DMA access.

@smallexample
void *lis_pci_alloc_consistent(lis_pci_dev_t *dev, size_t size,
                               lis_dma_addr_t * dma_handle);
void *lis_pci_free_consistent(lis_dma_addr_t * dma_handle);
@end smallexample

The following routines are used to obtain a DMA address from a returned DMA
handle.  You need to know whether or not your hardware environment is using
32-bit or 64-bit DMA addresses.

@smallexample
u32 lis_pci_dma_handle_to_32(lis_dma_addr_t * dma_handle);
u64 lis_pci_dma_handle_to_64(lis_dma_addr_t * dma_handle);
@end smallexample

The following routines are usd to map page-allocated memory for DMA purposes.
The direction indicator of LIS_SYNC_FOR_CPU means that you intend to use the
memory for DMA transfers into memory.  The direction indicator of
LIS_SYNC_FOR_DMA means that you intend to use the memory for DMA transfers out
of memory.  If the DMA operation goes both ways then use LIS_SYNC_FOR_BOTH.

@smallexample
void lis_pci_map_single(lis_pci_dev_t *dev, void *ptr, size_t size,
                        lis_dma_addr_t * dma_handle, int direction);
void *lis_pci_unmap_single(lis_dma_addr_t * dma_handle);
int lis_osif_pci_map_sg(struct pci_dev *hwdev, struct scatterlist *sg,
			int nents, int direction);
void lis_osif_pci_unmap_sg(struct pci_dev *hwdev, struct scatterlist *sg,
			int nents, int direction);
@end smallexample

The direction indicators are as follows:

@smallexample
LIS_SYNC_FOR_CPU
LIS_SYNC_FOR_DMA
LIS_SYNC_FOR_BOTH
@end smallexample

With mapped memory, i.e., non-consistent memory, you need to synchronize the
memory whenever the CPU writes into it and the DMA needs to read it, or when the
DMA has written into it and the CPU needs to read it.  The following routine is
used for that purpose.

@smallexample
void lis_pci_dma_sync_single(lis_dma_addr_t * dma_handle, size_t size,
                             int direction);
void lis_osif_pci_dma_sync_sg(struct pci_dev *hwdev,
			      struct scatterlist *sg,
			      int nelems, int direction);
@end smallexample

The following routines can be used at driver initialization time to discover and
control the addressing boundary restrictions of a device.

@smallexample
int lis_pci_dma_supported(lis_pci_dev_t *dev, u64 mask);
int lis_pci_set_dma_mask(lis_pci_dev_t *dev, u64 mask);
@end smallexample

Please consult the file @file{<sys/osif.h>} for additional routines that may be
present for DMA support.

@node LiS Atomic Functions
@subsection LiS Atomic Functions

LiS provides for atomic integers implemented in a portable fashion.  To declare
an LiS portable atomic integer use the following declaration syntax:

@smallexample
lis_atomic_t myatom;
@end smallexample

LiS then provides the following operations on variables of this type.

@smallexample
void lis_atomic_set(lis_atomic_t *atomic_addr, int valu);
int lis_atomic_read(lis_atomic_t *atomic_addr);
void lis_atomic_add(lis_atomic_t *atomic_addr, int amt);
void lis_atomic_sub(lis_atomic_t *atomic_addr, int amt);
void lis_atomic_inc(lis_atomic_t *atomic_addr);
void lis_atomic_dec(lis_atomic_t *atomic_addr);
int lis_atomic_dec_and_test(lis_atomic_t *atomic_addr);
@end smallexample

Of these, only lis_atomic_dec_and_test needs any explanation.  This routine
performs an atomic_dec on the variable and returns true if the counter reached
zero via that decrement operation.  Note that by the time the routine returns
some other CPU with access to the same variable may have changed its value.  So
the return reports only on the instantaneous value of the variable.

@node LiS Locks
@subsection LiS Locks

LiS provides an abstraction and an insulated interface to the Linux kernel for
spin locks, interrupt disabling and semaphores.  If you use this interface in
your STREAMS driver you can utilize these kernel services on different versions
of the Linux kernel without the necessity of recompiling your driver for each
version of the kernel.

The LiS locks are especially useful in consideration of Linux kernels compiled
with and without the SMP option set.  The spin locks and semaphores of the Linux
kernel are implemented using external inline functions.  These functions are
coded in assembly language and generate different sequences of instructions
depending upon the compile time setting of the SMP option.  Spin locks and
semaphores compiled with SMP reset will not function properly on a multi-CPU
system running an SMP kernel.

The LiS locks mechanism solves this problem by abstracting the locking
primitives into actual subroutines, not inlines, defined within LiS.  Since LiS
is compiled from source code when it is installed the subroutines in LiS have
the correct setting of SMP for the locking primitives.  This allows the STREAMS
driver code to be compiled once and the object code reused for multiple
installations with varying options.

The following sections document the spin locks, interrupt disabling and
semaphore mechanisms offered by LiS.  To use these mechanisms include the file
<sys/lislocks.h> in your STREAMS driver source code.

In choosing the appropriate type of lock to use, one must bear in mind that
STREAMS drivers are not allowed to "sleep" in "put" and "service" procedures,
only in "open" and "close" routines.  That means that spin locks are the mutual
exclusion mechanism of choice for "put" and "service" procedures.  It is
reasonable to use sleeping semaphores in "open" and "close" routines.

The simple interrupt exclusion mechanism can be used to exclude only interrupt
routine execution for a section of code.  However, this mechanism does not
exclude other "put" or "service" procedures that may be executed on other CPUs.
This may not be much of a consideration since LiS acquires a lock in the queue
structure before executing the "put" or "service" procedure pointed to by that
queue.

However, it could happen that the "read put/service" and "write put/service"
procedures get executed simultaneously since there are two different locks in
the STREAMS queues, one in the read queue and one in the write queue.  In this
case, the STREAMS driver code would need to use spin locks to protect data
structures shared between the read and write "put" or "service" procedures.
See the @samp{qlock} option for @command{strconf} for more information about LiS
implicit use of locks to protect put and service procedure entries.

@node LiS Spin Locks
@subsection LiS Spin Locks

LiS provides an implementation of spin locks that utilizes the Linux kernel's
spin lock mechanism to perform the actual locking functions.  The LiS
implementation adds features to the kernel spin locks such as the following:

@itemize @bullet
@item LiS spin locks are nestable.  The same thread can acquire the same lock and
release it in nested fashion.

@item LiS spin locks are more debuggable.  The LiS lock structure contains an
ASCII name for the lock which makes it easier to identify in debugging
situations.

@item LiS maintains a lock trace table.  A debugging option for LiS causes it to
log all spin lock operations to a trace table which can be printed out via an
option to the streams command.

@item LiS spin locks are portable.  A STREAMS driver can utilize the same LiS
lock mechanism across different versions of the Linux kernel.  This pushes the
kernel differences into LiS and out of the STREAMS driver code.

@item LiS spin locks are documented.  You don't have to read the kernel source
code to figure out how to use them.
@end itemize

For these reasons I highly recommend that STREAMS drivers use the LiS spin lock
implementation in place of the direct kernel spin locks.  The portability aspect
of LiS spin locks cannot be overemphasized.  Different Linux kernel compile-time
options can lead to a proliferation of STREAMS driver code versions, or the
necessity of always compiling the driver from source when it is installed.  LiS
spin locks allow a STREAMS driver to be compiled independently of kernel options
with only the binary needed at driver installation time.

To declare a spin lock, use the typedef lis_spin_lock_t, as in the following:

@tpindex lis_spin_lock_t

@smallexample
lis_spin_lock_t mylock;
@end smallexample


LiS spin locks must be initialized before they are used.  There is one
initialization routine no matter which style of locking you intend to use.

void lis_spin_lock_init(lis_spin_lock_t *lock, const char *name) ;

This routine initializes the spin lock and associates an ASCII string name with
it.  The pointer name is saved in the lock structure for later use in printing
out the lock trace table.  It is the caller's responsibility to ensure that the
name resides in memory that will persist for the duration of the existence of
the lock.

You can also use dynamically allocated spin locks.  This technique allows your
STREAMS driver to be completely immune from changes in kernel version regarding
the size of a spin lock since your driver only has to store a pointer to the
allocated lock.  The allocation and deallocation routines are as follows.

@smallexample
lis_spin_lock_t *lis_spin_lock_alloc(const char *name);
lis_spin_lock_t *lis_spin_lock_free(lis_spin_lock_t *lock, const char *name);
@end smallexample

The allocation function returns a pointer to the spin lock, or NULL if the
memory could not be allocated.  The free function returns a NULL pointer for the
convenience of the caller.

For further information on spin locks, see the section on [89]debugging spin
locks.

To lock and unlock a spinlock, use any of the following pairs of routines.  If
you use the first routine to lock the spin lock then be sure to use its
companion unlock routine.  For nesting considerations, [91]see below.

@smallexample
void lis_spin_lock(lis_spin_lock_t *lock);
void lis_spin_unlock(lis_spin_lock_t *lock);
int lis_spin_trylock(lis_spin_lock_t *lock);
@end smallexample

These routines are to be called only from background processing to lock and
unlock a spin lock.  The trylock routine locks the spin lock if it is available,
returning "true", or leaves it unlocked if it is unavailable, returning "false".

Background processing means any STREAMS driver processing that does not occur at
interrupt time.  These routines lock the lock but do not exclude interrupt
routines from execution.  Thus, your interrupt service routine can still be
called whether or not your driver is holding a spin lock that was locked with
one of these routines.

You can nest pairs of calls to these routines from the same thread of execution.
[92]See below for more information on lock nesting.

Usage example:

@smallexample
lis_spin_lock(&mylock);
...
lis_spin_unlock(&mylock);
@end smallexample

@smallexample
void lis_spin_lock_irq(lis_spin_lock_t *lock);
void lis_spin_unlock_irq(lis_spin_lock_t *lock);
@end smallexample

This pair of routines locks the spin lock with interrupts disabled for the
duration of the holding of the lock.  The routine lis_spin_lock_irq re-enables
interrupts after unlocking the lock.

You can use this technique to exclude interrupt routine execution.  However, it
is not advisable for interrupt routines themselves, or any routines called from
an interrupt routine, to use this mechanism since the unlock primitive
unconditionally enables interrupts, which may not be desirable from inside an
interrupt routine.

These routines may be used in nested fashion.  Only the outermost unlock routine
will actually enable interrupts.  [94]See below for more information about lock
nesting.

Usage example:

@smallexample
lis_spin_lock_irq(&mylock);
...
lis_spin_unlock_irq(&mylock);
@end smallexample

@smallexample
void lis_spin_lock_irqsave(lis_spin_lock_t *lock, int *flags);
void lis_spin_unlock_irqrestore(lis_spin_lock_t *lock, int *flags);
@end smallexample

This pair of routines is similar to the "spin_lock_irq" routines in that the
locking routine disables interrupts.  However, it saves the interrupt state in
the integer argument whose pointer is passed to the locking routine.  The unlock
routine then restores the interrupt state after unlocking the lock.

These routines are suitable for use by routines that are called both from
interrupt level and from background.  They also have the effect, when used in an
interrupt routine, of excluding multiple execution of an interrupt routine on
multiple CPUs in an SMP system.

These routines may be used in nested fashion.  Only the outermost unlock routine
will actually restore the interrupt state.  [96]See below for more information
about lock nesting.

Usage example:

@smallexample
lis_spin_lock_t mylock;
int flags;
lis_spin_lock_irqsave(&mylock, &flags);
...
lis_spin_unlock_irqrestore(&mylock, &flags);
@end smallexample

Note that the unlock routine is passed the address of the flags just as in
calling the lock routine.

@node Lock Nesting
@subsection Lock Nesting

LiS spin locks can be locked and unlocked in nested fashion.  When doing so, it
is always best to use the same pair of lock and unlock routines at all levels of
nesting for the same lock.  Mixing different types of locking can lead to
unexpected results and non-portable behavior.

LiS allows a single thread to lock spin locks in nested fashion.  That is, the
second and subsequent calls to the lock routine from a single thread will not
spin on the lock because of finding it in a locked state from the first call.
Also, every unlock call except the last one, the one that balances the first
locking call, does not unlock the lock.  Only the outermost unlock call causes
the lock to be unlocked.

If the nesting is via lis_spin_lock_irq, then only the outermost unlock call
enables interrupts.  If the nesting is via lis_spin_lock_irqsave, then only the
outermost unlock call restores the interrupt state.

When two or more threads attempt to lock a spin lock "simultaneously" only one
thread is allowed to proceed at a time.  The other threads "spin", that is, the
CPUs executing the other threads are executing a loop that tests the lock
repeatedly until it becomes available.  Consequently, it is advisable to use
locks to protect the execution of fairly short pieces of code if there is any
likelihood of contention for the lock.  While one thread is holding the lock,
other CPUs may be idling waiting for it.

In the context of locking, "simultaneously" means any time from the moment of
the first thread locking the spin lock until that thread unlocks the lock.  If
another thread attempts to lock the spin lock at any point in that interval then
it will "spin."

When multiple threads use multiple spin locks to protect multiple resources, it
is always a good idea if all threads execute "lock" operations on the multiple
spin locks in the same order.  It is also highly recommended that they execute
"unlock" operations in the exact reverse order as the "lock" operations.  This
avoids so-called "deadly embrace" situations in which process A acquires spin
lock A, process B acquires spin lock B, and then process A waits on B while
process B waits on A.

@node LiS Read/Write Locks
@subsection LiS Read/Write Locks

LiS offers an abstraction of the kernel's read/write locks.  The LiS abstractions
allow STREAMS drivers to use these locks without concern for changes that occur
from one version of the kernel to the next.

A read/write lock is declared as a special data object of type lis_rw_lock_t.
There are two types of routines to manipulate these locks.  One set operates on
the lock as a "read" lock.  The other set operates on the lock as a "write" lock.

There can be multiple threads owning the lock in read mode.  There can only be
one thread that owns the lock in write mode.  Furthermore, in order to acquire
the lock in write mode, all the owners of the read mode lock must give it up.

The locks are used in the obvious way.  If you only need to read the protected
structure you use the read lock routine.  If you need to change the structure you
use the write lock routine.

Note that once you have a read lock you must give it up in order to get the same
lock as a write lock.

The lock manipulation routines also allow for "regular", "irq" and "irqsave"
manipulations of the read/write locks, just as with spin locks.

You must initialize your lock before using it, just as with spin locks.  And in
parallel to spin locks LiS provides two initialization routines.  One operates
directly on the read/write lock, and the other allocates memory dynamically for
the lock.  You can deallocate the dynamically allocated lock by calling the
"free" routine.

The following is a listing of the read/write lock routines in LiS.  The
prototypes are in the file <sys/lislocks.h>.

@smallexample
void lis_rw_read_lock(lis_rw_lock_t *lock);
void lis_rw_write_lock(lis_rw_lock_t *lock);
void lis_rw_read_unlock(lis_rw_lock_t *lock);
void lis_rw_write_unlock(lis_rw_lock_t *lock);

void lis_rw_read_lock_irq(lis_rw_lock_t *lock);
void lis_rw_write_lock_irq(lis_rw_lock_t *lock);
void lis_rw_read_unlock_irq(lis_rw_lock_t *lock);
void lis_rw_write_unlock_irq(lis_rw_lock_t *lock);

void lis_rw_read_lock_irqsave(lis_rw_lock_t *lock, int *flags);
void lis_rw_write_lock_irqsave(lis_rw_lock_t *lock, int *flags);
void lis_rw_read_unlock_irqrestore(lis_rw_lock_t *lock, int *flags);
void lis_rw_write_unlock_irqrestore(lis_rw_lock_t *lock, int *flags);

void lis_rw_lock_init(lis_rw_lock_t *lock, const char *name);
lis_rw_lock_t *lis_rw_lock_alloc(const char *name);
lis_rw_lock_t *lis_rw_lock_free(lis_rw_lock_t *lock, const char *name);
@end smallexample

@node LiS Interrupt Enable/Disable
@subsection LiS Interrupt Enable/Disable

LiS provides primitives for enabling and disabling interrupts modelled after the
SVR4 SPL mechanism.  There is one routine that is used to disable interrupts and
another one for enabling interrupts.  The routines are as follows:

@smallexample
int lis_splstr(void);
void lis_splx(int x);
@end smallexample

The lis_splstr routine is used to disable interrupts.  It returns a value that
must be passed to lis_splx when it it desired to restore the interrupt level to
its previous state.  These two routines are implemented using the primitives
lis_spin_lock_irqsave and lis_spin_unlock_irqrestore.

These routines can be used from background code ("put" and "service" procedures,
or "open" and "close" routines), or from interrupt level.  LiS itself uses these
routines to protect STREAMS structures from ill-timed modification by interrupt
routines.  Many LiS utility routines, such as putq, getq and qenable, call these
routines within themselves.

It is safe, and occurs frequently, to use these routines in a nested fashion.
When using these routines in a nested fashion be sure that the value returned by
the call to lis_splstr at level n is the value passed back to lis_splx at level
n.  The nesting rules for these routines are otherwise the same as for the pair
lis_spin_lock_irqsave and lis_spin_unlock_irqrestore.

Usage examples:

@smallexample
int x, y;
x = lis_splstr();
...
y = lis_splstr();
...
lis_splx(y);
...
lis_splx(x);
@end smallexample

For further information on these routines see the section on [100]debugging spin
locks.

@node LiS Semaphores
@subsection LiS Semaphores

LiS provides an implementation of semaphores that is built upon the Linux
kernel's semaphores.  The LiS implementation adds features to the kernel
semaphores such as the following:

@itemize @bullet
@item LiS semaphores are more debuggable.  The LiS semaphore structure contains
fields that save the file name and line number of the semaphore owner.  This
makes it easier to debug drivers which utilize semaphores.

@item LiS semaphores retain error information.  When a "down" operation fails,
LiS saves the error number in the semaphore structure for post mortem analysis.

@item LiS semaphores are portable.  A STREAMS driver can utilize the same LiS
semaphore mechanism across different versions of the Linux kernel.  This pushes
the kernel differences into LiS and out of the STREAMS driver code.

@item LiS semaphores can be easily allocated dynamically so your driver is
completely immune from Linux kernel version considerations.

@item LiS semaphores are documented.  You don't have to read the kernel source
code to figure out how to use them.
@end itemize

For these reasons I highly recommend that STREAMS drivers use the LiS semaphore
implementation in place of the direct kernel semaphores.  The portability aspect
of LiS semaphores cannot be overemphasized.  Different Linux kernel compile-time
options can lead to a proliferation of STREAMS driver code versions, or the
necessity of always compiling the driver from source when it is installed.  LiS
semaphores allow a STREAMS driver to be compiled independently of kernel options
with only the binary needed at driver installation time.

To declare an LiS semaphore, use a declaration similar to the following:

@smallexample
lis_semaphore_t mysem;
@end smallexample

LiS semaphores must be initialized before they are used.  Use the following
routine to initialize a declared semaphore.

@smallexample
void lis_sem_init(lis_semaphore_t *, int);
@end smallexample

If you initialize the semaphore to 0, then the first "down" operation on the
semaphore will wait.  If you initialize it to 1, then the first "down" operation
will not wait.  If you initialize it to n, then the first n "down" operations
will not wait.

You can also allocate semaphores dynamically using the following routine.

@smallexample
lis_semaphore_t *lis_sem_alloc(int);
@end smallexample

This routine uses the kernel's memory allocator to allocate space for the
semaphore.  The lis_sem_destroy routine will deallocate it for you.  The
advantage of using this routine is that your STREAMS driver only has to have a
pointer to the semaphore, not a semaphore structure itself.  This adds an extra
level of protection of your driver from kernel version considerations.

You can use the semaphore value to manage a pool of resources by initializing a
semaphore to the number of items in the resource and having a driver open
routine perform a "down" operation on the semaphore.  This causes the open
operations to be queued until the resource is available.

LiS semaphores should be explicitly destroyed when they are no longer needed,
typically from your STREAMS driver close routine.  This operation is accomplished
via the following routine.

@smallexample
lis_semaphore_t *lis_sem_destroy(lis_semaphore_t *,int);
@end smallexample

This routine returns a NULL pointer for the convenience of the caller.

For further information on semaphores, see the section on [102]debugging
semaphores.

The following two routines are used to acquire and release a semaphore.

@smallexample
int lis_down(lis_semaphore_t *sem);
void lis_down_nosig(lis_semaphore_t *lsem);
void lis_up(lis_semaphore_t *sem);
@end smallexample

The routine @command{lis_down}
@findex lis_down
returns 0 for success and a negative error code for failure.  The caller has not
acquired the semaphore unless the routine returns zero.

One reason for a negative return could be that the calling task was signalled
while waiting for the semaphore to become available.  If this has occurred the
return code will be set to -EINTR.

The function @command{lis_down_nosig}
@findex lis_down_nosig
waits for the sempahore with signals blocked.  It is useful in driver close
routines that must use a semaphore to control access to the structures that need
to be deallocated.  It is common for the driver close routine to be called from
a process that has been signalled -- for example a process that was killed with
a @key{Ctrl-C} from the keyboard.  In this case, @command{lis_down} will return
immediately with @code{-EINTR}, an undesirable situation.  using
@command{lis_down_nosig} in this situation blocks signals so that the close
routine can wait on the semaphore even if the process has been signalled.

Semaphores cannot be used in nested fashion.  Care must be exercised that a
single thread only performs one "down" operation on a given semaphore.

When multiple threads use multiple semaphores to protect multiple resources, it
is always a good idea if all threads execute "down" operations on the multiple
semaphores in the same order.  It is also highly recommended that they execute
"up" operations in the exact reverse order as the "down" operations.  This avoids
so-called "deadly embrace" situations in which process A acquires semaphore A,
process B acquires semaphore B, and then process A waits on B while process B
waits on A.

Semaphores should be used only in STREAMS driver "open" and "close" routines.
STREAMS driver "put" and "service" procedures are not allowed to sleep.  They
should use spin locks instead of semaphores.

Usage example:

@smallexample
if (lis_down(&mysem) == 0) @{
        ...
        lis_up(&mysem);
@}
@end smallexample

@node Debugging Spin Locks
@subsection Debugging Spin Locks

LiS spin lock structures contain fields that assist in the debugging of
spin-lock related problems.  The LiS spin lock structure contains the following
fields.

Field Description

spin_lock_mem An opaque memory area that contains the kernel's spin lock
structure.

name

Pointer to an ASCII name for the lock.  This allows one to readily identify the
function of the lock (assuming that it is aptly named).

taskp

A (void *) which is really a (struct task_struct *) pointer.  It points to the
task that originally acquired the lock, or is NULL if no task has acquired the
lock.
@tpindex struct task_struct

spinner_file, spinner_line

File and line number of the most recent call to one of the lis_spin_lock
functions.  This tells which line of code most recently tried to get the lock.

owner_file, owner_line

File and line number of the call to one of the lis_spin_lock functions that
first acquired the lock.  These fields are set at the same time as the taskp
field.

unlocker_file, unlocker_line

File and line number of the call to one of the lis_spin_unlock functions that
performed the final unlock on the lock, thus making it available for another
thread.  These fields are set at the same time as the taskp field is set to NULL.

If a thread owns the lock then its value of the current task pointer will be in
taskp.  If there is no other thread spinning on the lock, and if the lock has not
been acquired in a nested fashion, then the spinner and owner fields will
indicate the same file and line number.

If the spinner and owner fields are different and if the taskp is non-NULL then
if the thread that most recently called one of the lis_spin_lock routines is
different from the task that owns the lock, then that other task is spinning on
the lock.  By examination of the lock you can see which task owns the lock and
where in the code it was acquired.  This is often enough information to figure
out why a deadlock is occurring.

A "deadly embrace" occurs when two threads each need to acquire two spin locks
but they acquire them in the opposite order from each other.  Under circumstances
of contention each process owns the lock that the other is spinning on and will
not release the lock until it acquires the other lock.  Thus, both threads spin
forever.

Note that the LiS splstr and splx functions are written in terms of LiS spin
locks.  LiS does not use these routines internally.  They are provided to the user
for backwards compatibility.  However, it is important to know that these
routines are spin locks in disguise.  This means that the order of use of these
functions mixed in with explicit spin lock manipulations may also lead to deadly
embraces.

An effective technique for troubleshooting these kinds of problems is to use the
two-machine kernel debugger, [105]kgdb.  With this setup you can break into the
target machine and look at memory using high level debugging techniques,
including printing out of structures.  Using kgdb you can find out where each CPU
is executing, look at the corresponding source code lines, observe the locks
that are involved, and then print out the lis_spin_lock_t structures for the
specific locks.  Oftentimes the information contained in the two locks will
immediately reveal the nature of the deadly embrace.

It is also possible to have LiS trace all lock and semaphore operations.  One of
the LiS debug bits enables this function.  To set this debug bit use the
following command.

@example
streams -d0x0x80000
@end example

This causes LiS to make entries in a global trace buffer named lis_spl_track.
The global pointer lis_spl_track_ptr indicates the next location in the table
into which an entry is to be placed, which means that it points to the oldest
entry in the buffer.  Entries in the buffer are of type spl_track_t.

The fields of this structure are as follows.
Field Description
type
The type of entry as follows.

                                         Value

Meaning

                                                1

splstr

                                                2

splx

                                                3

spin lock

                                                4

spin unlock

                                                5

semaphore down

                                                6

semaphore up

cpu

The cpu number of the processor which made this entry.  addr The address of the
spin lock or semaphore involved in the operation.

tskp
The task pointer for the task that made this entry.  state Nesting value for
spin locks, count field of the semaphore.

file, line

File and line number of the call to the LiS locking or semaphore routine that
caused this entry to be made.

The trace buffer contains 4096 of these entries, maintained in a circular
fashion.  By printing out these entries you can see the history of lock
manipulation within LiS.  The command streams -p causes LiS to print out this
table from within the kernel.  The resulting output can be found in
@file{/var/log/messages} (typically).  However, in practice the system is usually hung
when you need this information so you end up printing it from within the
debugger.
@pgindex /var/log/messages

@node Lock Semaphore and Queue Contention
@subsection Lock Semaphore and Queue Contention

The @command{streams} command can be used to enable the tracking of contetion
for locks, semaphores and STREAMS queues.  Use the command @samp{streams -D0x08}
to enable the contention tracking.  The command @samp{streams -L} then causes
the contention tables to be printed out.

Locks and semaphores are in contention when a thread goes to spin on a lock or
perform a @command{down} function on a sempahore, and the thread has to wait
because the lock or semaphore is owned by another thread.  LiS counts such
occurences on a per-lock basis and reports the results with the @samp{streams -L}
command.

Queues are in contention when the semaphore that controls access to the queue is
in contention.  However, there are options that affect which semaphore is used
to control access to a queue and these options will also have an effect on the
reporting of queue contention.

@node Debugging Semaphores
@subsection Debugging Semaphores

LiS semaphore structures contain fields that assist in the debugging of
semaphore related problems.  The LiS semaphore structure contains the following
fields.

Field Description

sem_mem
An opaque memory area that contains the kernel's semaphore structure.

taskp

A (void *) which is really a (struct task_struct *) pointer.  It points to the
task that most recently acquired the semaphore, or is NULL if no task has
acquired the semaphore.  The taskp is set to NULL just prior to calling the
kernel's up routine on the semaphore.  Thus it stays NULL if no other task is
pending on the semaphore.
@tpindex struct task_struct

downer_file, downer_line
File and line number of the most recent call to the lis_down function.  This
tells which line of code most recently tried to get the semaphore.

owner_file, owner_line
File and line number of the call to the lis_down function that acquired the
semaphore.  These fields are set at the same time as the taskp field.

upper_file, upper_line
File and line number of the call to the lis_up function.  These fields are set at
the same time as the taskp field is set to NULL.

If the taskp field is non-NULL then the semaphore is owned by the task so
indicated.  If it is NULL then the semaphore is unowned.  The upper fields show
where the semaphore was last released.

If the downer and owner fields both indicate the same file and line number then
that is an indication that the semaphore was acquired at that location in the
program.  If they are different, and if the taskp is non-NULL, that is an
indication that there is a task waiting on the semaphore at the downer location.
The owner fields show where the semaphore was acquired.

Bear in mind that semaphore acquisitions do not nest as is the case with spin
locks.  Therefore, if the same thread calls lis_down without calling lis_up on
the same semaphore then the thread will be deadlocked.  The downer and owner
fields will usually offer a clue to this type of deadlock.

You can also use the LiS [107]lock trace buffer mechanism to assist in debugging
semaphore usage.

@node STREAMS Utility Routines
@subsection STREAMS Utility Routines

The following routines are available to LiS STREAMS drivers.  These are standard
AT&T SVR4 utility routines.  They (hopefully) have the same semantics in LiS as
they do in SVR4 STREAMS.

These routines are presented here in alphabetical order with no description.
Please refer to the [109]AT&T SVR4 STREAMS documentation for the descriptions of
these routines.

@node Freezing Streams
@subsection Freezing Streams

There are two sets of routines that can be used to @samp{freeze} a stream.  They
are used in slightly different ways and have slightly different semantics.  One
set uses the routines
@command{freezestr()}
@findex freezestr
and @command{unfreezestr()};
@findex unfreezestr
the other set uses the routines
@command{qprocesoff()}
@findex qprocesoff
and @command{qprocson()}.
@findex qprocson

@subsubsection Freezestr and Unfreezestr

@example
void freezestr(queue_t *q);
void unfreezestr(queue_t *q);
@end example

These routines operate on the entire stream of which the queue is a member.  The
stream is found by traversing the chain of queues in both directions until
encountering a queue that is not linked to another queue.  As a simple example
it includes all queues from the stream head down through any pushed modules to
the driver queue in which one of those queues is the one passed as the parameter
to either of these routines.

The process of freezing the stream is to place it into a state such that
messages will not flow up and down the stream.  That is @command{put} and
@command{service} procedures will not be called.  It @command{putnext()}
@findex putnext
is called on a queue within a frozen stream the passed message is placed into a
special deferred message list.  Messages are removed from this list and passed
to the @command{put} procedure when the stream is later unfrozen.

Drivers that have frozen a stream should refrain from performing queuing
operations on queues within the stream, such as @command{getq} and
@command{putq}.  LiS does not enforce this so one must exercise some care when
using these routines.

SVR4 STREAMS specification says that the driver's close routine will not be
called if the stream is frozen.  LiS does not implement this rule and will close
a frozen stream.

LiS uses these routines internally at stream close time to stop message flow
when the stream is being dismantled.  It also uses them during @code{I_PUSH} and
@code{I_POP} processing to inhibit message flow while replumbing the stream.

Drivers should use these routines with some caution.  Because the stream is
frozen the driver cannot receive any messages from above or below, including
@code{M_IOCTL}.  This may make it tricky deciding when to unfreeze a stream.

@subsubsection Qprocsoff and Qprocson

@example
void qprocson(queue_t *rdq);
void qprocsoff(queue_t *rdq);
@end example

These routines are conventionally used in a driver open (@command{qprocson}) and
close (@command{qprocsoff}) routine.  In some STREAMS implementations
@command{qprocson} must be called to enable messages to flow into the queue once
open processing has completed.  This is not necessary in LiS.

In LiS it does no harm to call @command{qprocson} in the driver open routine and
@command{qprocsoff} in the driver close routine, though it is not necessary to
do so.

The effect of @command{qprocsoff} is similar to that of @command{freezestr}
except that it applies just to the single queue rather than to the entire
stream.  Once significant difference is that if a pushable modules is in a
@samp{qprocsoff} condition and a message flows into the module, STREAMS will
route the message to the next module or driver in the chain of queues, looking
for one that is enabled.  If no such module or driver exists, the messag will be
placed into the deferred message list of the queue at the far end of the chain
of queues.  The messages will be presented to the driver put routine when
@command{qprocon} is called.

It is best to use these routines only at open and close time since that seems to
have been the intent of the STREAMS designers.

@node Flushing Queue Bands
@subsection Flushing Queue Bands

A special note on flushing queue bands is in order.  The rules for flushing
queues are a bit complex, so we wish to review them here in some detail.

@vrindex M_DATA
@vrindex M_PROTO
@vrindex M_PCPROTO
@vrindex M_DELAY

First some definitions and some things that affect all queue flushing.  The
term "data message" in the context of queue flushing means messages of type
@code{M_DATA}, @code{M_PROTO}, @code{M_PCPROTO} or @code{M_DELAY}.  All other
message types are considered "non-data messages".  You may find it less than
intuitive that @code{M_PCPROTO} is considered a "data message".

@vrindex M_DATA
@vrindex M_PROTO
@vrindex M_BREAK
@vrindex M_CTL
@vrindex M_DELAY
@vrindex M_IOCTL
@vrindex M_PASSFP
@vrindex M_RSE
@vrindex M_SETOPTS
@vrindex M_SIG
@vrindex M_PCPROTO

The term "ordinary message" in the context of queue flushing means messages of
type @code{M_DATA}, @code{M_PROTO}, @code{M_BREAK}, @code{M_CTL},
@code{M_DELAY}, @code{M_IOCTL}, @code{M_PASSFP}, @code{M_RSE},
@code{M_SETOPTS} or @code{M_SIG}.  Please note that @code{M_PCPROTO} is not on
this list.

The flag argument of FLUSHDATA means that only "data messages" are to be
flushed.  The flag argument of FLUSHALL means that "all" messages are to be
flushed.  As we shall see, in flushing queue bands whether a message gets flushed
or not depends upon what the meaning of the word "all" is.

First, let's take the case of the routine flushq(q,flag).  If flag is set to
FLUSHDATA then all "data messages" in the entire queue, including all queue
bands, are flushed.  If the flag is set to FLUSHALL then the entire queue is
flushed.

The case of the routine flushband(q,band,flag) is more complicated.

If the band argument is zero then special rules apply.  In this case, only
"ordinary" messages are flushed from the queue.  The value of the flag parameter
does not influence the operation.  In Solaris STREAMS this behavior does not
occur.  They flush either "data messages" or "all" messages on band zero.
Comments in the Solaris 8 source code indicate that the author of the flush code
was somewhat confused on this point.

If the band argument is non-zero then the specific band of the queue is flushed
in a manner similar to that of flushq.  That is, the flag argument of FLUSHDATA
means just flush "data messages" and the value of FLUSHALL means flush "all"
messages from the specific band.

@vrindex M_PCPROTO
One further item needs some attention.  Whenever an @code{M_PCPROTO} (or other
"high priority") message is inserted into a STREAMS queue it is queued ahead
of all messages in any queue band.  This means that an @code{M_PCPROTO} cannot
be directed to a queue band.  It also means that flushband can never flush an
@code{M_PCPROTO}, or any other "high priority" message from the queue.  In
order to flush @code{M_PCPROTO}s you must call flushq and flush the entire
queue of either "data messages" or "all" messages.


@node Utility Prototypes
@subsection Utility Prototypes

@smallexample
int adjmsg(mblk_t *mp, int length);
struct msgb *allocb(int size, unsigned int priority);
@tpindex struct msgb
__________________________________________

queue_t *backq(queue_t *q);
int bcanput(queue_t *q, unsigned char band);
int bcanputnext(queue_t *q, unsigned char band);
void bcopy(void *src, void *dst, int nbytes);
int bufcall(unsigned size, int priority, void (*function) (long), long arg);
void bzero(void *addr, int nbytes);
__________________________________________

int canput(queue_t *q);
int canputnext(queue_t *q);
void cmn_err(int err_lvl, char *fmt, ...);
mblk_t *copyb(mblk_t *mp);
mblk_t *copymsg(mblk_t *mp);
__________________________________________

#define datamsg(type) -- true if msg->b_datap->db_type is data
mblk_t *dupb(mblk_t *mp);
mblk_t *dupmsg(mblk_t *mp);
__________________________________________

void enableok(queue_t *q);
mblk_t *esballoc(unsigned char *base, int size, int priority, frtn_t *freeinfo);
int esbbcall(int priority, void (*function) (long), long arg);
__________________________________________

void flushband(queue_t *q, unsigned char band, int flag);
void flushq(queue_t *q, int flag);
void freeb(mblk_t *bp);
void freemsg(mblk_t *mp);
void freezestr(queue_t *q);
void unfreezestr(queue_t *q);
__________________________________________

int getmajor(dev_t dev);
int getminor(dev_t dev);
mblk_t *getq(queue_t *q);
__________________________________________

int insq(queue_t *q, mblk_t *emp, mblk_t *mp);
__________________________________________

void *kmem_alloc(int siz, int wait_code);
void *kmem_zalloc(int siz, int wait_code);
void kmem_free(void *ptr, int siz);
__________________________________________

void linkb(mblk_t *mp1, mblk_t *mp2);
__________________________________________

int msgdsize(mblk_t *mp);
mblk_t *msgpullup(mblk_t *mp, int length);
int msgsize(mblk_t *mp);
__________________________________________

void noenable(queue_t *q);
__________________________________________

queue_t *OTHERQ(queue_t *q);
__________________________________________

int pullupmsg(mblk_t *mp, int length);
int putbq(queue_t *q, mblk_t *mp);
int putctl(queue_t *q, int type);
int putctl1(queue_t *q, int type, int param);
void putnext(queue_t *q, mblk_t *mp);
int putnextctl(queue_t *q, int type);
int putnextctl1(queue_t *q, int type, int param);
int putq(queue_t *q, mblk_t *mp);
__________________________________________

void qenable(queue_t *q);
void qreply(queue_t *q, mblk_t *mp);
int qsize(queue_t *q);
void qprocsoff(queue_t *rdq);
void qprocson(queue_t *rdq);
__________________________________________

queue_t *RD(queue_t *q);
queue_t *WR(queue_t *q);
queue_t *OTHERQ(queue_t *q);
mblk_t *rmvb(mblk_t *mp, mblk_t *bp);
void rmvq(queue_t *q, mblk_t *mp);
__________________________________________

int SAMESTR(queue_t *q);
int strqget(queue_t *q, qfields_t what, unsigned char band, long *val);
int strqset(queue_t *q, qfields_t what, unsigned char band, long val);
__________________________________________

int testb(int size, unsigned int priority);
__________________________________________

#define HZ -- ticks per second
typedef void timo_fcn_t (caddr_t arg);
@tpindex timeo_fcn_t
toid_t timeout(timo_fcn_t *timo_fcn, caddr_t arg, long ticks);
toid_t lis_untimeout(toid_t id);
__________________________________________

void unbufcall(int bcid);
mblk_t *unlinkb(mblk_t *mp);
int untimeout(int id);
__________________________________________

queue_t *WR(queue_t *q);
__________________________________________

int xmsgsize(mblk_t *mp);
@end smallexample

@node System Calls from within the Kernel
@subsection System Calls from within the Kernel

LiS provides STREAMS drivers with a few system calls that can be made from
within the kernel.  These calls are intended to allow STREAMS drivers to manage
their device special files through which the drivers are accessed.  For example,
by using the @dfn{lis_mknod} function a dynamically loaded driver can register itself
with LiS, obtain a major device number and make its "/dev" entries at module
load time.  Using the lis_unlink function it can remove these "/dev" entries when
the module unloads.

The semantics of the following routines are exactly the same as the user level
routines of the same names without the "lis_" prefix.  This is so because these
routines are really just wrappers on a kernel system call.  We list the function
prototypes here but leave the detailed documentation to "man pages" and other
documentation.

The following function prototypes exist in the file <sys/dki.h>.

@smallexample
int lis_mknod(char *name, int mode, dev_t dev);
int lis_unlink(char *name);
int lis_mount(char *dev_name, char *dir_name, char *fstype,
              unsigned long rwfla g, void *data);
int lis_umount(char *file, int flags);
@end smallexample

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Conformance
@chapter Conformance
@cindex conformance

@menu
* STREAMS Compatibility::
* Porting::
@end menu

@node STREAMS Compatibility
@section STREAMS Compatibility
@cindex compatibility

@cite{@value{PACKAGE_TITLE}} provides some degree of compatibility with other @dfn{STREAMS}
implementation as follows:

@table @cite
@item --- SVR 4.2 ES/MP
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{SVR 4.2 ES/MP}
to ease portability and common comprehension,
@pxref{SVR 4.2 Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- AIX 5L Version 5.1
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{AIX 5L Version 5.1}
to ease portability and common comprehension,
@pxref{AIX Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- HP-UX 11.0i v2
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{HP-UX 11.0i v2}
to ease portability and common comprehension,
@pxref{HP-UX Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- OSF/1 1.2/Digital UNIX/True 64
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{OSF/1 1.2/Digital UNIX}
to ease portability and common comprehension,
@pxref{OSF/1 Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- UnixWare 7.1.3 (OpenUnix 8)
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{UnixWare 7.1.3 (OpenUnix 8)}
to ease portability and common comprehension,
@pxref{UnixWare Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- Solaris 9/SunOS 5.9
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{Solaris 9/SunOS 5.9}
to ease portability and common comprehension,
@pxref{Solaris Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- SUPER-UX
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{SUPER-UX}
to ease portability and common comprehension,
@pxref{SUX Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- UXP/V
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{UXP/V}
to ease portability and common comprehension,
@pxref{UXP Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.

@item --- LiS-2.16.18
@cite{@value{PACKAGE_TITLE}} provides some degree of operational compatibility with
@cite{LiS 2.16}
to ease portability and common comprehension,
@pxref{LiS Compatibility, , , LiSSPG, STREAMS Programmer's Guide}.
@end table

For additional details,
@pxref{Top, , About This Manual, LiSSPG, STREAMS Programmer's Guide}.

@node Porting
@section Porting
@cindex porting

@table @cite
@item --- SVR 4.2 ES/MP
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{SVR 4.2 ES/MP}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from SVR 4.2 MP, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- AIX 5L Version 5.1
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{AIX 5L Version 5.1}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from AIX 5L Version 5.1, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- HP-UX 11.0i v2
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{HP-UX 11.0i v2}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from HP-UX 11.0i v2, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- OSF/1 1.2/Digital UNIX/True 64
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{OSF/1 1.2/Digital UNIX/True 64}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from OSF/1 1.2/Digital UNIX, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- UnixWare 7.1.3 (OpenUnix 8)
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{UnixWare 7.1.3 (OpenUnix 8)}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from UnixWare 7.1.3 (OpenUnix 8), , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- Solaris 9/SunOS 5.9
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{Solaris 9/SunOS 5.9}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from Solaris 9/SunOS 5.9, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- SUPER-UX
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{SUPER-UX}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from SUPER-UX, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- UXP/V
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{UXP/V}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from UXP/V, , , porting, Linux Fast-STREAMS Porting Guide}.

@item --- LiS-2.16.18
@cite{@value{PACKAGE_TITLE}} provides compatibility functions for source level compatibility with
@cite{LiS-2.16.18}
and to ease porting of modules and drivers to @cite{@value{PACKAGE_TITLE}}.
Portability considerations are mantained in a separate manual:
@pxref{Porting from Linux STREAMS (LiS) 2.16.18, , , porting, Linux Fast-STREAMS Porting Guide}.
@end table

For additional details,
@pxref{Top, , About This Manual, proting, Linux Fast-STREAMS Porting Guide}.

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Releases
@chapter Releases
@cindex releases

@include releases.texi

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Installation
@chapter Installation
@cindex installation

@include install.texi

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Copying
@unnumbered Copying

@menu
* GNU General Public License::
* GNU Lesser General Public License::
@end menu

@include texi/gpl.texi

@include texi/lesser.texi

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Documentation License
@unnumbered Documentation License

@menu
* GNU Free Documentation License::
@end menu

@include texi/fdl.texi

@c ----------------------------------------------------------------------------
@c ----------------------------------------------------------------------------

@node Indices
@unnumbered Indices
@menu
* Concept Index::		Index of Concepts
* Type Index::			Index of Data Types
* Function Index::		Index of Functions and Macros
* Variable Index::		Index of Variables and Constants
* File Index::			Index of Files and Programs
* Option Index::		Index of Configuration Options
* Author Index::		Index of Authors
@end menu

@c ----------------------------------------------------------------------------

@page
@node Concept Index
@section Index of Concepts
@printindex cp

@page
@node Type Index
@section Index of Data Types
@printindex tp

@page
@node Function Index
@section Index of Functions and Macros
@printindex fn

@page
@node Variable Index
@section Index of Variables and Constants
@printindex vr

@page
@node File Index
@section Index of Files and Prorams
@printindex pg

@page
@node Option Index
@section Index of Configuration Options
@printindex op

@page
@node Author Index
@section Index of Authors
@printindex au

@c ----------------------------------------------------------------------------

@page
@shortcontents
@page
@contents
@bye

