#!/usr/bin/perl
# =============================================================================
# 
# @(#) $RCSfile: gdmocheck,v $ $Name:  $($Revision: 0.9.2.3 $) $Date: 2007/09/29 14:28:02 $
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2001-2007  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>, or write to the
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date: 2007/09/29 14:28:02 $ by $Author: brian $
#
# -----------------------------------------------------------------------------
#
# $Log: gdmocheck,v $
# Revision 0.9.2.3  2007/09/29 14:28:02  brian
# - update gdmos and asns
#
# Revision 0.9.2.2  2007/09/09 22:58:52  brian
# - updates for namespace
#
# Revision 0.9.2.1  2007/09/06 10:59:10  brian
# - added new gdmo files
#
# =============================================================================

eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
	if $running_under_some_shell;

$progname = $0;

$debug	    = 0;
$trace	    = 0;
$verbose    = 0;
$crossref   = 0;
@infiles    = ();

while ($ARGV[0]=~/^-/) {
	$_ = shift;
	last if /^--/;
	if (/^-n/) { $nflag++; next; }
	if (/^-d/) { $debug	= 1; next; }
	if (/^-t/) { $trace	= 1; next; }
	if (/^-v/) { $verbose	= 1; next; }
	if (/^-x/) { $crossref	= 1; next; }
	if (/^-f(.*)/) { if ($1) { push @infiles, $1; } else { push @infiles, shift; } next; }
	if (/^-o(.*)/) { if ($1) { $outfile = $1; } else { $outfile = shift; } next; }
	usage();
	die "I don't recognize this switch: $_\\n";
}

foreach $infile (@ARGV) {
	push @infiles, $infile;
}

sub usage {
	print STDERR "I: $0 Usage:\n";
	print STDERR "I:   $0 ".'[-d] [-t] [-v] [ [-f] infile [ [-o] outfile ] ]'."\n";
	print STDERR "I: 	-d - turn on debug mode\n";
	print STDERR "I: 	-t - turn on trace mode (lots of info)\n";
	print STDERR "I: 	-v - turn on verbose mode (lots of info)\n";
	print STDERR "I: 	-x - report crossreferences in output\n";
	print STDERR "I: 	[-f] infile  -  input file (default stdin)\n";
	print STDERR "I: 	[-o] outfile - output file (default stdout)\n";
}

$printit++ unless $nflag;

$\ = "\n";	# add new-line to print
$* = 0;		# do signleline matching
undef $/;	# read entire file

$file = '';

sub readfile {
	my $fh = shift;
	my $file = <$ifh>; # read entire file
	chomp $file;
	# strip leading whitespace
	$file=~s/^(?:\s|\n)*//s;
	# strip trailing whitespace
	$file=~s/(?:\s|\n)*$//s;
	# put an EOL on end in case file ends with comment
	$file .= "\n";
	return $file;
}

@filesread = ();

if (scalar @infiles > 0) {
	foreach $infile (@infiles) {
		open (INFILEH,"<$infile") || die "can't open $infile for input";
		$ifh = \*INFILEH;
		$file .= readfile($ifh);
		push @filesread, $infile;
	}
} else {
	$ifh = \*STDIN;
	$file .= readfile($ifh);
}

if ($outfile) {
	open (OUTFILEH,">$outfile") || die "can't open $outfile for output";
	select OUTFILEH;
} else {
	select STDOUT;
}

sub getchunk {
	# Get a chunk from the current or next file.  We try to look ahead 
}

@keywords = (
	'ABSENT', 'ABSTRACT-SYNTAX', 'ALL', 'APPLICATION', 'AUTOMATIC', 'BEGIN', 'BIT', 'BOOLEAN', 'BY', 'CHARACTER',
	'CHOICE', 'CLASS', 'COMPONENT', 'COMPONENTS', 'CONSTRAINED', 'CONTAINING', 'DATE', 'DATE-TIME', 'DEFAULT',
	'DEFINITIONS', 'DURATION', 'EMBEDDED', 'ENCODED', 'ENCODING-CONTROL', 'END', 'ENUMERATED', 'EXCEPT', 'EXPLICIT',
	'EXPORTS', 'EXTENSIBILITY', 'EXTERNAL', 'FALSE', 'FROM', 'IDENTIFIER', 'IMPLICIT', 'IMPLIED', 'IMPORTS',
	'INCLUDES', 'INSTANCE', 'INSTRUCTIONS', 'INTEGER', 'INTERSECTION', 'MAX', 'MIN', 'MINUS-INFINITY',
	'NOT-A-NUMBER', 'NULL', 'OBJECT', 'OCTET', 'OF', 'OPTIONAL', 'PATTERN', 'PDV', 'PER', 'PLUS-INFINITY',
	'PRESENT', 'PRIVATE', 'REAL', 'RELATIVE-OID', 'SEQUENCE', 'SET', 'SETTINGS', 'SIZE', 'STRING', 'SYNTAX', 'TAG',
	'TAGS', 'TIME', 'TIME-OF-DAY', 'TRUE', 'TYPE-IDENTIFIER', 'UNION', 'UNIQUE', 'UNIVERSAL', 'WITH', 'XER'
);

@typenames = (
	'BMPString', 'ISO646String', 'GeneralizedTime', 'GeneralString', 'GraphicString', 'IA5String', 'NumericString',
	'ObjectDescriptor', 'PrintableString', 'TeletexString', 'T61String', 'UniversalString', 'UTCTime', 'UTF8String',
	'VideotexString', 'VisibleString');

$i = 1; foreach my $k (@keywords) { $keywords{$k} = $i++; }

# -------------------------------------
package Parser;
use strict;
# -------------------------------------

sub parse {
	my $type = shift;
	my $self = {};
	#print STDERR "Type is $type.";
	bless $self, $type;
	$self->{id} = ++$::oid;
	if ($::debug) {
		unless ($type=~/^Comment/) {
			$::depth++;
			if ($type=~/Template$/) {
				# $self->indent($::depth);
				# printf "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n";
			}
			$self->indent($::depth);
			printf "<$type> ... ";
			printf "\`".substr($_[0],0,index($_[0],"\n"))."'\n";
		}
	}
#	$self->{line} = $_[0];
#	$self->{success} = $::success;
	$::success = '';
	#print STDERR "Testing for ".ref($self).".";
	my $ret = $self->read(@_);
	if ($ret) {
		#print STDERR "Found ".ref($self).".";
#		unless ($::success) {
#			$::success = $self->{line};
#		}
#		if ($#::objects) {
#			$ret->{previous} = $::objects[-1];
#		}
		push @::objects, $ret;
#		my $n = $::root->{alloc}->{ref $ret}->{refs}++;
#		$::root->{alloc}->{total}->{refs}++;
		#print STDERR "Allocated ".$n." ".ref($ret).".";
	} else {
		#print STDERR "Not found ".ref($self).".";
#		unless ($::success) {
#			$::success = $self->{success};
#		}
	}
	if ($::debug) {
		unless ($type=~/^Comment/) {
			if ($ret) {
				$self->indent($::depth);
				print "<$type> FOUND ";
				$self->gdmo();
				print "";
			} else {
				#$self->indent($::depth);
				#print "<$type> not found";
			}
			if ($type=~/Template$/) {
				# $self->indent($::depth);
				# printf "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
			}
			$::depth--;
		}
	}
	return $ret;
}

sub indent {
	my $self = shift;
	my $depth = shift;
	my $i; for ($i=0;$i<$depth;$i++) {
		printf '|';
	}
	return;
}

sub read {
	my $self = shift;
	return ($self->error(@_));
}

sub error {
	my $self = shift;
	unless ($::error) {
		# $::error = $_[0];
		$::errob = ref $self; }
	return undef;
}

# -------------------------------------
package Generator;
use strict;
# -------------------------------------

sub generate {
	my $self = shift;
	my $sub = shift;
	#print STDERR "//generating ".ref($self)."(".$sub.")";
	#print STDERR $self;
	return $self->$sub(@_);
}

sub call {
	my $self = shift;
	if ($::trace) { printf "--!!".ref($self)."!!--"; }
	#print STDERR "// calling ".ref($self)."(".$_[0].")";
	#print STDERR $self;
	push @::backtrack, $self;
	my $s; foreach $s (@{$self->{children}}) {
		#print STDERR "// calling ".ref($self)."(".$_[0].",".ref($s).")";
		if (defined $s) { $s->generate(@_); }
	}
	pop @::backtrack;
}

sub xref {
	my $self = shift;
	#print STDERR "// xref'ing ".ref($self)."(xref).";
	#print STDERR $self;
	return $self->call('xref',@_);
}
sub gdmo {
	my $self = shift;
	#print STDERR "// gdmo'ing ".ref($self)."(gdmo).";
	return $self->call('gdmo',@_);
}
sub head {
	my $self = shift;
	#print STDERR "// head'ing ".ref($self)."(head).";
	return $self->call('head',@_);
}
sub stub {
	my $self = shift;
	return $self->call('stub',@_);
}
sub code {
	my $self = shift;
	#print STDERR "// code'ing ".ref($self)."(code).";
	return $self->call('code',@_);
}

sub xform {
	my $self = shift;
	my $prefix = shift;
	my $label = shift;
	my $suffix = shift;
	$label=~s/-/_/g;
	$label=~s/\./_/g;
	$label=~s/\//_/g;
	#$label=~s/$suffix$//;
	#$label.=$suffix;
	#$label=$prefix.$label;
	#if (length($label) > 20) {
	#	$label=~s/[aeiouy]//g;
	#}
	return $label;
}

sub decclass {
	my $self = shift;
	my $parent = shift;
	printf "\n$::indent"."class $self->{name}";
}

sub begclass {
	my $self = shift;
	my $parent = shift;
	$self->decclass($parent);
	printf " : public $parent {";
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
}

sub endclass {
	my $self = shift;
	my $parent = shift;
	my $name = $self->{name};
	my ($a,$e);
	$::indent=~s/^.//s;
	printf "\n$::indent"."public:";
	$::indent.="\t";
	printf "\n$::indent"."$name"."(";
	if (defined $self->{constructorrefs}) {
		foreach $a (@{$self->{constructorrefs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{name}&";
		}
	}
	if (defined $self->{constructorptrs}) {
		foreach $a (@{$self->{constructorptrs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{name} *";
		}
	}
	printf ");";
	printf "\n$::indent"."virtual ~$name"."();";
	$::indent=~s/^.//s;
	$::indent=~s/^.//s;
	printf "\n$::indent}";
	#if ($::indent=~/^$/) {
	printf ";\t// class $name";
	#} else {
	#printf " $name;";
	#}
	print '';
}

sub genclass {
	my $self = shift;
	my $parent = shift;
	$self->begclass($parent);
	$self->call('head',@_);
	$self->endclass($parent);
}

sub cdtors {
	my $self = shift;
	my @inits = shift;
	my $parent = shift;
	my ($a,$e);
	printf "\n$::indent"."$self->{scopedname}"."::$self->{name}"."(";
	if (defined $self->{constructorrefs}) {
		foreach $a (@{$self->{constructorrefs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{scopedname}& $a->{name}_R";
		}
	}
	if (defined $self->{constructorptrs}) {
		foreach $a (@{$self->{constructorptrs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{scopedname} *$a->{name}_P";
		}
	}
	printf ")";
	if (scalar @inits) {
		printf "\n$::indent".": "; undef $e;
		foreach $a (@inits) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a";
		}
	}
	printf "\n$::indent"."{";
	printf "\n$::indent"."}";
	printf "\n$::indent"."$self->{scopedname}"."::~$self->{name}"."(";
	printf ")";
	printf "\n$::indent"."{";
	printf "\n$::indent"."}";
}


# -------------------------------------
package ParserGenerator;
use strict;
use vars qw(@ISA);
@ISA = qw(Parser Generator);
# -------------------------------------

# -------------------------------------
package ParserGeneratorNewLine;
use strict;
use vars qw(@ISA);
@ISA = qw(Parser Generator);
# -------------------------------------

sub gdmo {
	my $self = shift;
	#print STDERR "// gdmo'ing ".ref($self)."(gdmo).";
	if (!$::first) { printf "\n$::indent"; $::first = 1; }
	return $self->call('gdmo',@_);
}

# -------------------------------------
package ParserGeneratorMajor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub call {
	my $self = shift;
	#print STDERR "// calling ".ref($self)."(".$_[0].")";
	push @::backtrack, ref $self;
	my $c; foreach $c (@{$self->{children}}) {
		#print STDERR "// calling ".ref($self)."(".$_[0].",".ref($c).")";
		$c->generate(@_,$self);
	}
	pop @::backtrack;
}

# -------------------------------------
package DotList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($s = $type->parse($line,@_[1,-1])));
		push @{$self->{items}}, $s;
		push @{$self->{children}}, $s;
		while ($line=~s/^\.//s) {
			$s->{commentplus} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($s = $type->parse($line,@_[1,-1])));
			push @{$self->{items}}, $s;
			push @{$self->{children}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	$type=~s/Comma$//;
	return $self->readitem($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf '.'; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			$::first = 1; # fool it
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
	}
}
package Comma;
use strict;
use vars qw(@ISA);
@ISA = qw(Punctuation);

sub read { my $self = shift; return $self->readsymbols(',',@_); }

# -------------------------------------
package CommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$bt);
		last TEST unless (($s = $type->parse($line,@_[1,-1])));
		push @{$self->{items}}, $s;
		push @{$self->{children}}, $s;
		$bt = $line;
		LOOP: {
			while ($line=~s/^,//s) {
				$s->{commentplus} = Comments->parse($line,@_[1,-1]);
				if (($s = $type->parse($line,@_[1,-1]))) {
					push @{$self->{items}}, $s;
					push @{$self->{children}}, $s;
					$bt = $line;
				} else {
					$line = $bt;
					last LOOP;
				}
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	$type=~s/Comma$//;
	return $self->readitem($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		$::indent=~s/^.//s;
	}
}

# -------------------------------------
package CommaListNewLine;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		$::indent=~s/^.//s;
	}
}

# -------------------------------------
package CommaListNewLineUnindented;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		#$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		#$::indent=~s/^.//s;
	}
}

# -------------------------------------
package CommaListUnindented;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		#$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		#$::indent=~s/^.//s;
	}
}

# -------------------------------------
package SimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($s = $type->parse($line,@_[1,-1])));
		push @{$self->{items}}, $s;
		push @{$self->{children}}, $s;
		while (($s = $type->parse($line,@_[1,-1]))) {
			push @{$self->{items}}, $s;
			push @{$self->{children}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	$type=~s/Simple$//;
	return $self->readitem($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		#$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			$s->gdmo();
		}
		#$::indent=~s/^.//s;
	}
}

# -------------------------------------
package SimpleListIndented;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			$s->gdmo();
		}
		$::indent=~s/^.//s;
	}
}

# -------------------------------------
package MandatoryBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^{//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{interior} = $type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{interior};
		last TEST unless ($line=~s/^}//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Braced$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MandatoryBracedIndent;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			$::indent.="\t";
			#printf "--".ref($self)."--";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}


package MandatoryParens;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{interior} = $type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{interior};
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Parens$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		#if (!$::first) { printf ' '; }
		printf '('; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		#if (!$::first) { printf ' '; }
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MandatoryBracketed;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{interior} = $type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{interior};
		last TEST unless ($line=~s/^\]//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Bracketed$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '['; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf ']'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OptionalBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^{//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{interior} = $type->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{interior};
		}
		last TEST unless ($line=~s/^}//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Braced$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{interior})) { $s->gdmo(); }
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OptionalBracedIndent;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{interior})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Punctuation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readsymbols {
	my $self = shift;
	my $token = shift;
	my $line = @_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/(\W)/\\$1/g;
		$substitute=~s/[ \t]+/\\s\*/g;
		#print STDERR "Punctuation substitute line is '".$substitute."'";
		last TEST unless ($line=~s/^$substitute//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SimpleToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readtoken {
	my $self = shift;
	my $token = shift;
	my $line = $_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/[ \t]+/\(\?\:\\s|\\n\)\*/g;
		#print STDERR "Substituting '$substitute'.";
		last TEST unless ($line=~s/^$substitute(?![a-zA-Z0-9_])//s);
		# $self->{token} = $&;
		#print STDERR "Got '$self->{token}'.";
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	return $self->readtoken($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SimpleUCToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	$type = uc $type;
	return $self->readtoken($type,@_);
}

# -------------------------------------
package SimpleUCTokenIndented;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DashedToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readtoken {
	my $self = shift;
	my $token = shift;
	my $line = $_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/-/ /g;
		$substitute=~s/[ \t]+/\\s\*-?\\s\*/g;
		#print STDERR "Substituting '$substitute'.";
		last TEST unless ($line=~s/^$substitute//s);
		# $self->{token} = $&;
		#print STDERR "Got '$self->{token}'.";
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	return $self->readtoken($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DashedTokenIndented;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


sub read { my $self = shift; return $self->readtoken('AUTOMATIC TAGS',@_); }

# =====================================
package Gdmo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# =====================================

sub printem {
	my $self = shift;
	my $line = shift;
	my @lines = ( split(/\n/,$line,$::context) );
	my $l; my $i = 0; foreach $l (@lines) {
		if ($i < $::context - 1) {
			print $l;
		}
		$i++;
	}
	return;
}

sub read {
	my $self = shift;
	my $line = $_[0];
	my $s;
	$::error = '';
	if (($self->{modules} = GdmoModuleList->parse($line,@_[1,-1]))) {
		push @{$self->{children}}, $self->{modules};
	}
	if (length($line)) {
		print '<'.$::errob.">:\nSYNTAX ERROR (LINE $::lineno, LENGTH ".length($line).") NEAR(LENGTH ".length($::error)."):\n";
		$self->printem($::error);
		print '<'.$::errob.">:\nSYNTAX ERROR (LINE $::lineno, LENGTH ".length($line).") SUCCESS(LENGTH ".length($::success)."):\n";
		$self->printem($::success);
		print '<'.$::errob.">:\nSYNTAX ERROR LAST 10 SUCCESSFUL OBJECTS:";
		my $i; for ($i=-10;$i<0;$i++) {
			my $s = $::objects[$i];
			if ($s) {
				printf '<'.ref($s).">:\n'";
				$s->gdmo();
				print "'";
			}
		}
		return 0;
	}
	$_[0] = $line;
	return $self;
}

sub head {
	my $self = shift;
	my @names = ( 'relations', 'bindings', 'subordinates', 'objects', 'objects', 'packages', 'actions', 'notifications', 'groups', 'constraints', 'attributes', 'parameters', 'mappings', 'behaviours' );
	my @headers = ( 'Name Binding', 'Subordination Rule', 'Managed Object Class Factory', 'Managed Object Class', 'Package', 'Action', 'Notification', 'Attribute Group', 'Constraint Rule', 'Attribute', 'Parameter', 'Behaviour' );
	my @suffixes = ( '', '', 'Factory', '', '', '', '', '', '', '', '', '' );
	if (0) {
		my ($x,$d,$i,$e);
		for ($i=0;$i<scalar @names;$i++) {
			# Generate declarations for all classes
			printf "\n// $headers[$i] declarations\n";
			foreach $x (sort keys %{$::root->{$names[$i]}}) {
				if (($d = $::root->{$names[$i]}->{$x}->{defn})) {
					printf "\nclass $d->{scopedname}"."$suffixes[$i];";
					$e++;
				}
			}
			if ($e) { $e = 0; } else { printf "\n// No items\n"; }
			printf "\n";
		}
	}
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	print '--@@ GDMOCHECK $Revision: 0.9.2.3 $';
	print '--@@ Copyright (c), 2001-2007 OpenSS7 Corporation  <http://www.openss7.com/>';
	print '--@@ Copyright (c), 1999-2000 Brian F. G. Bidulock <bidulock@openss7.org>';
	print '--@@ ';
	my $file = $::infile;
	$file = "(standard input)" unless ($file);
	my $date = `date`;
	$date=~s/(?:\s|\n)*$//s;
	print "--@@ Input File: <$file>";
	print "--@@ Special File: <$file\.specials>";
	print "--@@ Date: ".$date;
	print '--@@ ';
	my ($s,$i);
	$::first = 1;
	if (($s = $self->{modules})) { $s->gdmo(); }
	if (!$::first) { printf "\n"; $::first = 1; }
	print '--@@ ';
	print '--@@ end of gdmos';
	print '--@@ ';
	my ($id,$n,$s);
	if (1) {
		$i = 0;
		foreach $id (sort keys %{$::root->{gdmos}}) {
			unless (($s = $::root->{gdmos}->{$id}->{defn})) {
				if (defined $::root->{gdmos}->{$id}->{refs}) {
					$n = scalar @{$::root->{gdmos}->{$id}->{refs}};
					unless ($i) { print "--@@"; }
					printf "--@@ These modules reference \"$id\" $n times.\n";
					$i++;
				}
			}
		}
		if ($i) { print "--@@"; }
	}
	if ($i) {
		$i = 0;
		foreach $id (sort keys %{$::root->{gdmos}}) {
			if (($s = $::root->{gdmos}->{$id}->{defn})) {
				unless ($i) { print "--@@"; }
				printf "--@@ These modules define \"$id\"\n";
				$i++;
			}
		}
		if ($i) { print "--@@"; }
	}
	if (1) {
		my ($g,$l);
		foreach $g (@{$::root->{modules}}) {
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if ($g->{objects}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines MANAGED OBJECT CLASS $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no MANAGED OBJECT CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if (!$g->{objects}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{objects}->{$l}->{docs}}) {
						print "--@@ This module references MANAGED OBJECT CLASS $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no MANAGED OBJECT CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if ($g->{packages}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines PACKAGE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no PACKAGE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if (!$g->{packages}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{packages}->{$l}->{docs}}) {
						print "--@@ This module references PACKAGE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no PACKAGE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if ($g->{parameters}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines PARAMETER $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no PARAMETER."; }
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if (!$g->{parameters}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{parameters}->{$l}->{docs}}) {
						print "--@@ This module references PARAMETER $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no PARAMETER."; }
			$i = 0;
			foreach $l (sort keys %{$g->{relations}}) {
				if ($g->{relations}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines RELATIONSHIP CLASS $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no RELATIONSHIP CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{relations}}) {
				if (!$g->{relations}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{relations}->{$l}->{docs}}) {
						print "--@@ This module references RELATIONSHIP CLASS $l in module \"$id\".";
					}
					$i++;
				}
			}
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if ($g->{bindings}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines NAME BINDING $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no NAME BINDING."; }
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if (!$g->{bindings}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{bindings}->{$l}->{docs}}) {
						print "--@@ This module references NAME BINDING $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no NAME BINDING."; }
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if ($g->{attributes}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ATTRIBUTE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ATTRIBUTE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if (!$g->{attributes}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{attributes}->{$l}->{docs}}) {
						print "--@@ This module references ATTRIBUTE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ATTRIBUTE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if ($g->{groups}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ATTRIBUTE GROUP $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ATTRIBUTE GROUP."; }
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if (!$g->{groups}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{groups}->{$l}->{docs}}) {
						print "--@@ This module references ATTRIBUTE GROUP $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ATTRIBUTE GROUP."; }
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if ($g->{behaviours}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines BEHAVIOUR $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no BEHAVIOUR."; }
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if (!$g->{behaviours}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{behaviours}->{$l}->{docs}}) {
						print "--@@ This module references BEHAVIOUR $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no BEHAVIOUR."; }
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if ($g->{actions}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ACTION $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ACTION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if (!$g->{actions}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{actions}->{$l}->{docs}}) {
						print "--@@ This module references ACTION $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ACTION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if ($g->{notifications}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines NOTIFICATION $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no NOTIFICATION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if (!$g->{notifications}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{notifications}->{$l}->{docs}}) {
						print "--@@ This module references NOTIFICATION $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no NOTIFICATION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if ($g->{constraints}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines CONSTRAINT RULE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no CONSTRAINT RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if (!$g->{constraints}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{constraints}->{$l}->{docs}}) {
						print "--@@ This module references CONSTRAINT RULE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no CONSTRAINT RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if ($g->{subordinates}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines SUBORDINATION RULE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no SUBORDINATION RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if (!$g->{subordinates}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{subordinates}->{$l}->{docs}}) {
						print "--@@ This module references SUBORDINATION RULE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no SUBORDINATION RULE."; }
		}
	}
	if (1) {
		my ($g,$l);
		$g = $::root;
		if (1) {
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if (!$g->{objects}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{objects}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference MANAGED OBJECT CLASS $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no MANAGED OBJECT CLASS."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{objects}}) {
					if ($g->{objects}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define MANAGED OBJECT CLASS $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no MANAGED OBJECT CLASS."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if (!$g->{packages}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{packages}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference PACKAGE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no PACKAGE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{packages}}) {
					if ($g->{packages}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define PACKAGE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no PACKAGE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if (!$g->{parameters}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{parameters}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference PARAMETER $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no PARAMETER."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{parameters}}) {
					if ($g->{parameters}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define PARAMETER $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no PARAMETER."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{relations}}) {
				if (!$g->{relations}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{relations}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference RELATIONSHIP CLASS $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NAME BINDING."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{relations}}) {
					if ($g->{relations}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define RELATIONSHIP CLASS $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NAME BINDING."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if (!$g->{bindings}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{bindings}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference NAME BINDING $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NAME BINDING."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{bindings}}) {
					if ($g->{bindings}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define NAME BINDING $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NAME BINDING."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if (!$g->{attributes}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{attributes}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ATTRIBUTE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ATTRIBUTE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{attributes}}) {
					if ($g->{attributes}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ATTRIBUTE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ATTRIBUTE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if (!$g->{groups}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{groups}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ATTRIBUTE GROUP $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ATTRIBUTE GROUP."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{groups}}) {
					if ($g->{groups}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ATTRIBUTE GROUP $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ATTRIBUTE GROUP."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if (!$g->{behaviours}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{behaviours}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference BEHAVIOUR $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no BEHAVIOUR."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{behaviours}}) {
					if ($g->{behaviours}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define BEHAVIOUR $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no BEHAVIOUR."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if (!$g->{actions}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{actions}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ACTION $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ACTION."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{actions}}) {
					if ($g->{actions}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ACTION $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ACTION."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if (!$g->{notifications}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{notifications}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference NOTIFICATION $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NOTIFICATION."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{notifications}}) {
					if ($g->{notifications}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define NOTIFICATION $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NOTIFICATION."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if (!$g->{constraints}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{constraints}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference CONSTRAINT RULE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no CONSTRAINT RULE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{constraints}}) {
					if ($g->{constraints}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define CONSTRAINT RULE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no CONSTRAINT RULE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if (!$g->{subordinates}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{subordinates}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference SUBORDINATION RULE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no SUBORDINATION RULE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{subordinates}}) {
					if ($g->{subordinates}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define SUBORDINATION RULE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no SUBORDINATION RULE."; }
			}
		}
	}
	print '--@@ ';
	if ($::crossref) {
		print "--@@ ****************************************";
		my $e;
		my $i = 0;
		foreach $e (keys %::refs) {
			$i++;
			unless ($::defs{$e}->{count}) {
				unless (${%{$::spec->{vars}}}{$e}) {
					print "--@@ UNDEFINED REFERENCE: $e";
				}
			}
		}
		print "--@@ THERE ARE $i REFERENCES.";
		$i = 0;
		foreach $e (keys %::defs) {
			$i++;
			if ($::defs{$e}->{count} > 1) {
				print "--@@ DEFINITION $e DEFINED $::defs{$e}->{count} TIMES!";
			}
			unless ($::refs{$e}) {
				print "--@@ UNREFERENCED DEFINITION: $e";
			}
		}
		print "--@@ THERE ARE $i DEFINITIONS.";
	}
#	print STDERR ref($::root->{alloc});
#	my ($k); foreach $k (sort keys %{$::root->{alloc}}) {
#		print STDERR "Allocated ".$::root->{alloc}->{$k}->{refs}." $k.";
#	}
	my ($l); foreach $l ('objects', 'packages', 'parameters', 'attributes', 'groups', 'behaviours', 'actions', 'notifications', 'constraints', 'subordinates') {
		my ($k); foreach $k (sort keys %{$::root->{$l}}) {
			if ($::root->{$l}->{$k}->{defn}) {
				if (!defined $::root->{$l}->{$k}->{refs}) {
					#print STDERR "W: $l $k defined but never referenced!";
				}
			} elsif (defined $::root->{$l}->{$k}->{refs}) {
				print "--@@ $l $k referenced but never defined!";
				print STDERR "E: $l $k referenced but never defined!";
				my $r; foreach $r (@{$::root->{$l}->{$k}->{refs}}) {
					print "--@@ ".ref($r)." references undefined \"$r->{documentid}\":$k";
				}
			}
		}
	}
	# print a derivation tree
	my ($d); if ($d = $::root->{objects}->{top}->{defn}) {
		printf "\n--@@";
		printf "\n--@@ Derivation Tree:";
		printf "\n--@@";
		$d->showderived();
		printf "\n--@@\n";
	}
	# print a containment tree
	my ($d); if ($d = $::root->{objects}->{top}->{defn}) {
		printf "\n--@@";
		printf "\n--@@ Containment Tree:";
		printf "\n--@@";
		$d->showcontained();
		printf "\n--@@\n";
	}
	print "--@@ vim: comments=\\b\\:\\-\\-,\\:\\-\\-,\\f\\b\\:- fo+=tcqlornw tw=120 nocin nosi";
}



# -------------------------------------
package GdmoModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------
#
# -------------------------------------
package GdmoModule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# A GDMO module consists of zero or more template specifiers.  GDMO Templates are only valid outside
# of ASN.1 modules.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$e);
		$e = 0;
		if (($s = GdmoPreambleDirectives->parse($line,$self))) {
			$self->{preamble} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		if (($s = Module->parse($line,$self))) {
			$self->{module} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		if (($s = TemplateList->parse($line,$self))) {
			$self->{templates} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		if (($s = Asn1ModuleList->parse($line,$self))) {
			$self->{asn1modules} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		last TEST unless (
			!$self->{module} ||
			($self->{end} = EndToken->parse($line,$self))
		);
		if ($self->{end}) {
			push @{$self->{children}}, $self->{end};
		}
		if (($s = GdmoPostambleDirectives->parse($line,$self))) {
			$self->{postamble} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		last TEST unless ($e != 0);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my @names = ( 'bindings', 'subordinates', 'objects', 'objects', 'packages', 'actions', 'notifications', 'groups', 'constraints', 'attributes', 'parameters', 'behaviours' );
	my @headers = ( 'Name Binding', 'Subordination Rule', 'Managed Object Class Factory', 'Managed Object Class', 'Package', 'Action', 'Notification', 'Attribute Group', 'Constraint Rule', 'Attribute', 'Parameter', 'Behaviour' );
	my @suffixes = ( '', '', 'Factory', '', '', '', '', '', '', '', '', '' );
	my ($x,$d,$i,$e);
	for ($i=0;$i<scalar @names;$i++) {
		# Generate declarations for all classes
		printf "\n// $headers[$i] declarations\n";
		foreach $x (sort keys %{$self->{$names[$i]}}) {
			if (($d = $self->{$names[$i]}->{$x}->{defn})) {
				printf "\nclass $d->{scopedname}"."$suffixes[$i];";
				$e++;
			}
		}
		if ($e) { $e = 0; } else { printf "\n// No items\n"; }
		printf "\n";
	}
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{preamble})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (($s = $self->{module})) { $s->gdmo(); }
		if (($s = $self->{templates})) { $s->gdmo(); }
		if (($s = $self->{asn1modules})) { $s->gdmo(); }
		if (($s = $self->{end})) { $s->gdmo(); }
		if (($s = $self->{postamble})) { $s->gdmo(); }
		if (0) {
			my ($d,$i);
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			foreach $d (sort keys %{$self->{aliases}}) {
				unless ($i) { print "--@@"; }
				print "--@@ This module defines \"$d\".";
				$i++;
			}
			if ($i) { print "--@@"; }
		}
	}
}

package EndToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCTokenIndented);

# -------------------------------------
package Module;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MODULE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if ($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if ($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{documentoid};
		}
		last TEST unless ($self->{documentstring} || $self->{documentoid});
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; };
		printf 'MODULE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoPreambleDirectives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package GdmoPostambleDirectives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package GdmoPreambleDirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GDMO\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^Version$/) {
		} elsif ($self->{directive}=~/^Namespace$/) {
		} elsif ($self->{directive}=~/^Copyright$/) {
		} elsif ($self->{directive}=~/^Document$/) {
		} elsif ($self->{directive}=~/^Alias$/) {
		} elsif ($self->{directive}=~/^Include$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Gdmo'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GDMO.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package GdmoPostambleDirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GDMO\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^ChangeLog$/) {
		} elsif ($self->{directive}=~/^EndDocument$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Gdmo'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GDMO.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package Asn1ModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
# ModuleDefinition ::=
# 	ModuleIdentifier
# 	DEFINITIONS
# 	TagDefault
# 	ExtensionDefault
# 	"::="
# 	BEGIN
# 	ModuleBody
# 	END
# 
# ModuleIdentifier ::=
# 	modulereference
# 	DefinitiveIdentifier
# 
# DefinitiveIdentifier ::=
# 	"{" DefinitiveObjIdComponentList "}"
# 	| empty
# 
# DefinitiveObjIdComponentList ::=
# 	DefinitiveObjIdComponent
# 	| DefinitiveObjIdComponent DefinitiveObjIdComponentList
# 
# DefinitiveObjIdComponent ::=
# 	NameForm
# 	| DefinitiveNumberForm
# 	| DefinitiveNameAndNumberForm
# 
# DefinitiveNumberForm ::=
# 	number
# 
# DefinitiveNameAndNumberForm ::=
# 	identifier "(" DefinitiveNumberForm ")"
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)	
#
# ModuleDefinition ::=
# 	ModuleIdentifier
# 	DEFINITIONS
# 	EncodingReferenceDefault
# 	TagDefault
# 	ExtensionDefault
# 	"::="
# 	BEGIN
# 	ModuleBody
# 	EncodingControlSections
# 	END
# 
# EncodingReferenceDefault ::=
# 	encodingreference INSTRUCTIONS
# 	| empty
#
# EncodingControlSections ::=
#	EncodingControlSection EncodingControlSections
#	| empty
#
# EncodingControlSection ::=
#	ENCODING-CONTROL
#	encodingreference
#	EncodingInstructionAssignmentList
#
# encodingreference ::=
#	TAG
#	| XER
#	| ...	
#
# -------------------------------------
# ITU-T Rec. X.680 (2002)/Amd.4 (05/2007)	
# -------------------------------------
# encodingreference ::=
#	TAG
#	| XER
#	| PER
#	| ...	
# -------------------------------------
package encodingreference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{token} = TagToken->parse($line,@_[1,-1])) ||
			($self->{token} = XerToken->parse($line,@_[1,-1])) ||
			($self->{token} = PerToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{token};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package TagToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package XerToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package PerToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);


# -------------------------------------
package Asn1Module;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# ASN.1 modules are distingushed by
#
# ModuleIdentifier ObjectIdentifier DEFINITIONS ::= BEGIN ... END

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if ($self->{directives} = Asn1Directives->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{directives};
		}
		last TEST unless (($self->{name} = ModuleIdentifier->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{name};
		last TEST unless (($self->{oid} = ObjectIdentifierValue->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{oid};
		last TEST unless (($self->{definitions} = DefinitionsToken->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{definitions};
		if ($self->{tagdefault} = TagDefault->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{tagdefault};
		}
		if ($self->{extdefault} = ExtensionDefault->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{extdefault};
		}
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{begin} = BeginToken->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{begin};
		if ($self->{body} = ModuleBody->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{body};
		}
		last TEST unless (($self->{end} = EndToken->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{end};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{directives})) { $s->gdmo(); }
		foreach $s (@{$self->{comments}}) { $s->gdmo(); }
		$self->{name}->gdmo();
		$self->{oid}->gdmo();
		$self->{definitions}->gdmo();
		if (($s = $self->{tagdefault})) { $s->gdmo(); }
		if (($s = $self->{extdefault})) { $s->gdmo(); }
		$self->{assign}->gdmo();
		$self->{begin}->gdmo();
		if (($s = $self->{body})) { $s->gdmo(); }
		$self->{end}->gdmo();
		printf "\n$::indent\n$::indent"; $::first = 1;
	}
}

package Assign;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('::=',@_); }

package BeginToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCTokenIndented);

package DefinitionsToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCTokenIndented);

# -------------------------------------
# TagDefault ::=
# 	EXPLICIT TAGS
# 	| IMPLICIT TAGS
# 	| AUTOMATIC TAGS
# 	| empty
# -------------------------------------
package TagDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{tags} = ExplicitTags->parse($line,@_[1,-1])) ||
			($self->{tags} = ImplicitTags->parse($line,@_[1,-1])) ||
			($self->{tags} = AutomaticTags->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{tags};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ExplicitTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('EXPLICIT TAGS',@_); }

package ImplicitTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('IMPLICIT TAGS',@_); }

package AutomaticTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);


# -------------------------------------
# ExtensionDefault ::=
# 	EXTENSIBILITY IMPLIED
# 	| empty
# -------------------------------------
package ExtensionDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXTENSIBILITY IMPLIED',@_);
}

# -------------------------------------
package Identifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-)//s);
		$self->{identifier} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{identifier}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# ModuleBody ::=
# 	Exports Imports AssignmentList
# 	| empty
# -------------------------------------
package ModuleBody;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if ($self->{exports} = Exports->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{exports};
		}
		if ($self->{imports} = Imports->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{imports};
		}
		if ($self->{assignmentlist} = AssignmentList->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{assignmentlist};
		}
		#last TEST unless ($line=~s/^\s*((?:.|\n)*?)\s*(?=END)//s);
		#$self->{text} = $1;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{exports})) { $s->gdmo(); }
		if (($s = $self->{imports})) { $s->gdmo(); }
		if (($s = $self->{assignmentlist})) { $s->gdmo(); }
		#if (!$::first) { printf "\n$::indent"; $::first = 1; }
		#printf "$self->{text}"; $::first = 0;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
# Exports ::=
# 	EXPORTS SymbolsExported ";"
# 	| EXPORTS ALL ";"
# 	| empty
# -------------------------------------
package Exports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = ExportsToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (
			($self->{exports} = ExportsAll->parse($line,@_[1,-1])) ||
			($self->{exports} = ExportsEverything->parse($line,@_[1,-1])) ||
			($self->{exports} = ExportedSymbols->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{exports};
		last TEST unless (($self->{semicolon} = Semicolon->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{semicolon};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ExportsAll;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('ALL',@_); }

package ExportsEverything;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('EVERYTHING',@_); }

package Semicolon;
use strict;
use vars qw(@ISA);
@ISA = qw(Punctuation);

sub read { my $self = shift; return $self->readsymbols(';',@_); }

package ExportsToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCTokenIndented);

# -------------------------------------
# SymbolsExported ::=
# 	SymbolList
# 	| empty
# -------------------------------------
package ExportedSymbols;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('TypeReference',@_); }

# -------------------------------------
# Imports ::=
# 	IMPORTS SymbolsImported ";"
# 	| empty
# -------------------------------------
package Imports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = ImportsToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		if (($self->{imports} = SymbolsFromModuleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{imports};
		}
		last TEST unless (($self->{semicolon} = Semicolon->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{semicolon};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ImportsToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCTokenIndented);

# -------------------------------------
# SymbolsImported ::=
# 	SymbolsFromModuleList
# 	| empty
# 
# SymbolsFromModuleList ::=
# 	SymbolsFromModule
# 	| SymbolsFromModuleList SymbolsFromModule
# -------------------------------------
package SymbolsFromModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
# SymbolsFromModule ::=
# 	SymbolList FROM GlobalModuleReference
# -------------------------------------
package SymbolsFromModule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($self->{symbols} = SymbolList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{symbols};
		last TEST unless (($self->{from} = FromToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{from};
		last TEST unless (
			($self->{module} = GlobalModuleReference->parse($line,@_[1,-1])) ||
			($self->{module} = ModuleReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{module};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	# note the order, imported symbols are called with the associated
	# module on the stack
	$self->{module}->xref(@_);
	$self->{symbols}->xref(@_,$self->{module});
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{symbols}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\t"; $::first = 1;
		$self->{from}->gdmo();
		$self->{module}->gdmo();
	}
}

package FromToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# GlobalModuleReference ::=
# 	modulereference AssignedIdentifier
# 
# AssignedIdentifier ::=
# 	ObjectIdentifierValue
# 	| DefinedValue
# 	| empty
# -------------------------------------
package GlobalModuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{module} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{module};
		last TEST unless (($self->{object} = ObjectIdentifierValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{module}->xref(@_);
	$self->{object}->xref(@_,$self->{module});
	return;
}

# -------------------------------------
# SymbolList ::=
# 	Symbol
# 	| SymbolList "," Symbol
# -------------------------------------
package SymbolList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
# Symbol ::=
# 	Reference
# 	| ParameterizedReference
# -------------------------------------
package Symbol;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{reference} = SymbolReference->parse($line,@_[1,-1])) ||
			($self->{reference} = ParameterizedReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{reference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# Reference ::=
# 	typereference
# 	| valuereference
# 	| objectclassreference
# 	| objectreference
# 	| objectsetreference
# -------------------------------------
package SymbolReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{reference} = TypeReference->parse($line,@_[1,-1])) ||
			($self->{reference} = ValueReference->parse($line,@_[1,-1])) ||
			($self->{reference} = ObjectClassReference->parse($line,@_[1,-1])) ||
			($self->{reference} = ObjectReference->parse($line,@_[1,-1])) ||
			($self->{reference} = ObjectSetReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{reference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# AssignmentList ::=
# 	Assignment
# 	| AssignmentList Assignment
# -------------------------------------
package AssignmentList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
# Assignment ::=
# 	TypeAssignment
# 	| ValueAssignment
# 	| XMLValueAssignment
# 	| ValueSetTypeAssignment
# 	| ObjectClassAssignment
# 	| ObjectAssignment
# 	| ObjectSetAssignment
# 	| ParameterizedAssignment
# -------------------------------------
package Assignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{assignment} = TypeAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ValueAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = XMLValueAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ValueSetTypeAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ObjectClassAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ObjectAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ObjectSetAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ParameterizedAssignment->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{assignment};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{assignment}->gdmo();
	}
}

# -------------------------------------
# DefinedType ::=
# 	ExternalTypeReference
# 	| typereference
# 	| ParameterizedType
# 	| ParameterizedValueSetType
# -------------------------------------
package DefinedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])) ||
			($self->{type} = TypeReference->parse($line,@_[1,-1])) ||
			($self->{type} = ParameterizedType->parse($line,@_[1,-1])) ||
			($self->{type} = ParameterizedValueSetType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExternalTypeReference ::=
# 	modulereference
# 	"."
# 	typereference
# -------------------------------------
package ExternalTypeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modulereference};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{typename} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typename};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 1; # fool typereference into concatenating
		$self->{typename}->gdmo();
	}
}

# -------------------------------------
# NonParameterizedTypeName ::=
# 	ExternalTypeReference
# 	| typereference
# 	| xmlasn1typename
# -------------------------------------
package NonParameterizedTypeName;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{reference} = ExternalTypeReference->parse($line,@_[1,-1])) ||
			($self->{reference} = TypeReference->parse($line,@_[1,-1])) ||
			($self->{reference} = XmlAsn1TypeName->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{reference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# DefinedValue ::=
# 	ExternalValueReference
# 	| valuereference
# 	| ParameterizedValue
# -------------------------------------
package DefinedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = ValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = ParameterizedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExternalValueReference ::=
# 	modulereference
# 	"."
# 	valuereference
# -------------------------------------
package ExternalValueReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modulereference};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{valuename} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valuename};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{valuename}->gdmo();
	}
}

sub oid {
	my $self = shift;
	my ($s,$name);
	if (($s = $self->{modulereference})) {
		$name = $self->{modulereference}.".".$self->{valuename};
	} else {
		$name = $self->{valuename};
	}
	# Just return the value of name for now
	return "$name";
}

# -------------------------------------
# AbsoluteReference ::=
# 	"@" ModuleIdentifier
# 	"."
# 	ItemSpec
# -------------------------------------
package AbsoluteReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^@//s);
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modulereference};
		last TEST unless ($line=~s/^\.//s);
		last TEST unless (($self->{itemspec} = ItemSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{itemspec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		if (!$::first) { printf ' '; }
		printf '@'; $::first = 0;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		$self->{itemspec}->gdmo();
	}
}

# -------------------------------------
# ItemSpec ::=
# 	typereference
# 	| ItemId "." ComponentId
# -------------------------------------
package ItemSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{reference} = TypeReference->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{reference};
		} else {
			last TEST unless (($self->{itemid} = ItemId->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{itemid};
			last TEST unless ($line=~s/^\.//s);
			last TEST unless (($self->{componentid} = ComponentId->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{componentid};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{reference})) { $s->gdmo(); } else {
			$self->{itemid}->gdmo();
			printf '.';
			$self->{componentid}->gdmo();
		}
	}
}

# -------------------------------------
# ItemId ::=
# 	ItemSpec
# -------------------------------------
package ItemId;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{itemspec} = ItemSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{itemspec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ComponentId ::=
# 	identifier
# 	| number
# 	| "*"
# -------------------------------------
package ComponentId;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{componentid} = Identifier->parse($line,@_[1,-1])) ||
			($self->{componentid} = Number->parse($line,@_[1,-1])) ||
			$line=~s/^\*//s
		);
		if ($self->{componentid}) {
			push @{$self->{children}}, $self->{componentid};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{componentid})) { $s->gdmo(); } else { printf '*'; }
	}
}

# -------------------------------------
# TypeAssignment ::=
# 	typereference
# 	"::="
# 	Type
# -------------------------------------
package TypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ValueAssignment ::=
# 	valuereference
# 	Type
# 	"::="
# 	Value
# -------------------------------------
package ValueAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLValueAssignment ::=
# 	valuereference
# 	"::="
# 	XMLTypedValue
# -------------------------------------
package XMLValueAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{assign} = XMLTypedValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLTypedValue ::=
# 	"<" & NonParameterizedTypeName ">"
# 	XMLValue
# 	"</" & NonParameterizedTypeName ">"
# 	| "<" & NonParameterizedTypeName "/>"
# -------------------------------------
package XMLTypedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\s*\<//s);
		last TEST unless (($self->{name1} = NonParameterizedTypeName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{name1};
		if ($line=~s/^\s*\>\s*//s) {
			last TEST unless (($self->{value} = XMLValue->parse($line,@_[1,-1])));
			last TEST unless ($line=~s/^\s*\<\///s);
			last TEST unless (($self->{name2} = NonParameterizedTypeName->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{name2};
			# NOTE: name 2 must be the same as name1
			last TEST unless ($line=~s/^\s*\>\s*//s);
		} else {
			last TEST unless ($line=~s/^\s*\/\>\s*//s);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '<'; $::first = 0;
		$self->{name1}->gdmo();
		if ($self->{name2}) {
			printf '>'; $::first = 0;
			$::indent.="\t";
			$self->{value}->gdmo();
			$::indent=~s/.$//s;
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '</'; $::first = 0;
			$self->{name2}->gdmo();
			printf '>'; $::first = 0;
		} else {
			printf '/>'; $::first = 0;
		}
	}
}

# -------------------------------------
# ValueSetTypeAssignment ::=
# 	typereference
# 	Type
# 	"::="
# 	ValueSet
# -------------------------------------
package ValueSetTypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{valueset} = ValueSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valueset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ValueSet ::=
# 	"{" ElementSetSpecs "}"
# -------------------------------------
package ValueSet;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ElementSetSpecs',@_); }

# -------------------------------------
# Type ::=
# 	BuiltinType
# 	| ReferencedType
# 	| ConstrainedType
# -------------------------------------
package Type;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{type} = TypeWithConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{type};
		} elsif (
			($self->{type} = BuiltinType->parse($line,@_[1,-1])) ||
			($self->{type} = ReferencedType->parse($line,@_[1,-1]))
		) {
			push @{$self->{children}}, $self->{type};
			# ConstrainedType has indefinite recursion so we
			# expand it here...
			my $s; while (($s = Constraint->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $s;
				push @{$self->{constraints}}, $s;
			}
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# BuiltinType ::=
# 	BitStringType
# 	| BooleanType
# 	| CharacterStringType
# 	| ChoiceType
# 	| EmbeddedPDVType
# 	| EnumeratedType
# 	| ExternalType
# 	| InstanceOfType
# 	| IntegerType
# 	| NullType
# 	| ObjectClassFieldType
# 	| ObjectIdentifierType
# 	| OctetStringType
# 	| RealType
# 	| RelativeOIDType
# 	| SequenceOfType
# 	| SequenceType
# 	| SetOfType
# 	| SetType
# 	| TaggedType
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)	
#
# BuiltinType ::=
# 	BitStringType
# 	| BooleanType
# 	| CharacterStringType
# 	| ChoiceType
# 	| EmbeddedPDVType
# 	| EnumeratedType
# 	| ExternalType
# 	| InstanceOfType
# 	| IntegerType
# 	| NullType
# 	| ObjectClassFieldType
# 	| ObjectIdentifierType
# 	| OctetStringType
# 	| PrefixedType
# 	| RealType
# 	| RelativeOIDType
# 	| SequenceOfType
# 	| SequenceType
# 	| SetOfType
# 	| SetType
# 	| TaggedType
#
# ITU-T Rec. X.680 (2002)/Amd.3 (06/2006)	
#
# BuiltinType ::=
# 	BitStringType
# 	| BooleanType
# 	| CharacterStringType
# 	| ChoiceType
#	| DateType
#	| DateTimeType	
#	| DurationType	
# 	| EmbeddedPDVType
# 	| EnumeratedType
# 	| ExternalType
# 	| InstanceOfType
# 	| IntegerType
# 	| NullType
# 	| ObjectClassFieldType
# 	| ObjectIdentifierType
# 	| OctetStringType
# 	| PrefixedType
# 	| TimeType
# 	| TimeOfDayType
# 	| RealType
# 	| RelativeOIDType
# 	| SequenceOfType
# 	| SequenceType
# 	| SetOfType
# 	| SetType
# 	| TaggedType
# -------------------------------------
package BuiltinType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BitStringType->parse($line,@_[1,-1])) ||
			($self->{type} = BooleanType->parse($line,@_[1,-1])) ||
			($self->{type} = CharacterStringType->parse($line,@_[1,-1])) ||
			($self->{type} = ChoiceType->parse($line,@_[1,-1])) ||
			($self->{type} = DateType->parse($line,@_[1,-1])) ||
			($self->{type} = DateTimeType->parse($line,@_[1,-1])) ||
			($self->{type} = DurationType->parse($line,@_[1,-1])) ||
			($self->{type} = EmbeddedPDVType->parse($line,@_[1,-1])) ||
			($self->{type} = EnumeratedType->parse($line,@_[1,-1])) ||
			($self->{type} = ExternalType->parse($line,@_[1,-1])) ||
			($self->{type} = InstanceOfType->parse($line,@_[1,-1])) ||
			($self->{type} = IntegerType->parse($line,@_[1,-1])) ||
			($self->{type} = NullType->parse($line,@_[1,-1])) ||
			($self->{type} = ObjectClassFieldType->parse($line,@_[1,-1])) ||
			($self->{type} = ObjectIdentifierType->parse($line,@_[1,-1])) ||
			($self->{type} = OctetStringType->parse($line,@_[1,-1])) ||
			($self->{type} = PrefixedType->parse($line,@_[1,-1])) ||
			($self->{type} = TimeType->parse($line,@_[1,-1])) ||
			($self->{type} = TimeOfDayType->parse($line,@_[1,-1])) ||
			($self->{type} = RealType->parse($line,@_[1,-1])) ||
			($self->{type} = RelativeOIDType->parse($line,@_[1,-1])) ||
			($self->{type} = SequenceOfType->parse($line,@_[1,-1])) ||
			($self->{type} = SequenceType->parse($line,@_[1,-1])) ||
			($self->{type} = SetOfType->parse($line,@_[1,-1])) ||
			($self->{type} = SetType->parse($line,@_[1,-1])) ||
			($self->{type} = TaggedType->parse($line,@_[1,-1])) ||
			($self->{type} = AnyDefinedByType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package AnyDefinedByType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = AnyDefinedBy->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{valref} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valref};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package AnyDefinedBy;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('ANY DEFINED BY',@_); }

# -------------------------------------
# NamedType ::=
# 	identifier Type
# -------------------------------------
package NamedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ReferencedType ::=
# 	DefinedType
# 	| UsefulType
# 	| SelectionType
# 	| TypeFromObject
# 	| ValueSetFromObjects
# -------------------------------------
package ReferencedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (
			($s = DefinedType->parse($line,@_[1,-1])) ||
			($s = UsefulType->parse($line,@_[1,-1])) ||
			($s = SelectionType->parse($line,@_[1,-1])) ||
			($s = TypeFromObject->parse($line,@_[1,-1])) ||
			($s = ValueSetFromObjects->parse($line,@_[1,-1]))
		);
		$self->{type} = $s;
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# Value ::=
# 	BuiltinValue
# 	| ReferencedValue
# 	| ObjectClassFieldValue
# -------------------------------------
package Value;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BuiltinValue->parse($line,@_[1,-1])) ||
			($self->{value} = ReferencedValue->parse($line,@_[1,-1])) ||
			($self->{value} = ObjectClassFieldValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLValue ::=
# 	XMLBuiltinValue
# 	| XMLObjectClassFieldValue
# -------------------------------------
package XMLValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = XMLBuiltinValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLObjectClassFieldValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# BuiltinValue ::=
# 	BitStringValue
# 	| BooleanValue
# 	| CharacterStringValue
# 	| ChoiceValue
# 	| EmbeddedPDVValue
# 	| EnumeratedValue
# 	| ExternalValue
# 	| InstanceOfValue
# 	| IntegerValue
# 	| NullValue
# 	| ObjectIdentifierValue
# 	| OctetStringValue
# 	| RealValue
# 	| RelativeOIDValue
# 	| SequenceValue
# 	| SequenceOfValue
# 	| SetValue
# 	| SetOfValue
# 	| TaggedValue
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)	
#
# BuiltinValue ::=
# 	BitStringValue
# 	| BooleanValue
# 	| CharacterStringValue
# 	| ChoiceValue
# 	| EmbeddedPDVValue
# 	| EnumeratedValue
# 	| ExternalValue
# 	| InstanceOfValue
# 	| IntegerValue
# 	| NullValue
# 	| ObjectIdentifierValue
# 	| OctetStringValue
# 	| PrefixedValue
# 	| RealValue
# 	| RelativeOIDValue
# 	| SequenceValue
# 	| SequenceOfValue
# 	| SetValue
# 	| SetOfValue
#
# ITU-T Rec. X.680 (2002)/Amd.3 (06/2006)	
#
# BuiltinValue ::=
# 	BitStringValue
# 	| BooleanValue
# 	| CharacterStringValue
# 	| ChoiceValue
# 	| EmbeddedPDVValue
# 	| EnumeratedValue
# 	| ExternalValue
# 	| InstanceOfValue
# 	| IntegerValue
# 	| NullValue
# 	| ObjectIdentifierValue
# 	| OctetStringValue
# 	| PrefixedValue
# 	| TimeValue
# 	| RealValue
# 	| RelativeOIDValue
# 	| SequenceValue
# 	| SequenceOfValue
# 	| SetValue
# 	| SetOfValue
# -------------------------------------
package BuiltinValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BitStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = BooleanValue->parse($line,@_[1,-1])) ||
			($self->{value} = CharacterStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = ChoiceValue->parse($line,@_[1,-1])) ||
			($self->{value} = EmbeddedPDVValue->parse($line,@_[1,-1])) ||
			($self->{value} = EnumeratedValue->parse($line,@_[1,-1])) ||
			($self->{value} = ExternalValue->parse($line,@_[1,-1])) ||
			#($self->{value} = InstanceOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = IntegerValue->parse($line,@_[1,-1])) ||
			($self->{value} = NullValue->parse($line,@_[1,-1])) ||
			($self->{value} = ObjectIdentifierValue->parse($line,@_[1,-1])) ||
			($self->{value} = OctetStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = RealValue->parse($line,@_[1,-1])) ||
			($self->{value} = RelativeOIDValue->parse($line,@_[1,-1])) ||
			($self->{value} = SequenceValue->parse($line,@_[1,-1])) ||
			($self->{value} = SequenceOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = SetValue->parse($line,@_[1,-1])) ||
			($self->{value} = SetOfValue->parse($line,@_[1,-1])) # ||
			#($self->{value} = TaggedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLBuiltinValue ::=
# 	XMLBitStringValue
# 	| XMLBooleanValue
# 	| XMLCharacterStringValue
# 	| XMLChoiceValue
# 	| XMLEmbeddedPDVValue
# 	| XMLEnumeratedValue
# 	| XMLExternalValue
# 	| XMLInstanceOfValue
# 	| XMLIntegerValue
# 	| XMLNullValue
# 	| XMLObjectIdentifierValue
# 	| XMLOctetStringValue
# 	| XMLRealValue
# 	| XMLRelativeOIDValue
# 	| XMLSequenceValue
# 	| XMLSequenceOfValue
# 	| XMLSetValue
# 	| XMLSetOfValue
# 	| XMLTaggedValue
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)
#
# XMLBuiltinValue ::=
# 	XMLBitStringValue
# 	| XMLBooleanValue
# 	| XMLCharacterStringValue
# 	| XMLChoiceValue
# 	| XMLEmbeddedPDVValue
# 	| XMLEnumeratedValue
# 	| XMLExternalValue
# 	| XMLInstanceOfValue
# 	| XMLIntegerValue
# 	| XMLNullValue
# 	| XMLObjectIdentifierValue
# 	| XMLOctetStringValue
# 	| XMLPrefixedValue
# 	| XMLRealValue
# 	| XMLRelativeOIDValue
# 	| XMLSequenceValue
# 	| XMLSequenceOfValue
# 	| XMLSetValue
# 	| XMLSetOfValue
# 	| XMLTaggedValue
#
# ITU-T Rec. X.680 (2002)/Amd.3 (06/2006)
#
# XMLBuiltinValue ::=
# 	XMLBitStringValue
# 	| XMLBooleanValue
# 	| XMLCharacterStringValue
# 	| XMLChoiceValue
# 	| XMLEmbeddedPDVValue
# 	| XMLEnumeratedValue
# 	| XMLExternalValue
# 	| XMLInstanceOfValue
# 	| XMLIntegerValue
# 	| XMLNullValue
# 	| XMLObjectIdentifierValue
# 	| XMLOctetStringValue
# 	| XMLPrefixedValue
# 	| XMLTimeValue
# 	| XMLRealValue
# 	| XMLRelativeOIDValue
# 	| XMLSequenceValue
# 	| XMLSequenceOfValue
# 	| XMLSetValue
# 	| XMLSetOfValue
# 	| XMLTaggedValue
# -------------------------------------
package XMLBuiltinValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = XMLBitStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLBooleanValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLCharacterStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLChoiceValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLEmbeddedPDVValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLEnumeratedValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLExternalValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLInstanceOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLIntegerValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLNullValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLObjectIdentifierValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLOctetStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLRealValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLRelativeOIDValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLSequenceValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLSequenceOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLSetValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLSetOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = XMLTaggedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ReferencedValue ::=
# 	DefinedValue
# 	| ValueFromObject
# -------------------------------------
package ReferencedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = DefinedValue->parse($line,@_[1,-1])) ||
			($self->{value} = ValueFromObject->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# NamedValue ::=
# 	identifier Value
# -------------------------------------
package NamedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLNamedValue ::=
# 	"<" & identifier ">" XMLValue "</" & identifier ">"
# -------------------------------------
package XMLNamedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\<//s);
		last TEST unless (($self->{identifier1} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier1};
		last TEST unless ($line=~s/^\s*\>\s*//s);
		last TEST unless (($self->{value} = XMLValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		last TEST unless ($line=~s/^\<\///s);
		last TEST unless (($self->{identifier2} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier2};
		# NOTE identifier1 and identifier2 must be the same
		last TEST unless ($line=~s/^\s*\>\s*//s);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '<'; $::first = 1; # fool identifier
		$self->{identifier1}->gdmo();
		printf '>'; $::first = 0;
		$::indent.="\t";
		$self->{value}->gdmo();
		$::indent=~s/.$//s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '</'; $::first = 1; # fool identifier
		$self->{identifier2}->gdmo();
		printf '>'; $::first = 0;
	}
}

# -------------------------------------
# BooleanType ::=
# 	BOOLEAN
# -------------------------------------
package BooleanType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);
sub read { my $self = shift; return $self->readtoken('BOOLEAN',@_); }
# -------------------------------------

# -------------------------------------
# BooleanValue::=
# 	TRUE
# 	| FALSE
# -------------------------------------
package BooleanValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($line=~s/^(TRUE|FALSE)//s));
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{value}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# XMLBooleanValue ::=
# 	"<" & "true" "/>"
# 	| "<" & "false" "/>"
#
# ITU-T Rec. X.680 (2002)/Amd.1 (2003)
#
# XMLBooleanValue ::=
#	EmtpyElementBoolean
#	| TextBoolean
#
# EmtpyElementBoolean ::=
# 	"<" & "true" "/>"
# 	| "<" & "false" "/>"
#
# TextBoolean ::=
#	extened-true
#	| extended-false
# -------------------------------------
package XMLBooleanValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($line=~s/^\<(true|false)\s*\/\>\s*//s));
		$self->{value} = $1;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '<'."$self->{value}".'/>'; $::first = 0;
	}
}

# -------------------------------------
# IntegerType ::=
# 	INTEGER
# 	| INTEGER "{" NamedNumberList "}"
# -------------------------------------
package IntegerType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = IntegerToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		if (($self->{list} = NamedNumberListBraced->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{list};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package IntegerToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);
# -------------------------------------

# -------------------------------------
package NamedNumberListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);
# -------------------------------------

# -------------------------------------
# NamedNumberList ::=
# 	NamedNumber
# 	| NamedNumberList "," NamedNumber
# -------------------------------------
package NamedNumberList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListNewLineUnindented);
# -------------------------------------

# -------------------------------------
# NamedNumber ::=
# 	identifier "(" SignedNumber ")"
# 	| identifier "(" DefinedValue ")"
# -------------------------------------
package NamedNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# In ASN.1 1994 Integer types are inherently extensible.  In 1990 they are not.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{ellipses} = Ellipses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{ellipses};
		} else {
			last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{identifier};
			last TEST unless ($line=~s/^\(//s);
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless (
				($self->{number} = SignedNumber->parse($line,@_[1,-1])) ||
				($self->{number} = DefinedValue->parse($line,@_[1,-1]))
			);
			push @{$self->{children}}, $self->{number};
			last TEST unless ($line=~s/^\)//s);
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{ellipses})) { $s->gdmo(); } else {
			$self->{identifier}->gdmo();
			printf '('; $::first = 1;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{number}->gdmo();
			printf ')'; $::first = 0;
			if (($s = $self->{comments2})) { $s->gdmo(); }
		}
	}
}

# -------------------------------------
# SignedNumber ::=
# 	number
# 	| "-" number
# -------------------------------------
package SignedNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(0|-?[1-9][0-9]*)//s);
		$self->{number} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Number;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(0|[1-9][0-9]*)//s);
		$self->{number} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# IntegerValue ::=
# 	SignedNumber
# 	| identifier
# -------------------------------------
package IntegerValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (
			($s = SignedNumber->parse($line,@_[1,-1])) ||
			($s = Identifier->parse($line,@_[1,-1]))
			# FIXME: the identifier here must ne one of the identifiers in the
			# IntegerType with which the value is associated, and shall represent the
			# corresponding number.  See X.608 Clause 18.10.
		);
		$self->{value} = $s;
		push @{$self->{children}}, $s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLIntegerValue ::=
# 	SignedNumber
# 	| "<" & identifier "/>"
#
# ITU-T Rec. X.680 (2002)/Amd.1 ((10/2003)
#
# XMLIntegerValue ::=
#	XMLSignedNumber
#	| EmptyElementInteger
#	| TextInteger
#
# XMLSignedNumber ::=
#	number
#	| "-" & number
#
# EmptyElementInteger ::=
#	"<" & identifier "/>"
#
# TextInteger ::=
#	identifier
#
# -------------------------------------



# -------------------------------------
# EnumeratedType ::=
# 	ENUMERATED "{" Enumerations "}"
# -------------------------------------
package EnumeratedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = EnumeratedToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{enumerations} = EnumerationsBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{enumerations};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package EnumeratedToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package EnumerationsBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);

# -------------------------------------
# Enumerations ::=
# 	RootEnumeration
# 	| RootEnumeration "," "..." ExceptionSpec
# 	| RootEnumeration "," "..." ExceptionSpec "," AdditionalEnumeration
# -------------------------------------
package Enumerations;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootEnumeration->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{root};
		if ($line=~s/^\,//s) {
			$self->{string1} = $&;
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless ($line=~s/^\.\.\.//s);
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{exceptionspec} = ExceptionSpec->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{exceptionspec};
			if ($line=~s/^\,//s) {
				$self->{string2} = $&;
				$self->{comments3} = Comments->parse($line,@_[1,-1]);
				last TEST unless (($self->{additional} = AdditionalEnumeration->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{additional};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if ($self->{string1}) {
			printf ','; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '...'; $::first = 0;
			if (($s = $self->{comments2})) { $s->gdmo(); }
			if (($s = $self->{exceptionspec})) { $s->gdmo(); }
			if ($self->{string2}) {
				printf ','; $::first = 0;
				if (($s = $self->{comments3})) { $s->gdmo(); }
				if (!$::first) { printf "\n$::indent"; $::first = 1; }
				if (($s = $self->{additional})) { $s->gdmo(); }

			}
		}
	}
}

# -------------------------------------
# RootEnumeration ::=
# 	Enumeration
# -------------------------------------
package RootEnumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{enumeration} = Enumeration->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{enumeration};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# AdditionalEnumeration ::=
# 	Enumeration
# -------------------------------------
package AdditionalEnumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{enumeration} = Enumeration->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{enumeration};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# Enumeration ::=
# 	EnumerationItem
# 	| EnumerationItem "," Enumeration
# -------------------------------------
package Enumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListNewLineUnindented);
# -------------------------------------

# -------------------------------------
# EnumerationItem ::=
# 	identifier
# 	| NamedNumber
# -------------------------------------
package EnumerationItem;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{item} = NamedNumber->parse($line,@_[1,-1])) ||
			($self->{item} = Identifier->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# EnumeratedValue ::=
# 	identifier
# -------------------------------------
package EnumeratedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		# FIXME: identifier must be in enumerated type
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLEnumeratedValue ::=
# 	"<" & identifier "/>"
#
# ITU-T Rec. X.680 (2002)/Amd.1 ((10/2003)
#
# XMLEnumeratedValue ::=
#	EmptyElementEnumerated
#	| TextEnumerated
#
# EmptyElementEnumerated ::=
#	"<" & identifier "/>"
#
# TextEnumerated ::=
#	identifier
#
# -------------------------------------


# -------------------------------------
# RealType ::=
# 	REAL
# -------------------------------------
package RealType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REAL',@_);
}

# -------------------------------------
# RealValue ::=
# 	NumericRealValue
# 	| SpecialRealValue
# -------------------------------------
package RealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = NumericRealValue->parse($line,@_[1,-1])) ||
			($self->{value} = SpecialRealValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# NumericRealValue ::=
# 	realnumber
# 	| "-" realnumber
# 	| SequenceValue -- Value of the associated sequence type
# -------------------------------------
package NumericRealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = SignedRealNumber->parse($line,@_[1,-1])) ||
			($self->{value} = SequenceValue->parse($line,@_[1,-1]))
			# FIXME; where the sequence must contain mantisa base and exponent
			# named numbers (exponent may only be 2 or 10).
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package SignedRealNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^-?(?:0|[1-9][0-9]*)(?:\.[0-9][0-9]*)?//s);
		$self->{number} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# SpecialRealValue ::=
# 	PLUS-INFINITY
# 	| MINUS-INFINITY
# -------------------------------------
package SpecialRealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:PLUS|MINUS)-INFINITY//s);
		$self->{value} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{value}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# XMLRealValue ::=
# 	XMLNumericRealValue
# 	| XMLSpecialRealValue
# -------------------------------------
# XMLNumericRealValue ::=
# 	realnumber
# 	| "-" realnumber
#
# XMLSpecialRealValue ::=
# 	"<" & PLUS-INFINITY "/>"
# 	| "<" & MINUS-INFINITY "/>"
#
# ITU-T Rec. X.680 (2002)/Amd.1 ((10/2003)
#
# XMLNumericRealValue ::=
# 	realnumber
# 	| "-" & realnumber
# 
# XMLSpecialRealValue ::=
# 	EmptyElementReal
# 	| TextReal
# 
# EmptyElementReal ::=
# 	"<" & PLUS-INFINITY "/>"
# 	| "<" & MINUS-INFINITY "/>"
# 	| "<" & NOT-A-NUMBER "/>"
# 
# TextReal ::=
# 	"INF"
# 	| "-" & "INF"
# 	| "NaN"
# -------------------------------------



# -------------------------------------
# BitStringType ::=
# 	BIT STRING
# 	| BIT STRING "{" NamedBitList "}"
# -------------------------------------
package BitStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIT\s*STRING//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{list} = NamedBitListBraced->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{list};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'BIT STRING';
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedBitListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);
# -------------------------------------

# -------------------------------------
# NamedBitList::=
# 	NamedBit
# 	| NamedBitList "," NamedBit
# -------------------------------------
package NamedBitList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListNewLineUnindented);
# -------------------------------------

# -------------------------------------
# NamedBit ::=
# 	identifier "(" number ")"
# 	| identifier "(" DefinedValue ")"
# -------------------------------------
package NamedBit;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# In ASN.1 1994 Bit String types are inherently extensible.  In 1990 they are not.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{ellipses} = Ellipses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{ellipses};
		} else {
			last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{identifier};
			last TEST unless ($line=~s/^\(//s);
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless (
				($self->{number} = Number->parse($line,@_[1,-1])) ||
				($self->{number} = DefinedValue->parse($line,@_[1,-1]))
			);
			push @{$self->{children}}, $self->{number};
			last TEST unless ($line=~s/^\)//s);
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{ellipses})) { $s->gdmo(); } else {
			$self->{identifier}->gdmo();
			printf '('; $::first = 1;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{number}->gdmo();
			printf ')'; $::first = 0;
			if (($s = $self->{comments2})) { $s->gdmo(); }
		}
	}
}
package Ellipses;
use strict;
use vars qw(@ISA);
@ISA = qw(Punctuation);

sub read { my $self = shift; return $self->readsymbols('...',@_); }

# -------------------------------------
# BitStringValue ::=
# 	bstring
# 	| hstring
# 	| "{" IdentifierList "}"
# 	| "{" "}"
# 	| CONTAINING Value
# -------------------------------------
package BitStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Bstring->parse($line,@_[1,-1])) ||
			($self->{value} = Hstring->parse($line,@_[1,-1])) ||
			($self->{value} = BitStringValueList->parse($line,@_[1,-1])) ||
			($self->{value} = ContainingValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package Bstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^'([01]*)'[Bb]//s);
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "'$self->{value}'B"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Hstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^'([0-9A-Fa-f]*)'[Hh]//s);
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "'$self->{value}'H"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBracedIndent);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('IdentifierList',@_); }

# -------------------------------------
package ContainingValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{containing} = ContainingToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{containing};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# IdentifierList ::=
# 	identifier
# 	| IdentifierList "," identifier
# -------------------------------------
package IdentifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
# XMLBitStringValue ::=
# 	XMLTypedValue
# 	| xmlbstring
# 	| XMLIdentifierList
# 	| empty
# -------------------------------------
# XMLIdentifierList ::=
# 	"<" & identifier "/>"
# 	| XMLIdentifierList "<" & identifier "/>"
#
# ITU-T Rec. X.680 (2002)/Amd.1 ((10/2003)
#
# XMLIdentifierList ::=
# 	EmptyElementList
# 	| TextList
# 
# EmptyElementList ::=
# 	"<" & identifier "/>"
# 	| EmptyElementList "<" & identifier "/>"
# 
# TextList ::=
# 	identifier
# 	| TextList identifier
# -------------------------------------

# -------------------------------------
# OctetStringType ::=
# 	OCTET STRING
# -------------------------------------
package OctetStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('OCTET STRING',@_);
}

# -------------------------------------
# OctetStringValue ::=
# 	bstring
# 	| hstring
# 	| CONTAINING Value
# -------------------------------------
package OctetStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Bstring->parse($line,@_[1,-1])) ||
			($self->{value} = Hstring->parse($line,@_[1,-1])) ||
			($self->{value} = ContainingValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLOctetStringValue ::=
# 	XMLTypedValue
# 	| xmlhstring
# -------------------------------------


# -------------------------------------
# NullType ::=
# 	NULL
# -------------------------------------
package NullType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NULL',@_);
}

# -------------------------------------
# NullValue ::=
# 	NULL
# -------------------------------------
package NullValue;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NULL',@_);
}

# -------------------------------------
# XMLNullValue ::=
# 	empty
# -------------------------------------


# -------------------------------------
# SequenceType ::=
# 	SEQUENCE "{" "}"
# 	| SEQUENCE "{" ExtensionAndException OptionalExtensionMarker "}"
# 	| SEQUENCE "{" ComponentTypeLists "}"
# -------------------------------------
package SequenceType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SequenceToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		if (($self->{list} = ExtensionOrComponentTypeListBraced->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{list};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package SequenceToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
package ExtensionOrComponentTypeListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBracedIndent);
# -------------------------------------

# -------------------------------------
package ExtensionOrComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{exception} = ExtensionAndExceptionList->parse($line,@_[1,-1])) ||
			($self->{component} = ComponentTypeLists->parse($line,@_[1,-1]))
		);
		if ($self->{exception}) {
			push @{$self->{children}}, $self->{exception};
		}
		if ($self->{component}) {
			push @{$self->{children}}, $self->{component};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package ExtensionAndExceptionList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{exception} = ExtensionAndException->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{exception};
			if (($self->{extension} = ExtensionMarker->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{extension};
			}
		} else { last TEST; }
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExtensionAndException ::=
# 	"..."
# 	| "..." ExceptionSpec
# -------------------------------------
package ExtensionAndException;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\.\.\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{exception} = ExceptionSpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{exception};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '...'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{exception})) { $s->gdmo(); }
	}
}

# -------------------------------------
# OptionalExtensionMarker ::=
# 	"," "..."
# 	| empty
# -------------------------------------
package ExtensionMarker;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^\.\.\.//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf ','; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '...'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
# ComponentTypeLists ::=
# 	RootComponentTypeList
# 	| RootComponentTypeList "," ExtensionAndException ExtensionAdditions
# 	OptionalExtensionMarker
# 	| RootComponentTypeList "," ExtensionAndException ExtensionAdditions
# 	ExtensionEndMarker "," RootComponentTypeList
# 	| ExtensionAndException ExtensionAdditions ExensionEndMarker ","
# 	RootComponentTypeList
# 	| ExtensionAndException ExtensionAdditions OptionalExtensionMarker
# -------------------------------------
package ComponentTypeLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{root} = RootComponentTypeList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{root};
			goto DONE unless ($line=~s/^\,//s);
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
		}
		push @{$self->{children}}, $self->{root};
		last TEST unless (($self->{exception} = ExtensionAndException->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{exception};
		if (($self->{addition} = ExtensionAdditions->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{addition};
		}
		if (($self->{endmarker} = ExtensionMarker->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{endmarker};
			last TEST unless ($line=~s/^,//s);
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{list} = RootComponentTypeList->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{list};
		} else {
			if (($self->{extension} = ExtensionMarker->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{extension};
			}
		}
	DONE:
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exception})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{exception}->gdmo();
			if (($s = $self->{addition})) { $s->gdmo(); }
			if (($s = $self->{endmarker})) {
				$s->gdmo();
				printf ','; $::first = 0;
				if (($s = $self->{comments2})) { $s->gdmo(); }
				$self->{list}->gdmo();
			} else {
				if (($s = $self->{extension})) { $s->gdmo(); }
			}
		}
	}
}

# -------------------------------------
# RootComponentTypeList ::=
# 	ComponentTypeList
# -------------------------------------
package RootComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = ComponentTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExtensionEndMarker ::=
# 	"," "..."
# -------------------------------------
# ExtensionAdditions ::=
# 	"," ExtensionAdditionList
# 	| empty
# -------------------------------------
package ExtensionAdditions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ExtensionAdditionList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		printf ','; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}

# -------------------------------------
# ExtensionAdditionList ::=
# 	ExtensionAddition
# 	| ExtensionAdditionList "," ExtensionAddition
# -------------------------------------
package ExtensionAdditionList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListUnindented);
# -------------------------------------

# -------------------------------------
# ExtensionAddition ::=
# 	ComponentType
# 	| ExtensionAdditionGroup
# -------------------------------------
package ExtensionAddition;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{addition} = ComponentType->parse($line,@_[1,-1])) ||
			($self->{addition} = ExtensionAdditionGroup->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{addition};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExtensionAdditionGroup ::=
# 	"[[" VersionNumber ComponentTypeList "]]"
# -------------------------------------
package ExtensionAdditionGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[\[//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{version} = VersionNumber->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{version};
		}
		last TEST unless (($self->{list} = ComponentTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^\]\]//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '[['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (($s = $self->{version})) { $s->gdmo(); }
		$self->{list}->gdmo();
		if (!$::first) { printf ' '; }
		printf ']]'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
# VersionNumber ::=
# 	empty
# 	| number ":"
# -------------------------------------
package VersionNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{number} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{number}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# ComponentTypeList ::=
# 	ComponentType
# 	| ComponentTypeList "," ComponentType
# -------------------------------------
package ComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListUnindented);
# -------------------------------------

# -------------------------------------
# ComponentType ::=
# 	NamedType
# 	| NamedType OPTIONAL
# 	| NamedType DEFAULT Value
# 	| COMPONENTS OF Type
# -------------------------------------
package ComponentType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorNewLine);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{components} = ComponentsToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{components};
			last TEST unless (($self->{of} = OfToken->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{of};
			last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{type};
		} else  {
			last TEST unless (($self->{namedtype} = NamedType->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{namedtype};
			if (($self->{optional} = OptionalToken->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{optional};
			} elsif (($self->{default} = DefaultToken->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{default};
				last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{value};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# SequenceValue ::=
# 	"{" ComponentValueList "}"
# 	| "{" "}"
# -------------------------------------
package SequenceValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ComponentValueList',@_); }

# -------------------------------------
# ComponentValueList ::=
# 	NamedValue
# 	| ComponentValueList "," NamedValue
# -------------------------------------
package ComponentValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('NamedValue',@_);
}

# -------------------------------------
# XMLSequenceValue ::=
# 	XMLComponentValueList
# 	| empty
# -------------------------------------
# XMLComponentValueList ::=
# 	XMLNamedValue
# 	| XMLComponentValueList XMLNamedValue
# -------------------------------------

# -------------------------------------
# SequenceOfType ::=
# 	SEQUENCE OF Type
# 	| SEQUENCE OF NamedType
# -------------------------------------
package SequenceOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SequenceOfToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (
			($self->{type} = Type->parse($line,@_[1,-1])) ||
			($self->{type} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package SequenceOfToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
sub read { my $self = shift; return $self->readtoken('SEQUENCE OF',@_); }

# -------------------------------------
# SequenceOfValue ::=
# 	"{" ValueList "}"
# 	| "{" NamedValueList "}"
# 	| "{" "}"
# -------------------------------------
package SequenceOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ValueListOrNameValueList',@_); }

# -------------------------------------
package ValueListOrNameValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{list} = ValueList->parse($line,@_[1,-1])) ||
			($self->{list} = NamedValueList->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ValueList ::=
# 	Value
# 	| ValueList "," Value
# -------------------------------------
package ValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
# XMLSequenceOfValue ::=
# 	XMLValueList
# 	| XMLDelimitedItemList
# 	| XMLSpaceSeparatedList
# 	| empty
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)
#
#  The ammendment removes XMLSpaceSeparatedList.
#
# -------------------------------------
# XMLValueList ::=
# 	XMLValueOrEmpty
# 	| XMLValueOrEmpty XMLValueList
# -------------------------------------
# XMLValueOrEmpty ::=
# 	XMLValue
# 	| "<" & NonParameterizedTypeName "/>"
# -------------------------------------
# XMLSpaceSeparatedList ::=
# 	XMLValueOrEmpty
# 	| XMLValueOrEmpty " " XMLSpaceSeparatedList
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)
#
#  The ammendment removes XMLSpaceSeparatedList.
#
# -------------------------------------
# XMLDelimitedItemList ::=
# 	XMLDelimitedItem
# 	| XMLDelimitedItem XMLDelimitedItemList
# -------------------------------------
# XMLDelimitedItem ::=
# 	"<" & NonParameterizedTypeName ">" XMLValue
# 	"</" & NonParameterizedTypeName ">"
# 	| "<" & identifier ">" XMLValue "</" & identifier ">"
# -------------------------------------


# -------------------------------------
# SetType ::=
# 	SET "{" "}"
# 	| SET "{" ExtensionAndException OptionalExtensionMarker "}"
# 	| SET "{" ComponentTypeLists "}"
# -------------------------------------
package SetType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{set} = SetToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{set};
		last TEST unless (($self->{list} = ExtensionOrComponentTypeListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# SetValue ::=
# 	"{" ComponentValueList "}"
# 	| "{" "}"
# -------------------------------------
package SetValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ComponentValueList',@_);
}

# -------------------------------------
# XMLSetValue ::=
# 	XMLComponentValueList
# 	| empty
# -------------------------------------


# -------------------------------------
# SetOfType ::=
# 	SET OF Type
# 	| SET OF NamedType
# -------------------------------------
package SetOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SetOfToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (
			($self->{type} = Type->parse($line,@_[1,-1])) ||
			($self->{type} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package SetOfToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('SET OF',@_); }

# -------------------------------------
# SetOfValue ::=
# 	"{" ValueList "}"
# 	| "{" NamedValueList "}"
# 	| "{" "}"
# -------------------------------------
package SetOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ValueListOrNameValueList',@_);
}

# -------------------------------------
# XMLSetOfValue ::=
# 	XMLValueList
# 	| XMLDelimitedItemList
# 	| XMLSpaceSeparatedList
# 	| empty
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003)
#
#  The ammendment removes XMLSpaceSeparatedList.
#
# -------------------------------------


# -------------------------------------
# ChoiceType ::=
# 	CHOICE "{" AlternativeTypeLists "}"
# -------------------------------------
package ChoiceType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = ChoiceToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{alternatives} = AlternativeTypeListsBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{alternatives};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package ChoiceToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
package AlternativeTypeListsBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);
# -------------------------------------

# -------------------------------------
# AlternativeTypeLists ::=
# 	RootAlternativeTypeList
# 	| RootAlternativeTypeList ","
# 	ExtensionAndException ExtensionAdditionAlternatives OptionalExtensionMarker
# -------------------------------------
package AlternativeTypeLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootAlternativeTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{root};
		if ($line=~s/^,//s) {
			$self->{comments} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{exception} = ExtensionAndException->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{exception};
			if (($self->{addition} = ExtensionAdditionAlternatives->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{addition};
			}
			if (($self->{marker} = ExtensionMarker->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{marker};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exception})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{exception}->gdmo();
			if (($s = $self->{addition})) { $s->gdmo(); }
			if (($s = $self->{marker})) { $s->gdmo(); }
		}
	}
}

# -------------------------------------
# RootAlternativeTypeList ::=
# 	AlternativeTypeList
# -------------------------------------
package RootAlternativeTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = AlternativeTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExtensionAdditionAlternatives ::=
# 	"," ExtensionAdditionAlternativesList
# 	| empty
# -------------------------------------
package ExtensionAdditionAlternatives;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ExtensionAdditionAlternativesList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf ','; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}


# -------------------------------------
# ExtensionAdditionAlternativesList ::=
# 	ExtensionAdditionAlternative
# 	| ExtensionAdditionAlternativesList "," ExtensionAdditionAlternative
# -------------------------------------
package ExtensionAdditionAlternativesList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListUnindented);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('ExtensionAdditionAlternative',@_); }

# -------------------------------------
# ExtensionAdditionAlternative ::=
# 	ExtensionAdditionAlternativesGroup
# 	| NamedType
# -------------------------------------
package ExtensionAdditionAlternative;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{alternative} = ExtensionAdditionAlternativesGroup->parse($line,@_[1,-1])) ||
			($self->{alternative} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{alternative};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExtensionAdditionAlternativesGroup ::=
# 	"[[" VersionNumber AlternativeTypeList "]]"
# -------------------------------------
package ExtensionAdditionAlternativesGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[\[//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{version} = VersionNumber->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{version};
		}
		last TEST unless (($self->{list} = AlternativeTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^\]\]//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '[['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (($s = $self->{version})) { $s->gdmo(); }
		$self->{list}->gdmo();
		if (!$::first) { printf ' '; }
		printf ']]'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
# AlternativeTypeList ::=
# 	NamedType
# 	| AlternativeTypeList "," NamedType
# -------------------------------------
package AlternativeTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListNewLineUnindented);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('NamedType',@_); }

# -------------------------------------
# ChoiceValue ::=
# 	identifier ":" Value
# -------------------------------------
package ChoiceValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
# XMLChoiceValue ::=
# 	"<" & identifier ">" XMLValue "</" & identifier ">"
# -------------------------------------


# -------------------------------------
# SelectionType ::=
# 	identifier "<" Type
# -------------------------------------
package SelectionType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^\<//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		if (!$::first) { printf ' '; }
		printf '<'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003) 
# -------------------------------------

# -------------------------------------
# PrefixedType ::=
# 	TaggedType
# 	| EncodingPrefixedType
# -------------------------------------
package PrefixedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = TaggedType->parse($line,@_[1,-1])) ||
			($self->{type} = EncodingPrefixedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# EncodingPrefixedType ::=
# 	EncodingPrefix Type
# -------------------------------------
package EncodingPrefixedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{prefix} = EncodingPrefix->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{prefix};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# EncodingPrefix ::=
# 	"[" EncodingReference EncodingInstruction "]"
# -------------------------------------
package EncodingPrefix;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracketed);

sub read { my $self = shift; return $self->readinterior('EncodingPrefixList',@_); }

package EncodingPrefixList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{eref} = EncodingReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{eref};
		last TEST unless (($self->{inst} = EncodingInstruction->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{inst};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# PrefixedValue ::=
# 	Value
# -------------------------------------

# -------------------------------------
# XMLPrefixedValue ::=
# 	XMLValue
# -------------------------------------

# -------------------------------------
# TaggedType ::=
# 	Tag Type
# 	| Tag IMPLICIT Type
# 	| Tag EXPLICIT Type
# -------------------------------------
package TaggedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{tag} = Tag->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{tag};
		if (
			($self->{token} = ImplicitToken->parse($line,@_[1,-1])) ||
			($self->{token} = ExplicitToken->parse($line,@_[1,-1]))
		) {
			push @{$self->{children}}, $self->{token};
		}
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ImplicitToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package ExplicitToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# Tag ::=
# 	"[" Class ClassNumber "]"
#
# -------------------------------------
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003) 
# -------------------------------------
#
# Tag ::=
# 	"[" EncodingReference Class ClassNumber "]"
# 
# -------------------------------------
# -------------------------------------
package Tag;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[//);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{eref} = EncodingReference->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{eref};
		}
		if (($self->{class} = Class->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{class};
		}
		last TEST unless (($self->{number} = ClassNumber->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^\]//);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1;
		if (($s = $self->{eref})) { $s->gdmo(); }
		if (($s = $self->{class})) { $s->gdmo(); }
		$self->{number}->gdmo();
		printf ']'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003) 
# -------------------------------------
# EncodingReference ::=
# 	encodingreference ":"
# 	| empty
# -------------------------------------
package EncodingReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{eref} = encodingreference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{eref};
		last TEST unless ($line=~s/^\://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{eref}->gdmo();
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# ClassNumber ::=
# 	number
# 	| DefinedValue
# -------------------------------------
package ClassNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Number->parse($line,@_[1,-1])) ||
			($self->{value} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# Class ::=
# 	UNIVERSAL
# 	| APPLICATION
# 	| PRIVATE
# 	| empty
# -------------------------------------
package Class;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{class} = ClassUniversal->parse($line,@_[1,-1])) ||
			($self->{class} = ClassApplication->parse($line,@_[1,-1])) ||
			($self->{class} = ClassPrivate->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{class};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ClassUniversal;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('UNIVERSAL',@_); }

package ClassApplication;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('APPLICATION',@_); }

package ClassPrivate;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('PRIVATE',@_); }

# -------------------------------------
# TaggedValue ::=
# 	Value
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003) 
#
#  The Ammendment 1 deletes TaggedValue. 
#
# -------------------------------------
package TaggedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(Value);
# -------------------------------------

# -------------------------------------
# XMLTaggedValue ::=
# 	XMLValue
#
# ITU-T Rec. X.680 (2002)/Amd.1 (10/2003) 
#
#  The Ammendment 1 deletes XMLTaggedValue. 
#
# -------------------------------------

# -------------------------------------
# EmbeddedPDVType ::=
# 	EMBEDDED PDV
# -------------------------------------
package EmbeddedPDVType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EMBEDDED PDV',@_);
}

# -------------------------------------
# EmbeddedPDVValue ::=
# 	SequenceValue
# -------------------------------------
package EmbeddedPDVValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLEmbeddedPDVValue ::=
# 	XMLSequenceValue
# -------------------------------------


# -------------------------------------
# ExternalType ::=
# 	EXTERNAL
# -------------------------------------
package ExternalType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXTERNAL',@_);
}

# -------------------------------------
# ITU-T Rec. X.680 (2002)/Amd.3 (06/2006) 
# -------------------------------------
#
# -------------------------------------
# TimeType ::=
# 	TIME
# -------------------------------------
package TimeType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('TIME',@_); }

# -------------------------------------
# tstring
# -------------------------------------
package tstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\"([0-9\+\-\:\.\,\/CDHMRPSTWYZ]*)\"//s);
		$self->{text} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf '"'; $::first = 0;
		printf "$self->{text}"; $::first = 0;
		printf '"'; $::first = 0;
	}
}

# -------------------------------------
# TimeValue ::=
# 	tstring
# -------------------------------------
package TimeValue;
use strict;
use vars qw(@ISA);
@ISA = qw(tstring);

# -------------------------------------
# xmltstring
# -------------------------------------
package xmltstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([0-9\+\-\:\.\,\/CDHMRPSTWYZ]*)//s);
		$self->{text} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf '"'; $::first = 0;
		printf "$self->{text}"; $::first = 0;
		printf '"'; $::first = 0;
	}
}

# -------------------------------------
# XMLTimeValue ::=
# 	xmltstring
# -------------------------------------
package XMLTimeValue;
use strict;
use vars qw(@ISA);
@ISA = qw(xmltstring);

# -------------------------------------
# DateType ::=
# 	DATE
# -------------------------------------
package DateType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('DATE',@_); }

# -------------------------------------
# TimeOfDayType ::=
# 	TIME-OF-DAY
# -------------------------------------
package TimeOfDayType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('TIME-OF-DAY',@_); }

# -------------------------------------
# DateTimeType ::=
# 	DATE-TIME
# -------------------------------------
package DateTimeType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('DATE-TIME',@_); }

# -------------------------------------
# DurationType ::=
# 	DURATION
# -------------------------------------
package DurationType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('DURATION',@_); }

# -------------------------------------
# ExternalValue ::=
# 	SequenceValue
# -------------------------------------
package ExternalValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLExternalValue ::=
# 	XMLSequenceValue
# -------------------------------------


# -------------------------------------
# ObjectIdentifierType ::=
# 	OBJECT IDENTIFIER
# -------------------------------------
package ObjectIdentifierType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('OBJECT IDENTIFIER',@_);
}

# -------------------------------------
# ObjectIdentifierValue ::=
# 	"{" ObjIdComponentsList "}"
# 	| "{" DefinedValue ObjIdComponentsList "}"
# -------------------------------------
package ObjectIdentifierValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ObjIdComponentsList',@_);
}

# -------------------------------------
# ObjIdComponentsList ::=
# 	ObjIdComponents
# 	| ObjIdComponents ObjIdComponentsList
# -------------------------------------
package ObjIdComponentsList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
# ObjIdComponents ::=
# 	NameForm
# 	| NumberForm
# 	| NameAndNumberForm
# 	| DefinedValue
# -------------------------------------
package ObjIdComponents;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{component} = NameAndNumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = NumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = NameForm->parse($line,@_[1,-1])) ||
			($self->{component} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{component};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# NameForm ::=
# 	identifier
# -------------------------------------
package NameForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# NumberForm ::=
# 	number
# 	| DefinedValue
# -------------------------------------
package NumberForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{number} = Number->parse($line,@_[1,-1])) ||
			($self->{number} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{number};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# NameAndNumberForm ::=
# 	identifier "(" NumberForm ")"
# -------------------------------------
package NameAndNumberForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{number}  = NumberForm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 1;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
# XMLObjectIdentifierValue ::=
# 	XMLObjIdComponentList
# -------------------------------------
# XMLObjIdComponentList ::=
# 	XMLObjIdComponent
# 	| XMLObjIdComponent & "." & XMLObjIdComponentList
# -------------------------------------
# XMLObjIdComponent ::=
# 	NameForm
# 	| XMLNumberForm
# 	| XMLNameAndNumberForm
# -------------------------------------
# XMLNumberForm ::=
# 	number
# -------------------------------------
# XMLNameAndNumberForm ::=
# 	identifier & "(" & XMLNumberForm & ")"
# -------------------------------------


# -------------------------------------
# RelativeOIDType ::=
# 	RELATIVE-OID
# -------------------------------------
package RelativeOIDType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('RELATIVE-OID',@_);
}

# -------------------------------------
# RelativeOIDValue ::=
# 	"{" RelativeOIDComponentsList "}"
# -------------------------------------
package RelativeOIDValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('RelativeOIDComponentsList');
}

# -------------------------------------
# RelativeOIDComponentsList ::=
# 	RelativeOIDComponents
# 	| RelativeOIDComponents RelativeOIDComponentsList
# -------------------------------------
package RelativeOIDComponentsList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
# RelativeOIDComponents ::=
# 	NumberForm
# 	| NameAndNumberForm
# 	| DefinedValue
# -------------------------------------
package RelativeOIDComponents;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{component} = NameAndNumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = NumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{component};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLRelativeOIDValue ::=
# 	XMLRelativeOIDComponentList
# -------------------------------------
# XMLRelativeOIDComponentList ::=
# 	XMLRelativeOIDComponent
# 	| XMLRelativeOIDComponent & "." & XMLRelativeOIDComponentList
# -------------------------------------
# XMLRelativeOIDComponent ::=
# 	XMLNumberForm
# 	| XMLNameAndNumberForm
# -------------------------------------


# -------------------------------------
# CharacterStringType ::=
# 	RestrictedCharacterStringType
# 	| UnrestrictedCharacterStringType
# -------------------------------------
package CharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = RestrictedCharacterStringType->parse($line,@_[1,-1])) ||
			($self->{type} = UnrestrictedCharacterStringType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# RestrictedCharacterStringType ::=
# 	BMPString
# 	| GeneralString
# 	| GraphicString
# 	| IA5String
# 	| ISO646String
# 	| NumericString
# 	| PrintableString
# 	| TeletexString
# 	| T61String
# 	| UniversalString
# 	| UTF8String
# 	| VideotexString
# 	| VisibleString
# -------------------------------------
package RestrictedCharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BMPStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = GeneralStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = GraphicStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = IA5StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = ISO646StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = NumericStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = PrintableStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = TeletexStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = T61StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = UniversalStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = UTF8StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = VideotexStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = VisibleStringToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package UTF8StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package VideotexStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package VisibleStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# RestrictedCharacterStringValue ::=
# 	cstring
# 	| CharacterStringList
# 	| Quadruple
# 	| Tuple
# -------------------------------------
package RestrictedCharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = CString->parse($line,@_[1,-1])) ||
			($self->{value} = CharacterStringList->parse($line,@_[1,-1])) ||
			($self->{value} = Quadruple->parse($line,@_[1,-1])) ||
			($self->{value} = Tuple->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# CharacterStringList ::=
# 	"{" CharSyms "}"
# -------------------------------------
package CharacterStringList;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('CharSyms',@_); }

# -------------------------------------
# CharSyms ::=
# 	CharsDefn
# 	| CharSyms "," CharsDefn
# -------------------------------------
package CharSyms;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('CharsDefn',@_); }

# -------------------------------------
# CharsDefn ::=
# 	cstring
# 	| Quadruple
# 	| Tuple
# 	| DefinedValue
# -------------------------------------
package CharsDefn;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = CString->parse($line,@_[1,-1])) ||
			($self->{value} = CharacterStringList->parse($line,@_[1,-1])) ||
			($self->{value} = Quadruple->parse($line,@_[1,-1])) ||
			($self->{value} = Tuple->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# Quadruple ::=
# 	"{" Group "," Plane "," Row "," Cell "}"
# -------------------------------------
package Quadruple;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('QuadrupleList',@_); }

# -------------------------------------
# Group ::=
# 	number
# -------------------------------------
# Plane ::=
# 	number
# -------------------------------------
# Row ::=
# 	number
# -------------------------------------
# Cell ::=
# 	number
# -------------------------------------
package QuadrupleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{group} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{group};
		last TEST unless ($line=~s/^,//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{plane} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{plane};
		last TEST unless ($line=~s/^,//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{row} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{row};
		last TEST unless ($line=~s/^,//s);
		$self->{comments3} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{cell} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{cell};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{group}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{plane}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{row}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }
		$self->{cell}->gdmo();
	}
}

# -------------------------------------
# Tuple ::=
# 	"{" TableColumn "," TableRow "}"
# -------------------------------------
package Tuple;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('TupleList',@_); }

# -------------------------------------
# TableColumn ::=
# 	number
# -------------------------------------
# TableRow ::=
# 	number
# -------------------------------------
package TupleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{column} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{column};
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{row} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{row};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{column}->gdmo();
		printf ','; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{row}->gdmo();
	}
}

# -------------------------------------
# XMLRestrictedCharacterStringValue ::=
# 	xmlcstring
# -------------------------------------


# -------------------------------------
# UnrestrictedCharacterStringType ::=
# 	CHARACTER STRING
# -------------------------------------
package UnrestrictedCharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('CHARACTER STRING',@_); }

# -------------------------------------
# CharacterStringValue ::=
# 	RestrictedCharacterStringValue
# 	| UnrestrictedCharacterStringValue
# -------------------------------------
package CharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = RestrictedCharacterStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = UnrestrictedCharacterStringValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLCharacterStringValue ::=
# 	XMLRestrictedCharacterStringValue
# 	|XMLUnrestrictedCharacterStringValue
# -------------------------------------


# -------------------------------------
package CString;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $string;
		last TEST unless ($line=~s/^\"((?:[^"]|\"\s*\")*)\"//s);
		$string = $1;
		$string=~s/\"\s+\"//gs;
		$string=~s/\"\"/\"/gs;
		$self->{string} = $string;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($string,$s);
		$string = $self->{string};
		$string=~s/\"/\"\"/g;
		if (!$::first) { printf ' '; }
		printf "\"$string\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# UnrestrictedCharacterStringValue ::=
# 	SequenceValue
# -------------------------------------
package UnrestrictedCharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLUnrestrictedCharacterStringValue ::=
# 	XMLSequenceValue
# -------------------------------------


# -------------------------------------
# UsefulType ::=
# 	typereference
# -------------------------------------
package UsefulType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = GeneralizedTimeToken->parse($line,@_[1,-1])) ||
			($self->{type} = UTCTimeToken->parse($line,@_[1,-1])) ||
			($self->{type} = ObjectDescriptorToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# The following character string types are defined in 37.1:
# -------------------------------------
# NumericString
# -------------------------------------
package NumericStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# VisibleString
# -------------------------------------
# PrintableString
# -------------------------------------
package PrintableStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# ISO646String
# -------------------------------------
package ISO646StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# TeletexString
# -------------------------------------
package TeletexStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# IA5String
# -------------------------------------
package IA5StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# T61String
# -------------------------------------
package T61StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# GraphicString
# -------------------------------------
package GraphicStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# VideotexString
# -------------------------------------
# GeneralString
# -------------------------------------
package GeneralStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# UniversalString
# -------------------------------------
package UniversalStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# BMPString
# -------------------------------------
package BMPStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# The following useful types are defined in clauses 42 to 44:
# -------------------------------------
# GeneralizedTime
# -------------------------------------
package GeneralizedTimeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# UTCTime
# -------------------------------------
package UTCTimeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# ObjectDescriptor
# -------------------------------------
package ObjectDescriptorToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
# The following productions are used in clauses 45 to 47:
# -------------------------------------
# ConstrainedType ::=
# 	Type Constraint
# 	| TypeWithConstraint
# -------------------------------------
package ConstrainedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{type} = Type->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{type};
			last TEST unless (($self->{constraint} = Constraint->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{constraint};
		} else {
			last TEST unless (($self->{typewithconstraint} = TypeWithConstraint->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{typewithconstraint};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# TypeWithConstraint ::=
# 	SET Constraint OF Type
# 	| SET SizeConstraint OF Type
# 	| SEQUENCE Constraint OF Type
# 	| SEQUENCE SizeConstraint OF Type
# 	| SET Constraint OF NamedType
# 	| SET SizeConstraint OF NamedType
# 	| SEQUENCE Constraint OF NamedType
# 	| SEQUENCE SizeConstraint OF NamedType
# -------------------------------------
package TypeWithConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{setorseq} = SetToken->parse($line,@_[1,-1])) ||
			($self->{setorseq} = SequenceToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{setorseq};
		last TEST unless (
			($self->{constraint} = Constraint->parse($line,@_[1,-1])) ||
			($self->{constraint} = SizeConstraint->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{constraint};
		last TEST unless (($self->{token} = OfToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (
			($self->{type} = Type->parse($line,@_[1,-1])) ||
			($self->{type} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};

		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package OfToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# Constraint ::=
# 	"(" ConstraintSpec ExceptionSpec ")"
# -------------------------------------
package Constraint;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryParens);
sub read { my $self = shift; return $self->readinterior('ConstraintLists',@_); }

# -------------------------------------
package ConstraintLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{cspec} = ConstraintSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{cspec};
		last TEST unless (($self->{espec} = ExceptionSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{espec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ConstraintSpec ::=
# 	SubtypeConstraint
# 	| GeneralConstraint
# -------------------------------------
package ConstraintSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{constraint} = GeneralConstraint->parse($line,@_[1,-1])) ||
			($self->{constraint} = SubtypeConstraint->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# SubtypeConstraint ::=
# 	ElementSetSpecs
# -------------------------------------
package SubtypeConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{specs} = ElementSetSpecs->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{specs};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExceptionSpec ::=
# 	"!" ExceptionIdentification
# 	| empty
# -------------------------------------
package ExceptionSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{exceptionid} = ExceptionIdentification->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{exceptionid};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExceptionIdentification ::=
# 	SignedNumber
# 	| DefinedValue
# 	| Type ":" Value
# -------------------------------------
package ExceptionIdentification;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{id} = SignedNumber->parse($line,@_[1,-1])) ||
			($self->{id} = DefinedValue->parse($line,@_[1,-1])) ||
			($self->{id} = TypeColonValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{id};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package TypeColonValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
# ElementSetSpecs ::=
# 	RootElementSetSpec
# 	| RootElementSetSpec "," "..."
# 	| RootElementSetSpec "," "..." "," AdditionalElementSetSpec
# -------------------------------------
package ElementSetSpecs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootElementSetSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{root};
		if ($line=~s/^\,//s) {
			$self->{string1} = ',';
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless ($line=~s/^\.\.\.//s);
			$self->{string2} = '...';
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
			if ($line=~s/^\,//s) {
				$self->{string3} = ',';
				$self->{comments3} = Comments->parse($line,@_[1,-1]);
				last TEST unless (($self->{add} = AdditionalElementSetSpec->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{add};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if ($self->{string1}) {
			printf ',';
			if (($s = $self->{comments1})) { $s->gdmo(); }
			printf "\n$::indent"; $::first = 1;
			if ($self->{string2}) {
				if (!$::first) { printf "\n$::indent"; $::first = 1; }
				printf '...'; $::first = 0;
				if (($s = $self->{comments2})) { $s->gdmo(); }
				if ($self->{string3}) {
					printf ',';
					if (($s = $self->{comments3})) { $s->gdmo(); }
					printf "\n$::indent"; $::first = 1;
					$self->{add}->gdmo();
				}
			}
		}
	}
}

# -------------------------------------
# RootElementSetSpec ::=
# 	ElementSetSpec
# -------------------------------------
package RootElementSetSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{elementspec} = ElementSetSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{elementspec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# AdditionalElementSetSpec ::=
# 	ElementSetSpec
# -------------------------------------
package AdditionalElementSetSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{elementspec} = ElementSetSpec->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{elementspec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ElementSetSpec ::=
# 	Unions
# 	| ALL Exclusions
# -------------------------------------
package ElementSetSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{spec} = Unions->parse($line,@_[1,-1])) ||
			($self->{spec} = AllExclusions->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{spec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
package AllExclusions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = AllToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{exclusions} = Exclusions->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{exclusions};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package AllToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# Unions ::=
# 	Intersections
# 	| UElems UnionMark Intersections
#
# UElems ::=
# 	Unions
# -------------------------------------
package Unions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (($s = Intersections->parse($line,@_[1,-1])));
		push @{$self->{children}}, $s;
		push @{$self->{intersections}}, $s;
		while (($s = UnionMark->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $s;
			push @{$self->{marks}}, $s;
			last TEST unless (($s = Intersections->parse($line,@_[1,-1])));
			push @{$self->{children}}, $s;
			push @{$self->{intersections}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# Intersections ::=
# 	IntersectionElements
# 	| IElems IntersectionMark IntersectionElements
#
# IElems ::=
# 	Intersections
# -------------------------------------
package Intersections;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (($s = IntersectionElements->parse($line,@_[1,-1])));
		push @{$self->{children}}, $s;
		push @{$self->{elements}}, $s;
		while (($s = IntersectionMark->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $s;
			push @{$self->{marks}}, $s;
			last TEST unless (($s = IntersectionElements->parse($line,@_[1,-1])));
			push @{$self->{children}}, $s;
			push @{$self->{elements}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# IntersectionElements ::=
# 	Elements
# 	| Elems Exclusions
#
# Elems ::=
# 	Elements
#
# Exclusions ::=
# 	EXCEPT Elements
# -------------------------------------
package IntersectionElements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{elements1} = Elements->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{elements1};
		if (($self->{token} = ExceptToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{token};
			last TEST unless (($self->{elements2} = Elements->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{elements2};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package ExceptToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# UnionMark ::=
# 	"|"
# 	| UNION
# -------------------------------------
package UnionMark;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:\||UNION)//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf '|'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# IntersectionMark ::=
# 	"^"
# 	| INTERSECTION
# -------------------------------------
package IntersectionMark;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:\^|INTERSECTION)//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf '^'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# Elements ::=
# 	SubtypeElements
# 	| ObjectSetElements
# 	| "(" ElementSetSpec ")"
# -------------------------------------
package Elements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{elements} = SubtypeElements->parse($line,@_[1,-1])) ||
			($self->{elements} = ObjectSetElements->parse($line,@_[1,-1])) ||
			($self->{elements} = ElementSetSpecParens->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{elements};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
package ElementSetSpecParens;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryParens);
# -------------------------------------

# -------------------------------------
# SubtypeElements ::=
# 	SingleValue
# 	| ContainedSubtype
# 	| ValueRange
# 	| PermittedAlphabet
# 	| SizeConstraint
# 	| TypeConstraint
# 	| InnerTypeConstraints
# 	| PatternConstraint
#
# ITU-T Rec. X.680 (2002)/Amd.3 (06/2006) 
#
# SubtypeElements ::=
# 	SingleValue
# 	| ContainedSubtype
# 	| ValueRange
# 	| PermittedAlphabet
# 	| SizeConstraint
# 	| TypeConstraint
# 	| InnerTypeConstraints
# 	| PatternConstraint
# 	| PropertySettings
# 	| DurationRange
# 	| TimePointRange
# 	| RecurrenceRange
# -------------------------------------
package SubtypeElements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{element} = InnerTypeConstraints->parse($line,@_[1,-1])) ||
			($self->{element} = ValueRange->parse($line,@_[1,-1])) ||
			($self->{element} = SingleValue->parse($line,@_[1,-1])) ||
			($self->{element} = ContainedSubtype->parse($line,@_[1,-1])) ||
			($self->{element} = PermittedAlphabet->parse($line,@_[1,-1])) ||
			($self->{element} = SizeConstraint->parse($line,@_[1,-1])) ||
			($self->{element} = TypeConstraint->parse($line,@_[1,-1])) ||
			($self->{element} = PatternConstraint->parse($line,@_[1,-1]))||
			($self->{element} = PropertySettings->parse($line,@_[1,-1]))||
			($self->{element} = DurationRange->parse($line,@_[1,-1]))||
			($self->{element} = TimePointRange->parse($line,@_[1,-1]))||
			($self->{element} = RecurrenceRange->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{element};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$::first = 1;
		$self->{element}->gdmo();
	}
}

# -------------------------------------
# SingleValue ::=
# 	Value
# -------------------------------------
package SingleValue;
use strict;
use vars qw(@ISA);
@ISA = qw(Value);
# -------------------------------------

# -------------------------------------
# ContainedSubtype ::=
# 	Includes Type
#
# Includes ::=
# 	INCLUDES
# 	| empty
# -------------------------------------
package ContainedSubtype;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{includes} = IncludesToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{includes};
		}
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package IncludesToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# ValueRange ::=
# 	LowerEndpoint ".." UpperEndpoint
#
# LowerEndpoint ::=
# 	LowerEndValue
# 	| LowerEndValue "<"
#
# UpperEndpoint ::=
# 	UpperEndValue
# 	| "<" UpperEndValue
#
# LowerEndValue ::=
# 	Value
# 	| MIN
#
# UpperEndValue ::=
# 	Value
# 	| MAX
# -------------------------------------
package ValueRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{lower} = MinToken->parse($line,@_[1,-1])) ||
			($self->{lower} = Value->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{lower};
		if ($line=~s/^\<//s) {
			$self->{lessthan1} = $&;
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless ($line=~s/^\.\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if ($line=~s/^\<//s) {
			$self->{lessthan2} = $&;
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless (
			($self->{upper} = MaxToken->parse($line,@_[1,-1])) ||
			($self->{upper} = Value->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{upper};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$::first = 1;
		$self->{lower}->gdmo();
		printf "$self->{lessthan1}";
		if (($s = $self->{comments1})) { $s->gdmo(); }
		printf '..';
		if (($s = $self->{comments})) { $s->gdmo(); }
		printf "$self->{lessthan2}";
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$::first = 1;
		$self->{upper}->gdmo();

	}
}

package MinToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package MaxToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# SizeConstraint ::=
# 	SIZE Constraint
# -------------------------------------
package SizeConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SizeToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{constraint} = Constraint->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package SizeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# PermittedAlphabet ::=
# 	FROM Constraint
# -------------------------------------
package PermittedAlphabet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = FromToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{constraint} = Constraint->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$::first = 1;
		$self->{token}->gdmo();
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
# TypeConstraint ::=
# 	Type
# -------------------------------------
package TypeConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(Type);
# -------------------------------------

# -------------------------------------
# InnerTypeConstraints ::=
# 	WITH COMPONENT SingleTypeConstraint
# 	| WITH COMPONENTS MultipleTypeConstraints
# -------------------------------------
package InnerTypeConstraints;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{with} = WithToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{with};
		if (($self->{token} = ComponentsToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{token};
			last TEST unless (($self->{constraint} = MultipleTypeConstraints->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{constraint};
		} elsif (($self->{token} = ComponentToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{token};
			last TEST unless (($self->{constraint} = SingleTypeConstraint->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{constraint};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package WithToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package ComponentToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);
 
package ComponentsToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);
 
# -------------------------------------
# SingleTypeConstraint::=
# 	Constraint
# -------------------------------------
package SingleTypeConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(Constraint);
# -------------------------------------

# -------------------------------------
# MultipleTypeConstraints ::=
# 	FullSpecification
# 	| PartialSpecification
#
# FullSpecification ::=
# 	"{" TypeConstraints "}"
#
# PartialSpecification ::=
# 	"{" "..." "," TypeConstraints "}"
# -------------------------------------
package MultipleTypeConstraints;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('FullOrPartialConstraints',@_); }

# -------------------------------------
package FullOrPartialConstraints;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = @_[0];
	TEST: {
		if ($line=~s/^\.\.\.//s) {
			$self->{string1} = '...';
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless ($line=~s/^\,//s);
			$self->{string2} = ',';
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless (($self->{constraints} = TypeConstraints->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraints};
		$_[0] = $line; return $self;
	}
	return $self->error($line) ;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($self->{string1}) {
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '...'; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			printf ','; $::first = 0;
			if (($s = $self->{comments2})) { $s->gdmo(); }
		}
		$self->{constraints}->gdmo();
	}
}

# -------------------------------------
# TypeConstraints ::=
# 	NamedConstraint
# 	| NamedConstraint "," TypeConstraints
# -------------------------------------
package TypeConstraints;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListNewLineUnindented);
# -------------------------------------

sub read { my $self = shift;  return $self->readitem('NamedConstraint',@_); }

# -------------------------------------
# NamedConstraint ::=
# 	identifier ComponentConstraint
# -------------------------------------
package NamedConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = @_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless (($self->{constraint} = ComponentConstraint->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line) ;
}

# -------------------------------------
# ComponentConstraint ::=
# 	ValueConstraint PresenceConstraint
# -------------------------------------
package ComponentConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = @_[0];
	TEST: {
		if (($self->{value} = ValueConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{value};
		}
		if (($self->{presence} = PresenceConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{presence};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line) ;
}

# -------------------------------------
# ValueConstraint ::=
# 	Constraint
# 	| empty
# -------------------------------------
package ValueConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(Constraint);
# -------------------------------------


# -------------------------------------
# PresenceConstraint ::=
# 	PRESENT
# 	| ABSENT
# 	| OPTIONAL
# 	| empty
# -------------------------------------
package PresenceConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = @_[0];
	TEST: {
		last TEST unless (
			($self->{presence} = PresentToken->parse($line,@_[1,-1])) ||
			($self->{presence} = AbsentToken->parse($line,@_[1,-1])) ||
			($self->{presence} = OptionalToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{presence};
		$_[0] = $line; return $self;
	}
	return $self->error($line) ;
}

package PresentToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package AbsentToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package OptionalToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# PatternConstraint ::=
# 	PATTERN Value
# -------------------------------------
# -------------------------------------
package PatternConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = @_[0];
	TEST: {
		last TEST unless (($self->{token} = PatternToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line) ;
}

package PatternToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# ITU-T Rec. X.680 (2002)/Amd.3 (06/2006) 
# -------------------------------------
# -------------------------------------
# simplestring
# -------------------------------------
package simplestring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\"([^"]*)\"//s);
		$self->{text} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf '"'; $::first = 0;
		printf "$self->{text}"; $::first = 0;
		printf '"'; $::first = 0;
	}
}


# -------------------------------------
# PropertySettings ::=
# 	SETTINGS simplestring
# -------------------------------------
package PropertySettings;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SettingsToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{string} = simplestring->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{string};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package SettingsToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# PropertySettingsList ::=
# 	PropertyAndSettingPair
# 	| PropertySettingsList PropertyAndSettingPair
# -------------------------------------
package PropertySettingsList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{pair} = PropertySettingsPair->parse($line,@_[1,-1])) ||
			($self->{pair} = PropertySettingsListAndPair->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{pair};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package PropertySettingsListAndPair;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = PropertySettingsList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{pair} = PropertyAndSettingPair->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{pair};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# PropertyAndSettingPair ::=
# 	PropertyName "=" SettingName
# -------------------------------------
package PropertyAndSettingPair;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{property} = PropertyName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{property};
		last TEST unless (($self->{equals} = Equals->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{equals};
		last TEST unless (($self->{setting} = SettingName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{setting};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package Equals;
use strict;
use vars qw(@ISA);
@ISA = qw(Punctuation);

sub read { my $self = shift; return $self->readsymbols('=',@_); }


# -------------------------------------
# psname
# -------------------------------------
package psname;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# PropertyName ::=
# 	psname
# -------------------------------------
package PropertyName;
use strict;
use vars qw(@ISA);
@ISA = qw(psname);
# -------------------------------------
# SettingName ::=
# 	psname
# -------------------------------------
package SettingName;
use strict;
use vars qw(@ISA);
@ISA = qw(psname);
# -------------------------------------
# DurationRange ::=
# 	ValueRange
# -------------------------------------
package DurationRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{range} = ValueRange->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{range};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
 
# -------------------------------------
# TimePointRange ::=
# 	ValueRange
# -------------------------------------
package TimePointRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{range} = ValueRange->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{range};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
 
# -------------------------------------
# RecurrenceRange ::=
# 	ValueRange
# -------------------------------------
package RecurrenceRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{range} = ValueRange->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{range};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
 
# -------------------------------------
# DefinedObjectClass ::=
# 	ExternalObjectClassReference
# 	| objectclassreference
# 	| UsefulObjectClassReference
# -------------------------------------
package DefinedObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{reference} = ExternalObjectReference->parse($line,@_[1,-1])) ||
			($self->{reference} = ObjectClassReference->parse($line,@_[1,-1])) ||
			($self->{reference} = UsefulObjectClassReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{reference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# ExternalObjectClassReference ::=
# 	modulereference "." objectclassreference
# -------------------------------------
package ExternalObjectClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modref} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modref};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{clsref} = ObjectClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{clsref};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modref}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{clsref}->gdmo();
	}
}

# -------------------------------------
# UsefulObjectClassReference ::=
# 	TYPE-IDENTIFIER
# 	| ABSTRACT-SYNTAX
# -------------------------------------
package UsefulObjectClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{useful} = TypeIdentifierToken->parse($line,@_[1,-1])) ||
			($self->{useful} = AbstractSyntaxToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{useful};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package TypeIdentifierToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('TYPE-IDENTIFIER',@_); }

package AbstractSyntaxToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('ABSTRACT-SYNTAX',@_); }

# -------------------------------------
# ObjectClassAssignment ::=
# 	objectclassreference "::=" ObjectClass
# -------------------------------------
package ObjectClassAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{clsref} = ObjectClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{clsref};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{objcls} = ObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectClass ::=
# 	DefinedObjectClass
# 	| ObjectClassDefn
# 	| ParameterizedObjectClass
# -------------------------------------
package ObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{objcls} = DefinedObjectClass->parse($line,@_[1,-1])) ||
			($self->{objcls} = ObjectClassDefn->parse($line,@_[1,-1])) ||
			($self->{objcls} = ParameterizedObjectClass->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{objcls};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectClassDefn ::=
# 	CLASS "{" FieldSpec "," + "}" WithSyntaxSpec ?
# -------------------------------------
package ObjectClassDefn;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{class} = ClassToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		last TEST unless (($self->{defn} = FieldSpecListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{defn};
		if (($self->{syntax} = WithSyntaxSpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{syntax};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package FieldSpecListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);

package FieldSpecList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);

package ClassToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# FieldSpec ::=
# 	TypeFieldSpec
# 	| FixedTypeValueFieldSpec
# 	| VariableTypeValueFieldSpec
# 	| FixedTypeValueSetFieldSpec
# 	| VariableTypeValueSetFieldSpec
# 	| ObjectFieldSpec
# 	| ObjectSetFieldSpec
# -------------------------------------
package FieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{spec} = TypeFieldSpec->parse($line,@_[1,-1])) ||
			($self->{spec} = FixedTypeValueFieldSpec->parse($line,@_[1,-1])) ||
			($self->{spec} = VariableTypeValueFieldSpec->parse($line,@_[1,-1])) ||
			($self->{spec} = FixedTypeValueSetFieldSpec->parse($line,@_[1,-1])) ||
			($self->{spec} = VariableTypeValueSetFieldSpec->parse($line,@_[1,-1])) ||
			($self->{spec} = ObjectFieldSpec->parse($line,@_[1,-1])) ||
			($self->{spec} = ObjectSetFieldSpec->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{spec};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# PrimitiveFieldName ::=
# 	typefieldreference
# 	| valuefieldreference
# 	| valuesetfieldreference
# 	| objectfieldreference
# 	| objectsetfieldreference
# -------------------------------------
package PrimitiveFieldName;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{field} = TypeFieldReference->parse($line,@_[1,-1])) ||
			($self->{field} = ValueFieldReference->parse($line,@_[1,-1])) ||
			($self->{field} = ValueSetFieldReference->parse($line,@_[1,-1])) ||
			($self->{field} = ObjectFieldReference->parse($line,@_[1,-1])) ||
			($self->{field} = ObjectSetFieldReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{field};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# FieldName ::=
# 	PrimitiveFieldName "." +
# -------------------------------------
package FieldName;
use strict;
use vars qw(@ISA);
@ISA = qw(DotList);

sub read { my $self = shift; return $self->readitem('PrimitiveFieldName',@_); }

# -------------------------------------
# TypeFieldSpec ::=
# 	typefieldreference TypeOptionalitySpec ?
# -------------------------------------
package TypeFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = TypeFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		if (($self->{spec} = TypeOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# TypeOptionalitySpec ::=
# 	OPTIONAL
# 	| DEFAULT Type
# -------------------------------------
package TypeOptionalitySpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{optional} = OptionalToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{optional};
		} elsif (($self->{default} = DefaultToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{default};
			last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{type};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package DefaultToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# FixedTypeValueFieldSpec ::=
# 	valuefieldreference Type UNIQUE ? ValueOptionalitySpec ?
# -------------------------------------
package FixedTypeValueFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = ValueFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		if (($self->{unique} = UniqueToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{unique};
		}
		if (($self->{spec} = ValueOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package UniqueToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# ValueOptionalitySpec ::=
# 	OPTIONAL
# 	| DEFAULT Value
# -------------------------------------
package ValueOptionalitySpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{optional} = OptionalToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{optional};
		} elsif (($self->{default} = DefaultToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{default};
			last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{value};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# VariableTypeValueFieldSpec ::=
# 	valuefieldreference FieldName ValueOptionalitySpec ?
# -------------------------------------
package VariableTypeValueFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = ValueFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		last TEST unless (($self->{name} = FieldName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{name};
		if (($self->{spec} = ValueOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# FixedTypeValueSetFieldSpec ::=
# 	valuesetfieldreference Type ValueSetOptionalitySpec ?
# -------------------------------------
package FixedTypeValueSetFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = ValueSetFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		if (($self->{spec} = ValueSetOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ValueSetOptionalitySpec ::=
# 	OPTIONAL
# 	| DEFAULT ValueSet
# -------------------------------------
package ValueSetOptionalitySpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{optional} = OptionalToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{optional};
		} elsif (($self->{default} = DefaultToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{default};
			last TEST unless (($self->{value} = ValueSet->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{value};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# VariableTypeValueSetFieldSpec ::=
# 	valuesetfieldreference FieldName ValueSetOptionalitySpec?
# -------------------------------------
package VariableTypeValueSetFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = ValueSetFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		last TEST unless (($self->{name} = FieldName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{name};
		if (($self->{spec} = ValueSetOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectFieldSpec ::=
# 	objectfieldreference DefinedObjectClass ObjectOptionalitySpec?
# -------------------------------------
package ObjectFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = ObjectFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		last TEST unless (($self->{class} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{spec} = ObjectOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectOptionalitySpec ::=
# 	OPTIONAL
# 	| DEFAULT Object
# -------------------------------------
package ObjectOptionalitySpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{optional} = OptionalToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{optional};
		} elsif (($self->{default} = DefaultToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{default};
			last TEST unless (($self->{object} = Object->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{object};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectSetFieldSpec ::=
# 	objectsetfieldreference DefinedObjectClass ObjectSetOptionalitySpec ?
# -------------------------------------
package ObjectSetFieldSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{field} = ObjectSetFieldReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{field};
		last TEST unless (($self->{class} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{spec} = ObjectSetOptionalitySpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{spec};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectSetOptionalitySpec ::=
# 	OPTIONAL
# 	| DEFAULT ObjectSet
# -------------------------------------
package ObjectSetOptionalitySpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{optional} = OptionalToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{optional};
		} elsif (($self->{default} = DefaultToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{default};
			last TEST unless (($self->{object} = ObjectSet->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{object};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# WithSyntaxSpec ::=
# 	WITH SYNTAX SyntaxList
# -------------------------------------
package WithSyntaxSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{with} = WithToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{with};
		last TEST unless (($self->{syntax} = SyntaxToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless (($self->{list} = SyntaxList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package SyntaxToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# SyntaxList ::=
# 	"{" TokenOrGroupSpec empty + "}"
# -------------------------------------
package SyntaxList;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);

sub read { my $self = shift; return $self->readinterior('TokenOrGroupSpecList',@_); }

package TokenOrGroupSpecList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleListIndented);

# -------------------------------------
# TokenOrGroupSpec ::=
# 	RequiredToken
# 	| OptionalGroup
# -------------------------------------
package TokenOrGroupSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{token} = RequiredToken->parse($line,@_[1,-1])) ||
			($self->{token} = OptionalGroup->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{token};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# OptionalGroup ::=
# 	"[" TokenOrGroupSpec empty + "]"
# -------------------------------------
package OptionalGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracketed);

sub read { my $self = shift; return $self->readinterior('TokenOrGroupSpecList',@_); }

# -------------------------------------
# RequiredToken ::=
# 	Literal
# 	| PrimitiveFieldName
# -------------------------------------
package RequiredToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{token} = Literal->parse($line,@_[1,-1])) ||
			($self->{token} = PrimitiveFieldName->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{token};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# word
# -------------------------------------
package Word;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# Literal ::=
# 	word
# 	| ","
# -------------------------------------
package Literal;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{word} = Word->parse($line,@_[1,-1])) ||
			($self->{word} = Comma->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{word};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# DefinedObject ::=
# 	ExternalObjectReference
# 	| objectreference
# -------------------------------------
package DefinedObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{object} = ExternalObjectReference->parse($line,@_[1,-1])) ||
			($self->{object} = ObjectReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ExternalObjectReference ::=
# 	modulereference "." objectreference
# -------------------------------------
package ExternalObjectReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modref} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modref};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{objref} = ObjectReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objref};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modref}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{objref}->gdmo();
	}
}

# -------------------------------------
# ObjectAssignment ::=
# 	objectreference DefinedObjectClass "::=" Object
# -------------------------------------
package ObjectAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objref} = ObjectReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objref};
		last TEST unless (($self->{objcls} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{object} = Object->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# Object ::=
# 	DefinedObject
# 	| ObjectDefn
# 	| ObjectFromObject
# 	| ParameterizedObject
# -------------------------------------
package Object;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{object} = DefinedObject->parse($line,@_[1,-1])) ||
			($self->{object} = ObjectDefn->parse($line,@_[1,-1])) ||
			($self->{object} = ObjectFromObject->parse($line,@_[1,-1])) ||
			($self->{object} = ParameterizedObject->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectDefn ::=
# 	DefaultSyntax
# 	| DefinedSyntax
# -------------------------------------
package ObjectDefn;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{syntax} = DefaultSyntax->parse($line,@_[1,-1])) ||
			($self->{syntax} = DefinedSyntax->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{syntax};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# DefaultSyntax ::=
# 	"{" FieldSetting "," * "}"
# -------------------------------------
package DefaultSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBracedIndent);

sub read { my $self = shift; return $self->readinterior('FieldSettingList',@_); }

package FieldSettingList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);

# -------------------------------------
# FieldSetting ::=
# 	PrimitiveFieldName Setting
# -------------------------------------
package FieldSetting;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{name} = PrimitiveFieldName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{name};
		last TEST unless (($self->{setting} = Setting->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{setting};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# DefinedSyntax ::=
# 	"{" DefinedSyntaxToken empty * "}"
# -------------------------------------
package DefinedSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBracedIndent);

sub read { my $self = shift; return $self->readinterior('DefinedSyntaxTokenList',@_); }

package DefinedSyntaxTokenList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);

# -------------------------------------
# DefinedSyntaxToken ::=
# 	Literal
# 	| Setting
# -------------------------------------
package DefinedSyntaxToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{token} = Literal->parse($line,@_[1,-1])) ||
			($self->{token} = Setting->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{token};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# Setting ::=
# 	Type
# 	| Value
# 	| ValueSet
# 	| Object
# 	| ObjectSet
# -------------------------------------
package Setting;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{setting} = Type->parse($line,@_[1,-1])) ||
			($self->{setting} = Value->parse($line,@_[1,-1])) ||
			($self->{setting} = ValueSet->parse($line,@_[1,-1])) ||
			($self->{setting} = Object->parse($line,@_[1,-1])) ||
			($self->{setting} = ObjectSet->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{setting};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# DefinedObjectSet ::=
# 	ExternalObjectSetReference
# 	| objectsetreference
# -------------------------------------
package DefinedObjectSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{objref} = ExternalObjectSetReference->parse($line,@_[1,-1])) ||
			($self->{objref} = ObjectSetReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{objref};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ExternalObjectSetReference ::=
# 	modulereference "." objectsetreference
# -------------------------------------
package ExternalObjectSetReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modref} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modref};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{objref} = ObjectSetReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objref};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modref}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{objref}->gdmo();
	}
}

# -------------------------------------
# ObjectSetAssignment ::=
# 	objectsetreference DefinedObjectClass "::=" ObjectSet
# -------------------------------------
package ObjectSetAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{setref} = ObjectSetReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{setref};
		last TEST unless (($self->{objcls} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{objset} = ObjectSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectSet ::=
# 	"{" ObjectSetSpec "}"
# -------------------------------------
package ObjectSet;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBracedIndent);

sub read { my $self = shift; return $self->readinterior('ObjectSetSpec',@_); }

# -------------------------------------
# ObjectSetSpec ::=
# 	RootElementSetSpec
# 	| RootElementSetSpec "," "..."
# 	| "..."
# 	| "..." "," AdditionalElementSetSpec
# 	| RootElementSetSpec "," "..." "," AdditionalElementSetSpec
# -------------------------------------
package ObjectSetSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{root} = RootElementSetSpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{root};
			if ($line=~s/^\,//s) {
				$self->{string1} = ',';
				$self->{comments1} = Comments->parse($line,@_[1,-1]);
				last TEST unless ($line=~s/^\.\.\.//s);
				$self->{string2} = '...';
				$self->{comments2} = Comments->parse($line,@_[1,-1]);
				if ($line=~s/^\,//s) {
					$self->{string3} = ',';
					$self->{comments3} = Comments->parse($line,@_[1,-1]);
					last TEST unless (($self->{add} = AdditionalElementSetSpec->parse($line,@_[1,-1])));
					push @{$self->{children}}, $self->{add};
				}
			}
		} elsif ($line=~s/^\.\.\.//s) {
			$self->{string4} = '...';
			$self->{comments4} = Comments->parse($line,@_[1,-1]);
			if ($line=~s/^\,//s) {
				$self->{string5} = ',';
				$self->{comments5} = Comments->parse($line,@_[1,-1]);
				last TEST unless (($self->{add} = AdditionalElementSetSpec->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{add};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{root})) {
			$s->gdmo();
			if ($self->{string1}) {
				printf ',';
				if (($s = $self->{comments1})) { $s->gdmo(); }
				printf "\n$::indent"; $::first = 1;
				if ($self->{string2}) {
					if (!$::first) { printf "\n$::indent"; $::first = 1; }
					printf '...'; $::first = 0;
					if (($s = $self->{comments2})) { $s->gdmo(); }
					if ($self->{string3}) {
						printf ',';
						if (($s = $self->{comments3})) { $s->gdmo(); }
						printf "\n$::indent"; $::first = 1;
						$self->{add}->gdmo();
					}
				}
			}
		} else {
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '...'; $::first = 0;
			if (($s = $self->{comments4})) { $s->gdmo(); }
			if ($self->{string5}) {
				printf ','; $::first = 0;
				if (($s = $self->{comments5})) { $s->gdmo(); }
				printf "\n$::indent"; $::first = 1;
				$self->{add}->gdmo();
			}
		}
	}
}

# -------------------------------------
# ObjectSetElements ::=
# 	Object
# 	| DefinedObjectSet
# 	| ObjectSetFromObjects
# 	| ParameterizedObjectSet
# -------------------------------------
package ObjectSetElements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{elements} = Object->parse($line,@_[1,-1])) ||
			($self->{elements} = DefinedObjectSet->parse($line,@_[1,-1])) ||
			($self->{elements} = ObjectSetFromObjects->parse($line,@_[1,-1])) ||
			($self->{elements} = ParameterizedObjectSet->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{elements};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ObjectClassFieldType ::=
# 	DefinedObjectClass "." FieldName
# -------------------------------------
package ObjectClassFieldType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{class} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{name} = FieldName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{name};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{class}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{name}->gdmo();
	}
}

# -------------------------------------
# ObjectClassFieldValue ::=
# 	OpenTypeFieldVal
# 	| FixedTypeFieldVal
# -------------------------------------
package ObjectClassFieldValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = OpenTypeFieldVal->parse($line,@_[1,-1])) ||
			($self->{value} = FixedTypeFieldVal->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# OpenTypeFieldVal ::=
# 	Type ":" Value
# -------------------------------------
package OpenTypeFieldVal;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless ($line=~s/^\://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{type}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
# FixedTypeFieldVal ::=
# 	BuiltinValue
# 	| ReferencedValue
# -------------------------------------
package FixedTypeFieldVal;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BuiltinValue->parse($line,@_[1,-1])) ||
			($self->{value} = ReferencedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# XMLObjectClassFieldValue ::=
# 	XMLOpenTypeFieldVal
# 	| XMLFixedTypeFieldVal
# -------------------------------------
package XMLObjectClassFieldValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = XMLOpenTypeFieldVal->parse($line,@_[1,-1])) ||
			($self->{value} = XMLFixedTypeFieldVal->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# XMLOpenTypeFieldVal ::=
# 	XMLTypedValue
#
# ITU-T Rec. X.681 (2002)/Amd.1 (10/2003)	
#
# XMLOpenTypeFieldVal ::=
# 	XMLTypedValue
#	| xmlhstring	
#
# -------------------------------------
package XMLOpenTypeFieldVal;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = XMLTypedValue->parse($line,@_[1,-1])) ||
			($self->{value} = xmlhstring->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
# XMLFixedTypeFieldVal ::=
# 	XMLBuiltinValue
# -------------------------------------
package XMLFixedTypeFieldVal;
use strict;
use vars qw(@ISA);
@ISA = qw(XMLBuiltinValue);

# -------------------------------------
# InformationFromObjects ::=
# 	ValueFromObject
# 	| ValueSetFromObjects
# 	| TypeFromObject
# 	| ObjectFromObject
# 	| ObjectSetFromObjects
# -------------------------------------
package InformationFromObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ValueFromObject->parse($line,@_[1,-1])) ||
			($self->{value} = ValueSetFromObjects->parse($line,@_[1,-1])) ||
			($self->{value} = TypeFromObject->parse($line,@_[1,-1])) ||
			($self->{value} = ObjectFromObject->parse($line,@_[1,-1])) ||
			($self->{value} = ObjectSetFromObjects->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ReferencedObjects ::=
# 	DefinedObject
# 	| ParameterizedObject
# 	| DefinedObjectSet
# 	| ParameterizedObjectSet
# -------------------------------------
package ReferencedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{objects} = DefinedObject->parse($line,@_[1,-1])) ||
			($self->{objects} = ParameterizedObject->parse($line,@_[1,-1])) ||
			($self->{objects} = DefinedObjectSet->parse($line,@_[1,-1])) ||
			($self->{objects} = ParameterizedObjectSet->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{objects};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ValueFromObject ::=
# 	ReferencedObjects "." FieldName
# -------------------------------------
package ReferencedFieldName;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objects} = ReferencedObjects->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objects};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{name} = FieldName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{name};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{objects}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{name}->gdmo();
	}
}

package ValueFromObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ReferencedFieldName);

# -------------------------------------
# ValueSetFromObjects ::=
# 	ReferencedObjects "." FieldName
# -------------------------------------
package ValueSetFromObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(ReferencedFieldName);

# -------------------------------------
# TypeFromObject ::=
# 	ReferencedObjects "." FieldName
# -------------------------------------
package TypeFromObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ReferencedFieldName);

# -------------------------------------
# ObjectFromObject ::=
# 	ReferencedObjects "." FieldName
# -------------------------------------
package ObjectFromObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ReferencedFieldName);

# -------------------------------------
# ObjectSetFromObjects ::=
# 	ReferencedObjects "." FieldName
# -------------------------------------
package ObjectSetFromObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(ReferencedFieldName);

# -------------------------------------
# InstanceOfType ::=
# 	INSTANCE OF DefinedObjectClass
# -------------------------------------
package InstanceOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{instance} = InstanceToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{instance};
		last TEST unless (($self->{of} = OfToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{of};
		last TEST unless (($self->{class} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package InstanceToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
# InstanceOfValue ::=
# 	Value
# -------------------------------------
package InstanceOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(Value);

# -------------------------------------
# XMLInstanceOfValue ::=
# 	XMLValue
# -------------------------------------
package XMLInstanceOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(XMLValue);

# -------------------------------------

# -------------------------------------
# ITU-T Rec. X.682 (07/2002) 
# -------------------------------------
# GeneralConstraint ::=
# 	UserDefinedConstraint
# 	| TableConstraint
# 	| ContentsConstraint
# -------------------------------------
package GeneralConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{constraint} = UserDefinedConstraint->parse($line,@_[1,-1])) ||
			($self->{constraint} = TableConstraint->parse($line,@_[1,-1])) ||
			($self->{constraint} = ContentsConstraint->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# UserDefinedConstraint ::=
# 	CONSTRAINED BY "{" UserDefinedConstraintParameter "," * "}"
# -------------------------------------
package UserDefinedConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{constrained} = ConstrainedToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constrained};
		last TEST unless (($self->{by} = ByToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{by};
		last TEST unless (($self->{list} = UserDefinedConstraintParameterListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ConstrainedToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package UserDefinedConstraintParameterListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);

package UserDefinedConstraintParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);

# -------------------------------------
# UserDefinedConstraintParameter ::=
# 	Governor ":" Value
# 	| Governor ":" ValueSet
# 	| Governor ":" Object
# 	| Governor ":" ObjectSet
# 	| Type
# 	| DefinedObjectClass
# -------------------------------------
package UserDefinedConstraintParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{parm} = GovernorColonValue->parse($line,@_[1,-1])) ||
			($self->{parm} = GovernorColonValueSet->parse($line,@_[1,-1])) ||
			($self->{parm} = GovernorColonObject->parse($line,@_[1,-1])) ||
			($self->{parm} = GovernorColonObjectSet->parse($line,@_[1,-1])) ||
			($self->{parm} = Type->parse($line,@_[1,-1])) ||
			($self->{parm} = DefinedObjectClass->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{parm};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package GovernorColonValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{govenor} = Governor->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{govenor};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{govenor}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

package GovernorColonValueSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{govenor} = Governor->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{govenor};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{valueset} = ValueSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valueset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{govenor}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{valueset}->gdmo();
	}
}

package GovernorColonObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{govenor} = Governor->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{govenor};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{object} = Object->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{govenor}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{object}->gdmo();
	}
}

package GovernorColonObjectSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{govenor} = Governor->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{govenor};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{objectset} = ObjectSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objectset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{govenor}->gdmo();
		if (!$::first) { printf ' '; }
		printf ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{objectset}->gdmo();
	}
}

# -------------------------------------
# TableConstraint ::=
# 	SimpleTableConstraint
# 	| ComponentRelationConstraint
# -------------------------------------
package TableConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{constraint} = ComponentRelationConstraint->parse($line,@_[1,-1])) ||
			($self->{constraint} = SimpleTableConstraint->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# SimpleTableConstraint ::=
# 	ObjectSet
# -------------------------------------
package SimpleTableConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objset} = ObjectSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ComponentRelationConstraint ::=
# 	"{" DefinedObjectSet "}" "{" AtNotation "," + "}"
# -------------------------------------
package ComponentRelationConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objset} = DefinedObjectSetBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objset};
		last TEST unless (($self->{atnote} = AtNotationListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{atnote};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
package DefinedObjectSetBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);

package AtNotationListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);

package AtNotationList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);

# -------------------------------------
# AtNotation ::=
# 	"@" ComponentIdList
# 	| "@." Level ComponentIdList
# -------------------------------------
package AtNotation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\@//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{level} = Level->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{level};
		}
		last TEST unless (($self->{list} = ComponentIdList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf '@'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{level})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}

# -------------------------------------
# Level ::=
# 	"." Level
# 	| empty
# -------------------------------------
package Level;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\.+//s);
		$self->{dots} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		printf "$self->{dots}";
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
# ComponentIdList ::=
# 	identifier "." +
# -------------------------------------
package ComponentIdList;
use strict;
use vars qw(@ISA);
@ISA = qw(DotList);

sub read { my $self = shift; return $self->readitem('Identifier',@_); }

# -------------------------------------
# ContentsConstraint ::=
# 	CONTAINING Type
# 	| ENCODED BY Value
# 	| CONTAINING Type ENCODED BY Value
# -------------------------------------
package ContentsConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{containing} = ContainingToken->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{containing};
			last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{type};
			if (($self->{encoded} = EncodedToken->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{encoded};
				last TEST unless (($self->{by} = ByToken->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{by};
				last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{value};
			}
		} else {
			last TEST unless (($self->{encoded} = EncodedToken->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{encoded};
			last TEST unless (($self->{by} = ByToken->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{by};
			last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{value};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package ContainingToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package ByToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

package EncodedToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------


# -------------------------------------
# ITU-T Rec. X.683 (07/2002) 
# -------------------------------------
# ParameterizedAssignment ::=
# 	ParameterizedTypeAssignment
# 	| ParameterizedValueAssignment
# 	| ParameterizedValueSetTypeAssignment
# 	| ParameterizedObjectClassAssignment
# 	| ParameterizedObjectAssignment
# 	| ParameterizedObjectSetAssignment
# -------------------------------------
package ParameterizedAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{assignment} = ParameterizedTypeAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ParameterizedValueAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ParameterizedValueSetTypeAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ParameterizedObjectClassAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ParameterizedObjectAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ParameterizedObjectSetAssignment->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{assignment};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedTypeAssignment ::=
# 	typereference ParameterList "::=" Type
# -------------------------------------
package ParameterizedTypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{typeref} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typeref};
		last TEST unless (($self->{list} = ParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedValueAssignment ::=
# 	valuereference ParameterList Type "::=" Value
# -------------------------------------
package ParameterizedValueAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{valref} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valref};
		last TEST unless (($self->{list} = ParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedValueSetTypeAssignment ::=
# 	typereference ParameterList Type "::=" ValueSet
# -------------------------------------
package ParameterizedValueSetTypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{typeref} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typeref};
		last TEST unless (($self->{list} = ParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{valset} = ValueSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedObjectClassAssignment ::=
# 	objectclassreference ParameterList "::=" ObjectClass
# -------------------------------------
package ParameterizedObjectClassAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{clsref} = ObjectClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{clsref};
		last TEST unless (($self->{list} = ParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{objcls} = ObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedObjectAssignment ::=
# 	objectreference ParameterList DefinedObjectClass "::=" Object
# -------------------------------------
package ParameterizedObjectAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objref} = ObjectReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objref};
		last TEST unless (($self->{list} = ParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{objcls} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{object} = Objecth->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedObjectSetAssignment ::=
# 	objectsetreference ParameterList DefinedObjectClass "::=" ObjectSet
# -------------------------------------
package ParameterizedObjectSetAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{setref} = ObjectSetReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{setref};
		last TEST unless (($self->{list} = ParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless (($self->{objcls} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{objset} = ObjectSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterList ::=
# 	"{" Parameter "," + "}"
# -------------------------------------
package ParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);

sub read { my $self = shift; return $self->readinterior('ParametersList',@_); }

package ParametersList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);

sub read { my $self = shift; return $self->readitem('Asn1Parameter',@_); }

# -------------------------------------
# Parameter ::=
# 	ParamGovernor ":" DummyReference
# 	| DummyReference
# -------------------------------------
package Asn1Parameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{param} = ParamGovernor->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{param};
			last TEST unless ($line=~s/^://s);
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless (($self->{dummy} = DummyReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{dummy};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{param})) {
			$s->gdmo();
			if (!$::first) { printf ' '; }
			printf ':'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		$self->{dummy}->gdmo();

	}
}

# -------------------------------------
# ParamGovernor ::=
# 	Governor
# 	| DummyGovernor
# -------------------------------------
package ParamGovernor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{govenor} = Governor->parse($line,@_[1,-1])) ||
			($self->{govenor} = DummyGovernor->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{govenor};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# Governor ::=
# 	Type
# 	| DefinedObjectClass
# -------------------------------------
package Governor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = Type->parse($line,@_[1,-1])) ||
			($self->{type} = DefinedObjectClass->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# DummyGovernor ::=
# 	DummyReference
# -------------------------------------
package DummyGovernor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{dummy} = DummyReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{dummy};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# DummyReference ::=
# 	Reference
# -------------------------------------
package DummyReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = Reference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedReference ::=
# 	Reference
# 	| Reference "{" "}"
# -------------------------------------
package ParameterizedReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = Reference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		if ($line=~s/^\{//s) {
			$self->{string1} = '{';
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless ($line=~s/^\}//s);
			$self->{string2} = '}';
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{reference}->gdmo();
		if ($self->{string1}) {
			if (!$::first) { printf ' '; }
			printf '{'; $::first = 0;
			if (!$::first) { printf ' '; }
			printf '}'; $::first = 0;
		}
	}
}

# -------------------------------------
# SimpleDefinedType ::=
# 	ExternalTypeReference
# 	| typereference
# -------------------------------------
package SimpleDefinedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])) ||
			($self->{type} = TypeReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# SimpleDefinedValue ::=
# 	ExternalValueReference
# 	| valuereference
# -------------------------------------
package SimpleDefinedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = ValueReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedType ::=
# 	SimpleDefinedType ActualParameterList
# -------------------------------------
package ParameterizedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = SimpleDefinedType->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{params} = ActualParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{params};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedValue ::=
# 	SimpleDefinedValue ActualParameterList
# -------------------------------------
package ParameterizedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SimpleDefinedValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		last TEST unless (($self->{params} = ActualParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{params};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedValueSetType ::=
# 	SimpleDefinedType ActualParameterList
# -------------------------------------
package ParameterizedValueSetType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = SimpleDefinedType->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{params} = ActualParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{params};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedObjectClass ::=
# 	DefinedObjectClass ActualParameterList
# -------------------------------------
package ParameterizedObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objcls} = DefinedObjectClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objcls};
		last TEST unless (($self->{params} = ActualParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{params};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedObjectSet ::=
# 	DefinedObjectSet ActualParameterList
# -------------------------------------
package ParameterizedObjectSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{objset} = DefinedObjectSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objset};
		last TEST unless (($self->{params} = ActualParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{params};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ParameterizedObject ::=
# 	DefinedObject ActualParameterList
# -------------------------------------
package ParameterizedObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{object} = DefinedObject->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{object};
		last TEST unless (($self->{params} = ActualParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{params};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------
# ActualParameterList ::=
# 	"{" ActualParameter "," + "}"
# -------------------------------------
package ActualParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);

sub read { my $self = shift; return $self->readinterior('ActualParameters',@_); }

package ActualParameters;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);

sub read { my $self = shift; return $self->readitem('ActualParameter',@_); }

# -------------------------------------
# ActualParameter ::=
# 	Type
# 	| Value
# 	| ValueSet
# 	| DefinedObjectClass
# 	| Object
# 	| ObjectSet
# -------------------------------------
package ActualParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{param} = Type->parse($line,@_[1,-1])) ||
			($self->{param} = Value->parse($line,@_[1,-1])) ||
			($self->{param} = ValueSet->parse($line,@_[1,-1])) ||
			($self->{param} = DefinedObjectClass->parse($line,@_[1,-1])) ||
			($self->{param} = Object->parse($line,@_[1,-1])) ||
			($self->{param} = ObjectSet->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{param};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
# -------------------------------------


# -------------------------------------
package AAA;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package GdmoAliasDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		#print STDERR "I: GDMO.Alias: '".$line."'";
		last TEST unless (($self->{documentId} = DocumentSpecifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{documentId};
		last TEST unless (($s = DocumentIdentifier->parse($line,@_[1,-1])));
		push @{$self->{documentAliases}}, $s;
		push @{$self->{children}}, $s;
		while ($line=~s/^,(?:\s|\n)*//s) {
			last TEST unless (($s = DocumentIdentifier->parse($line,@_[1,-1])));
			push @{$self->{documentAliases}}, $s;
			push @{$self->{children}}, $s;
		}
		$_[0] = $line; return $self;
	}
	$self->{errors} = "must consist of GDMO.Alias <directive>";
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		$self->{documentId}->gdmo();
		my $i = 0;
		foreach $s (@{$self->{documentAliases}}) {
			if ($i) { printf ",\n-- "; $::first = 0; }
			$s->gdmo();
			$i++;
		}
	}
}

# -------------------------------------
package DocumentSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{specifier} = DocumentReference->parse($line,@_[1,-1])) ||
			($self->{specifier} = ObjectIdentifierValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{specifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{specifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoDocumentDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		print STDERR "I: GDMO.Document: '".$line."'";
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		last TEST unless ($self->{documentstring} || $self->{documentoid});
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{documentstring})) {
			if ($::first) { printf '-- '; $::first = 0; }
			$s->gdmo();
		}
		if (($s = $self->{documentoid})) {
			if (!$::first) { printf "\n-- "; $::first = 0; }
			$s->gdmo();
		}
	}
}

# -------------------------------------
package GdmoEndDocumentDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		print STDERR "I: GDMO.EndDocument: '".$line."'";
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{documentstring})) {
			if ($::first) { printf '-- '; $::first = 0; }
			$s->gdmo();
		}
		if (($s = $self->{documentoid})) {
			if (!$::first) { printf "\n-- "; $::first = 0; }
			$s->gdmo();
		}
	}
}

# -------------------------------------
package GdmoVersionDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		print STDERR "I: GDMO.Version: '".$line."'";
		last TEST unless (($self->{version} = GdmoVersion->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{version};
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		$self->{version}->gdmo();
		if (($s = $self->{documentstring})) {
			if ($::first) { printf '-- '; $::first = 0; }
			$s->gdmo();
		}
		if (($s = $self->{documentoid})) {
			if (!$::first) { printf "\n-- "; $::first = 0; }
			$s->gdmo();
		}
	}
}

# -------------------------------------
package GdmoVersion;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[0-9]+(?:\.[0-9]+)*//s);
		$self->{version} = $&;
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{version}"; $::first = 0;
	}
}

# -------------------------------------
package GdmoNamespaceDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		print STDERR "I: GDMO.Namespace: '".$line."'";
		last TEST unless (($self->{namespace} = Namespace->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{namespace};
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		$self->{namespace}->gdmo();
		if (($s = $self->{documentstring})) {
			if ($::first) { printf '-- '; $::first = 0; }
			$s->gdmo();
		}
		if (($s = $self->{documentoid})) {
			if (!$::first) { printf "\n-- "; $::first = 0; }
			$s->gdmo();
		}
	}
}

# -------------------------------------
package GdmoCopyrightDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{copyright} = $line;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if ($::first) { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{copyright})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}

# -------------------------------------
package GdmoChangeLogDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{changelog} = $line;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if ($::first) { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{changelog})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}

# -------------------------------------
package GdmoIncludeDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\s*"([^"]*)"\s*//s);
		$self->{filename} = $1;
		#print STDERR "Checking $self->{filename}...";
		my $f; foreach $f (@::filesread) {
			if ($f eq $self->{filename}) {
				#print STDERR "$self->{filename} is equal to $f";
				goto DONE;
			} else {
				#print STDERR "$self->{filename} is not equal to $f";
			}
		}
		{
			push @::filesread, $self->{filename};
			print STDERR "I: Including $self->{filename}...";
			open (MYFILEH,"<$self->{filename}") || die "can't open $self->{filename} for input";
			my $ifh = \*MYFILEH;
			my $file = <$ifh>;
			chomp $file;
			# strip leading whitespace
			$file=~s/^(?:\s|\n)*//s;
			# strip trailing whitespace
			$file=~s/(?:\s|\n)*$//s;
			# put an EOL on end in case file ends with comment
			$file .= "\n";
			close (MYFILEH);
			#print STDERR "Included file $self->{filename} is:";
			#print STDERR $file;
			die "could not parse $self->{filename}"
				unless (($self->{module} = GdmoModule->parse($file)));
			push @{$self->{children}}, $self->{module};
		}
	DONE:
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $name = $self->{filename};
	$name=~s/\.gdmo$/.hh/;
	$name=~s/(\.hh)?$/.hh/;
	printf "\n$::indent"."#include <$name>"; $::first = 0;
}

sub stub {
	my $self = shift;
	my $name = $self->{filename};
	$name=~s/\.gdmo$/.hh/;
	$name=~s/(\.hh)?$/.hh/;
	printf "\n$::indent"."#include <$name>"; $::first = 0;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if ($::first) { printf '-- '; $::first = 0; } else { printf ' '; }
		printf "\"$self->{filename}\""; $::first = 0;
	}
}


# -------------------------------------
package Asn1VersionDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		print STDERR "I: ASN1.Version: '".$line."'";
		last TEST unless (($self->{version} = Asn1Version->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{version};
		if (($self->{moduleref} = ModuleReference->parse($line,@_[1,-1]))) {
			#print STDERR "Got module reference.";
			push @{$self->{children}}, $self->{moduleref};
		}
		if (($self->{moduleoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			#print STDERR "Got module Oid.";
			push @{$self->{children}}, $self->{moduleoid};
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		$self->{version}->gdmo();
		if (($s = $self->{moduleref})) {
			if ($::first) { printf '-- '; $::first = 0; }
			$s->gdmo();
		}
		if (($s = $self->{moduleoid})) {
			if (!$::first) { printf "\n-- "; $::first = 0; }
			$s->gdmo();
		}
	}
}

# -------------------------------------
package Asn1Version;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(1990\s*\,\s*1994|1994\s*,\s*1990|1990|1994)\s*//s);
		$self->{version} = $1;
		if ($self->{version}=~/1990/) { $self->{1990} = '1990'; }
		if ($self->{version}=~/1994/) { $self->{1994} = '1994'; }
		if ($self->{1990} && $self->{1994}) {
			$self->{version} = '1990,1994';
		} elsif ($self->{1990}) {
			$self->{version} = '1990';
		} elsif ($self->{1994}) {
			$self->{version} = '1994';
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{version}"; $::first = 0;
	}
}

# -------------------------------------
package Namespace;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $gdmo = $_[-1];
	TEST: {
		last TEST unless ($line=~s/^"?([a-zA-Z_][0-9a-zA-Z_]*)"?//s);
		$self->{namespace} = $1;
		#print STDERR "Assigning namespace \"$self->{namespace}\" to ".ref($gdmo)." from Namespace";
		$gdmo->{namespace} = $self->{namespace};
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{namespace}"; $::first = 0;
	}
}

# -------------------------------------
package Directives;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readdirective {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$directive,$e);
		do {
			if ($line=~s/^(?:\s|\n)*--\<((?:.|\n)*?)\>--(?:\s|\n)*//s) {
				$directive = $1;
				# strip all the continuation markers
				$directive=~s/\n[ \t]*(?:--[ \t]*)?/\n/sg;
				# strip leading and trailing whitespace
				$directive=~s/^(?:\s|\n)*//s;
				$directive=~s/(?:\s|\n)*$//s;
				if (($s = $type->parse($directive,@_[1,-1]))) {
					push @{$self->{directives}}, $s;
					push @{$self->{children}}, $s;
				}
				$e++;
			} elsif (($s = Comments->parse($line,@_[1,-1]))) {
				push @{$self->{comments}}, $s;
				$e++;
			}
		} while ($s);
		last TEST unless ($e);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref($self).'Choice';
	return $self->readdirective($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		foreach $s (@{$self->{directives}}) {
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '--<'; $::first = 0;
			$s->gdmo();
			if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
			printf '>--'; $::first = 0;
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
		}
		foreach $s (@{$self->{comments}}) { $s->gdmo(); }
	}
}

# -------------------------------------
package Asn1Directives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package Asn1DirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ASN1\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^Version$/) {
		} elsif ($self->{directive}=~/^FileNameExtension$/) {
		} elsif ($self->{directive}=~/^FileNamePrefixe$/) {
		} elsif ($self->{directive}=~/^FileNameSuffix$/) {
		} elsif ($self->{directive}=~/^Nickname$/) {
		} elsif ($self->{directive}=~/^Remove$/) {
		} elsif ($self->{directive}=~/^WorkingSet1$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Asn1'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ASN1.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}


# ----------------------------------------
package Comments;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (($s = Comment->parse($line,@_[1,-1])));
		push @{$self->{comments}}, $s;
		while (($s = Comment->parse($line,@_[1,-1]))) {
			push @{$self->{comments}}, $s;
		}
		# always eat leading whitespace
		$line=~s/^(\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	# always eat leading whitespace
	$_[0]=~s/^(\s|\n)*//s;
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		foreach $s (@{$self->{comments}}) {
			$s->gdmo();
		}
	}
}

# ----------------------------------------
package Comment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------
# Comments can either be -- folowed by an end of line or a -- followed by a ---.  There is a special
# construct in the Ammendment 3 for X.722 which provides for the following:


sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^((?:\s|\n)*?)--(?!\<)([^\n]*?)(\n|--)//s);
		$self->{beginning} = $1;
		$self->{comment} = $2;
		$self->{ending} = $3;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		# do not print our own compiler generated comments
		unless ($self->{comment}=~/^@@/s) {
			if ($self->{beginning}=~/\n/s) {
				if (!$::first) {
					printf "\n$::indent--"; $::first = 0;
				} else {
					printf '--'; $::first = 0;
				}
			} else {
				printf '--'; $::first = 0;
			}
			printf "$self->{comment}"; $::first = 0;
			if ($self->{ending}=~/^--/) {
				printf '--'; $::first = 0;
			} else {
				printf "\n$::indent"; $::first = 1;
			}
		}
	}
}

# ----------------------------------------
package TemplateList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# ----------------------------------------

# ----------------------------------------
package Template;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$::noref++;
		last TEST unless (
			($self->{template} = ClassTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = PackageTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = ParameterTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = NameBindingTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = AttributeTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = AttributeGroupTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = BehaviourTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = ActionTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = NotificationTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = SubordinationRuleTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = ConstraintRuleTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = RelationshipClassTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = RelationshipMappingTemplate->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{template};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\n$::indent";
		if (($s = $self->{template})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\n$::indent";
	}
}

# ----------------------------------------
package ObjectTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# ----------------------------------------

sub xreftyped {
	my $self = shift;
	my $type = shift;
	my $gdmo = $_[0];

#	if (defined $::root{$type}->{$self->{label}}->{defn}) {
#		print STDERR "E: object ".ref($self)."($self->{label}) already defined.";
#		print STDERR "E: attempted redefinition from \"$gdmo->{documentid}\".";
#		print STDERR "E: original definition in \"$::root->{$type}->{$self->{label}}->{modl}->{documentid}\".";
#		die "multiple definitions";
#	}
#	print STDERR "Assigning document id \"$gdmo->{documentid}\" from ".ref($gdmo)." to ".ref($self)." from xreftyped";
#	$self->{documentid} = $gdmo->{documentid};
#	$gdmo->{$type}->{$self->{label}}->{defn} = $self;
#	$::root->{$type}->{$self->{label}}->{defn} = $self;
#	$::root->{$type}->{$self->{label}}->{modl} = $gdmo;
	if ($type=~/bindings|subordinates/) {
		if (defined $self->{superior}) {
			my $s = $self->{superior}->{class};
			if (defined $::root->{objects}->{$s->{label}}->{defn}) {
				$::root->{objects}->{$s->{label}}->{defn}->{subordinate} = $self;
				push @{$::root->{objects}->{$s->{label}}->{defn}->{subordinates}}, $self;
			}
			push @{$self->{constructorrefs}}, $s;
		}
		if (defined $self->{subordinate}) {
			my $s = $self->{subordinate}->{class};
			if (defined $::root->{objects}->{$s->{label}}->{defn}) {
				$::root->{objects}->{$s->{label}}->{defn}->{superior} = $self;
				push @{$::root->{objects}->{$s->{label}}->{defn}->{superiors}}, $self;
			}
			push @{$self->{constructorrefs}}, $s;
		}
		if (defined $self->{subordinates}) {
			my $s; foreach $s (@{$self->{subordinates}->{items}}) {
				if (defined $::root->{objects}->{$s->{label}}->{defn}) {
					$::root->{objects}->{$s->{label}}->{defn}->{superior} = $self;
					push @{$::root->{objects}->{$s->{label}}->{defn}->{superiors}}, $self;
				}
				push @{$self->{constructorrefs}}, $s;
			}
		}
	}
	$self->call('xref',@_);
}

sub pushscope {
	my $self = shift;
	my $label = shift;
	my $suffix = ref $self;
	$suffix=~s/Template//;
	$suffix=~s/Class/ManagedObject/;
	$suffix=~s/SubordinationRule/Subordinate/;
	$suffix=~s/ConstraintRule/Constraint/;
	$self->{label} = $label;
	$self->{name} = $self->xform('',$label,$suffix);
	$self->{scope} = join('::',@::scopes);
	push @::scopes, $self->{name};
	$self->{scopedname} = join('::',@::scopes);
}
sub popscope {
	my $self = shift;
	pop @::scopes;
}
sub definition {
	my $self = shift;
	my $gdmo = $_[1];

	#print STDERR "I: Stack from: ".ref($self);
	#my $s; foreach $s (@_) {
	#	print STDERR "I: Stack is: ".ref($s);
	#}

	my $type = ref $self;
	$type=~s/Template//;
	$type=lc $type;
	$type.='s';
	$type=~s/classs/objects/;
	$type=~s/namebindings/bindings/;
	$type=~s/attributegroups/groups/;
	$type=~s/subordinationrules/subordinates/;
	$type=~s/constraintrules/constraints/;
	$type=~s/relationshipclass/relations/;
	$type=~s/relationshipmapping/mapping/;

	if (defined $::root{$type}->{$self->{label}}->{defn}) {
		print STDERR "E: object ".ref($self)."($self->{label}) already defined.";
		print STDERR "E: attempted redefinition from \"$gdmo->{documentid}\".";
		print STDERR "E: original definition in \"$::root->{$type}->{$self->{label}}->{modl}->{documentid}\".";
		die "multiple definitions";
	}
	#print STDERR "Assigning document id \"$gdmo->{documentid}\" from ".ref($gdmo)." to ".ref($self)." $self->{label} from definition";
	$self->{documentid} = $gdmo->{documentid};
	$self->{namespace} = $gdmo->{namespace};
	$gdmo->{$type}->{$self->{label}}->{defn} = $self;
	$::root->{$type}->{$self->{label}}->{defn} = $self;
	$::root->{$type}->{$self->{label}}->{modl} = $gdmo;
}

sub xref {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Template//;
	$type=lc $type;
	$type.='s';
	$type=~s/classs/objects/;
	$type=~s/namebindings/bindings/;
	$type=~s/attributegroups/groups/;
	$type=~s/subordinationrules/subordinates/;
	$type=~s/constraintrules/constraints/;
	$type=~s/relationshipclass/relations/;
	$type=~s/relationshipmapping/mapping/;
	return $self->xreftyped($type,@_);
}

sub gdmolabel {
	my $self = shift;
	my $title = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my ($s,$r);
		printf "$self->{label} $title"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$r = 0;
			foreach $s (@{$self->{children}}) {
				if (ref $s eq 'RegisteredAs') {
					if (!$r) { $::indent=~s/^.//s; $r = 1; }
				}
				$s->gdmo();
			}
			if (!$r) { $::indent=~s/^.//s; $r = 1; }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ClassTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*MANAGED(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{derivedfrom} = DerivedFromClasses->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{derivedfrom};
		}
		if (($self->{characterization} = Characterization->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{characterization};
		}
		if (($self->{conditionalpackages} = ConditionalPackages->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{conditionalpackages};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{objects}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{objects}->{$self->{label}}->{intf} = $self;
		printf "\n$::indent"."class $self->{name}"."Factory : public ManagedObjectFactory {";
		$::indent.="\t";
		printf "\n$::indent"."public:";
		$::indent.="\t";
		printf "\n$::indent"."$self->{scopedname}& create(";
		#if (defined $self->{superior}) {
		#	printf "\n$::indent"."\t$self->{superior}->{scopedname}& nameBinding,";
		#	printf "\n$::indent"."\t$self->{superior}->{superior}->{class}->{scopedname}& superiorObject,";
		#} else {
			printf "\n$::indent"."\tNameBinding& nameBinding,";
			printf "\n$::indent"."\tManagedObject& superiorObject,";
		#}
		printf "\n$::indent"."\tconst char **name";
		my ($d,@derived,@list,$l,$s);
		@list = ( $self );
		while ($d = shift @list) {
			if ($d->{derivedfrom}) {
				my @superiors = ();
				foreach $l (@{$d->{derivedfrom}->{classes}->{items}}) {
					if (($s = $::root->{objects}->{$l->{label}}->{defn})) {
						unshift @superiors, $s;
					}
				}
				push @list, @superiors;
			}
			push @derived, $d;
		}
		while ($d = pop @derived) {
			my ($p,$e,$a);
			#if (!defined $self->{head}->{$d->{label}}->{refs}) {
			#	$self->{head}->{$d->{label}}->{refs}++;
				if (defined $d->{constructorrefs}) {
					foreach $p (@{$d->{constructorrefs}}) {
						#printf ",\n$::indent"."\t$p->{scopedname}& $p->{name}Reference";
						if ($p = $::root->{packages}->{$p->{label}}->{defn}) {
							if (defined $p->{constructorrefs}) {
								foreach $a (@{$p->{constructorrefs}}) {
									printf ",\n$::indent"."\t$a->{scopedname}& $a->{name}Reference";
								}
							}
							if (defined $p->{constructorptrs}) {
								foreach $a (@{$p->{constructorptrs}}) {
									printf ",\n$::indent"."\t$a->{scopedname} *$a->{name}Pointer";
								}
							}
						}
					}
				}
				if (defined $d->{constructorptrs}) {
					foreach $p (@{$d->{constructorptrs}}) {
						#printf ",\n$::indent"."\t$p->{scopedname} *$p->{name}Pointer";
						if ($p = $::root->{packages}->{$p->{label}}->{defn}) {
							if (defined $p->{constructorrefs}) {
								foreach $a (@{$p->{constructorrefs}}) {
									printf ",\n$::indent"."\t$a->{scopedname} *$a->{name}Pointer";
								}
							}
							if (defined $p->{constructorptrs}) {
								foreach $a (@{$p->{constructorptrs}}) {
									printf ",\n$::indent"."\t$a->{scopedname} *$a->{name}Pointer";
								}
							}
						}
					}
				}
			#}
		}
		printf "\n$::indent".");";
		printf "\n$::indent"."$self->{name}"."Factory();";
		printf "\n$::indent"."virtual ~$self->{name}"."Factory();";
		$::indent=~s/^.//s;
		$::indent=~s/^.//s;
		printf "\n$::indent"."}; // class $self->{name}"."Factory";
		printf "\n$::indent";
		if ($self->{derivedfrom}) {
			$self->decclass('ManagedObject');
		} else {
			$self->begclass('ManagedObject');
		}
		my $x;
		if (($x = $self->{derivedfrom})) { $x->generate('head',@_,$self); }
		printf "\n$::indent"."static const char name"."[];";
		printf "\n$::indent"."static bool subclassOf(typename type);";
		printf "\n$::indent"."static $self->{name}& Create();";
		printf "\n$::indent"."virtual Delete();";
		if (defined $self->{superiors}) {
			printf "\n$::indent"."// NAMED BY SUPERIOR OBJECT CLASS:";
			foreach $x (@{$self->{superiors}}) {
				printf "\n$::indent"."$x->{scopedname}& $x->{superior}->{class}->{name};";
			}
		} elsif (defined $self->{superior}) {
			printf "\n$::indent"."// NAMED BY SUPERIOR OBJECT CLASS:";
			printf "\n$::indent"."$self->{superior}->{scopedname}& $self->{superior}->{superior}->{class}->{name};"
		}
		if (defined $self->{subordinates}) {
			printf "\n$::indent"."// SUBORDINATE OBJECT CLASS:";
			foreach $x (@{$self->{subordinates}}) {
				printf "\n$::indent"."list <"."$x->{scopedname}&> $x->{subordinate}->{class}->{name};"
			}
		} elsif (defined $self->{subordinate}) {
			printf "\n$::indent"."// SUBORDINATE OBJECT CLASS:";
			printf "\n$::indent"."list <"."$self->{subordinate}->{scopedname}&> $self->{subordinate}->{subordinate}->{class}->{name};"
		}
		if (($x = $self->{characterization})) { $x->generate('head',@_,$self); }
		if (($x = $self->{conditionalpackages})) { $x->generate('head',@_,$self); }
		if (($x = $self->{registration})) { $x->generate('head',@_,$self); }
		$self->endclass('ManagedObject');
	}
}

# subclassOf() is used by the managed object Create() operation to create an instance
sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// MANAGED OBJECT CLASS: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		printf "\n$::indent"."bool $name"."::subclassOf(typename type)";
		printf "\n$::indent"."{";
		printf "\n$::indent"."\t// Quite simply the current class is subclass of the specified class,";
		printf "\n$::indent"."\t// 'type', if the specified class is the parent class, or the parent";
		printf "\n$::indent"."\t// class is a subclass of the specified class.";
		printf "\n$::indent"."\t";
		printf "\n$::indent"."\treturn ( false";
		my $p; foreach $p (@{$self->{derivedfrom}->{classes}->{items}}) {
			printf "\n$::indent"."\t\t|| (type == $p->{name}) || $p->{scopedname}"."::subclassOf(type)";
		}
		printf "\n$::indent"."\t);";
		printf "\n$::indent"."\t";
		printf "\n$::indent"."}";
		printf "\n$::indent"."bool $name& $name"."::Create()";
		printf "\n$::indent"."{";
		printf "\n$::indent"."}";
		printf "\n$::indent"."$name"."::Delete()";
		printf "\n$::indent"."{";
		printf "\n$::indent"."}";
		$self->call('stub',@_);
		$self->cdtors((),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('MANAGED OBJECT CLASS',@_); }

sub showderived {
	my $self = shift;
	printf "\n--@@ $::indent";
	if (defined $self->{namespace}) {
		printf "$self->{namespace}::$self->{name}";
	} elsif (defined $self->{documentid}) {
		printf "\"$self->{documentid}\":$self->{name}";
	} else {
		printf "$self->{name}";
	}
	if ($::indent eq '') { $::indent='+- '; } else { $::indent='|  '.$::indent; }
	if (defined $self->{derivations}) {
		my ($d); foreach $d (@{$self->{derivations}}) {
			$d->showderived();
		}
	}
	$::indent=~s/^...//;
}

sub walkcontained {
	my $self = shift;
	printf "\n--@@ $::indent";
	if (defined $self->{namespace}) {
		printf "$self->{namespace}::$self->{name}";
	} elsif (defined $self->{documentid}) {
		printf "\"$self->{documentid}\":$self->{name}";
	} else {
		printf "$self->{name}";
	}
#	if (defined $self->{derivations}) {
#		if ($::indent eq '') { $::indent='>- '; } else { $::indent='|  '.$::indent; }
#		$::indent=~s/>/+/;
#		my ($d); foreach $d (@{$self->{derivations}}) {
#			$d->showderived();
#		}
#		$::indent=~s/\+/>/;
#		$::indent=~s/^...//;
#	}
	if ($::indent eq '') { $::indent='>- '; } else { $::indent='|  '.$::indent; }
	if (defined $self->{contains}) {
		if (!defined $self->{beenthere}) {
			$self->{beenthere} = 1;
			my ($d); foreach $d (@{$self->{contains}}) {
				if ($d->{label} eq $self->{label}) {
					printf "\n--@@ $::indent";
					if (defined $self->{namespace}) {
						printf "$self->{namespace}::$self->{name}";
					} elsif (defined $self->{documentid}) {
						printf "\"$self->{documentid}\":$self->{name}";
					} else {
						printf "$self->{name}";
					}
				} else {
					$d->walkcontained();
				}
			}
		} else {
			printf ' +++';
		}
	}
	$::indent=~s/^...//;
}

sub showcontained {
	my $self = shift;
	if (!defined $self->{container} && defined $self->{contains}) {
		$self->walkcontained();
	}
	if (defined $self->{derivations}) {
		my ($d); foreach $d (@{$self->{derivations}}) {
			$d->showcontained();
		}
	}
}

# ----------------------------------------
package PackageTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*PACKAGE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{attributes} = Attributes->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{attributes};
		}
		if (($self->{attributegroups} = AttributeGroups->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{attributegroups};
		}
		if (($self->{actions} = Actions->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{actions};
		}
		if (($self->{notifications} = Notifications->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{notifications};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{packages}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{packages}->{$self->{label}}->{intf} = $self;
		$self->begclass('Package');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Package');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// PACKAGE: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::"."name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Package(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('PACKAGE',@_); }

# ----------------------------------------
package ParameterTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*PARAMETER//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless ($self->{context} = Context->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{context};
		last TEST unless (
			($self->{syntax} = WithSyntax->parse($line,@_[1,-1],$self)) ||
			($self->{syntax} = Attribute->parse($line,@_[1,-1],$self))
		);
		push @{$self->{children}}, $self->{syntax};
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{parameters}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{parameters}->{$self->{label}}->{intf} = $self;
		$self->begclass('Parameter');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Parameter');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// PARAMETER: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Parameter(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('PARAMETER',@_); }

# ----------------------------------------
package NameBindingTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------
# This template allows alternative naming structures to be defined for managed objects of a given
# managed object class by means of name bindings.  A name binding allows an attribtue to be selected
# as the naming attribute that shall be used when a subordinate object which is an instnance of the
# specified managed object class is named by a superior object which is an instance of the specified
# managed object class or other object class, such as a Directory obejct class.
#
# If a given name binding is used, the attribute identified as the naming attribute shall be present
# in the subordinate object.  The naming attribute is used to construct the relative distinguished
# name (RDN) of subordinate objects of that class.  An RDN is constructued from the object identifier
# assigned ot that attribute type and the avlaue of the instance of the attribute.  The Distinguished
# Name of the subordinate object is obtained by appending the RDN to the Distinguished Name of its
# superior object.
#
# Name bindings are not considered to be part of the definition of either of the classes that they
# reference.  A given subordinate managed object class may have more than one name binding associated
# with it.  The set of name bindings defines the set of possible naming relationships with superior
# objects and the set of managed object classes from which subordinate objects may be instantiated.
#
# A name binding may also be defined to apply to all subclasses of the specified superior object class
# or all subclasses of the sepcified subordinate object class, or both.
#
#   NOTE -- Name binding may be specified for a managed object class subsequent to the specification
#   of the managed object class itself.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*NAME(?:\s|\n)*((-)?)(?:\s|\n)*BINDING//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless ($self->{subordinate} = SubordinateObjectClass->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{subordinate};
		last TEST unless ($self->{superior} = NamedBySuperior->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{superior};
		last TEST unless ($self->{attribute} = WithAttribute->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{createit} = Create->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{createit};
		}
		if (($self->{deleteit} = Delete->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{deleteit};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my ($sup,$sub);
	if (
		($sup = $::root->{objects}->{$self->{superior}->{class}->{label}}->{defn}) &&
		($sub = $::root->{objects}->{$self->{subordinate}->{class}->{label}}->{defn})
	) {
		push @{$sup->{contains}}, $sub;
		push @{$sub->{container}}, $sup;
	}
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	if (defined $::root->{bindings}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{bindings}->{$self->{label}}->{intf} = $self;
		$self->begclass('NameBinding');
		printf "\n$::indent"."static const char name"."[];";
		printf "\n$::indent"."static const typename superiorClassType;";
		printf "\n$::indent"."static const bool superiorSubclassesAllowed;";
		printf "\n$::indent"."static const typename subordinateClassType;";
		printf "\n$::indent"."static const bool subordinateSubclassesAllowed;";
		printf "\n$::indent"."static const bool managersMayCreate;";
		printf "\n$::indent"."static const NameBinding::deletePolicy deletePolicy;";
		printf "\n$::indent"."$self->{superior}->{class}->{scopedname}& superiorClass;";
		printf "\n$::indent"."$self->{subordinate}->{class}->{scopedname}& subordinateClass;";
		$self->call('head',@_);
		$self->endclass('NameBinding');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// NAME BINDING: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		printf "\n$::indent"."const typename $name"."::superiorClassType = $self->{superior}->{class}->{scopedname};";
		printf "\n$::indent"."const bool $name"."::superiorSubclassesAllowed = ";
		if (defined $self->{superior}->{subclasses}) { printf 'true;'; } else { printf 'false;'; }
		printf "\n$::indent"."const typename $name"."::subordinateClassType = $self->{subordinate}->{class}->{scopedname};";
		printf "\n$::indent"."const bool $name"."::subordinateSubclassesAllowed = ";
		if (defined $self->{subordinate}->{subclasses}) { printf 'true;'; } else { printf 'false;'; }
		printf "\n$::indent"."const bool $name"."::managersMayCreate = ";
		if (defined $self->{createit}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const NameBinding::deletePolicy $name"."::deletePolicy = NameBinding::";
		if (defined $self->{deleteit}) { printf "$self->{deleteit}->{policy};"; } else { printf "notDeletable;"; }
		$self->cdtors(('NameBinding(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('NAME BINDING',@_); }

# ----------------------------------------
package AttributeTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*ATTRIBUTE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless (
			($self->{syntax} = DerivedFromAttribute->parse($line,@_[1,-1],$self)) ||
			($self->{syntax} = WithAttributeSyntax->parse($line,@_[1,-1],$self))
		);
		push @{$self->{children}}, $self->{syntax};
		if (($self->{matches} = MatchesFor->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{matches};
		}
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{parameters} = Parameters->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{attributes}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{attributes}->{$self->{label}}->{intf} = $self;
		my $x;
		$self->decclass('Attribute');
		$self->{syntax}->generate('head',@_,$self);
		printf "\n$::indent"."static const char name"."[];";
		printf "\n$::indent"."static const bool equality;";
		printf "\n$::indent"."static const bool ordering;";
		printf "\n$::indent"."static const bool substrings;";
		printf "\n$::indent"."static const bool setComparison;";
		printf "\n$::indent"."static const bool setInteraction;";
		if (($x = $self->{behaviour}))	    { $x->generate('head',@_,$self); }
		if (($x = $self->{parameters}))	    { $x->generate('head',@_,$self); }
		if (($x = $self->{registration}))   { $x->generate('head',@_,$self); }
		$self->endclass('Attribute');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// ATTTRIBUTE: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->{syntax}->generate('stub',@_,$self);
		printf "\n$::indent"."const bool $name"."::"."equality = ";
		if ($self->{equality}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."ordering = ";
		if ($self->{ordering}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."substrings = ";
		if ($self->{substrings}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."setComparison = ";
		if ($self->{setcomparison}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."setIntersection = ";
		if ($self->{setintersection}) { printf "true;"; } else { printf "false;"; }
		my $x;
		if (($x = $self->{behaviour}))	    { $x->generate('stub',@_,$self); }
		if (($x = $self->{parameters}))	    { $x->generate('stub',@_,$self); }
		if (($x = $self->{registration}))   { $x->generate('stub',@_,$self); }
		$self->cdtors(('Attribute(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('ATTRIBUTE',@_); }

# ----------------------------------------
package AttributeGroupTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUP//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{groupelements} = GroupElements->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{groupelements};
		}
		if (($self->{fixed} = Fixed->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{fixed};
		}
		if (($self->{description} = Description->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{description};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{groups}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{groups}->{$self->{label}}->{intf} = $self;
		$self->begclass('AttributeGroup');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_,$self);
		$self->endclass('AttributeGroup');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// ATTTRIBUTE GROUP: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('AttributeGroup(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('ATTRIBUTE GROUP',@_); }

# ----------------------------------------
package BehaviourTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*BEHAVIOUR//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{definedas} = DefinedAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{definedas};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{behaviours}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{behaviours}->{$self->{label}}->{intf} = $self;
		$self->begclass('Behaviour');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_,$self);
		$self->endclass('Behaviour');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// BEHAVIOUR: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Behaviour(name,definedas)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('BEHAVIOUR',@_); }

# ----------------------------------------
package ActionTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*ACTION//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{mode} = Mode->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{mode};
		}
		if (($self->{parameters} = Parameters->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		if (($self->{infosyntax} = WithInformationSyntax->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{infosyntax};
		}
		if (($self->{replysyntax} = WithReplySyntax->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{replysyntax};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{actions}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{actions}->{$self->{label}}->{intf} = $self;
		$self->begclass('Action');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Action');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// ACTION: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Action(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('ACTION',@_); }

# ----------------------------------------
package NotificationTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*NOTIFICATION//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{parameters} = Parameters->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		if (($self->{infosyntax} = WithInformationSyntaxAndAttributeIds->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{infosyntax};
		}
		if (($self->{replysyntax} = WithReplySyntax->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{replysyntax};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{notifications}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{notifications}->{$self->{label}}->{intf} = $self;
		$self->begclass('Notification');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Notification');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// NOTIFICATION: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Notification(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('NOTIFICATION',@_); }

# -------------------------------------
package SubordinationRuleTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*SUBORDINATION(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless (($self->{superior} = SuperiorObjectClass->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{superior};
		last TEST unless (($self->{subordinates} = NamesSubordinates->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{subordinates};
		last TEST unless (($self->{accordingto} = AccordingToRule->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{accordingto};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{subordinates}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{subordinates}->{$self->{label}}->{intf} = $self;
		$self->begclass('Subordination');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Subordination');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		printf "\n$::indent"."//";
		printf "\n$::indent"."// SUBORDINATION RULE: $name";
		printf "\n$::indent"."//";
		$self->call('stub',@_);
		$self->cdtors(('SubordinationRule(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('SUBORDINATION RULE',@_); }

# -------------------------------------
package ConstraintRuleTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*CONSTRAINT(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless (($self->{objectclass} = GdmoObjectClass->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{objectclass};
		last TEST unless (($self->{isrelatedto} = IsRelatedTo->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{isrelatedto};
		last TEST unless (($self->{usingattribute} = UsingAttribute->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{usingattribute};
		last TEST unless (($self->{ruleset} = ConstraintRuleSet->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{ruleset};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (defined $::root->{constraints}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{constraints}->{$self->{label}}->{intf} = $self;
		$self->begclass('Constraint');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Constraint');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// CONSTRAINT RULE: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('ConstraintRule(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('CONSTRAINT RULE',@_); }

# -------------------------------------
package RelationshipClassTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*RELATIONSHIP(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{derivedfrom} = DerivedFromRelationshipClasses->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{derivedfrom};
		}
		last TEST unless (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{behaviour};
		if (($self->{supports} = Supports->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{supports};
		}
		if (($self->{qualifiedby} = QualifiedBy->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{qualifiedby};
		}
		last TEST unless (($self->{rolespecifiers} = RoleSpecifiers->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{rolespecifiers};
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub gdmo { my $self = shift; return $self->gdmolabel('RELATIONSHIP CLASS',@_); }

# -------------------------------------
package RelationshipMappingTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = join('::',@::scopes);
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/_]|-(?!-))*(?<!-))(?:\s|\n)*RELATIONSHIP(?:\s|\n)*((-)?)(?:\s|\n)*MAPPING//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = RelationshipClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		last TEST unless (($self->{behavior} = Behaviour->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{behavior};
		if (($self->{object} = RelationshipObject->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{object};
		}
		last TEST unless (($self->{roles} = RoleMappingSpecifications->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{roles};
		if (($self->{operations} = OperationsMapping->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operations};
		}
		if (($self->{registered} = RegisteredAs->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{registered};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo { my $self = shift; return $self->gdmolabel('RELATIONSHIP MAPPING',@_); }

# -------------------------------------
package RelationshipClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATIONSHIP\s*-?\s*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = RelationshipClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'RELATIONSHIP CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}


# -------------------------------------
package AccordingToRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{accordingto} = AccordingToRuleToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{accordingto};
		last TEST unless (($self->{rule} = SubordinationRule->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rule};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$::indent.="\t";
		$self->{accordingto}->gdmo();
		{
			$self->{rule}->gdmo();
			$::indent=~s/^.//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SuperiorObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUPERIOR\s*-?\s*OBJECT\s*-?\s*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "SUPERIOR OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamesSubordinates;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMES\s*-?\s*SUBORDINATES//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ClassReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "NAMES SUBORDINATES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{list}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IsRelatedTo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^IS(?:\s|\n)*((-)?)(?:\s|\n)*RELATED(?:\s|\n)*((-)?)(?:\s|\n)*TO//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ClassSpecList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "IS RELATED TO"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{list}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ClassSpecList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ClassSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{reference}->gdmo();
		if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UsingAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USING(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'USING ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintRuleSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{ruleset} = SingleConstraintRule->parse($line,@_[1,-1])) ||
			($self->{ruleset} = NamedTypeConstraintRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{ruleset};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{ruleset}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SingleConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACCORDING\s*-?\s*TO\s*-?\s*RULE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rule} = ConstraintRule->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACCORDING TO RULE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package NamedTypeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CASE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = NamedTypeConstraintRuleListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'CASE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package NamedTypeConstraintRuleListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedTypeConstraintRuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('NamedTypeConstraintRuleItem',@_); }

# -------------------------------------
package NamedTypeConstraintRuleItem;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{accordingto} = AccordingToRuleToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{accordingto};
		last TEST unless (($self->{rule} = ConstraintRule->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{type}->gdmo();
		$self->{accordingto}->gdmo();
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package AccordingToRuleToken;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('ACCORDING TO RULE',@_); }

# -------------------------------------
package SubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{rule} = SetSubordinationRule->parse($line,@_[1,-1])) ||
			($self->{rule} = ChoiceSubordinationRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SetSizeSubordinationRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package ConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{rule} = SetConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SequenceConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = ChoiceConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SetSizeConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SequenceSizeConstraintRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package SetSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SetToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{rules} = SubordinationTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{token}->gdmo();
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SetConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{token} = SetToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{token};
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{token}->gdmo();
		$self->{rules}->gdmo();
	}
}

package SetToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleUCToken);

# -------------------------------------
package SequenceConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SEQUENCE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package ChoiceSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = SubordinationTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package ChoiceConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SetSizeSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ordinality};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{constraint} = SubordinationTerm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package SetSizeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ordinality};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{constraint} = ConstraintTerm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package SequenceSizeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ordinality};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{constraint} = ConstraintTerm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SEQUENCE SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package OrdinalityParens;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryParens);
# -------------------------------------

# -------------------------------------
package Ordinality;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{ordinality} = GdmoValueRange->parse($line,@_[1,-1])) ||
			($self->{ordinality} = ValueList->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{ordinality};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		$::first = 1; # fool it
	}
}

# -------------------------------------
package GdmoValueRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{lower} = IntegerValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{lower};
		last TEST unless ($line=~s/^\.\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			$line=~s/^N//s ||
			($self->{upper} = IntegerValue->parse($line,@_[1,-1]))
		);
		if ($self->{upper}) {
			push @{$self->{children}}, $self->{upper};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$::first = 1; # fool it
		$self->{lower}->gdmo();
		printf '..'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{upper})) { $s->gdmo(); } else {
			printf 'N'; $::first = 0;
		}
		$::first = 1; # fool it
	}
}

# -------------------------------------
package SubordinationTermListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package SubordinationTermList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package SubordinationTerm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{term} = ClassReference->parse($line,@_[1,-1])) ||
			($self->{term} = SubordinationRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{term};
		my $ref = ref $self->{term};
		if ($ref=~/ClassReference/) {
			if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{subclasses};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{term}->gdmo();
		my $s; if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintTermListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package ConstraintTermList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ConstraintTerm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{term} = ClassReference->parse($line,@_[1,-1])) ||
			($self->{term} = ConstraintRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{term};
		my $ref = ref $self->{term};
		if ($ref=~/ClassReference/) {
			if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{subclasses};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{term}->gdmo();
		my $s; if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DerivedFromRelationshipClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This construct shall be used to specify the superclass(es) from which the managed relationsihp
# class inherits its characteristics including any which may, in turn, have been inherited from
# other managed relationship class(es).  The managed relationship calss is a specialization of the
# inherited characteristics and those specified in the balance of the completed template; the
# specialization is such that the subclass is consistent with its superclass(es). If this construct
# is absent, the managed relationship class is not specialized from other relationship classes.
#
# Specification of characteristics that are inherited from other managed relationship classes shall
# not be repeated in the specification of the subclass unless on eof the techniques described in
# CCITT Rec. X.722 | ISO/IEC 10165-4 for extending a specification inherited from a superclass is
# being used.
#
# The rules for specifying managed relationship subclasses to ensure consistency are as follows:
#
# a) SUPPORTS: The specialized relationship management operation shall be the union of the
#    relationship management operations of the superclass and those specified in the subclass;
#    inheritance and specialization shall not introduce additional relationship management
#    notificiations into a subclass.
#
# b) QUALIFIED BY: Permitted and required value-sets of atrribute ranges shall not be changed in a
#    subclass behaviour.
#
# c) BEHAVIOUR: The behaviour of a subclass shall be:
#
#    - the disjunctive combination of the pre-conditions inherited from its superclass(es) and those
#      specified in the sublcass;
#
#    - the conjunctive combination of the post-conditions inherited from its superclass(es) and
#      those specified in the subclass;
#
#    - the conjunctive combination of the invariants inherited from its superclass(es) and those
#      specified in the subclass; if the invariants are mutually contradictory, a subclass cannot be
#      specified.
#
# d) ROLE:
#
#    - Additional role specifications may be included in the subclass definition.
#
#    - A managed objects class introduced by the COMPATIBLE WITH clause in the subclass shall be
#      compatible to those referenced in similar clauses in the superclass(es).
#
#    - The inherited PERMITTED-ROLE-CARDINALITY-CONSTRAINT value of a role inherited from more than
#      one superclass shall be the set intersection of the values specified for that role in the
#      superclasses; any permitted role cardinality constraint value specified in the subclass shall
#      be a subset of, or equal to, the inherited permitted role cardinality constraint value; the
#      specialized permitted role cardinality constraint value shall be the set intersection of the
#      inherited values and that specified in the subclass.
#
#    - The inherited REQUIRED-ROLE-CARDINALITY-CONSTRAINT value of a rule inherited from more than
#      one superclass hsall be the set union of the values specified for the role in the
#      superclasses set-intersected with the inherited permitted role cardinality constraint value;
#      any required role cardinality constraint value specified in the subclass shall be a superset
#      of, or equal to, the inherited required role cardinality constraint value; the specialized
#      required role cardinality constraint value shall be the set union of the inherited value and
#      that specified in the subclass set-intersected with the value of the specialized permitted
#      rold cardinality constraint.
#
#    - BIND-SUPPORT may be added in the subclass specification.
#
#    - UNBIND-SUPPORT may be added in the subclass specification.
#
#    - The inherited PERMITTED-RELATIONSHIP-CARDINALITY-CONSTRAINT value of a rule inherited from
#      more than one superclass shall be the set intersection of the values sepecified for the role
#      in the superclasses; any permitted relationship cardinality constraint value specified in the
#      subclass shall be a subset of, or equal to, the inherited permitted relationship cardinality
#      constraint value; the specialized permitted relationship cardinality constraint value shall
#      be the set intersection of the inherited value and that specified in the subclass.
#
# e) REGISTERED AS: The subclass registration shall replace any registration inherited from other
#    definiitons.
#

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{classes} = ClassReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	my $gdmo = $_[-2];
	my ($i,$d);
	foreach $i (@{$self->{classes}->{items}}) {
		if (defined $::root->{objects}->{$i->{label}}) {
			if ($d = $::root->{objects}->{$i->{label}}->{defn}) {
				my ($t);
				if (defined $tmpl->{backtrace}) {
					print STDERR "E: multiple markings of $tmpl->{label}";
					print STDERR "E: backtrace is:";
					my $b; foreach $b (@::backtrack) {
						print STDERR "E: B: ".ref($b);
					}
					print STDERR "E: original backtrace was:";
					my $b; foreach $b (@{$tmpl->{backtrace}}) {
						print STDERR "E: B: ".ref($b);
					}
					#die "multiple markings";
				} else {
					my $b; foreach $b (@::backtrace) {
						push @{$tmpl->{backtrace}}, $b;
					}
					my ($t,$e); foreach $t (@{$d->{derivations}}) {
						if ($t->{label} eq $tmpl->{label}) {
							print STDERR "E: multiple markings with same label $t->{label}";
							print STDERR "E: template 1 is ".ref($t).".$t->{id}";
							print STDERR "E: template 2 is ".ref($tmpl).".$t->{id}";
							$e++;
						}
					}
					unless ($e) {
						#print "--@@ $tmpl->{label} is derived from $d->{label}.";
						push @{$d->{derivations}}, $tmpl;
					}
				}
			}
		}
	}
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	my ($i,$e);
	printf ' : public ';
	foreach $i (@{$self->{classes}->{items}}) {
		if ($e) { printf ', '; } else { $e++; }
		printf "$i->{name}";
	}
	printf ' {';
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	return $self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "DERIVED FROM"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{classes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Supports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# A.1.3.3  SUPPORTS supported [, supported]*
#
# This construct shall be used to define the relationship management operaitons and notifications
# that a managed relationship supports.  The 'supported' production shall be used to specifiy the
# prototypical operation or notification on which the relationship mangement operation or
# notification is based, namely:
#
# - ESTABLISH [operation-name];
# - TERMINATE [operation-name];
# - QUERY [operation-name];
# - NOTIFY [notification-name];
# - USER DEFINED [operation-name];
#

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUPPORTS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{supported} = SupportedList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{supported};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "SUPPORTS"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{supported}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SupportedList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Supported;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{supported} = EstablishSupport->parse($line,@_[1,-1])) ||
			($self->{supported} = TerminateSupport->parse($line,@_[1,-1])) ||
			($self->{supported} = QuerySupport->parse($line,@_[1,-1])) ||
			($self->{supported} = NotifySupport->parse($line,@_[1,-1])) ||
			($self->{supported} = UserDefinedSupport->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{supported};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package EstablishSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ESTABLISH//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ESTABLISH'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TerminateSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^TERMINATE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'TERMINATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QuerySupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^QUERY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'QUERY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotifySupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{notification} = NotificationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{notification};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'NOTIFY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{notification})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UserDefinedSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USER\s*-?\s*DEFINED//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'USER DEFINED'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleSpecifiers;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = RoleSpecifierList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
		printf ';'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleSpecifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package RoleSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# A.1.3.5 ROLE role-name
#
# This construct shall be used to specify the roles associated with the managed relationship calss;
# the label 'role-name' shll be used as a reference name o the role.
#
#

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ROLE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rolename} = RoleName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rolename};
		if (($self->{compatiblewith} = CompatibleWith->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{compatiblewith};
		}
		if (($self->{permittedrole} = PermittedRoleCardinalityConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{permittedrole};
		}
		if (($self->{requiredrole} = RequiredRoleCardinalityConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{requiredrole};
		}
		if (($self->{bindsupport} = BindSupport->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{bindsupport};
		}
		if (($self->{unbindsupport} = UnbindSupport->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{unbindsupport};
		}
		if (($self->{permittedrel} = PermittedRelationshipCardinalityConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{permittedrel};
		}
		if (($self->{registeredas} = RegisteredAs->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{registeredas};
		}
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ROLE'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{rolename}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{compatiblewith})) { $s->gdmo(); }
			if (($s = $self->{permittedrole} )) { $s->gdmo(); }
			if (($s = $self->{requiredrole}  )) { $s->gdmo(); }
			if (($s = $self->{bindsupport}   )) { $s->gdmo(); }
			if (($s = $self->{unbindsupport} )) { $s->gdmo(); }
			if (($s = $self->{permittedrel}  )) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		if (($s = $self->{registeredas})) { $s->gdmo(); }
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CompatibleWith;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^COMPATIBLE\s*-?\s*WITH//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'COMPATIBLE-WITH'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{class}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PermittedRoleCardinalityConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED\s*-?\s*ROLE\s*-?\s*CARDINALITY\s*-?\s*CONSTRAINT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED-ROLE-CARDINALITY-CONSTRAINT'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{type}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RequiredRoleCardinalityConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REQUIRED\s*-?\s*ROLE\s*-?\s*CARDINALITY\s*-?\s*CONSTRAINT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REQUIRED-ROLE-CARDINALITY-CONSTRAINT'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{type}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BindSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIND\s*-?\s*SUPPORT//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'BIND-SUPPORT'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UnbindSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^UNBIND\s*-?\s*SUPPORT//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'UNBIND-SUPPORT'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PermittedRelationshipCardinalityConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED\s*-?\s*RELATIONSHIP\s*-?\s*CARDINALITY\s*-?\s*CONSTRAINT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED-RELATIONSHIP-CARDINALITY-CONSTRAINT'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{type}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QualifiedBy;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This construct shall be used to specify attributes that are associated with the managed
# relationship as a whole.  Qualifying attributes shall be made available in all implementations of
# the managed relationship irrespective of the representation method used.  The relationship mapping
# template shall be used to specify how these attributes are made available by a paticular
# representation.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RelationshipObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATIONSHIP\s*-?\s*OBJECT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{qualifies} = QualifiesComma->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{qualifies};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'RELATIONSHIP OBJECT'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{class}->gdmo();
			if (($s = $self->{qualifies})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QualifiesComma;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		last TEST unless ($line=~s/^QUALIFIES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributes} = AttributeReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributes};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'QUALIFIES'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
	}
}

# -------------------------------------
package RoleMappingSpecifications;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{roles} = RoleMappingSpecificationList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{roles};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{roles}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleMappingSpecificationList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListUnindented);
# -------------------------------------

# -------------------------------------
package RoleMappingSpecification;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{role} = Role->parse($line, @_[1,-1])));
		push @{$self->{children}}, $self->{role};
		last TEST unless (($self->{classes} = RelatedClasses->parse($line, @_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		if (($self->{representedby} = RepresentedBy->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{representedby};
		}
		if (($self->{qualifies} = QualifiesSimple->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{qualifies};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		$self->{role}->gdmo();
		{
			$::indent.="\t";
			$self->{classes}->gdmo();
			if (($s = $self->{representedby})) { $s->gdmo(); }
			if (($s = $self->{qualifies})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
	}
}

# -------------------------------------
package Role;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ROLE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rolename} = RoleName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rolename};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "ROLE"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{rolename}->gdmo();
	}
}

# -------------------------------------
package RelatedClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATED\s*-?\s*CLASSES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{classes} = ClassReferenceSimpleList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "RELATED-CLASSES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{classes}->gdmo();
	}
}

# -------------------------------------
package RepresentedBy;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REPRESENTED\s*-?\s*BY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{representation} = Representation->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{representation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REPRESENTED-BY'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{representation}->gdmo();
	}
}

# -------------------------------------
package Representation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{representation} = Naming->parse($line,@_[1,-1])) ||
			($self->{representation} = AttributeRepresentation->parse($line,@_[1,-1])) ||
			($self->{representation} = RelationshipObjectUsingPointer->parse($line,@_[1,-1])) ||
			($self->{representation} = Operation->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{representation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

package Operation;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('OPERATION',@_); }

# -------------------------------------
package AttributeRepresentation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		#if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package Naming;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMING//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{binding} = NameBindingReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{binding};
		last TEST unless (($self->{using} = Using->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{using};
		last TEST unless (
			($self->{suporsub} = Superior->parse($line,@_[1,-1])) ||
			($self->{suporsub} = Subordinate->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{suporsub};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAMING'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{binding}->gdmo();
		$self->{using}->gdmo();
		$self->{suporsub}->gdmo();
	}
}

package Using;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('USING',@_); }

package Superior;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('SUPERIOR',@_); }

package Subordinate;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);

sub read { my $self = shift; return $self->readtoken('SUBORDINATE',@_); }

# -------------------------------------
package ClassReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package RelationshipObjectUsingPointer;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATIONSHIP\s*-?\s*OBJECT\s*-?\s*USING\s*-?\s*POINTER\s*-?\s*//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'RELATIONSHIP-OBJECT-USING-POINTER'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QualifiesSimple;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^QUALIFIES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributes} = AttributeReferenceSimpleList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributes};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'QUALIFIES'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
	}
}

# -------------------------------------
package AttributeReferenceCommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package OperationsMapping;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^OPERATIONS\s*-?\s*MAPPING//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{operationmaps} = RelationshipOperationsMapList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operationmaps};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'OPERATIONS MAPPING'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{operationmaps}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RelationshipOperationsMapList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package RelationshipOperationsMap;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{operation} = RelationshipOperation->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operation};
		last TEST unless (($self->{mapsto} = MapsTo->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{mapsto};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->call('gdmo',@_);
	}
}

# -------------------------------------
package RelationshipOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{operation} = EstablishOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = TerminateOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = BindOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = UnbindOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = QueryOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = NotifyOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = UserDefinedOperation->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{operation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package EstablishOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ESTABLISH//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ESTABLISH'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TerminateOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^TERMINATE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'TERMINATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BindOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIND//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		if (($self->{role} = RoleName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{role};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'BIND'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
		if (($s = $self->{role})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UnbindOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^UNBIND//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		if (($self->{role} = RoleName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{role};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'UNBIND'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
		if (($s = $self->{role})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QueryOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^QUERY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		if (($self->{role} = RoleName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{role};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'QUERY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
		if (($s = $self->{role})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotifyOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{notification} = NotificationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'NOTIFY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		if (($s = $self->{notification})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UserDefinedOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USER\s*-?\s*DEFINED//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'USER DEFINED'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OperationName;
use strict;
use vars qw(@ISA);
@ISA = qw(Identifier);
# -------------------------------------
# The operation-name and notification-name shall be used, where necessary, to:
#
# - provide a link to an optional specificaiton, in behaviour templates referenced  by the BEHAVIOUR
#   construct, of behaviour additional to the  referenced prototypical operation;
#
# - disambiguate relationship management operations or notifications that are based on the same
#   prototypical operation or notification respectively;
#
# - provide a link to the related systems management operations and notifications specified in the
#   relationship mapping template.

# -------------------------------------
package RoleName;
use strict;
use vars qw(@ISA);
@ISA = qw(Identifier);
# -------------------------------------

# -------------------------------------
package NotificationName;
use strict;
use vars qw(@ISA);
@ISA = qw(Identifier);
# -------------------------------------

# -------------------------------------
package MapsTo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MAPS\s*-?\s*TO\s*-?\s*OPERATION\s*-?\s*//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{operations} = SystemManagementOperationRoleList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operations};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'MAPS-TO-OPERATION'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{operations}->gdmo();
	}
}

# -------------------------------------
package SystemManagementOperationRoleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleListIndented);
# -------------------------------------

# -------------------------------------
package SystemManagementOperationRole;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{operation} = SystemManagementOperation->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operation};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{roleorobj} = RoleOrRelationshipObject->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{roleorobj};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{operation}->gdmo();
		if (!$::first) { printf ' '; }
		printf "OF"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{roleorobj}->gdmo();
	}
}

# -------------------------------------
package SystemManagementOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{operation} = GetOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = ReplaceOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = AddOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = RemoveOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = CreateOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = DeleteOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = ActionOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = NotificationOperation->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{operation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package GetOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GET//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GET'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ReplaceOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REPLACE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'REPLACE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AddOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ADD//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ADD'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RemoveOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REMOVE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'REMOVE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CreateOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CREATE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{class} = ClassReference->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{class};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'CREATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		if (($s = $self->{class})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DeleteOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DELETE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'DELETE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTION//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{action} = ActionReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{action};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'CREATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{action}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotificationOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATION//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{notification} = NotificationReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notification};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'NOTIFICATION'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{notification}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleOrRelationshipObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			$line=~s/^RELATIONSHIP\s*-?\s*OBJECT//s ||
			($self->{rolename} = RoleName->parse($line,@_[1,-1]))
		);
		if ($self->{rolename}) {
			push @{$self->{children}}, $self->{rolename};
		} else {
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{rolename})) {
			$s->gdmo();
		} else {
			if (!$::first) { printf ' '; }
			printf 'RELATIONSHIP OBJECT'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
	}
}

# -------------------------------------
package DocumentIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $gdmo = $_[-1];
	TEST: {
		last TEST unless ($line=~s/^(?:"([^"]*)")//s);
		$self->{documentid} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		#print STDERR "Assigning document id \"$self->{documentid}\" to ".ref($gdmo)." from DocumentIdentifier";
		$gdmo->{documentid} = $self->{documentid};
		$gdmo->{aliases}->{$self->{documentid}}++;
		$::root->{gdmos}->{$self->{documentid}}->{defn} = $gdmo;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	# last TEST if ($::root->{gdmos}->{$self->{documentid}}->{defn});
	#print STDERR "Assigning document id to ".ref($gdmo);
	#$gdmo->{documentid} = $self->{documentid};
	#$gdmo->{aliases}->{$self->{documentid}}++;
	#$::root->{gdmos}->{$self->{documentid}}->{defn} = $gdmo;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "\"$self->{documentid}\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DocumentReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $gdmo = $_[1];
	TEST: {
		last TEST unless ($line=~s/^(?:"([^"]*)")//s);
		$self->{documentid} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		push @{$gdmo->{docrefs}->{$self->{documentid}}->{refs}}, $self;
		push @{$::root->{gdmos}->{$self->{documentid}}->{refs}}, $self;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	#push @{$gdmo->{docrefs}->{$self->{documentid}}->{refs}}, $self;
	#push @{$::root->{gdmos}->{$self->{documentid}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "\"$self->{documentid}\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Label;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		# ok, you can have a period or slash in a label
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-)//s);
		$self->{label} = $&;
		$self->{name} = $self->xform('',$self->{label},'');
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf "$self->{label}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


# ----------------------------------------
package Reference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{documentid} = DocumentReference->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentid};
			last TEST unless ($line=~s/^://s);
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless (($self->{label} = Label->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{label};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (($s = $self->{documentid})) {
			$s->gdmo();
			printf ':'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		if (($s = $self->{label})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package GdmoObjectReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub readreference {
	my $self = shift;
	my $tmpl = shift;
	my $line = $_[0];
	my $gdmo = $_[1];
	TEST: {
		if (($self->{reference} = $tmpl->parse($line,@_[1,-1]))) {
			$self->{label} = $self->{reference}->{label};
			$self->{name} = $self->{reference}->{name};
			$self->{scope} = $self->{reference}->{scope};
			$self->{scopedname} = $self->{reference}->{scopedname};
		} elsif (($self->{reference} = Reference->parse($line,@_[1,-1]))) {
			if ($self->{reference}->{documentid}) {
				$self->{documentid} = $self->{reference}->{documentid}->{documentid};
			}
			if ($self->{reference}->{label}) {
				$self->{label} = $self->{reference}->{label}->{label};
				$self->{name} = $self->{reference}->{label}->{name};
				$self->{scope} = '';
				$self->{scopedname} = $self->{name};
			}
		} else {
			last TEST;
		}
		push @{$self->{children}}, $self->{reference};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $tmpl = ref $self;
	$tmpl=~s/Reference/Template/;
	return $self->readreference($tmpl,@_);
}

sub xreftyped {
	my $self = shift;
	my $type = shift;
	my $gdmo = $_[0];
	my ($l,$d);

	$l = $self->{label};
	push @{$gdmo->{$type}->{$l}->{refs}}, $self;
	push @{$::root->{$type}->{$l}->{refs}}, $self;
	if ($d = $self->{documentid}) {
		push @{$gdmo->{$type}->{$l}->{docs}->{$d}->{refs}}, $self;
		push @{$::root->{$type}->{$l}->{docs}->{$d}->{refs}}, $self;
	}
	if ($d = $::root->{$type}->{$l}->{defn}) {
		$self->{scope} = $d->{scope};
		$self->{scopedname} = $d->{scopedname};
	}
	$self->call('xref',@_);
}

sub xref {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Reference//;
	$type=lc $type;
	$type.='s';
	$type=~s/classs/objects/;
	$type=~s/namebindings/bindings/;
	$type=~s/attributegroups/groups/;
	$type=~s/subordinationrules/subordinates/;
	$type=~s/constraintrules/constraints/;
	$type=~s/relationshipclass/relations/;
	$type=~s/relationshipmapping/mapping/;
	return $self->xreftyped($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{reference}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package PackageReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package ParameterReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package NameBindingReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package AttributeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package AttributeGroupReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package BehaviourReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package ActionReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package NotificationReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package SubordinationRuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package ConstraintRuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package RelationshipClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# ----------------------------------------
package RelationshipMappingReference;
use strict;
use vars qw(@ISA);
@ISA = qw(GdmoObjectReference);
# ----------------------------------------

# -------------------------------------
package DerivedFromClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{classes} = ClassReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	my $gdmo = $_[-2];
	my ($i,$d);
	foreach $i (@{$self->{classes}->{items}}) {
		if (defined $::root->{objects}->{$i->{label}}) {
			if ($d = $::root->{objects}->{$i->{label}}->{defn}) {
				my ($t);
				if (defined $tmpl->{backtrace}) {
					print STDERR "E: multiple markings of $tmpl->{label}";
					print STDERR "E: backtrace is:";
					my $b; foreach $b (@::backtrack) {
						print STDERR "E: B: ".ref($b);
					}
					print STDERR "E: original backtrace was:";
					my $b; foreach $b (@{$tmpl->{backtrace}}) {
						print STDERR "E: B: ".ref($b);
					}
					#die "multiple markings";
				} else {
					my $b; foreach $b (@::backtrace) {
						push @{$tmpl->{backtrace}}, $b;
					}
					my ($t,$e); foreach $t (@{$d->{derivations}}) {
						if ($t->{label} eq $tmpl->{label}) {
							print STDERR "E: multiple markings with same label $t->{label}";
							print STDERR "E: template 1 is ".ref($t).".$t->{id}";
							print STDERR "E: template 2 is ".ref($tmpl).".$t->{id}";
							$e++;
						}
					}
					unless ($e) {
						#print "--@@ $tmpl->{label} is derived from $d->{label}.";
						push @{$d->{derivations}}, $tmpl;
					}
				}
			}
		}
	}
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	my ($i,$e);
	printf ' : public ';
	foreach $i (@{$self->{classes}->{items}}) {
		if ($e) { printf ', '; } else { $e++; }
		printf "$i->{name}";
	}
	printf ' {';
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	return $self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "DERIVED FROM"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{classes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ClassReferenceCommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Characterization;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHARACTERIZED(?:\s|\n)*((-)?)(?:\s|\n)*BY//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{packages} = PackageReferenceList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{packages};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	$self->call('xref',@_);
	my $p; foreach $p (@{$self->{packages}->{items}}) {
		#print STDERR "Pushing $p->{name} on ".ref($tmpl)." constructor references";
		push @{$tmpl->{constructorrefs}}, $p;
	}
}

sub head {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	print "\n\n$::indent"."// CHARACTERIZED BY: (mandatory packages)";
	$self->call('head',@_);
	my $p; foreach $p (@{$self->{packages}->{items}}) {
		printf "\n$::indent"."$p->{name} $p->{name};";
	}
	print '';
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "CHARACTERIZED BY"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{packages}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PackageReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ConditionalPackages;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CONDITIONAL(?:\s|\n)*((-)?)(?:\s|\n)*PACKAGES//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{conditions} = PackageConditionList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{conditions};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// CONDITIONAL PACKAGES::\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "CONDITIONAL PACKAGES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{conditions}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PackageConditionList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package PackageCondition;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{package} = PackageReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{package};
		last TEST unless (
			($self->{condition} = PresentIf->parse($line,@_[1,-1])) ||
			($self->{condition} = PresentOnlyIf->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{condition};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	#print STDERR "Pushing $self->{package}->{name} on ".ref($tmpl)." constructor pointers";
	push @{$tmpl->{constructorptrs}}, $self->{package};
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	#printf "\n$::indent// $self->{package}->{scopedname} is a ".ref($self->{package}->{reference}).".";
	if (ref($self->{package}->{reference})=~/PackageTemplate/) {
		if (!defined $::root->{packages}->{$self->{package}->{label}}->{intf}) {
			#$::root->{packages}->{$self->{package}->{label}}->{intf} = $self->{package}->{reference};
			#printf "\n$::indent// calling head";
			$self->{package}->{reference}->head(@_);
		}
	}
	$self->{condition}->generate('head',@_,$self->{package});
	printf "\n$::indent"."$self->{package}->{scopedname} *$self->{package}->{name};";
	printf "\n$::indent";
}

sub stub {
	my $self = shift;
	$self->{package}->generate('stub',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{package}->gdmo();
		$::indent.="\t";
		$self->{condition}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package PresentIf;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PRESENT(?:\s|\n)*((-)?)(?:\s|\n)*IF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,',;',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// PRESENT-IF:\n$::indent// "; $::first = 1;
	# dig right down to the string inside the delimited string object
	my ($s, $col, $spc, $len, $line, $d, $e);
	$line = $self->{delimited}->{string};
	$d = $self->{delimited}->{delimiter};
	$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
	$line=~s/$d$d/$d/gs;
	$col = 0;
	my @paras = ( split(/\n\n/s,$line) );
	my $p; foreach $p (@paras) {
		if ($e) {
			if (!$::first) { printf "\n\n$::indent// "; $col = 0; $::first = 1; }
		} else { $e++; }
		my @lines = ( split(/\n/s,$p) );
		my $l; foreach $l (@lines) {
			$l=~s/^\t+//s;
			if ($l=~/^[^ ]/) {
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if ($col == 0) { $spc = 0; } else { $spc = 1; }
					$len = length($w);
					if ($len) {
						if ($col + $spc + $len < $::colwidth) {
							if ($spc) { printf ' '; }
							$col += $spc + $len;
						} else {
							printf "\n$::indent// ";
							$col = $len;
						}
						printf "$w";
					}
				}
			} else {
				if (!$::first) { printf "\n$::indent// "; $::first = 1; }
				printf "$l"; $::first = 0;
				if (!$::first) { printf "\n$::indent// "; $::first = 1; }
			}
		}
	}

	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "PRESENT IF"; $::first = 0;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{delimited})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package PresentOnlyIf;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PRESENT(?:\s|\n)*((-)?)(?:\s|\n)*ONLY(?:\s|\n)*((-)?)(?:\s|\n)*IF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,',;',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// PRESENT-ONLY-IF:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "PRESENT ONLY IF"; $::first = 0;
		my $s;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{delimited})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package DelimitedString;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $term = $_[1];
	TEST: {
		my $pattern;
		if ($line=~s/^[!"#\$%^&\*'`~\?@\\]//s) {
			my $d = $&;
			$self->{delimiter} = $d;
			$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
			$pattern="((?:[^".$d."]|[".$d."](?=[".$d."]))*)[".$d."]";
		} else {
			$pattern="([^".$term."]*)";
		}
		last TEST unless ($line=~s/^$pattern//s);
		$self->{string} = $1;
		$self->{comments} = Comments->parse($line,@_[2,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub stub {
	my $self = shift;
	my ($s, $col, $spc, $len, $line, $d, $e);
	$line = $self->{string};
	$d = $self->{delimiter};
	$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
	$line=~s/$d$d/$d/gs;
	$line=~s/"/\"/gs;
	$col = 0;
	my @paras = ( split(/\n\n/s,$line) );
	my $p; foreach $p (@paras) {
		if ($e) {
			if (!$::first) { printf "\\n\\\n\\n\\\n"; $col = 0; $::first = 1; }
		} else { $e++; }
		my @lines = ( split(/\n/s,$p) );
		my $l; foreach $l (@lines) {
			$l=~s/^\t+//s;
			if ($l=~/^[^ ]/) {
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if ($col == 0) { $spc = 0; } else { $spc = 1; }
					$len = length($w);
					if ($len) {
						if ($col + $spc + $len < $::colwidth) {
							if ($spc) { printf ' '; }
							$col += $spc + $len;
						} else {
							printf "\\n\\\n";
							$col = $len;
						}
						printf "$w";
					}
				}
			} else {
				if (!$::first) { printf "\\n\\\n"; $::first = 1; }
				printf "$l"; $::first = 0;
				if (!$::first) { printf "\\n\\\n"; $::first = 1; }
			}
		}
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$col,$e,$tws,$lws,$sep);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{delimiter}";
		$col = 0;
		# any line with trailing whitespace is a continutation line
		if ($self->{string}=~s/[ \t]+\n[ \t]*/ /sg) {
			$tws = 1;
		}
		# anything separated by a double line break is a paragraph
		my @paras = ( split(/\n\n/s,$self->{string}) );
		if ($tws || scalar @paras <= 1) {
			# this treats lines as paragraphs but doesn't doublespace them unless they
			# were already double spaced
			if (scalar @paras > 1) { $sep = "\n"; } else { $sep = ''; }
			# if there was trailing whitespace, all single line breaks are paragraphs
			@paras = ( split(/\n/s,join("\n",@paras)) );
		} else {
			# if there are lines in pagarages separated by double linefeeeds, separate
			# them again by double linefeeds
			$sep = "\n";
		}
		my $p; foreach $p (@paras) {
			if ($e) { printf "$sep\n$::indent"; $col = 0; $::first = 1; } else { $e++; }
			my @lines = ( split(/\n/s,$p) );
			my $l; foreach $l (@lines) {
				$l=~s/^\t+//s;
				$l=~s/\s+$//s;
				$l=~s/\t/ /sg;
				$l=~s/^(\s+|\s*(?:-|\xB7)\s+|\s*[\(\[\{]?[a-zA-Z1-9][ivxIVX0-9]*[\.:]??[\.:\)\]\}]\s*)//;
				$lws = $1;
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if (!$::first) {
						printf ' ';  $col++;
						if ($col + length($w) > $::colwidth) {
							printf "\n$::indent"; $::first = 1;
						}
					}
					if ($::first) {
						printf "$lws"; $col = length($lws); $::first = 0; $lws=~s/[^ ]/ /sg;
					}
					printf "$w"; $::first = 0; $col += length($w);
				}
			}
		}
		printf "$self->{delimiter}";
		#for now: flow it later
		#printf "$self->{delimiter}$self->{string}$self->{delimiter}";
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 0;
	}
}

# -------------------------------------
package Attributes;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTES//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributes} = AttributePropertyList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributes};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// ATTRIBUTES:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "ATTRIBUTES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributePropertyList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package AttributeProperty;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1],$self)));
		if (($self->{properties} = PropertyList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{properties};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (ref($self->{attribute}->{reference}) eq "AttributeTemplate") {
		$self->call('head',@_);
	} else {
		my $x;
		printf "\n$::indent"."$self->{attribute}->{scopedname} $self->{attribute}->{name};";
		if (($x = $self->{properties})) { $x->generate('head',@_,$self); }
		if (($x = $self->{parameters})) { $x->generate('head',@_,$self); }
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{attribute})) { $s->gdmo(); }
		{
			$::indent.="\t";
			if (($s = $self->{properties})) { $s->gdmo(); }
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
	}
}

# -------------------------------------
package PropertyList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Property;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{property} = ReplaceWithDefault->parse($line,@_[1,-1])) ||
			($self->{property} = DefaultValue->parse($line,@_[1,-1])) ||
			($self->{property} = InitialValue->parse($line,@_[1,-1])) ||
			($self->{property} = PermittedValues->parse($line,@_[1,-1])) ||
			($self->{property} = RequiredValues->parse($line,@_[1,-1])) ||
			($self->{property} = GetReplace->parse($line,@_[1,-1])) ||
			($self->{property} = Get->parse($line,@_[1,-1])) ||
			($self->{property} = Replace->parse($line,@_[1,-1])) ||
			($self->{property} = AddRemove->parse($line,@_[1,-1])) ||
			($self->{property} = Add->parse($line,@_[1,-1])) ||
			($self->{property} = Remove->parse($line,@_[1,-1])) ||
			($self->{property} = SetByCreate->parse($line,@_[1,-1])) ||
			($self->{property} = NoModify->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{property};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{property}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ReplaceWithDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REPLACE-WITH-DEFAULT',@_);
}

sub head {
	my $self = shift;
	my $tmpl = $_[-2];
	my $prop = $_[-1];
	printf "\n$::indent"."static bool ReplaceWithDefault = true;";
}

sub stub {
	my $self = shift;
	my $tmpl = $_[-2];
	my $prop = $_[-1];
	my $name = $tmpl->{scopedname};
	printf "\n$::indent"."bool $name"."::ReplaceWithDefault = true;";
}

# -------------------------------------
package DefaultValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DEFAULT(?:\s|\n)*((-)?)(?:\s|\n)*VALUE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = ValueSpecifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Default;";
	printf "\n$::indent"."$name"."SetDefault();";
	$self->{value}->generate('head',@_);
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr"."SetDefault()";
	printf "\n$::indent"."{";
	printf "\n$::indent"."}";
	$self->{value}->generate('stub',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DEFAULT VALUE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{value})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package InitialValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^INITIAL(?:\s|\n)*((-)?)(?:\s|\n)*VALUE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = ValueSpecifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Initial;";
	$self->{value}->generate('head',@_);
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."const $attr& $attr"."Initial = 0;";
	$self->{value}->generate('stub',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'INITIAL VALUE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package PermittedValues;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED(?:\s|\n)*((-)?)(?:\s|\n)*VALUES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typereference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Permitted;";
	$self->{typereference}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED VALUES'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{typereference}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package RequiredValues;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REQUIRED(?:\s|\n)*((-)?)(?:\s|\n)*VALUES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typereference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Required;";
	$self->{typereference}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REQUIRED VALUES'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{typereference}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package GetReplace;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: Inclusing of the GET-REPLACE peroperty is the notation for specifying that both
# the GET property and the REPLACE property are included.

sub read {
	my $self = shift;
	return $self->readtoken('GET-REPLACE',@_);
}

sub xref {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	#print STDERR "Pushing $prop->{attribute}->{name} on ".ref($tmpl)." constructor pointers";
	push @{$tmpl->{constructorptrs}}, $prop->{attribute};
	return $self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $name"."Get();";
	printf "\n$::indent"."$name"."Set($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $scop"."::$name"."Get() {";
	printf "\n$::indent"."\treturn $name;";
	printf "\n$::indent"."}";
	printf "\n$::indent"."$scop"."::$name"."Set($attr& val) {";
	printf "\n$::indent"."\t$name = val;";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Get;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The GET property is included if the value of the attributes may be retrieved
# with the Get attribute value operation.

sub read {
	my $self = shift;
	return $self->readtoken('GET',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $name"."Get();";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $scop"."::$name"."Get() {";
	printf "\n$::indent"."\treturn $name;";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Replace;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The REPLACE property is included if the attribute may be set with the Replace
# attribute value operation andw ith the Create operation.  Setting with the Create operation applies
# only if the Create operation is supported by the name binding of the managed object instance.

sub read {
	my $self = shift;
	return $self->readtoken('REPLACE',@_);
}

sub xref {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	#print STDERR "Pushing $prop->{attribute}->{name} on ".ref($tmpl)." constructor pointers";
	push @{$tmpl->{constructorptrs}}, $prop->{attribute};
	return $self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Set($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Set($attr& val) {";
	printf "\n$::indent"."\t$name = val;";
	printf "\n$::indent"."}";
}

# -------------------------------------
package AddRemove;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: Inclusinon of the ADD-REMOVE property is the notation for specifying that both
# the ADD property and the REMOVE property are included.

sub read {
	my $self = shift;
	return $self->readtoken('ADD-REMOVE',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Add($attr& val);";
	printf "\n$::indent"."$name"."Remove($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Add($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
	printf "\n$::indent"."$scop"."::$name"."Remove($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Add;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The ADD property is included if the attribut may be set with the Add member
# operation.

sub read {
	my $self = shift;
	return $self->readtoken('ADD',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Add($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Add($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Remove;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The REMOVE property is included if the attribute may bse sset with the Remove
# member operation.

sub read {
	my $self = shift;
	return $self->readtoken('REMOVE',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Remove($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Remove($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
}

# -------------------------------------
package SetByCreate;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The SET-BY-CREATE property is included if the attribute may be set by means of
# the Create operation.  This property is only meaningful if the Create operation is supported by the
# name binding of the managed object instance.  Since the REPLACE poperty is included if the attribute
# may be set by means of the Replace operation or the Create operation, the SET-BY-CREATE property
# does not have to be included if the REPLACE property is present.  Similarly, teh SET-BY-CREATE
# property does nto have to be included if the ADD, REMOVE, or ADD-REMOVE property is present.  Even
# if SET-BY-CREATE is absent, the attempt to set a value with the Create operation may succeeed.

sub read {
	my $self = shift;
	return $self->readtoken('SET-BY-CREATE',@_);
}

sub xref {
	my $self = shift;
	my $prop = $_[-1]; # AttributeProperty
	my $tmpl = $_[-2]; # PackageTemplate
	#print STDERR "Pushing $prop->{attribute}->{name} on ".ref($tmpl)." constructor references";
	push @{$tmpl->{constructorrefs}}, $prop->{attribute};
	return $self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1]; # AttributeProperty
	my $tmpl = $_[-2]; # PackageTemplate
	printf "\n$::indent"."// SET-BY-CREATE: $prop->{attribute}->{scopedname}";
}

# -------------------------------------
package NoModify;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 2: The absence of the REPLACE property may be used to specify that an attribute
# cannot be replaced for instances of a class but this absence does not preclude subclasses adding the
# REPLACE property.  The NO-MODIFY property is present to explicitly specify that an attribute cannot
# be modified (is read-only) in the class having this property and in all subclassess and in all
# compatible managed objects (i.e. managed objects behaving allomorphically to the class).  This
# property is inconsistent with and shall not be present in a managed object class definition hta thas
# any of the REPLACE, GET-REPLACE, ADD, REMOVE, or ADD-REMOVE properties of the same attribute.
#
#   NOTE 3 -- The NO-MODIFY property is not necessarily inconsistent wih the REPLACE-WITH-DEFAULT
#   property because this operation is often used with the meanning of "reset" that can be consistent
#   with a manager's inability to control the attribute's value.
#
#   NOTE 4 -- Before the NOT-MODIFY property was added to GDMO, the convention was to specify that
#   property in BEHAVIOUR templates or in documents referenced in BEHAVIOUR templates.
#
# If it is desired that part of the definition of an attriabute is that the attribute shall not be
# replaced in any class that specifies the attribute, then this constraint sha be specified in a
# BEHAVIOUR repmplate referenced by the ATTRIBUTE template.

sub read {
	my $self = shift;
	return $self->readtoken('NO-MODIFY',@_);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// FIXME: override default $_[-1]->{attribute}->{scopedname} ops with errors";
	#fixme provide error overrides for default operations
	#printf "\n$::indent"."static bool NoModify = true;";
}

# -------------------------------------
package ValueSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = DerivationRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{value}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DerivationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# Some ITU standareds use DERIVED RULES instead of DERIVATION RULE... go figure.
# It will be corrrected on output.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			$line=~s/^DERIVATION(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s ||
			$line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s\|\n)*RULES//s
		);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($self->{behaviour} = BehaviourReference->parse($line,@_[1,-1]));
		push @{$self->{children}}, $self->{behaviour};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		my $s;
		printf 'DERIVATION RULE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{behaviour}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package ModuleIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{reference} = $&;
		last TEST if ($::keywords{$self->{reference}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# ModuleIdentifier's occur only in the definition of an ASN module.  We keep track of which module
# identifiers are defined in all documents, the definiting GDMO document and the definining ASN
# module.

sub xref {
	my $self = shift;
	my $asn1 = $_[1]; # ASN1 module

	$asn1->{moduleid} = $self->{reference};
	$::root->{asnmodules}->{$self->{reference}}->{defn} = $asn1;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf "$self->{reference}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ModuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{reference} = $&;
		last TEST if ($::keywords{$self->{reference}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# ModuleRference's occur on SymbolsFromModule (after FROM in ASN module IMPORTS statment), a global
# module reference of the form ModuleName and ObjectIdentifier (also after FROM in ASN module
# IMPORTS statement) an ExternalTypeReference or ExternalValueReference which can occur just about
# anywhere, including GDMO templates, which are proliferated with ExternalTypeRerferences and have a
# few ExternalValueReferences for Initial and Default values for attributes.
#
# When this function is called, we might or might not be within an ASN module (we might only be
# within a gdmo).  We must keep track of all external module references for the root, each gdmo
# document and each ASN1 module.

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{asnmodules}->{$self->{reference}}->{refs}}, $self; }
	push @{$gdmo->{asnmodules}->{$self->{reference}}->{refs}}, $self;
	push @{$::root->{asnmodules}->{$self->{reference}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{reference}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{vrefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{vrefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{vrefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{orefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{orefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{orefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectFieldReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\&[a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{orefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{orefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{orefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueFieldReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\&[a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{fvrefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{fvrefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{fvrefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TypeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{trefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{trefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{trefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{crefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{crefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{crefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectSetReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{srefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{srefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{srefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectSetFieldReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{srefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{srefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{srefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TypeFieldReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\&[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{ftrefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{ftrefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{ftrefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueSetFieldReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\&[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		last TEST if ($::keywords{$self->{name}});
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{fsrefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{fsrefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{fsrefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroups;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUPS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{groups} = AttributeGroupAttributesList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{groups};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE GROUPS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{groups}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroupAttributesList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package AttributeGroupAttributes;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{group} = AttributeGroupReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{groups};
		if (($self->{attributes} = AttributeReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{attributes};
		}
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// ATTRIBUTE GROUPS:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{group}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{attributes})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('AttributeReference',@_); }

# -------------------------------------
package Actions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTIONS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{actions} = ActionParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{actions};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// ACTIONS:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACTIONS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{actions}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ActionParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{action} = ActionReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{action};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (ref($self->{action}->{reference})=~/ActionTemplate/) {
		$self->call('head',@_);
	} else {
		printf "\n$::indent"."$self->{action}->{name}"."();";
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{action}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package ParameterReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('ParameterReference',@_); }

# -------------------------------------
package Notifications;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATIONS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{notifications} = NotificationParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notifications};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// NOTIFICATIONS:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NOTIFICATIONS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{notifications}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotificationParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NotificationParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{notification} = NotificationReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notification};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (ref($self->{notification}) eq "NotificationTemplate") {
		$self->call('head',@_);
	} else {
		my $x;
		printf "\n$::indent"."$self->{notification}->{scopedname} $self->{notification}->{name};";
		if (($x = $self->{parameters})) { $x->generate('head',@_,$self); }
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{notification}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RegisteredAs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless
		($line=~s/^REGISTERED(?:\s|\n)*((-)?)(?:\s|\n)*AS//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{objectid} = ObjectIdentifierValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objectid};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REGISTERED AS'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{objectid}->gdmo();
	}
}

# -------------------------------------
package WithSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Package;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PACKAGE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{package} = PackageReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{package};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PACKAGE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{package}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Parameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PARAMETER//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{parameter} = ParameterReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{parameter};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PARAMETER'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{parameter}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NameBinding;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAME(?:\s|\n)*((-)?)(?:\s|\n)*BINDING//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{namebinding} = NameBindingReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{namebinding};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAME BINDING'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{namebinding}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Attribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUP//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributegroup} = AttributeGroupReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributegroup};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE GROUP'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attributegroup}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Behaviour;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BEHAVIOUR//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{behaviour} = BehaviourReferenceList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{behaviour};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'BEHAVIOUR'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{behaviour}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BehaviourReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Action;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTION//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{action} = ActionReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{action};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACTION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{action}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Notification;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATION//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{notification} = NotificationReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notification};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NOTIFICATION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{notification}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SubordinateObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This defines a manged object class whose instances may be named by instances of the object class
# defined by the NAME BY SUPERIOR OBJECT CLASS constuct.  The name of an instance of this subordinate
# object class is constructed by concatentating the distinguished name of it's superior object with
# the relative disinguished name of the specified managed object class.  IF AND SUBCLASSES is
# specified, the name binding also applies to all subclasses of the specified managed object class.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUBORDINATE(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SUBORDINATE OBJECT CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedBySuperior;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This defines a managed object class or other object class, such as a Directory object class, whose
# instances may name instances of the managed object class defined by the SUBORDINATE OBJECT CLASS
# construct.  If AND SUBCLASSES is specified, the name binding also applies to all subclasses of the
# specified object class.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMED(?:\s|\n)*((-)?)(?:\s|\n)*BY//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^SUPERIOR(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments3} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAMED BY'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (!$::first) { printf ' '; }
		printf 'SUPERIOR OBJECT CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments2})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AndSubclasses;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('AND SUBCLASSES',@_);
}

# -------------------------------------
package WithAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This defines the attribute that shall be used, in the context of this name binding, to construct the
# relative distinguisehed name for instances of the managed object class defined by the SUBORDINATE
# OBJECT CLASS construct.  Values of this attribute shall be repsrented by single-valued data types
# complying with the restrictions specified in CCITT Rec. X.720 | ISO/IEC 10165-1; if no suitable
# attribute is available for use as a naming attribute, managed object designers are encouraged to
# provide a naming attribute of type GraphicString.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Create;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# Present if it is permitted to create new instances of the managed object class referenced by the
# SUBORDINATE OBJECT CLASS construct in the context of this name binding, by means of system
# management operation.  The create--modifier values specify the options available on creation.
#
# The behaviour definitions shall specify what course of action is taken when there is a choice of
# Name Bindings that may be applied to the new managed object.
#
# The sources of initial attribute values used at managed object creation time, and their associated
# precedence rules, are defined in CCITT Rec. X.720 | ISO/IEC 10165-1.
#
# If present, the parameter-labels identify the name binding specific error parameters associated with
# the Create operation.  These are reported as processing failures.  The syntax of the error
# parameters are defined in the referenced templates.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^CREATE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{modifiers} = CreateModifierList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{modifiers};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		last TEST unless ($line=~s/^;//s); 
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CREATE'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{modifiers})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CreateModifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package CreateModifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{modifier} = WithReferenceObject->parse($line,@_[1,-1])) ||
			($self->{modifier} = WithAutomaticInstanceNaming->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{modifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithReferenceObject;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If present, a reference managed object may be specified on creation as a source of default values
# and to specify choice of conditional packages.

sub read {
	my $self = shift;
	return $self->readtoken('WITH-REFERENCE-OBJECT',@_);
}

# -------------------------------------
package WithAutomaticInstanceNaming;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If present, the Create request may omit to specify the instance name of the new managed object.

sub read {
	my $self = shift;
	return $self->readtoken('WITH-AUTOMATIC-INSTANCE-NAMING',@_);
}

# -------------------------------------
package Delete;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# Prsent if it is permitted to delete instances of the managed object class referenced by the
# SUBORDINATE OBJECT CLASS construct in the context of this name binding.  The delete-modifier, if
# present, indicates the behaviour of a managed object of that class if the managed object is deleted.
#
# Other rules which describe the behaviour with respect to delettion of contained manged objects may
# be specified in the BEHAVIOUR construct.
#
#   NOTE 2 -- Givent that the DELETES-CONTAINED-OBJECTS modifier permits the deletion of a manged
#   object regardless of whether it contains other managed objects, it is advisable to user the
#   ONLY-IF-NO-CONTAINED-OBJECTS modifier if there is any doubt as to which modifier is appropriate.
#
# If there are constraints on deletion relative to other relationships or conditions that are generic
# to the managed object class, these shall be specified as part of the behaviour of the managed object
# class.
#
# If present, the paraemter-labels identifier name binding specified error parameters associated with
# the Delete operation.  These are reported as processing failures.  The syntax of the error
# parameters are defined in the referenced templates.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^DELETE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{modifiers} = DeleteModifierList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{modifiers};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		last TEST unless ($line=~s/^;//s); 
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{policy} = 'deleteOnlyIfNoContained';
	$self->call('xref',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DELETE'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{modifiers})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DeleteModifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package DeleteModifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{modifier} = OnlyIfNoContainedObjects->parse($line,@_[1,-1])) ||
			($self->{modifier} = DeletesContainedObjects->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{modifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OnlyIfNoContainedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If specified, any contained managed objects shall be explicitly deleted by management operations
# prior to deletion of the containing managed object, i.e, a Delete request will cause an error if
# there are contained managed objects.

sub read {
	my $self = shift;
	return $self->readtoken('ONLY-IF-NO-CONTAINED-OBJECTS',@_);
}

sub xref {
	my $self = shift;
	my $dele = $_[-1];
	$dele->{policy} = 'deleteOnlyIfNoContained';
}

# -------------------------------------
package DeletesContainedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If a Delete request is applied to a managed object for which the DELETES-CONTAINED-OBJECTS modifier
# is specified, the Delete request will faile if any directly or indirectly contained managed object
# has the ONLY-IF-NO-CONTAINED-OBJECTS modifier specified and also has a contained manged object;
# otherwise, a successful Delete request will aso have the effect of deleting contained managed
# objects.

sub read {
	my $self = shift;
	return $self->readtoken('DELETES-CONTAINED-OBJECTS',@_);
}

sub xref {
	my $self = shift;
	my $dele = $_[-1];
	$dele->{policy} = 'deletesContainedObjects';
}

# -------------------------------------
package DerivedFromAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf " : public $self->{attribute}->{name} {";
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	$self->{attribute}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DERIVED FROM'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithAttributeSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf ' : public Attribute {';
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	# could actually let the syntax fill out the parent class
	$self->{syntax}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH ATTRIBUTE SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MatchesFor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MATCHES(?:\s|\n)*((-)?)(?:\s|\n)*FOR//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{matches} = MatchQualifierList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{matches};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'MATCHES FOR'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{matches}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MatchQualifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package MatchQualifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{qualifier} = Equality->parse($line,@_[1,-1])) ||
			($self->{qualifier} = Ordering->parse($line,@_[1,-1])) ||
			($self->{qualifier} = Substrings->parse($line,@_[1,-1])) ||
			($self->{qualifier} = SetComparison->parse($line,@_[1,-1])) ||
			($self->{qualifier} = SetIntersection->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{qualifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		#if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{qualifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Equality;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EQUALITY',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{equality} = $self;
}

# -------------------------------------
package Ordering;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ORDERING',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{ordering} = $self;
}

# -------------------------------------
package Substrings;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SUBSTRINGS',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{substrings} = $self;
}

# -------------------------------------
package SetComparison;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-COMPARISON',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{setcomparison} = $self;
}

# -------------------------------------
package SetIntersection;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-INTERSECTION',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{setintersection} = $self;
}

# -------------------------------------
package Parameters;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PARAMETERS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{parameters} = ParameterReferenceList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{parameters};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// PARAMETERS:\n$::indent";
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PARAMETERS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{parameters}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ParameterReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package GroupElements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GROUP(?:\s|\n)*((-)?)(?:\s|\n)*ELEMENTS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{elements} = AttributeReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{elements};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'GROUP ELEMENTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{elements}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Fixed;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^FIXED//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'FIXED'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Description;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DESCRIPTION//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,';',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $name = $_[-1]->{name};
	printf "\n$::indent"."static const char description"."[];";
	$self->call('head',@_);
}

sub stub {
	my $self = shift;
	my $tmpl = $_[-1];
	my $name = $tmpl->{scopedname};
	printf "\n$::indent"."const char $name"."::description[] = \"\\\n";
	$self->call('stub',@_);
	printf "\";";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DESCRIPTION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{delimited}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DefinedAs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DEFINED(?:\s|\n)*((-)?)(?:\s|\n)*AS//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,';',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $tmpl = $_[-1];
	printf "\n$::indent"."static const char definedas[];";
	$self->call('head',@_);
}

sub stub {
	my $self = shift;
	my $tmpl = $_[-1];
	my $name = $tmpl->{scopedname};
	printf "\n$::indent"."const char $name"."::definedas[] = \"\\\n";
	$self->call('stub',@_);
	printf "\";";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DEFINED AS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{delimited}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package Mode;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MODE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{mode} = Confirmed->parse($line,@_[1,-1])) ||
			($self->{mode} = Unconfirmed->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{mode};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'MODE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{mode}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Confirmed;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('CONFIRMED',@_);
}

# -------------------------------------
package Unconfirmed;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('UNCONFIRMED',@_);
}

# -------------------------------------
package WithInformationSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*INFORMATION(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH INFORMATION SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithReplySyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*REPLY(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH REPLY SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithInformationSyntaxAndAttributeIds;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*INFORMATION(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		if (($self->{attributeids} = AndAttributeIds->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{attributeids};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH INFORMATION SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			if (($s = $self->{attributeids})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AndAttributeIds;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^AND(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*IDS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ids} = FieldAttributeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ids};
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'AND ATTRIBUTE IDS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{ids}->gdmo();
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package FieldAttributeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package FieldAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-))//s);
		$self->{fieldname} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{fieldname}"; $::first = 0;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{attribute}->gdmo();
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package Context;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless ($line=~s/^CONTEXT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ContextType->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CONTEXT'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{type}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ContextType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ContextKeyword->parse($line,@_[1,-1])) ||
			($self->{type} = ActionInfo->parse($line,@_[1,-1])) ||
			($self->{type} = ActionReply->parse($line,@_[1,-1])) ||
			($self->{type} = EventInfo->parse($line,@_[1,-1])) ||
			($self->{type} = EventReply->parse($line,@_[1,-1])) ||
			($self->{type} = SpecificError->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{type}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ContextKeyword;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typereference};
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^\.//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{typereference}->gdmo();
		if (($s = $self->{comments1})) { $s->gdmo(); }
		printf '.'; $::first = 1;
		$self->{identifier}->gdmo();
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionInfo;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ACTION-INFO',@_);
}

# -------------------------------------
package ActionReply;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ACTION-REPLY',@_);
}

# -------------------------------------
package EventInfo;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EVENT-INFO',@_);
}

# -------------------------------------
package EventReply;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EVENT-REPLY',@_);
}

# -------------------------------------
package SpecificError;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SPECIFIC-ERROR',@_);
}

# -------------------------------------
package XXX;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package main;
use strict;
# -------------------------------------

no strict;

$s = '\s';
$lineno = 0;
$endoffile = 0;
$done = 0;
$error = '';
$success = '';
$errob = '';
$indent = '';
$first = 0;
$noref = 0;
$depth = 0;
$colwidth = 80; # width of delimited string reflow
$context = 50; # number of lines to report on error
@objects = ();
$root = {}; # root object
$scope = '';
@scopes = ();
@backtrack = ();
$oid = 0;

$root->{gdmos} = {};
$root->{oids} = {};

undef $/; # suck entire file

#
# Several things that we want to do:
#
# gdmocheck:
#   - check syntax and crossreferences and emit pretty printed results to stdout
#
# gdmohead:
#   - read GDMO input files and generate C++ header files for each input file
#   - where the input file is named x.gdmo the output file is named x.gdmo.hh
#   - where the input file is named x.gdmo the associated ASN syntax is named x.asn
#   - GDMO include files are searched in the current directory and in any include directory paths
#
# gdmostub:
#   - read GDMO input files and generate C++ stub implementation files for each input
#   - where the intput file is named x.gdmo the output file is named x.gdmo.cpp
#   - where the input file is named x.gdmo the associated ASN syntax is named x.asn
#   - GDMO include files are searched in the current directory and in any include directory paths
#
# gdmodep:
#   - read GDMO input files and generate makefile dependencies for each input to stdout
#

if (($gdmo = Gdmo->parse($file))) {
	print STDERR "Performing cross-references...";
	$gdmo->generate('xref');
	if ($progname=~/check$/) {
		print STDERR "Generating GDMO...";
		$gdmo->generate('gdmo');
	} elsif ($progname=~/head$/) {
		print STDERR "Generating Headers...";
		$gdmo->generate('head');
	} elsif ($progname=~/stub$/) {
		print STDERR "Generating Stubs...";
		$gdmo->generate('stub');
	}
} else {
	die "E: PARSE FAILED!";
}

# vim: ft=perl comments=b\:#,b\:##,b\:#\! formatoptions+=tcqlorn
