
-- 15 Supporting ASN.1 Productions
SDHProtASN1 { itu(0) recommendation(0) g(7) g774(774) hyphen(127) prot(03)
informationModel(0) asn1Module(2) sdhmsp(0) }
DEFINITIONS IMPLICIT TAGS ::=
BEGIN
-- EXPORTS everything --
IMPORTS
NameType
FROM
ASN1DefinedTypesModule { itu(0) recommendation m gnm(3100) informationModel(0)
asn1Modules(2) asn1DefinedTypesModule(0) }
RelativeDistinguishedName
FROM
InformationFramework { joint-iso-itu ds(5) modules(1) informationFramework(1) }
ObjectInstance
FROM
CMIP-1 { joint-iso-ccitt ms(9) cmip(1) modules(0) protocol(3) }
AdditionalInformation,
ManagementExtension
FROM
Attribute-ASN1Module { joint-iso-itu ms(9) smi(3) part2(2) asn1Module(2) 1 };
sdhProt OBJECT IDENTIFIER ::= { itu(0) recommendation(0) g(7) g774(774) hyphen(127)
prot(03) informationModel(0) }
g774-03ObjectClass OBJECT IDENTIFIER ::= { sdhProt managedObjectClass(3) }
g774-03Attribute OBJECT IDENTIFIER ::= { sdhProt attribute(7) }
g774-03NameBinding OBJECT IDENTIFIER ::= { sdhProt nameBinding(6) }
g774-03Action OBJECT IDENTIFIER ::= { sdhProt action(9) }
g774-03Notification OBJECT IDENTIFIER ::= { sdhProt notification(10) }
g774-03Parameter OBJECT IDENTIFIER ::= { sdhProt parameter(5) }
g774-03Package OBJECT IDENTIFIER ::= { sdhProt package(4) }
-- default value definitions --
booleanTrueDefault Boolean ::= TRUE
-- supporting productions --
Boolean ::= BOOLEAN
Integer ::= INTEGER
InvokeExerciseArg ::= SEQUENCE {
protectionEntity ProtectionEntity OPTIONAL, -- if absent, all PUs --
otherInfo SET OF ManagementExtension OPTIONAL }
InvokeExerciseReply ::= SET OF SEQUENCE {
protectionUnit RelativeDistinguishedName,
result LastAttemptResult }
LastAttemptResult ::= CHOICE {
success [0] NULL, -- default value --
denied [1] NULL,
fail [2] RxTxAPS }
RxTxAPS ::= SEQUENCE {
rxAPSvalue [0] INTEGER,
txAPSvalue [1] INTEGER } -- APS byte 1 in low order byte, byte 2 in high order byte --
InvokeProtectionArg ::= SEQUENCE {
switchType SwitchType,
protectionEntity ProtectionEntity OPTIONAL, -- if absent, all PUs --
otherInfo SET OF ManagementExtension OPTIONAL }
ProtectionDirection ::= ENUMERATED {
transmit (0),
receive (1),
bidirectional (2) }
ProtectionEntity ::= SEQUENCE {
protectedUnits [0] SEQUENCE OF RelativeDistinguishedName OPTIONAL,
protectingUnits [1] SEQUENCE OF RelativeDistinguishedName OPTIONAL
}
-- In case of a 1 + 1 non revertive MSP system for a manual switch from the protecting protection unit to the protected
one, the protectingUnits field shall be used and shall indicate the protection unit which has the channel number 0.
If both fields are present they should be compatible sequences. --
ProtectionGroupType ::= ENUMERATED {
plus (0), -- 1 + 1 (1 plus 1) or hot-standby
colon (1) -- M:N (M for N) --
}
ProtectionMismatchStatus ::= SEQUENCE {
uniBi [0] BOOLEAN,
plusColon [1] BOOLEAN }
ProtectionStatus ::= SET OF CHOICE {
noRequest [0] NULL,
doNotRevert [1] NULL,
manualSwitch [2] SEQUENCE {
requestSource [0] RequestSource OPTIONAL,
switchStatus [1] SwitchStatus,
relatedChannel [2] FromAndToProtectionUnit },
autoSwitch [3] SEQUENCE {
requestSource [0] RequestSource OPTIONAL,
switchStatus [1] SwitchStatus,
relatedChannel [2] FromAndToProtectionUnit,
autoSwitchReason [3] AutoSwitchReason },
forcedSwitch [4] SEQUENCE {
requestSource [0] RequestSource OPTIONAL,
switchStatus [1] SwitchStatus,
relatedChannel [2] FromAndToProtectionUnit },
lockout [5] SEQUENCE {
requestSource [0] RequestSource OPTIONAL,
switchStatus [1] SwitchStatus },
releaseFailed [6] NULL,
protectionFailCond [7] CHOICE {
aPSInvalid [0] BOOLEAN,
channelMismatch [1] BOOLEAN } -- invalid or toggling APS byte value
-- received or channel mismatch --
AutoSwitchReason ::= CHOICE {
waitToRestore [0] NULL,
signalDegrade [1] NULL,
signalFail [2] NULL }
ProtectionSwitchMode ::= ENUMERATED {
bidirectional (0),
unidirectional (1) }
ProtectionSwitchReportingInfo ::= SEQUENCE {
protectionUnit ProtectionUnit,
additionalInfo AdditionalInformation }
ProtectionUnit ::= CHOICE {
protectingUnit [0] RelativeDistinguishedName,
protectedUnit [1] RelativeDistinguishedName }
ProtectionStatusParameter ::= SEQUENCE {
oldProtectionStatus ProtectionStatus,
newProtectionStatus ProtectionStatus,
psDirection ProtectionDirection DEFAULT bidirectional }
ReleaseProtectionArg ::= SEQUENCE {
switchType SwitchType,
protectionEntity ProtectionEntity,
otherInfo SET OF ManagementExtension OPTIONAL }
RequestSource ::= ENUMERATED {
local (0),
remote (1) }
ResourcePointer ::= CHOICE {
null NULL,
objectInstances SEQUENCE OF ObjectInstance }
SDHMSPriority ::= Integer(1 .. 2)
-- 1 = high priority, 2 = low priority --
SDHMSResourcePointer ::= ResourcePointer(WITH COMPONENTS {
...,
objectInstances(SIZE(1))
} )
SwitchStatus ::= ENUMERATED {
pending (0),
completed (1),
operateFailed (2) }
SwitchType ::= ENUMERATED {
manual (0),
forced (1),
lockout (2) }
FromAndToProtectionUnit ::= CHOICE {
fromProtectionUnitNumber [0] RelativeDistinguishedName,
toProtectionUnitNumber [1] RelativeDistinguishedName }
-- The fromProtectionUnitNumber is used for protecting protection unit in order to hold the name of the protected
protection unit which has been protected by that protecting protection unit. The toProtectionUnitNumber is used for
protected protection unit in order to hold the number of the protecting protection unit to which it has been switched to.
In case of a MSP 1 + 1 system these parameters are not mandatory. --
InvokeProtectionError ::= ENUMERATED {
preempted (0),
failure (1),
timeout (2) }
ReleaseProtectionError ::= ENUMERATED {
failure (0),
timeout (1) }
END

