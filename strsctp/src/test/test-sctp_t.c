/*****************************************************************************

 @(#) $RCSfile: test-sctp_t.c,v $ $Name:  $($Revision: 0.9.2.21 $) $Date: 2006/10/27 23:10:14 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2006  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 Unauthorized distribution or duplication is prohibited.

 This software and related documentation is protected by copyright and
 distributed under licenses restricting its use, copying, distribution and
 decompilation.  No part of this software or related documentation may be
 reproduced in any form by any means without the prior written authorization
 of the copyright holder, and licensors, if any.

 The recipient of this document, by its retention and use, warrants that the
 recipient will protect this information and keep it confidential, and will
 not disclose the information contained in this document without the written
 permission of its owner.

 The author reserves the right to revise this software and documentation for
 any reason, including but not limited to, conformity with standards
 promulgated by various agencies, utilization of advances in the state of the
 technical arts, or the reflection of changes in the design of any techniques,
 or procedures embodied, described, or referred to herein.  The author is
 under no obligation to provide any feature listed herein.

 -----------------------------------------------------------------------------

 As an exception to the above, this software may be distributed under the GNU
 General Public License (GPL) Version 2, so long as the software is distributed
 with, and only used for the testing of, OpenSS7 modules, drivers, and
 libraries.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2006/10/27 23:10:14 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: test-sctp_t.c,v $
 Revision 0.9.2.21  2006/10/27 23:10:14  brian
 - rationalized to new test suites

 Revision 0.9.2.20  2006/10/21 19:55:40  brian
 - a couple more test case corrections

 Revision 0.9.2.19  2006/10/21 17:00:41  brian
 - fixed test cases, added split client/server operation

 Revision 0.9.2.18  2006/10/16 00:14:54  brian
 - updates for release and test case passes on UP

 Revision 0.9.2.17  2006/07/29 07:44:25  brian
 - CVS checkin of changes before leaving for SCTP interop

 Revision 0.9.2.16  2006/07/08 07:26:26  brian
 - removed trigraphs

 Revision 0.9.2.15  2006/03/25 10:20:32  brian
 - working up ETSI test cases for SCTP

 Revision 0.9.2.14  2006/03/03 11:47:02  brian
 - 32/64-bit compatibility

 Revision 0.9.2.13  2005/12/28 10:01:04  brian
 - remove warnings on FC4 compile

 Revision 0.9.2.12  2005/07/18 12:53:10  brian
 - standard indentation

 Revision 0.9.2.11  2005/06/23 22:06:51  brian
 - changes to pass _FORTIFY_SOURCE=2 on gcc 4 testing on FC4

 Revision 0.9.2.10  2005/06/16 21:07:39  brian
 - first round of testing and fixing

 Revision 0.9.2.9  2005/06/16 04:34:04  brian
 - modifications to test-sctp_t

 Revision 0.9.2.8  2005/06/07 00:52:20  brian
 - upgrading test suites

 *****************************************************************************/

#ident "@(#) $RCSfile: test-sctp_t.c,v $ $Name:  $($Revision: 0.9.2.21 $) $Date: 2006/10/27 23:10:14 $"

static char const ident[] = "$RCSfile: test-sctp_t.c,v $ $Name:  $($Revision: 0.9.2.21 $) $Date: 2006/10/27 23:10:14 $";

/*
 *  This file is for testing the sctp_t driver.  It is provided for the
 *  purpose of testing the OpenSS7 sctp_t driver only.
 */

#include <sys/types.h>
#include <stropts.h>
#include <stdlib.h>

#ifdef HAVE_INTTYPES_H
# include <inttypes.h>
#else
# ifdef HAVE_STDINT_H
#  include <stdint.h>
# endif
#endif

#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/poll.h>
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <sys/uio.h>
#include <time.h>

#ifdef HAVE_SYS_WAIT_H
# include <sys/wait.h>
#endif

#ifdef _GNU_SOURCE
#include <getopt.h>
#endif

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define NEED_T_USCALAR_T

#include <xti.h>
#include <tihdr.h>
#include <timod.h>
#include <xti_inet.h>
#include <sys/xti_sctp.h>

#if 1
#define SCTP_VERSION_2 1

#ifndef SCTP_VERSION_2
#   ifndef sctp_addr_t
typedef struct sctp_addr {
	uint16_t port __attribute__ ((packed));
	uint32_t addr[0] __attribute__ ((packed));
} sctp_addr_t;

#	define sctp_addr_t sctp_addr_t
#   endif			/* sctp_addr_t */
#endif				/* SCTP_VERSION_2 */
#endif

/*
 *  -------------------------------------------------------------------------
 *
 *  Configuration
 *
 *  -------------------------------------------------------------------------
 */

static const char *lpkgname = "OpenSS7 SCTP Driver";

/* static const char *spkgname = "SCTP"; */
static const char *lstdname = "XNS 5.2/TPI Rev 2";
static const char *sstdname = "XNS/TPI";
static const char *shortname = "SCTP";
static char devname[256] = "/dev/sctp_t";

static const int test_level = T_INET_SCTP;

static int repeat_on_success = 0;
static int repeat_on_failure = 0;
static int exit_on_failure = 0;

static int client_port_specified = 0;
static int server_port_specified = 0;
static int client_host_specified = 0;
static int server_host_specified = 0;

static int verbose = 1;

static int client_exec = 0; /* execute client side */
static int server_exec = 0; /* execute server side */

static int show_msg = 0;
static int show_acks = 0;
static int show_timeout = 0;
//static int show_data = 1;

static int last_prim = 0;
static int last_event = 0;
static int last_errno = 0;
static int last_retval = 0;
static int last_t_errno = 0;
static int last_qlen = 2;
static int last_sequence = 1;
static int last_servtype = T_COTS_ORD;
static int last_provflag = T_SENDZERO | T_ORDRELDATA | T_XPG4_1;
static int last_tstate = TS_UNBND;
struct T_info_ack last_info = { 0, };
static int last_prio = 0;

static int MORE_flag = 0;
static int DATA_flag = T_ODF_EX | T_ODF_MORE;

int test_fd[3] = { 0, 0, 0 };

#define BUFSIZE 5*4096

#define FFLUSH(stream)

#define SHORT_WAIT	  20	// 100 // 10
#define NORMAL_WAIT	 100	// 500 // 100
#define LONG_WAIT	 500	// 5000 // 500
#define LONGER_WAIT	1000	// 10000 // 5000
#define LONGEST_WAIT	5000	// 20000 // 10000
#define TEST_DURATION	20000
#define INFINITE_WAIT	-1

static int test_duration = TEST_DURATION; /* wait on other side */

ulong seq[10] = { 0, };
ulong tok[10] = { 0, };
ulong tsn[10] = { 0, };
ulong sid[10] = { 0, };
ulong ssn[10] = { 0, };
ulong ppi[10] = { 0, };
ulong exc[10] = { 0, };

char cbuf[BUFSIZE];
char dbuf[BUFSIZE];

struct strbuf ctrl = { BUFSIZE, -1, cbuf };
struct strbuf data = { BUFSIZE, -1, dbuf };

static int test_pflags = MSG_BAND;	/* MSG_BAND | MSG_HIPRI */
static int test_pband = 0;
static int test_gflags = 0;		/* MSG_BAND | MSG_HIPRI */
static int test_gband = 0;
static int test_bufsize = 256;
static int test_tidu = 256;
static int test_mgmtflags = T_NEGOTIATE;
static struct sockaddr_in *test_addr = NULL;
static socklen_t test_alen = sizeof(*test_addr);
static const char *test_data = NULL;
static int test_dlen = 0;
static int test_resfd = -1;
static int test_timout = 200;
static void *test_opts = NULL;
static int test_olen = 0;
static int test_prio = 1;

struct strfdinsert fdi = {
	{BUFSIZE, 0, cbuf},
	{BUFSIZE, 0, dbuf},
	0,
	0,
	0
};
int flags = 0;

int dummy = 0;

#if 1
#ifndef SCTP_VERSION_2
typedef struct addr {
	uint16_t port __attribute__ ((packed));
	struct in_addr addr[3] __attribute__ ((packed));
} addr_t;
#endif				/* SCTP_VERSION_2 */
#endif

struct timeval when;

/*
 *  -------------------------------------------------------------------------
 *
 *  Events and Actions
 *
 *  -------------------------------------------------------------------------
 */
enum {
	__EVENT_NO_MSG = -6, __EVENT_TIMEOUT = -5, __EVENT_UNKNOWN = -4,
	__RESULT_DECODE_ERROR = -3, __RESULT_SCRIPT_ERROR = -2,
	__RESULT_INCONCLUSIVE = -1, __RESULT_SUCCESS = 0, __RESULT_FAILURE = 1,
	__RESULT_NOTAPPL = 3, __RESULT_SKIPPED = 77,
};

/*
 *  -------------------------------------------------------------------------
 */

int show = 1;

enum {
	__TEST_CONN_REQ = 100, __TEST_CONN_RES, __TEST_DISCON_REQ,
	__TEST_DATA_REQ, __TEST_EXDATA_REQ, __TEST_INFO_REQ, __TEST_BIND_REQ,
	__TEST_UNBIND_REQ, __TEST_UNITDATA_REQ, __TEST_OPTMGMT_REQ,
	__TEST_ORDREL_REQ, __TEST_OPTDATA_REQ, __TEST_ADDR_REQ,
	__TEST_CAPABILITY_REQ, __TEST_CONN_IND, __TEST_CONN_CON,
	__TEST_DISCON_IND, __TEST_DATA_IND, __TEST_EXDATA_IND,
	__TEST_INFO_ACK, __TEST_BIND_ACK, __TEST_ERROR_ACK, __TEST_OK_ACK,
	__TEST_UNITDATA_IND, __TEST_UDERROR_IND, __TEST_OPTMGMT_ACK,
	__TEST_ORDREL_IND, __TEST_NRM_OPTDATA_IND, __TEST_EXP_OPTDATA_IND,
	__TEST_ADDR_ACK, __TEST_CAPABILITY_ACK, __TEST_WRITE, __TEST_WRITEV,
	__TEST_PUTMSG_DATA, __TEST_PUTPMSG_DATA, __TEST_PUSH, __TEST_POP,
	__TEST_READ, __TEST_READV, __TEST_GETMSG, __TEST_GETPMSG,
	__TEST_DATA,
	__TEST_DATACK_REQ, __TEST_DATACK_IND, __TEST_RESET_REQ,
	__TEST_RESET_IND, __TEST_RESET_RES, __TEST_RESET_CON,
	__TEST_O_TI_GETINFO, __TEST_O_TI_OPTMGMT, __TEST_O_TI_BIND,
	__TEST_O_TI_UNBIND,
	__TEST__O_TI_GETINFO, __TEST__O_TI_OPTMGMT, __TEST__O_TI_BIND,
	__TEST__O_TI_UNBIND, __TEST__O_TI_GETMYNAME, __TEST__O_TI_GETPEERNAME,
	__TEST__O_TI_XTI_HELLO, __TEST__O_TI_XTI_GET_STATE,
	__TEST__O_TI_XTI_CLEAR_EVENT, __TEST__O_TI_XTI_MODE,
	__TEST__O_TI_TLI_MODE,
	__TEST_TI_GETINFO, __TEST_TI_OPTMGMT, __TEST_TI_BIND,
	__TEST_TI_UNBIND, __TEST_TI_GETMYNAME, __TEST_TI_GETPEERNAME,
	__TEST_TI_SETMYNAME, __TEST_TI_SETPEERNAME, __TEST_TI_SYNC,
	__TEST_TI_GETADDRS, __TEST_TI_CAPABILITY,
	__TEST_TI_SETMYNAME_DATA, __TEST_TI_SETPEERNAME_DATA,
	__TEST_TI_SETMYNAME_DISC, __TEST_TI_SETPEERNAME_DISC,
	__TEST_TI_SETMYNAME_DISC_DATA, __TEST_TI_SETPEERNAME_DISC_DATA,
	__TEST_PRIM_TOO_SHORT, __TEST_PRIM_WAY_TOO_SHORT,
};

/*
 *  -------------------------------------------------------------------------
 *
 *  Timer Functions
 *
 *  -------------------------------------------------------------------------
 */

/*
 *  Timer values for tests: each timer has a low range (minus error margin)
 *  and a high range (plus error margin).
 */

static long timer_scale = 1;

#define TEST_TIMEOUT 5000

typedef struct timer_range {
	long lo;
	long hi;
} timer_range_t;

enum {
	t1 = 0, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15,
	t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29,
	t30, t31, t32, t33, t34, t35, t36, t37, t38, tmax
};

long test_start = 0;

static int state = 0;
static const char *failure_string = NULL;

#if 1
#undef lockf
#define lockf(x,y,z) 0
#endif

#if 0
/*
 *  Return the current time in milliseconds.
 */
static long
now(void)
{
	long ret;
	struct timeval now;

	if (gettimeofday(&now, NULL)) {
		last_errno = errno;
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "***************ERROR! couldn't get time!            !  !                    \n");
		fprintf(stdout, "%20s! %-54s\n", __FUNCTION__, strerror(last_errno));
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
		return (0);
	}
	if (!test_start)	/* avoid blowing over precision */
		test_start = now.tv_sec;
	ret = (now.tv_sec - test_start) * 1000L;
	ret += (now.tv_usec + 999L) / 1000L;
	return ret;
}
static long
milliseconds(char *t)
{
	if (verbose > 0) {
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "                    .               :               .  .                    \n");
		fprintf(stdout, "                    .             %6s            .  .                    <%d>\n", t, state);
		fprintf(stdout, "                    .               :               .  .                    \n");
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	return now();
}
static long
milliseconds_2nd(char *t)
{
	if (verbose > 0) {
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "                    .               :   :           .  .                    \n");
		fprintf(stdout, "                    .               : %6s        .  .                    <%d>\n", t, state);
		fprintf(stdout, "                    .               :   :           .  .                    \n");
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	return now();
}

/*
 *  Check the current time against the beginning time provided as an argnument
 *  and see if the time inverval falls between the low and high values for the
 *  timer as specified by arguments.  Return SUCCESS if the interval is within
 *  the allowable range and FAILURE otherwise.
 */
static int
check_time(const char *t, long i, long lo, long hi)
{
	float tol, dlo, dhi, itv;

	itv = i * timer_scale;
	dlo = lo;
	dhi = hi;
	tol = 100 * timer_scale;
	itv = itv / 1000;
	dlo = dlo / 1000;
	dhi = dhi / 1000;
	tol = tol / 1000;
	if (verbose > 0) {
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "                    |(%7.3g <= %7.3g <= %7.3g)|  | %6s             <%d>\n", dlo - tol, itv, dhi + tol, t, state);
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	if (dlo - tol <= itv && itv <= dhi + tol)
		return __RESULT_SUCCESS;
	else
		return __RESULT_FAILURE;
}
#endif

static int
time_event(int child, int event)
{
	if (verbose > 4) {
		float t, m;
		struct timeval now;

		gettimeofday(&now, NULL);
		if (!test_start)
			test_start = now.tv_sec;
		t = (now.tv_sec - test_start);
		m = now.tv_usec;
		m = m / 1000000;
		t += m;
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "                    | %11.6g                    |  |                    <%d:%03d>\n", t, child, state);
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	return (event);
}

static int timer_timeout = 0;

static void
timer_handler(int signum)
{
	if (signum == SIGALRM)
		timer_timeout = 1;
	return;
}

static int
timer_sethandler(void)
{
	sigset_t mask;
	struct sigaction act;

	act.sa_handler = timer_handler;
	act.sa_flags = SA_RESTART | SA_ONESHOT;
	sigemptyset(&act.sa_mask);
	if (sigaction(SIGALRM, &act, NULL))
		return __RESULT_FAILURE;
	sigemptyset(&mask);
	sigaddset(&mask, SIGALRM);
	sigprocmask(SIG_UNBLOCK, &mask, NULL);
	siginterrupt(SIGALRM, 1);
	return __RESULT_SUCCESS;
}

/*
 *  Start an interval timer as the overall test timer.
 */
static int
start_tt(long duration)
{
	struct itimerval setting = {
		{0, 0},
		{duration / 1000, (duration % 1000) * 1000}
	};

	if (duration == (long)INFINITE_WAIT)
		return __RESULT_SUCCESS;
	if (timer_sethandler())
		return __RESULT_FAILURE;
	if (setitimer(ITIMER_REAL, &setting, NULL))
		return __RESULT_FAILURE;
	timer_timeout = 0;
	return __RESULT_SUCCESS;
}

#if 0
static int
start_st(long duration)
{
	long sdur = (duration + timer_scale - 1) / timer_scale;

	return start_tt(sdur);
}
#endif

static int
stop_tt(void)
{
	struct itimerval setting = { {0, 0}, {0, 0} };
	sigset_t mask;
	struct sigaction act;

	if (setitimer(ITIMER_REAL, &setting, NULL))
		return __RESULT_FAILURE;
	act.sa_handler = SIG_DFL;
	act.sa_flags = 0;
	sigemptyset(&act.sa_mask);
	if (sigaction(SIGALRM, &act, NULL))
		return __RESULT_FAILURE;
	timer_timeout = 0;
	sigemptyset(&mask);
	sigaddset(&mask, SIGALRM);
	sigprocmask(SIG_BLOCK, &mask, NULL);
	return __RESULT_SUCCESS;
}

/*
 *  Addresses
 */
#if 1
#ifndef SCTP_VERSION_2
addr_t addrs[4];
#else				/* SCTP_VERSION_2 */
struct sockaddr_in addrs[4][3];
#endif				/* SCTP_VERSION_2 */
#else
struct sockaddr_in addrs[4];
#endif
int anums[4] = { 3, 3, 3, 3 };
unsigned short ports[4] = { 10000, 10001, 10002, 10003 };
const char *addr_strings[4] = { "127.0.0.1", "127.0.0.2", "127.0.0.3", "127.0.0.4" };

/*
 *  Options
 */

/*
 * data options
 */
struct {
#if 1
	struct t_opthdr tos_hdr;
	union {
		unsigned char opt_val;
		t_scalar_t opt_fil;
	} tos_val;
	struct t_opthdr ttl_hdr;
	union {
		unsigned char opt_val;
		t_scalar_t opt_fil;
	} ttl_val;
#endif
	struct t_opthdr drt_hdr;
	t_scalar_t drt_val;
#if 0
	struct t_opthdr csm_hdr;
	t_scalar_t csm_val;
#endif
#if 1
	struct t_opthdr ppi_hdr;
	t_uscalar_t ppi_val;
	struct t_opthdr sid_hdr;
	t_scalar_t sid_val;
#endif
} opt_data = {
#if 1
	{
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
	.opt_val = 0x0}
	, {
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
	.opt_val = 64},
#endif
	{
	sizeof(struct t_opthdr) + sizeof(unsigned int), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}, T_NO
#if 0
	    , {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO
#endif
#if 1
	    , {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 50, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0
#endif
};

/*
 * connect options
 */
struct {
	struct t_opthdr dbg_hdr;
	t_uscalar_t dbg_val;
	struct t_opthdr lin_hdr;
	struct t_linger lin_val;
	struct t_opthdr rbf_hdr;
	t_uscalar_t rbf_val;
	struct t_opthdr rlw_hdr;
	t_uscalar_t rlw_val;
	struct t_opthdr sbf_hdr;
	t_uscalar_t sbf_val;
	struct t_opthdr slw_hdr;
	t_uscalar_t slw_val;
	struct t_opthdr tos_hdr;
	union {
		unsigned char opt_val;
		t_scalar_t opt_fil;
	} tos_val;
	struct t_opthdr ttl_hdr;
	union {
		unsigned char opt_val;
		t_scalar_t opt_fil;
	} ttl_val;
	struct t_opthdr drt_hdr;
	t_scalar_t drt_val;
	struct t_opthdr bca_hdr;
	t_scalar_t bca_val;
	struct t_opthdr reu_hdr;
	t_scalar_t reu_val;
#if 1
	struct t_opthdr ist_hdr;
	t_scalar_t ist_val;
	struct t_opthdr ost_hdr;
	t_scalar_t ost_val;
#endif
} opt_conn = {
	{
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0, {
	sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
	T_NO, T_UNSPEC}
	, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
	.opt_val = 0x0}
	, {
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
	.opt_val = 64}
	, {
	sizeof(struct t_opthdr) + sizeof(unsigned int), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}, T_NO, {
	sizeof(struct t_opthdr) + sizeof(unsigned int), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}, T_NO, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO
#if 1
	    , {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1
#endif
};

/*
 * management options
 */
struct {
#if 0
#if 1
	struct t_opthdr xdb_hdr;
	t_uscalar_t xdb_val;
#else
	struct t_opthdr dbg_hdr;
	t_uscalar_t dbg_val;
#endif
#endif
	struct t_opthdr lin_hdr;
	struct t_linger lin_val;
	struct t_opthdr rbf_hdr;
	t_uscalar_t rbf_val;
	struct t_opthdr rlw_hdr;
	t_uscalar_t rlw_val;
	struct t_opthdr sbf_hdr;
	t_uscalar_t sbf_val;
	struct t_opthdr slw_hdr;
	t_uscalar_t slw_val;
	struct t_opthdr tos_hdr;
	union {
		unsigned char opt_val;
		t_scalar_t opt_fil;
	} tos_val;
	struct t_opthdr ttl_hdr;
	union {
		unsigned char opt_val;
		t_scalar_t opt_fil;
	} ttl_val;
	struct t_opthdr drt_hdr;
	t_scalar_t drt_val;
	struct t_opthdr bca_hdr;
	t_scalar_t bca_val;
	struct t_opthdr reu_hdr;
	t_scalar_t reu_val;
#if 0
	struct t_opthdr csm_hdr;
	t_scalar_t csm_val;
#endif
#if 0
	struct t_opthdr ndl_hdr;
	t_scalar_t ndl_val;
	struct t_opthdr mxs_hdr;
	t_scalar_t mxs_val;
#endif
#if 0
	struct t_opthdr kpa_hdr;
	struct t_kpalive kpa_val;
#endif
#if 1
	struct t_opthdr nod_hdr;
	t_scalar_t nod_val;
	struct t_opthdr crk_hdr;
	t_scalar_t crk_val;
	struct t_opthdr ppi_hdr;
	t_scalar_t ppi_val;
	struct t_opthdr sid_hdr;
	t_scalar_t sid_val;
	struct t_opthdr rcv_hdr;
	t_scalar_t rcv_val;
	struct t_opthdr ckl_hdr;
	t_scalar_t ckl_val;
	struct t_opthdr skd_hdr;
	t_scalar_t skd_val;
	struct t_opthdr prt_hdr;
	t_scalar_t prt_val;
	struct t_opthdr art_hdr;
	t_scalar_t art_val;
	struct t_opthdr irt_hdr;
	t_scalar_t irt_val;
	struct t_opthdr hbi_hdr;
	t_scalar_t hbi_val;
	struct t_opthdr rin_hdr;
	t_scalar_t rin_val;
	struct t_opthdr rmn_hdr;
	t_scalar_t rmn_val;
	struct t_opthdr rmx_hdr;
	t_scalar_t rmx_val;
	struct t_opthdr ist_hdr;
	t_scalar_t ist_val;
	struct t_opthdr ost_hdr;
	t_scalar_t ost_val;
	struct t_opthdr cin_hdr;
	t_scalar_t cin_val;
	struct t_opthdr tin_hdr;
	t_scalar_t tin_val;
	struct t_opthdr mac_hdr;
	t_scalar_t mac_val;
	struct t_opthdr dbg_hdr;
	t_scalar_t dbg_val;
#endif
} opt_optm = {
	{
#if 0
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0, {
#endif
	sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
	T_NO, T_UNSPEC}
	, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
	.opt_val = 0x0}
	, {
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
	.opt_val = 64}
	, {
	sizeof(struct t_opthdr) + sizeof(unsigned int), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}, T_NO, {
	sizeof(struct t_opthdr) + sizeof(unsigned int), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}, T_NO, {
	sizeof(struct t_opthdr) + sizeof(unsigned int), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}, T_NO
#if 0
	    , {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO
#endif
#if 0
	    , {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576
#endif
#if 0
	    , {
	sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
	T_NO, 0}
#endif
#if 1
	, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES, {
	sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE, {
	sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0
#endif
};

struct t_opthdr *
find_option(int level, int name, const char *cmd_buf, size_t opt_ofs, size_t opt_len)
{
	const char *opt_ptr = cmd_buf + opt_ofs;
	struct t_opthdr *oh = NULL;

	for (oh = _T_OPT_FIRSTHDR_OFS(opt_ptr, opt_len, 0); oh; oh = _T_OPT_NEXTHDR_OFS(opt_ptr, opt_len, oh, 0)) {
		int len = oh->len - sizeof(*oh);

		if (len < 0) {
			oh = NULL;
			break;
		}
		if (oh->level != level)
			continue;
		if (oh->name != name)
			continue;
		break;
	}
	return (oh);
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Printing things
 *
 *  -------------------------------------------------------------------------
 */

char *
errno_string(t_scalar_t err)
{
	switch (err) {
	case 0:
		return ("ok");
	case EPERM:
		return ("[EPERM]");
	case ENOENT:
		return ("[ENOENT]");
	case ESRCH:
		return ("[ESRCH]");
	case EINTR:
		return ("[EINTR]");
	case EIO:
		return ("[EIO]");
	case ENXIO:
		return ("[ENXIO]");
	case E2BIG:
		return ("[E2BIG]");
	case ENOEXEC:
		return ("[ENOEXEC]");
	case EBADF:
		return ("[EBADF]");
	case ECHILD:
		return ("[ECHILD]");
	case EAGAIN:
		return ("[EAGAIN]");
	case ENOMEM:
		return ("[ENOMEM]");
	case EACCES:
		return ("[EACCES]");
	case EFAULT:
		return ("[EFAULT]");
	case ENOTBLK:
		return ("[ENOTBLK]");
	case EBUSY:
		return ("[EBUSY]");
	case EEXIST:
		return ("[EEXIST]");
	case EXDEV:
		return ("[EXDEV]");
	case ENODEV:
		return ("[ENODEV]");
	case ENOTDIR:
		return ("[ENOTDIR]");
	case EISDIR:
		return ("[EISDIR]");
	case EINVAL:
		return ("[EINVAL]");
	case ENFILE:
		return ("[ENFILE]");
	case EMFILE:
		return ("[EMFILE]");
	case ENOTTY:
		return ("[ENOTTY]");
	case ETXTBSY:
		return ("[ETXTBSY]");
	case EFBIG:
		return ("[EFBIG]");
	case ENOSPC:
		return ("[ENOSPC]");
	case ESPIPE:
		return ("[ESPIPE]");
	case EROFS:
		return ("[EROFS]");
	case EMLINK:
		return ("[EMLINK]");
	case EPIPE:
		return ("[EPIPE]");
	case EDOM:
		return ("[EDOM]");
	case ERANGE:
		return ("[ERANGE]");
	case EDEADLK:
		return ("[EDEADLK]");
	case ENAMETOOLONG:
		return ("[ENAMETOOLONG]");
	case ENOLCK:
		return ("[ENOLCK]");
	case ENOSYS:
		return ("[ENOSYS]");
	case ENOTEMPTY:
		return ("[ENOTEMPTY]");
	case ELOOP:
		return ("[ELOOP]");
	case ENOMSG:
		return ("[ENOMSG]");
	case EIDRM:
		return ("[EIDRM]");
	case ECHRNG:
		return ("[ECHRNG]");
	case EL2NSYNC:
		return ("[EL2NSYNC]");
	case EL3HLT:
		return ("[EL3HLT]");
	case EL3RST:
		return ("[EL3RST]");
	case ELNRNG:
		return ("[ELNRNG]");
	case EUNATCH:
		return ("[EUNATCH]");
	case ENOCSI:
		return ("[ENOCSI]");
	case EL2HLT:
		return ("[EL2HLT]");
	case EBADE:
		return ("[EBADE]");
	case EBADR:
		return ("[EBADR]");
	case EXFULL:
		return ("[EXFULL]");
	case ENOANO:
		return ("[ENOANO]");
	case EBADRQC:
		return ("[EBADRQC]");
	case EBADSLT:
		return ("[EBADSLT]");
	case EBFONT:
		return ("[EBFONT]");
	case ENOSTR:
		return ("[ENOSTR]");
	case ENODATA:
		return ("[ENODATA]");
	case ETIME:
		return ("[ETIME]");
	case ENOSR:
		return ("[ENOSR]");
	case ENONET:
		return ("[ENONET]");
	case ENOPKG:
		return ("[ENOPKG]");
	case EREMOTE:
		return ("[EREMOTE]");
	case ENOLINK:
		return ("[ENOLINK]");
	case EADV:
		return ("[EADV]");
	case ESRMNT:
		return ("[ESRMNT]");
	case ECOMM:
		return ("[ECOMM]");
	case EPROTO:
		return ("[EPROTO]");
	case EMULTIHOP:
		return ("[EMULTIHOP]");
	case EDOTDOT:
		return ("[EDOTDOT]");
	case EBADMSG:
		return ("[EBADMSG]");
	case EOVERFLOW:
		return ("[EOVERFLOW]");
	case ENOTUNIQ:
		return ("[ENOTUNIQ]");
	case EBADFD:
		return ("[EBADFD]");
	case EREMCHG:
		return ("[EREMCHG]");
	case ELIBACC:
		return ("[ELIBACC]");
	case ELIBBAD:
		return ("[ELIBBAD]");
	case ELIBSCN:
		return ("[ELIBSCN]");
	case ELIBMAX:
		return ("[ELIBMAX]");
	case ELIBEXEC:
		return ("[ELIBEXEC]");
	case EILSEQ:
		return ("[EILSEQ]");
	case ERESTART:
		return ("[ERESTART]");
	case ESTRPIPE:
		return ("[ESTRPIPE]");
	case EUSERS:
		return ("[EUSERS]");
	case ENOTSOCK:
		return ("[ENOTSOCK]");
	case EDESTADDRREQ:
		return ("[EDESTADDRREQ]");
	case EMSGSIZE:
		return ("[EMSGSIZE]");
	case EPROTOTYPE:
		return ("[EPROTOTYPE]");
	case ENOPROTOOPT:
		return ("[ENOPROTOOPT]");
	case EPROTONOSUPPORT:
		return ("[EPROTONOSUPPORT]");
	case ESOCKTNOSUPPORT:
		return ("[ESOCKTNOSUPPORT]");
	case EOPNOTSUPP:
		return ("[EOPNOTSUPP]");
	case EPFNOSUPPORT:
		return ("[EPFNOSUPPORT]");
	case EAFNOSUPPORT:
		return ("[EAFNOSUPPORT]");
	case EADDRINUSE:
		return ("[EADDRINUSE]");
	case EADDRNOTAVAIL:
		return ("[EADDRNOTAVAIL]");
	case ENETDOWN:
		return ("[ENETDOWN]");
	case ENETUNREACH:
		return ("[ENETUNREACH]");
	case ENETRESET:
		return ("[ENETRESET]");
	case ECONNABORTED:
		return ("[ECONNABORTED]");
	case ECONNRESET:
		return ("[ECONNRESET]");
	case ENOBUFS:
		return ("[ENOBUFS]");
	case EISCONN:
		return ("[EISCONN]");
	case ENOTCONN:
		return ("[ENOTCONN]");
	case ESHUTDOWN:
		return ("[ESHUTDOWN]");
	case ETOOMANYREFS:
		return ("[ETOOMANYREFS]");
	case ETIMEDOUT:
		return ("[ETIMEDOUT]");
	case ECONNREFUSED:
		return ("[ECONNREFUSED]");
	case EHOSTDOWN:
		return ("[EHOSTDOWN]");
	case EHOSTUNREACH:
		return ("[EHOSTUNREACH]");
	case EALREADY:
		return ("[EALREADY]");
	case EINPROGRESS:
		return ("[EINPROGRESS]");
	case ESTALE:
		return ("[ESTALE]");
	case EUCLEAN:
		return ("[EUCLEAN]");
	case ENOTNAM:
		return ("[ENOTNAM]");
	case ENAVAIL:
		return ("[ENAVAIL]");
	case EISNAM:
		return ("[EISNAM]");
	case EREMOTEIO:
		return ("[EREMOTEIO]");
	case EDQUOT:
		return ("[EDQUOT]");
	case ENOMEDIUM:
		return ("[ENOMEDIUM]");
	case EMEDIUMTYPE:
		return ("[EMEDIUMTYPE]");
	default:
	{
		static char buf[32];

		snprintf(buf, sizeof(buf), "[%ld]", (long) err);
		return buf;
	}
	}
}

char *
terrno_string(t_uscalar_t terr, t_scalar_t uerr)
{
	switch (terr) {
	case TBADADDR:
		return ("[TBADADDR]");
	case TBADOPT:
		return ("[TBADOPT]");
	case TACCES:
		return ("[TACCES]");
	case TBADF:
		return ("[TBADF]");
	case TNOADDR:
		return ("[TNOADDR]");
	case TOUTSTATE:
		return ("[TOUTSTATE]");
	case TBADSEQ:
		return ("[TBADSEQ]");
	case TSYSERR:
		return errno_string(uerr);
	case TLOOK:
		return ("[TLOOK]");
	case TBADDATA:
		return ("[TBADDATA]");
	case TBUFOVFLW:
		return ("[TBUFOVFLW]");
	case TFLOW:
		return ("[TFLOW]");
	case TNODATA:
		return ("[TNODATA]");
	case TNODIS:
		return ("[TNODIS]");
	case TNOUDERR:
		return ("[TNOUDERR]");
	case TBADFLAG:
		return ("[TBADFLAG]");
	case TNOREL:
		return ("[TNOREL]");
	case TNOTSUPPORT:
		return ("[TNOTSUPPORT]");
	case TSTATECHNG:
		return ("[TSTATECHNG]");
	case TNOSTRUCTYPE:
		return ("[TNOSTRUCTYPE]");
	case TBADNAME:
		return ("[TBADNAME]");
	case TBADQLEN:
		return ("[TBADQLEN]");
	case TADDRBUSY:
		return ("[TADDRBUSY]");
	case TINDOUT:
		return ("[TINDOUT]");
	case TPROVMISMATCH:
		return ("[TPROVMISMATCH]");
	case TRESQLEN:
		return ("[TRESQLEN]");
	case TRESADDR:
		return ("[TRESADDR]");
	case TQFULL:
		return ("[TQFULL]");
	case TPROTO:
		return ("[TPROTO]");
	default:
	{
		static char buf[32];

		snprintf(buf, sizeof(buf), "[%lu]", (ulong) terr);
		return buf;
	}
	}
}

#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
#define ICMP_ECHO		8	/* Echo Request			*/
#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
#define ICMP_INFO_REQUEST	15	/* Information Request		*/
#define ICMP_INFO_REPLY		16	/* Information Reply		*/
#define ICMP_ADDRESS		17	/* Address Mask Request		*/
#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
#define NR_ICMP_TYPES		18

/* Codes for UNREACH. */
#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
#define ICMP_SR_FAILED		5	/* Source Route failed		*/
#define ICMP_NET_UNKNOWN	6
#define ICMP_HOST_UNKNOWN	7
#define ICMP_HOST_ISOLATED	8
#define ICMP_NET_ANO		9
#define ICMP_HOST_ANO		10
#define ICMP_NET_UNR_TOS	11
#define ICMP_HOST_UNR_TOS	12
#define ICMP_PKT_FILTERED	13	/* Packet filtered */
#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */

/* Codes for REDIRECT. */
#define ICMP_REDIR_NET		0	/* Redirect Net			*/
#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/

/* Codes for TIME_EXCEEDED. */
#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/

char *
etype_string(t_uscalar_t etype)
{
	switch (etype) {
	case TBADADDR:
		return ("[TBADADDR]");
	case TBADOPT:
		return ("[TBADOPT]");
	case TACCES:
		return ("[TACCES]");
	case TBADF:
		return ("[TBADF]");
	case TNOADDR:
		return ("[TNOADDR]");
	case TOUTSTATE:
		return ("[TOUTSTATE]");
	case TBADSEQ:
		return ("[TBADSEQ]");
	case TSYSERR:
		return ("[TSYSERR]");
	case TLOOK:
		return ("[TLOOK]");
	case TBADDATA:
		return ("[TBADDATA]");
	case TBUFOVFLW:
		return ("[TBUFOVFLW]");
	case TFLOW:
		return ("[TFLOW]");
	case TNODATA:
		return ("[TNODATA]");
	case TNODIS:
		return ("[TNODIS]");
	case TNOUDERR:
		return ("[TNOUDERR]");
	case TBADFLAG:
		return ("[TBADFLAG]");
	case TNOREL:
		return ("[TNOREL]");
	case TNOTSUPPORT:
		return ("[TNOTSUPPORT]");
	case TSTATECHNG:
		return ("[TSTATECHNG]");
	case TNOSTRUCTYPE:
		return ("[TNOSTRUCTYPE]");
	case TBADNAME:
		return ("[TBADNAME]");
	case TBADQLEN:
		return ("[TBADQLEN]");
	case TADDRBUSY:
		return ("[TADDRBUSY]");
	case TINDOUT:
		return ("[TINDOUT]");
	case TPROVMISMATCH:
		return ("[TPROVMISMATCH]");
	case TRESQLEN:
		return ("[TRESQLEN]");
	case TRESADDR:
		return ("[TRESADDR]");
	case TQFULL:
		return ("[TQFULL]");
	case TPROTO:
		return ("[TPROTO]");
	default:
	{
		unsigned char code = ((etype >> 0) & 0x00ff);
		unsigned char type = ((etype >> 8) & 0x00ff);

		switch (type) {
		case ICMP_DEST_UNREACH:
			switch (code) {
			case ICMP_NET_UNREACH:
				return ("<ICMP_NET_UNREACH>");
			case ICMP_HOST_UNREACH:
				return ("<ICMP_HOST_UNREACH>");
			case ICMP_PROT_UNREACH:
				return ("<ICMP_PROT_UNREACH>");
			case ICMP_PORT_UNREACH:
				return ("<ICMP_PORT_UNREACH>");
			case ICMP_FRAG_NEEDED:
				return ("<ICMP_FRAG_NEEDED>");
			case ICMP_NET_UNKNOWN:
				return ("<ICMP_NET_UNKNOWN>");
			case ICMP_HOST_UNKNOWN:
				return ("<ICMP_HOST_UNKNOWN>");
			case ICMP_HOST_ISOLATED:
				return ("<ICMP_HOST_ISOLATED>");
			case ICMP_NET_ANO:
				return ("<ICMP_NET_ANO>");
			case ICMP_HOST_ANO:
				return ("<ICMP_HOST_ANO>");
			case ICMP_PKT_FILTERED:
				return ("<ICMP_PKT_FILTERED>");
			case ICMP_PREC_VIOLATION:
				return ("<ICMP_PREC_VIOLATION>");
			case ICMP_PREC_CUTOFF:
				return ("<ICMP_PREC_CUTOFF>");
			case ICMP_SR_FAILED:
				return ("<ICMP_SR_FAILED>");
			case ICMP_NET_UNR_TOS:
				return ("<ICMP_NET_UNR_TOS>");
			case ICMP_HOST_UNR_TOS:
				return ("<ICMP_HOST_UNR_TOS>");
			default:
				return ("<ICMP_DEST_UNREACH?>");
			}
		case ICMP_SOURCE_QUENCH:
			return ("<ICMP_SOURCE_QUENCH>");
		case ICMP_TIME_EXCEEDED:
			switch (code) {
			case ICMP_EXC_TTL:
				return ("<ICMP_EXC_TTL>");
			case ICMP_EXC_FRAGTIME:
				return ("<ICMP_EXC_FRAGTIME>");
			default:
				return ("<ICMP_TIME_EXCEEDED?>");
			}
		case ICMP_PARAMETERPROB:
			return ("<ICMP_PARAMETERPROB>");
		default:
			return ("<ICMP_???? >");
		}
	}
	}
}

const char *
event_string(int event)
{
	switch (event) {
	case __EVENT_NO_MSG:
		return ("NO MESSAGE");
	case __EVENT_TIMEOUT:
		return ("TIMEOUT");
	case __EVENT_UNKNOWN:
		return ("UNKNOWN");
	case __RESULT_DECODE_ERROR:
		return ("DECODE ERROR");
	case __RESULT_SCRIPT_ERROR:
		return ("SCRIPT ERROR");
	case __RESULT_INCONCLUSIVE:
		return ("INCONCLUSIVE");
	case __RESULT_SUCCESS:
		return ("SUCCESS");
	case __RESULT_FAILURE:
		return ("FAILURE");
	case __TEST_CONN_REQ:
		return ("T_CONN_REQ");
	case __TEST_CONN_RES:
		return ("T_CONN_RES");
	case __TEST_DISCON_REQ:
		return ("T_DISCON_REQ");
	case __TEST_DATA_REQ:
		return ("T_DATA_REQ");
	case __TEST_EXDATA_REQ:
		return ("T_EXDATA_REQ");
	case __TEST_OPTDATA_REQ:
		return ("T_OPTDATA_REQ");
	case __TEST_INFO_REQ:
		return ("T_INFO_REQ");
	case __TEST_BIND_REQ:
		return ("T_BIND_REQ");
	case __TEST_UNBIND_REQ:
		return ("T_UNBIND_REQ");
	case __TEST_UNITDATA_REQ:
		return ("T_UNITDATA_REQ");
	case __TEST_OPTMGMT_REQ:
		return ("T_OPTMGMT_REQ");
	case __TEST_ORDREL_REQ:
		return ("T_ORDREL_REQ");
	case __TEST_CONN_IND:
		return ("T_CONN_IND");
	case __TEST_CONN_CON:
		return ("T_CONN_CON");
	case __TEST_DISCON_IND:
		return ("T_DISCON_IND");
	case __TEST_DATA_IND:
		return ("T_DATA_IND");
	case __TEST_EXDATA_IND:
		return ("T_EXDATA_IND");
	case __TEST_NRM_OPTDATA_IND:
		return ("T_OPTDATA_IND(nrm)");
	case __TEST_EXP_OPTDATA_IND:
		return ("T_OPTDATA_IND(exp)");
	case __TEST_INFO_ACK:
		return ("T_INFO_ACK");
	case __TEST_BIND_ACK:
		return ("T_BIND_ACK");
	case __TEST_ERROR_ACK:
		return ("T_ERROR_ACK");
	case __TEST_OK_ACK:
		return ("T_OK_ACK");
	case __TEST_UNITDATA_IND:
		return ("T_UNITDATA_IND");
	case __TEST_UDERROR_IND:
		return ("T_UDERROR_IND");
	case __TEST_OPTMGMT_ACK:
		return ("T_OPTMGMT_ACK");
	case __TEST_ORDREL_IND:
		return ("T_ORDREL_IND");
	case __TEST_ADDR_REQ:
		return ("T_ADDR_REQ");
	case __TEST_ADDR_ACK:
		return ("T_ADDR_ACK");
	case __TEST_CAPABILITY_REQ:
		return ("T_CAPABILITY_REQ");
	case __TEST_CAPABILITY_ACK:
		return ("T_CAPABILITY_ACK");
	default:
		return ("(unexpected");
	}
}

const char *
ioctl_string(int cmd, intptr_t arg)
{
	switch (cmd) {
	case I_NREAD:
		return ("I_NREAD");
	case I_PUSH:
		return ("I_PUSH");
	case I_POP:
		return ("I_POP");
	case I_LOOK:
		return ("I_LOOK");
	case I_FLUSH:
		return ("I_FLUSH");
	case I_SRDOPT:
		return ("I_SRDOPT");
	case I_GRDOPT:
		return ("I_GRDOPT");
	case I_STR:
		if (arg) {
			struct strioctl *icp = (struct strioctl *) arg;

			switch (icp->ic_cmd) {
#if 0
			case _O_TI_BIND:
				return ("_O_TI_BIND");
			case O_TI_BIND:
				return ("O_TI_BIND");
			case _O_TI_GETINFO:
				return ("_O_TI_GETINFO");
			case O_TI_GETINFO:
				return ("O_TI_GETINFO");
			case _O_TI_GETMYNAME:
				return ("_O_TI_GETMYNAME");
			case _O_TI_GETPEERNAME:
				return ("_O_TI_GETPEERNAME");
			case _O_TI_OPTMGMT:
				return ("_O_TI_OPTMGMT");
			case O_TI_OPTMGMT:
				return ("O_TI_OPTMGMT");
			case _O_TI_TLI_MODE:
				return ("_O_TI_TLI_MODE");
			case _O_TI_UNBIND:
				return ("_O_TI_UNBIND");
			case O_TI_UNBIND:
				return ("O_TI_UNBIND");
			case _O_TI_XTI_CLEAR_EVENT:
				return ("_O_TI_XTI_CLEAR_EVENT");
			case _O_TI_XTI_GET_STATE:
				return ("_O_TI_XTI_GET_STATE");
			case _O_TI_XTI_HELLO:
				return ("_O_TI_XTI_HELLO");
			case _O_TI_XTI_MODE:
				return ("_O_TI_XTI_MODE");
			case TI_BIND:
				return ("TI_BIND");
			case TI_CAPABILITY:
				return ("TI_CAPABILITY");
			case TI_GETADDRS:
				return ("TI_GETADDRS");
			case TI_GETINFO:
				return ("TI_GETINFO");
			case TI_GETMYNAME:
				return ("TI_GETMYNAME");
			case TI_GETPEERNAME:
				return ("TI_GETPEERNAME");
			case TI_OPTMGMT:
				return ("TI_OPTMGMT");
			case TI_SETMYNAME:
				return ("TI_SETMYNAME");
			case TI_SETPEERNAME:
				return ("TI_SETPEERNAME");
			case TI_SYNC:
				return ("TI_SYNC");
			case TI_UNBIND:
				return ("TI_UNBIND");
#endif
			}
		}
		return ("I_STR");
	case I_SETSIG:
		return ("I_SETSIG");
	case I_GETSIG:
		return ("I_GETSIG");
	case I_FIND:
		return ("I_FIND");
	case I_LINK:
		return ("I_LINK");
	case I_UNLINK:
		return ("I_UNLINK");
	case I_RECVFD:
		return ("I_RECVFD");
	case I_PEEK:
		return ("I_PEEK");
	case I_FDINSERT:
		return ("I_FDINSERT");
	case I_SENDFD:
		return ("I_SENDFD");
#if 0
	case I_E_RECVFD:
		return ("I_E_RECVFD");
#endif
	case I_SWROPT:
		return ("I_SWROPT");
	case I_GWROPT:
		return ("I_GWROPT");
	case I_LIST:
		return ("I_LIST");
	case I_PLINK:
		return ("I_PLINK");
	case I_PUNLINK:
		return ("I_PUNLINK");
	case I_FLUSHBAND:
		return ("I_FLUSHBAND");
	case I_CKBAND:
		return ("I_CKBAND");
	case I_GETBAND:
		return ("I_GETBAND");
	case I_ATMARK:
		return ("I_ATMARK");
	case I_SETCLTIME:
		return ("I_SETCLTIME");
	case I_GETCLTIME:
		return ("I_GETCLTIME");
	case I_CANPUT:
		return ("I_CANPUT");
#if 0
	case I_SERROPT:
		return ("I_SERROPT");
	case I_GERROPT:
		return ("I_GERROPT");
	case I_ANCHOR:
		return ("I_ANCHOR");
#endif
#if 0
	case I_S_RECVFD:
		return ("I_S_RECVFD");
	case I_STATS:
		return ("I_STATS");
	case I_BIGPIPE:
		return ("I_BIGPIPE");
#endif
#if 0
	case I_GETTP:
		return ("I_GETTP");
	case I_AUTOPUSH:
		return ("I_AUTOPUSH");
	case I_HEAP_REPORT:
		return ("I_HEAP_REPORT");
	case I_FIFO:
		return ("I_FIFO");
	case I_PUTPMSG:
		return ("I_PUTPMSG");
	case I_GETPMSG:
		return ("I_GETPMSG");
	case I_FATTACH:
		return ("I_FATTACH");
	case I_FDETACH:
		return ("I_FDETACH");
	case I_PIPE:
		return ("I_PIPE");
#endif
	default:
		return ("(unexpected)");
	}
}

const char *
service_type(t_uscalar_t type)
{
	switch (type) {
	case T_CLTS:
		return ("T_CLTS");
	case T_COTS:
		return ("T_COTS");
	case T_COTS_ORD:
		return ("T_COTS_ORD");
	default:
		return ("(unknown)");
	}
}

const char *
state_string(t_uscalar_t state)
{
	switch (state) {
	case TS_UNBND:
		return ("TS_UNBND");
	case TS_WACK_BREQ:
		return ("TS_WACK_BREQ");
	case TS_WACK_UREQ:
		return ("TS_WACK_UREQ");
	case TS_IDLE:
		return ("TS_IDLE");
	case TS_WACK_OPTREQ:
		return ("TS_WACK_OPTREQ");
	case TS_WACK_CREQ:
		return ("TS_WACK_CREQ");
	case TS_WCON_CREQ:
		return ("TS_WCON_CREQ");
	case TS_WRES_CIND:
		return ("TS_WRES_CIND");
	case TS_WACK_CRES:
		return ("TS_WACK_CRES");
	case TS_DATA_XFER:
		return ("TS_DATA_XFER");
	case TS_WIND_ORDREL:
		return ("TS_WIND_ORDREL");
	case TS_WREQ_ORDREL:
		return ("TS_WRES_ORDREL");
	case TS_WACK_DREQ6:
		return ("TS_WACK_DREQ6");
	case TS_WACK_DREQ7:
		return ("TS_WACK_DREQ7");
	case TS_WACK_DREQ9:
		return ("TS_WACK_DREQ9");
	case TS_WACK_DREQ10:
		return ("TS_WACK_DREQ10");
	case TS_WACK_DREQ11:
		return ("TS_WACK_DREQ11");
	default:
		return ("(unknown)");
	}
}

#ifndef SCTP_VERSION_2
void
print_addr(char *add_ptr, size_t add_len)
{
	sctp_addr_t *a = (sctp_addr_t *) add_ptr;
	size_t anum = add_len >= sizeof(a->port) ? (add_len - sizeof(a->port)) / sizeof(a->addr[0]) : 0;

	dummy = lockf(fileno(stdout), F_LOCK, 0);
	if (add_len) {
		int i;

		if (add_len != sizeof(a->port) + anum * sizeof(a->addr[0]))
			fprintf(stdout, "Aaarrg! add_len = %d, anum = %d, ", add_len, anum);
		fprintf(stdout, "[%d]", ntohs(a->port));
		for (i = 0; i < anum; i++) {
			fprintf(stdout, "%s%d.%d.%d.%d", i ? "," : "", (a->addr[i] >> 0) & 0xff, (a->addr[i] >> 8) & 0xff, (a->addr[i] >> 16) & 0xff, (a->addr[i] >> 24) & 0xff);
		}
	} else
		fprintf(stdout, "(no address)");
	fprintf(stdout, "\n");
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

char *
addr_string(char *add_ptr, size_t add_len)
{
	static char buf[128];
	size_t len = 0;
	sctp_addr_t *a = (sctp_addr_t *) add_ptr;
	size_t anum = add_len >= sizeof(a->port) ? (add_len - sizeof(a->port)) / sizeof(a->addr[0]) : 0;

	if (add_len) {
		int i;

		if (add_len != sizeof(a->port) + anum * sizeof(a->addr[0]))
			len += snprintf(buf + len, sizeof(buf) - len, "Aaarrg! add_len = %d, anum = %d, ", add_len, anum);
		len += snprintf(buf + len, sizeof(buf) - len, "[%d]", ntohs(a->port));
		for (i = 0; i < anum; i++) {
			len += snprintf(buf + len, sizeof(buf) - len, "%s%d.%d.%d.%d", i ? "," : "", (a->addr[i] >> 0) & 0xff, (a->addr[i] >> 8) & 0xff, (a->addr[i] >> 16) & 0xff, (a->addr[i] >> 24) & 0xff);
		}
	} else
		len += snprintf(buf + len, sizeof(buf) - len, "(no address)");
	/* len += snprintf(buf + len, sizeof(buf) - len, "\0"); */
	return buf;
}

void
print_addrs(int fd, char *add_ptr, size_t add_len)
{
	fprintf(stdout, "Stupid!\n");
}
#else				/* SCTP_VERSION_2 */
void
print_addr(char *add_ptr, size_t add_len)
{
	struct sockaddr_in *a = (struct sockaddr_in *) add_ptr;
	size_t anum = add_len / sizeof(*a);

	dummy = lockf(fileno(stdout), F_LOCK, 0);
	if (add_len > 0) {
		int i;

		if (add_len != anum * sizeof(*a))
			fprintf(stdout, "Aaarrg! add_len = %lu, anum = %lu, ", (ulong) add_len, (ulong) anum);
		fprintf(stdout, "[%d]", ntohs(a[0].sin_port));
		for (i = 0; i < anum; i++) {
			uint32_t addr = a[i].sin_addr.s_addr;

			fprintf(stdout, "%s%d.%d.%d.%d", i ? "," : "", (addr >> 0) & 0xff, (addr >> 8) & 0xff, (addr >> 16) & 0xff, (addr >> 24) & 0xff);
		}
	} else
		fprintf(stdout, "(no address)");
	fprintf(stdout, "\n");
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

char *
addr_string(char *add_ptr, size_t add_len)
{
	static char buf[128];
	size_t len = 0;
	struct sockaddr_in *a = (struct sockaddr_in *) add_ptr;
	size_t anum = add_len / sizeof(*a);

	if (add_len > 0) {
		int i;

		if (add_len != anum * sizeof(*a))
			len += snprintf(buf + len, sizeof(buf) - len, "Aaarrg! add_len = %lu, anum = %lu, ", (ulong) add_len, (ulong) anum);
		len += snprintf(buf + len, sizeof(buf) - len, "[%d]", ntohs(a[0].sin_port));
		for (i = 0; i < anum; i++) {
			uint32_t addr = a[i].sin_addr.s_addr;

			len += snprintf(buf + len, sizeof(buf) - len, "%s%d.%d.%d.%d", i ? "," : "", (addr >> 0) & 0xff, (addr >> 8) & 0xff, (addr >> 16) & 0xff, (addr >> 24) & 0xff);
		}
	} else
		len += snprintf(buf + len, sizeof(buf) - len, "(no address)");
	/* len += snprintf(buf + len, sizeof(buf) - len, "\0"); */
	return buf;
}
void print_string(int child, const char *string);
void
print_addrs(int child, char *add_ptr, size_t add_len)
{
	struct sockaddr_in *sin;

	if (verbose < 3)
		return;
	if (add_len == 0)
		print_string(child, "(no address)");
	for (sin = (typeof(sin)) add_ptr; add_len >= sizeof(*sin); sin++, add_len -= sizeof(*sin)) {
		char buf[128];

		snprintf(buf, sizeof(buf), "%d.%d.%d.%d:%d", (sin->sin_addr.s_addr >> 0) & 0xff, (sin->sin_addr.s_addr >> 8) & 0xff, (sin->sin_addr.s_addr >> 16) & 0xff, (sin->sin_addr.s_addr >> 24) & 0xff, ntohs(sin->sin_port));
		print_string(child, buf);
	}
}
#endif				/* SCTP_VERSION_2 */

#if 1
char *
status_string(struct t_opthdr *oh)
{
	switch (oh->status) {
	case 0:
		return (NULL);
	case T_SUCCESS:
		return ("T_SUCCESS");
	case T_FAILURE:
		return ("T_FAILURE");
	case T_PARTSUCCESS:
		return ("T_PARTSUCCESS");
	case T_READONLY:
		return ("T_READONLY");
	case T_NOTSUPPORT:
		return ("T_NOTSUPPORT");
	default:
	{
		static char buf[32];

		snprintf(buf, sizeof(buf), "(unknown status %ld)", (long) oh->status);
		return buf;
	}
	}
}

#ifndef T_ALLLEVELS
#define T_ALLLEVELS -1
#endif

char *
level_string(struct t_opthdr *oh)
{
	switch (oh->level) {
	case T_ALLLEVELS:
		return ("T_ALLLEVELS");
	case XTI_GENERIC:
		return ("XTI_GENERIC");
	case T_INET_IP:
		return ("T_INET_IP");
	case T_INET_UDP:
		return ("T_INET_UDP");
	case T_INET_TCP:
		return ("T_INET_TCP");
	case T_INET_SCTP:
		return ("T_INET_SCTP");
	default:
	{
		static char buf[32];

		snprintf(buf, sizeof(buf), "(unknown level %ld)", (long) oh->level);
		return buf;
	}
	}
}

char *
name_string(struct t_opthdr *oh)
{
	if (oh->name == T_ALLOPT)
		return ("T_ALLOPT");
	switch (oh->level) {
	case XTI_GENERIC:
		switch (oh->name) {
		case XTI_DEBUG:
			return ("XTI_DEBUG");
		case XTI_LINGER:
			return ("XTI_LINGER");
		case XTI_RCVBUF:
			return ("XTI_RCVBUF");
		case XTI_RCVLOWAT:
			return ("XTI_RCVLOWAT");
		case XTI_SNDBUF:
			return ("XTI_SNDBUF");
		case XTI_SNDLOWAT:
			return ("XTI_SNDLOWAT");
		}
		break;
	case T_INET_IP:
		switch (oh->name) {
		case T_IP_OPTIONS:
			return ("T_IP_OPTIONS");
		case T_IP_TOS:
			return ("T_IP_TOS");
		case T_IP_TTL:
			return ("T_IP_TTL");
		case T_IP_REUSEADDR:
			return ("T_IP_REUSEADDR");
		case T_IP_DONTROUTE:
			return ("T_IP_DONTROUTE");
		case T_IP_BROADCAST:
			return ("T_IP_BROADCAST");
		case T_IP_ADDR:
			return ("T_IP_ADDR");
		}
		break;
	case T_INET_UDP:
		switch (oh->name) {
		case T_UDP_CHECKSUM:
			return ("T_UDP_CHECKSUM");
		}
		break;
	case T_INET_TCP:
		switch (oh->name) {
		case T_TCP_NODELAY:
			return ("T_TCP_NODELAY");
		case T_TCP_MAXSEG:
			return ("T_TCP_MAXSEG");
		case T_TCP_KEEPALIVE:
			return ("T_TCP_KEEPALIVE");
		case T_TCP_CORK:
			return ("T_TCP_CORK");
		case T_TCP_KEEPIDLE:
			return ("T_TCP_KEEPIDLE");
		case T_TCP_KEEPINTVL:
			return ("T_TCP_KEEPINTVL");
		case T_TCP_KEEPCNT:
			return ("T_TCP_KEEPCNT");
		case T_TCP_SYNCNT:
			return ("T_TCP_SYNCNT");
		case T_TCP_LINGER2:
			return ("T_TCP_LINGER2");
		case T_TCP_DEFER_ACCEPT:
			return ("T_TCP_DEFER_ACCEPT");
		case T_TCP_WINDOW_CLAMP:
			return ("T_TCP_WINDOW_CLAMP");
		case T_TCP_INFO:
			return ("T_TCP_INFO");
		case T_TCP_QUICKACK:
			return ("T_TCP_QUICKACK");
		}
		break;
	case T_INET_SCTP:
		switch (oh->name) {
		case T_SCTP_NODELAY:
			return ("T_SCTP_NODELAY");
		case T_SCTP_CORK:
			return ("T_SCTP_CORK");
		case T_SCTP_PPI:
			return ("T_SCTP_PPI");
		case T_SCTP_SID:
			return ("T_SCTP_SID");
		case T_SCTP_SSN:
			return ("T_SCTP_SSN");
		case T_SCTP_TSN:
			return ("T_SCTP_TSN");
		case T_SCTP_RECVOPT:
			return ("T_SCTP_RECVOPT");
		case T_SCTP_COOKIE_LIFE:
			return ("T_SCTP_COOKIE_LIFE");
		case T_SCTP_SACK_DELAY:
			return ("T_SCTP_SACK_DELAY");
		case T_SCTP_PATH_MAX_RETRANS:
			return ("T_SCTP_PATH_MAX_RETRANS");
		case T_SCTP_ASSOC_MAX_RETRANS:
			return ("T_SCTP_ASSOC_MAX_RETRANS");
		case T_SCTP_MAX_INIT_RETRIES:
			return ("T_SCTP_MAX_INIT_RETRIES");
		case T_SCTP_HEARTBEAT_ITVL:
			return ("T_SCTP_HEARTBEAT_ITVL");
		case T_SCTP_RTO_INITIAL:
			return ("T_SCTP_RTO_INITIAL");
		case T_SCTP_RTO_MIN:
			return ("T_SCTP_RTO_MIN");
		case T_SCTP_RTO_MAX:
			return ("T_SCTP_RTO_MAX");
		case T_SCTP_OSTREAMS:
			return ("T_SCTP_OSTREAMS");
		case T_SCTP_ISTREAMS:
			return ("T_SCTP_ISTREAMS");
		case T_SCTP_COOKIE_INC:
			return ("T_SCTP_COOKIE_INC");
		case T_SCTP_THROTTLE_ITVL:
			return ("T_SCTP_THROTTLE_ITVL");
		case T_SCTP_MAC_TYPE:
			return ("T_SCTP_MAC_TYPE");
		case T_SCTP_CKSUM_TYPE:
			return ("T_SCTP_CKSUM_TYPE");
		case T_SCTP_ECN:
			return ("T_SCTP_ECN");
		case T_SCTP_ALI:
			return ("T_SCTP_ALI");
		case T_SCTP_ADD:
			return ("T_SCTP_ADD");
		case T_SCTP_SET:
			return ("T_SCTP_SET");
		case T_SCTP_ADD_IP:
			return ("T_SCTP_ADD_IP");
		case T_SCTP_DEL_IP:
			return ("T_SCTP_DEL_IP");
		case T_SCTP_SET_IP:
			return ("T_SCTP_SET_IP");
		case T_SCTP_PR:
			return ("T_SCTP_PR");
		case T_SCTP_LIFETIME:
			return ("T_SCTP_LIFETIME");
		case T_SCTP_DISPOSITION:
			return ("T_SCTP_DISPOSITION");
		case T_SCTP_MAX_BURST:
			return ("T_SCTP_MAX_BURST");
		case T_SCTP_HB:
			return ("T_SCTP_HB");
		case T_SCTP_RTO:
			return ("T_SCTP_RTO");
		case T_SCTP_MAXSEG:
			return ("T_SCTP_MAXSEG");
		case T_SCTP_STATUS:
			return ("T_SCTP_STATUS");
		case T_SCTP_DEBUG:
			return ("T_SCTP_DEBUG");
		}
		break;
	}
	{
		static char buf[32];

		snprintf(buf, sizeof(buf), "(unknown name %ld)", (long) oh->name);
		return buf;
	}
}

char *
yesno_string(struct t_opthdr *oh)
{
	switch (*((t_uscalar_t *) T_OPT_DATA(oh))) {
	case T_YES:
		return ("T_YES");
	case T_NO:
		return ("T_NO");
	default:
		return ("(invalid)");
	}
}

char *
number_string(struct t_opthdr *oh)
{
	static char buf[32];

	snprintf(buf, 32, "%d", *((t_scalar_t *) T_OPT_DATA(oh)));
	return (buf);
}

char *
value_string(int child, struct t_opthdr *oh)
{
	static char buf[64] = "(invalid)";

	if (oh->len == sizeof(*oh))
		return (NULL);
	switch (oh->level) {
	case XTI_GENERIC:
		switch (oh->name) {
		case XTI_DEBUG:
			break;
		case XTI_LINGER:
			break;
		case XTI_RCVBUF:
			break;
		case XTI_RCVLOWAT:
			break;
		case XTI_SNDBUF:
			break;
		case XTI_SNDLOWAT:
			break;
		}
		break;
	case T_INET_IP:
		switch (oh->name) {
		case T_IP_OPTIONS:
			break;
		case T_IP_TOS:
			if (oh->len == sizeof(*oh) + sizeof(unsigned char))
				snprintf(buf, sizeof(buf), "0x%02x", *((unsigned char *) T_OPT_DATA(oh)));
			return buf;
		case T_IP_TTL:
			if (oh->len == sizeof(*oh) + sizeof(unsigned char))
				snprintf(buf, sizeof(buf), "0x%02x", *((unsigned char *) T_OPT_DATA(oh)));
			return buf;
		case T_IP_REUSEADDR:
			return yesno_string(oh);
		case T_IP_DONTROUTE:
			return yesno_string(oh);
		case T_IP_BROADCAST:
			return yesno_string(oh);
		case T_IP_ADDR:
			if (oh->len == sizeof(*oh) + sizeof(uint32_t)) {
				uint32_t addr = *((uint32_t *) T_OPT_DATA(oh));

				snprintf(buf, sizeof(buf), "%d.%d.%d.%d", (addr >> 0) & 0x00ff, (addr >> 8) & 0x00ff, (addr >> 16) & 0x00ff, (addr >> 24) & 0x00ff);
			}
			return buf;
		}
		break;
	case T_INET_UDP:
		switch (oh->name) {
		case T_UDP_CHECKSUM:
			return yesno_string(oh);
		}
		break;
	case T_INET_TCP:
		switch (oh->name) {
		case T_TCP_NODELAY:
			return yesno_string(oh);
		case T_TCP_MAXSEG:
			if (oh->len == sizeof(*oh) + sizeof(t_uscalar_t))
				snprintf(buf, sizeof(buf), "%lu", (ulong) *((t_uscalar_t *) T_OPT_DATA(oh)));
			return buf;
		case T_TCP_KEEPALIVE:
			break;
		case T_TCP_CORK:
			return yesno_string(oh);
		case T_TCP_KEEPIDLE:
			break;
		case T_TCP_KEEPINTVL:
			break;
		case T_TCP_KEEPCNT:
			break;
		case T_TCP_SYNCNT:
			break;
		case T_TCP_LINGER2:
			break;
		case T_TCP_DEFER_ACCEPT:
			break;
		case T_TCP_WINDOW_CLAMP:
			break;
		case T_TCP_INFO:
			break;
		case T_TCP_QUICKACK:
			break;
		}
		break;
	case T_INET_SCTP:
		switch (oh->name) {
		case T_SCTP_NODELAY:
			return yesno_string(oh);
		case T_SCTP_CORK:
			return yesno_string(oh);
		case T_SCTP_PPI:
			return number_string(oh);;
		case T_SCTP_SID:
#if 1
			sid[child] = *((t_uscalar_t *) T_OPT_DATA(oh));
#endif
			return number_string(oh);;
		case T_SCTP_SSN:
		case T_SCTP_TSN:
			return number_string(oh);;
		case T_SCTP_RECVOPT:
			return yesno_string(oh);
		case T_SCTP_COOKIE_LIFE:
		case T_SCTP_SACK_DELAY:
		case T_SCTP_PATH_MAX_RETRANS:
		case T_SCTP_ASSOC_MAX_RETRANS:
		case T_SCTP_MAX_INIT_RETRIES:
		case T_SCTP_HEARTBEAT_ITVL:
		case T_SCTP_RTO_INITIAL:
		case T_SCTP_RTO_MIN:
		case T_SCTP_RTO_MAX:
		case T_SCTP_OSTREAMS:
		case T_SCTP_ISTREAMS:
		case T_SCTP_COOKIE_INC:
		case T_SCTP_THROTTLE_ITVL:
			return number_string(oh);;
		case T_SCTP_MAC_TYPE:
			break;
		case T_SCTP_CKSUM_TYPE:
			break;
		case T_SCTP_ECN:
			break;
		case T_SCTP_ALI:
			break;
		case T_SCTP_ADD:
			break;
		case T_SCTP_SET:
			break;
		case T_SCTP_ADD_IP:
			break;
		case T_SCTP_DEL_IP:
			break;
		case T_SCTP_SET_IP:
			break;
		case T_SCTP_PR:
			break;
		case T_SCTP_LIFETIME:
		case T_SCTP_DISPOSITION:
		case T_SCTP_MAX_BURST:
		case T_SCTP_HB:
		case T_SCTP_RTO:
		case T_SCTP_MAXSEG:
			return number_string(oh);
		case T_SCTP_STATUS:
			break;
		case T_SCTP_DEBUG:
			break;
		}
		break;
	}
	return ("(unknown value)");
}
#endif

#if 1
void
parse_options(int fd, char *opt_ptr, size_t opt_len)
{
	struct t_opthdr *oh;

	for (oh = _T_OPT_FIRSTHDR_OFS(opt_ptr, opt_len, 0); oh; oh = _T_OPT_NEXTHDR_OFS(opt_ptr, opt_len, oh, 0)) {
		if (oh->len == sizeof(*oh))
			continue;
		switch (oh->level) {
		case T_INET_SCTP:
			switch (oh->name) {
			case T_SCTP_PPI:
				ppi[fd] = *((t_uscalar_t *) T_OPT_DATA(oh));
				continue;
			case T_SCTP_SID:
				sid[fd] = *((t_uscalar_t *) T_OPT_DATA(oh));
				continue;
			case T_SCTP_SSN:
				ssn[fd] = *((t_uscalar_t *) T_OPT_DATA(oh));
				continue;
			case T_SCTP_TSN:
				tsn[fd] = *((t_uscalar_t *) T_OPT_DATA(oh));
				continue;
			}
		}
	}
}
#endif

char *
mgmtflag_string(t_uscalar_t flag)
{
	switch (flag) {
	case T_NEGOTIATE:
		return ("T_NEGOTIATE");
	case T_CHECK:
		return ("T_CHECK");
	case T_DEFAULT:
		return ("T_DEFAULT");
	case T_SUCCESS:
		return ("T_SUCCESS");
	case T_FAILURE:
		return ("T_FAILURE");
	case T_CURRENT:
		return ("T_CURRENT");
	case T_PARTSUCCESS:
		return ("T_PARTSUCCESS");
	case T_READONLY:
		return ("T_READONLY");
	case T_NOTSUPPORT:
		return ("T_NOTSUPPORT");
	}
	return "(unknown flag)";
}

#if 1
char *
size_string(t_uscalar_t size)
{
	static char buf[128];

	switch (size) {
	case T_INFINITE:
		return ("T_INFINITE");
	case T_INVALID:
		return ("T_INVALID");
	case T_UNSPEC:
		return ("T_UNSPEC");
	}
	snprintf(buf, sizeof(buf), "%lu", (ulong) size);
	return buf;
}
#endif

const char *
prim_string(t_uscalar_t prim)
{
	switch (prim) {
	case T_CONN_REQ:
		return ("T_CONN_REQ------");
	case T_CONN_RES:
		return ("T_CONN_RES------");
	case T_DISCON_REQ:
		return ("T_DISCON_REQ----");
	case T_DATA_REQ:
		return ("T_DATA_REQ------");
	case T_EXDATA_REQ:
		return ("T_EXDATA_REQ----");
	case T_INFO_REQ:
		return ("T_INFO_REQ------");
	case T_BIND_REQ:
		return ("T_BIND_REQ------");
	case T_UNBIND_REQ:
		return ("T_UNBIND_REQ----");
	case T_UNITDATA_REQ:
		return ("T_UNITDATA_REQ--");
	case T_OPTMGMT_REQ:
		return ("T_OPTMGMT_REQ---");
	case T_ORDREL_REQ:
		return ("T_ORDREL_REQ----");
	case T_OPTDATA_REQ:
		return ("T_OPTDATA_REQ---");
	case T_ADDR_REQ:
		return ("T_ADDR_REQ------");
	case T_CAPABILITY_REQ:
		return ("T_CAPABILITY_REQ");
	case T_CONN_IND:
		return ("T_CONN_IND------");
	case T_CONN_CON:
		return ("T_CONN_CON------");
	case T_DISCON_IND:
		return ("T_DISCON_IND----");
	case T_DATA_IND:
		return ("T_DATA_IND------");
	case T_EXDATA_IND:
		return ("T_EXDATA_IND----");
	case T_INFO_ACK:
		return ("T_INFO_ACK------");
	case T_BIND_ACK:
		return ("T_BIND_ACK------");
	case T_ERROR_ACK:
		return ("T_ERROR_ACK-----");
	case T_OK_ACK:
		return ("T_OK_ACK--------");
	case T_UNITDATA_IND:
		return ("T_UNITDATA_IND--");
	case T_UDERROR_IND:
		return ("T_UDERROR_IND---");
	case T_OPTMGMT_ACK:
		return ("T_OPTMGMT_ACK---");
	case T_ORDREL_IND:
		return ("T_ORDREL_IND----");
	case T_OPTDATA_IND:
		return ("T_OPTDATA_IND---");
	case T_ADDR_ACK:
		return ("T_ADDR_ACK------");
	case T_CAPABILITY_ACK:
		return ("T_CAPABILITY_ACK");
	default:
		return ("T_????_??? -----");
	}
}

char *
t_errno_string(t_scalar_t err, t_scalar_t syserr)
{
	switch (err) {
	case 0:
		return ("ok");
	case TBADADDR:
		return ("[TBADADDR]");
	case TBADOPT:
		return ("[TBADOPT]");
	case TACCES:
		return ("[TACCES]");
	case TBADF:
		return ("[TBADF]");
	case TNOADDR:
		return ("[TNOADDR]");
	case TOUTSTATE:
		return ("[TOUTSTATE]");
	case TBADSEQ:
		return ("[TBADSEQ]");
	case TSYSERR:
		return errno_string(syserr);
	case TLOOK:
		return ("[TLOOK]");
	case TBADDATA:
		return ("[TBADDATA]");
	case TBUFOVFLW:
		return ("[TBUFOVFLW]");
	case TFLOW:
		return ("[TFLOW]");
	case TNODATA:
		return ("[TNODATA]");
	case TNODIS:
		return ("[TNODIS]");
	case TNOUDERR:
		return ("[TNOUDERR]");
	case TBADFLAG:
		return ("[TBADFLAG]");
	case TNOREL:
		return ("[TNOREL]");
	case TNOTSUPPORT:
		return ("[TNOTSUPPORT]");
	case TSTATECHNG:
		return ("[TSTATECHNG]");
	case TNOSTRUCTYPE:
		return ("[TNOSTRUCTYPE]");
	case TBADNAME:
		return ("[TBADNAME]");
	case TBADQLEN:
		return ("[TBADQLEN]");
	case TADDRBUSY:
		return ("[TADDRBUSY]");
	case TINDOUT:
		return ("[TINDOUT]");
	case TPROVMISMATCH:
		return ("[TPROVMISMATCH]");
	case TRESQLEN:
		return ("[TRESQLEN]");
	case TRESADDR:
		return ("[TRESADDR]");
	case TQFULL:
		return ("[TQFULL]");
	case TPROTO:
		return ("[TPROTO]");
	default:
	{
		static char buf[32];

		snprintf(buf, sizeof(buf), "[%ld]", (long) err);
		return buf;
	}
	}
}

void
print_less(int child)
{
	if (verbose < 1 || !show)
		return;
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	switch (child) {
	case 0:
		fprintf(stdout, " .         .  <---->|               .               :  :                    \n");
		fprintf(stdout, " .  (more) .  <---->|               .               :  :                     [%d:%03d]\n", child, state);
		fprintf(stdout, " .         .  <---->|               .               :  :                    \n");
		break;
	case 1:
		fprintf(stdout, "                    :               .               :  |<-->  .         .   \n");
		fprintf(stdout, "                    :               .               :  |<-->  . (more)  .    [%d:%03d]\n", child, state);
		fprintf(stdout, "                    :               .               :  |<-->  .         .   \n");
		break;
	case 2:
		fprintf(stdout, "                    :               .               |<-:--->  .         .   \n");
		fprintf(stdout, "                    :               .               |<-:--->  . (more)  .    [%d:%03d]\n", child, state);
		fprintf(stdout, "                    :               .               |<-:--->  .         .   \n");
		break;
	}
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	show = 0;
	return;
}

void
print_more(void)
{
	show = 1;
}

void
print_simple(int child, const char *msgs[])
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child]);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_simple_int(int child, const char *msgs[], int val)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], val);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_double_int(int child, const char *msgs[], int val, int val2)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], val, val2);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_triple_int(int child, const char *msgs[], int val, int val2, int val3)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], val, val2, val3);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_simple_string(int child, const char *msgs[], const char *string)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], string);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_pipe(int child)
{
	static const char *msgs[] = {
		"  pipe()      ----->v  v<------------------------------>v                   \n",
		"                    v  v<------------------------------>v<-----     pipe()  \n",
		"                    .  .                                .                   \n",
	};

	if (verbose > 3)
		print_simple(child, msgs);
}

void
print_open(int child, const char *name)
{
	static const char *msgs[] = {
		"  open()      ----->v %-30.30s    .                   \n",
		"                    | %-30.30s    v<-----     open()  \n",
		"                    | %-30.30s v<-+------     open()  \n",
		"                    . %-30.30s .  .                   \n",
	};

	if (verbose > 3)
		print_simple_string(child, msgs, name);
}

void
print_close(int child)
{
	static const char *msgs[] = {
		"  close()     ----->X                                   |                   \n",
		"                    .                                   X<-----    close()  \n",
		"                    .                                X<-+------    close()  \n",
		"                    .                                .  .                   \n",
	};

	if (verbose > 3)
		print_simple(child, msgs);
}

void
print_preamble(int child)
{
	static const char *msgs[] = {
		"--------------------+-------------Preamble-----------+--+                   \n",
		"                    +-------------Preamble-----------+  +-------------------\n",
		"                    +-------------Preamble-----------+--+-------------------\n",
		"--------------------+-------------Preamble-----------+--+-------------------\n",
	};

	if (verbose > 0)
		print_simple(child, msgs);
}

void print_string_state(int child, const char *msgs[], const char *string);

void
print_failure(int child, const char *string)
{
	static const char *msgs[] = {
		"....................|%-32s|..|                    [%d:%03d]\n",
		"                    |%-32s|  |................... [%d:%03d]\n",
		"                    |%-32s|...................... [%d:%03d]\n",
		"....................|%-32s|..|................... [%d:%03d]\n",
	};

	if (string && strnlen(string, 32) > 0 && verbose > 0)
		print_string_state(child, msgs, string);
}

void
print_notapplicable(int child)
{
	static const char *msgs[] = {
		"X-X-X-X-X-X-X-X-X-X-|X-X-X-X-X NOT APPLICABLE -X-X-X-|X-|                    [%d:%03d]\n",
		"                    |X-X-X-X-X NOT APPLICABLE -X-X-X-|  |X-X-X-X-X-X-X-X-X-X [%d:%03d]\n",
		"                    |X-X-X-X-X NOT APPLICABLE -X-X-X-|X-|X-X-X-X-X-X-X-X-X-X [%d:%03d]\n",
		"X-X-X-X-X-X-X-X-X-X-|X-X-X-X-X NOT APPLICABLE -X-X-X-|X-|X-X-X-X-X-X-X-X-X-X [%d:%03d]\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, state);
	print_failure(child, failure_string);
}

void
print_skipped(int child)
{
	static const char *msgs[] = {
		"::::::::::::::::::::|:::::::::::: SKIPPED :::::::::::|::|                    [%d:%03d]\n",
		"                    |:::::::::::: SKIPPED :::::::::::|  |::::::::::::::::::: [%d:%03d]\n",
		"                    |:::::::::::: SKIPPED :::::::::::|::|::::::::::::::::::: [%d:%03d]\n",
		"::::::::::::::::::::|:::::::::::: SKIPPED :::::::::::|::|::::::::::::::::::: [%d:%03d]\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, state);
	print_failure(child, failure_string);
}

void
print_inconclusive(int child)
{
	static const char *msgs[] = {
		"????????????????????|?????????? INCONCLUSIVE ????????|??|                    [%d:%03d]\n",
		"                    |?????????? INCONCLUSIVE ????????|  |??????????????????? [%d:%03d]\n",
		"                    |?????????? INCONCLUSIVE ????????|??|??????????????????? [%d:%03d]\n",
		"????????????????????|?????????? INCONCLUSIVE ????????|??|??????????????????? [%d:%03d]\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, state);
	print_failure(child, failure_string);
}

void
print_test(int child)
{
	static const char *msgs[] = {
		"--------------------+---------------Test-------------+--+                   \n",
		"                    +---------------Test-------------+  +-------------------\n",
		"                    +---------------Test-------------+--+-------------------\n",
		"--------------------+---------------Test-------------+--+-------------------\n",
	};

	if (verbose > 0)
		print_simple(child, msgs);
}

void
print_failed(int child)
{
	static const char *msgs[] = {
		"XXXXXXXXXXXXXXXXXXXX|XXXXXXXXXXXXX FAILED XXXXXXXXXXX|XX|                    [%d:%03d]\n",
		"                    |XXXXXXXXXXXXX FAILED XXXXXXXXXXX|  |XXXXXXXXXXXXXXXXXXX [%d:%03d]\n",
		"                    |XXXXXXXXXXXXX FAILED XXXXXXXXXXX|XX|XXXXXXXXXXXXXXXXXXX [%d:%03d]\n",
		"XXXXXXXXXXXXXXXXXXXX|XXXXXXXXXXXXX FAILED XXXXXXXXXXX|XX|XXXXXXXXXXXXXXXXXXX [%d:%03d]\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, state);
	print_failure(child, failure_string);
}

void
print_script_error(int child)
{
	static const char *msgs[] = {
		"####################|########### SCRIPT ERROR #######|##|                    [%d:%03d]\n",
		"                    |########### SCRIPT ERROR #######|  |################### [%d:%03d]\n",
		"                    |########### SCRIPT ERROR #######|##|################### [%d:%03d]\n",
		"####################|########### SCRIPT ERROR #######|##|################### [%d:%03d]\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, state);
	print_failure(child, failure_string);
}

void
print_passed(int child)
{
	static const char *msgs[] = {
		"********************|************* PASSED ***********|**|                    [%d:%03d]\n",
		"                    |************* PASSED ***********|  |******************* [%d:%03d]\n",
		"                    |************* PASSED ***********|**|******************* [%d:%03d]\n",
		"********************|************* PASSED ***********|**|******************* [%d:%03d]\n",
	};

	if (verbose > 2)
		print_double_int(child, msgs, child, state);
	print_failure(child, failure_string);
}

void
print_postamble(int child)
{
	static const char *msgs[] = {
		"--------------------+-------------Postamble----------+--+                   \n",
		"                    +-------------Postamble----------+  +-------------------\n",
		"                    +-------------Postamble----------+--+-------------------\n",
		"--------------------+-------------Postamble----------+--+-------------------\n",
	};

	if (verbose > 0)
		print_simple(child, msgs);
}

void
print_test_end(int child)
{
	static const char *msgs[] = {
		"--------------------+--------------------------------+--+                   \n",
		"                    +--------------------------------+  +-------------------\n",
		"                    +--------------------------------+--+-------------------\n",
		"--------------------+--------------------------------+--+-------------------\n",
	};

	if (verbose > 0)
		print_simple(child, msgs);
}

void
print_terminated(int child, int signal)
{
	static const char *msgs[] = {
		"@@@@@@@@@@@@@@@@@@@@|@@@@@@@@@@@ TERMINATED @@@@@@@@@|@@|                    {%d:%03d}\n",
		"                    |@@@@@@@@@@@ TERMINATED @@@@@@@@@|  |@@@@@@@@@@@@@@@@@@@ {%d:%03d}\n",
		"                    |@@@@@@@@@@@ TERMINATED @@@@@@@@@|@@|@@@@@@@@@@@@@@@@@@@ {%d:%03d}\n",
		"@@@@@@@@@@@@@@@@@@@@|@@@@@@@@@@@ TERMINATED @@@@@@@@@|@@|@@@@@@@@@@@@@@@@@@@ {%d:%03d}\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, signal);
}

void
print_stopped(int child, int signal)
{
	static const char *msgs[] = {
		"&&&&&&&&&&&&&&&&&&&&|&&&&&&&&&&&& STOPPED &&&&&&&&&&&|&&|                    {%d:%03d}\n",
		"                    |&&&&&&&&&&&& STOPPED &&&&&&&&&&&|  |&&&&&&&&&&&&&&&&&&& {%d:%03d}\n",
		"                    |&&&&&&&&&&&& STOPPED &&&&&&&&&&&|&&|&&&&&&&&&&&&&&&&&&& {%d:%03d}\n",
		"&&&&&&&&&&&&&&&&&&&&|&&&&&&&&&&&& STOPPED &&&&&&&&&&&|&&|&&&&&&&&&&&&&&&&&&& {%d:%03d}\n",
	};

	if (verbose > 0)
		print_double_int(child, msgs, child, signal);
}

void
print_timeout(int child)
{
	static const char *msgs[] = {
		"++++++++++++++++++++|++++++++++++ TIMEOUT! ++++++++++|++|                    [%d:%03d]\n",
		"                    |++++++++++++ TIMEOUT! ++++++++++|  |+++++++++++++++++++ [%d:%03d]\n",
		"                    |++++++++++++ TIMEOUT! ++++++++++|++|+++++++++++++++++++ [%d:%03d]\n",
		"++++++++++++++++++++|++++++++++++ TIMEOUT! ++++++++++|++|+++++++++++++++++++ [%d:%03d]\n",
	};

	if (show_timeout || verbose > 0) {
		print_double_int(child, msgs, child, state);
		show_timeout--;
	}
}

void
print_nothing(int child)
{
	static const char *msgs[] = {
		"- - - - - - - - - - |- - - - - - -nothing! - - - - - |  |                    [%d:%03d]\n",
		"                    |- - - - - - -nothing! - - - - - |  |- - - - - - - - - - [%d:%03d]\n",
		"                    |- - - - - - -nothing! - - - - - | -|- - - - - - - - - - [%d:%03d]\n",
		"- - - - - - - - - - |- - - - - - -nothing! - - - - - | -|- - - - - - - - - - [%d:%03d]\n",
	};

	if (verbose > 1)
		print_double_int(child, msgs, child, state);
}

void
print_string_state(int child, const char *msgs[], const char *string)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], string, child, state);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_syscall(int child, const char *command)
{
	static const char *msgs[] = {
		"%-14s----->|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |<---%-14s  [%d:%03d]\n",
		"                    |                                |<-+----%-14s  [%d:%03d]\n",
		"                    |          %-14s        |  |                    [%d:%03d]\n",
	};

	if (verbose > 4)
		print_string_state(child, msgs, command);
}

void
print_tx_prim(int child, const char *command)
{
	static const char *msgs[] = {
		"--%16s->|- - - - - - - - - - - - - - - ->|->|                    [%d:%03d]\n",
		"                    |<- - - - - - - - - - - - - - - -|- |<-%16s- [%d:%03d]\n",
		"                    |<- - - - - - - - - - - - - - - -|<----%16s- [%d:%03d]\n",
		"                    |                                |  |                    [%d:%03d]\n",
	};

	if (verbose > 0)
		print_string_state(child, msgs, command);
}

void
print_rx_prim(int child, const char *command)
{
	static const char *msgs[] = {
		"<-%16s--|<- - - - - - - - - - - - - - - -| -|                    [%d:%03d]\n",
		"                    |- - - - - - - - - - - - - - - ->|  |--%16s> [%d:%03d]\n",
		"                    |- - - - - - - - - - - - - - - ->|--+--%16s> [%d:%03d]\n",
		"                    |         <%16s>     |  |                    [%d:%03d]\n",
	};

	if (verbose > 0)
		print_string_state(child, msgs, command);
}

void
print_ack_prim(int child, const char *command)
{
	static const char *msgs[] = {
		"<-%16s-/|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |\\-%16s> [%d:%03d]\n",
		"                    |                                |\\-+--%16s> [%d:%03d]\n",
		"                    |         <%16s>     |  |                    [%d:%03d]\n",
	};

	if (verbose > 0)
		print_string_state(child, msgs, command);
}

void
print_long_state(int child, const char *msgs[], long value)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], value, child, state);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_no_prim(int child, long prim)
{
	static const char *msgs[] = {
		"????%4ld????  ?----?|?- - - - - - -?                |  |                     [%d:%03d]\n",
		"                    |                               |  |?--? ????%4ld????    [%d:%03d]\n",
		"                    |                               |?-+---? ????%4ld????    [%d:%03d]\n",
		"                    | ? - - - - - - %4ld  - - - - ? |  |                     [%d:%03d]\n",
	};

	if (verbose > 0)
		print_long_state(child, msgs, prim);
}

void
print_string_int_state(int child, const char *msgs[], const char *string, int val)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], string, val, child, state);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_tx_data(int child, const char *command, size_t bytes)
{
	static const char *msgs[] = {
		"--%1$16s->|- -%2$5d bytes- - - - - - - - ->|- |                    [%3$d:%4$03d]\n",
		"                    |< -%2$5d bytes- - - - - - - - - |  |<-%1$16s- [%3$d:%4$03d]\n",
		"                    |< -%2$5d bytes- - - - - - - - - |- |<-%1$16s- [%3$d:%4$03d]\n",
		"                    |- -%2$5d bytes %1$16s |  |                    [%3$d:%4$03d]\n",
	};

	if ((verbose && show) || verbose > 4)
		print_string_int_state(child, msgs, command, bytes);
}

void
print_rx_data(int child, const char *command, size_t bytes)
{
	static const char *msgs[] = {
		"<-%1$16s--|<- %2$5d bytes- - - - - - - - - |- |                    [%3$d:%4$03d]\n",
		"                    |- -%2$5d bytes- - - - - - - - ->|  |--%1$16s> [%3$d:%4$03d]\n",
		"                    |- -%2$5d bytes- - - - - - - - - |->|--%1$16s> [%3$d:%4$03d]\n",
		"                    |- -%2$5d bytes %1$16s |  |                    [%3$d:%4$03d]\n",
	};

	if ((verbose && show) || verbose > 4)
		print_string_int_state(child, msgs, command, bytes);
}

void
print_errno(int child, long error)
{
	static const char *msgs[] = {
		"  %-14s<--/|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |\\-->%14s  [%d:%03d]\n",
		"                    |                                |\\-+--->%14s  [%d:%03d]\n",
		"                    |          [%14s]      |  |                    [%d:%03d]\n",
	};

	if (verbose > 4)
		print_string_state(child, msgs, errno_string(error));
}

void
print_success(int child)
{
	static const char *msgs[] = {
		"  ok          <----/|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |\\---->         ok   [%d:%03d]\n",
		"                    |                                |\\-+----->         ok   [%d:%03d]\n",
		"                    |                 ok             |  |                    [%d:%03d]\n",
	};

	if (verbose > 4)
		print_double_int(child, msgs, child, state);
}

void
print_success_value(int child, int value)
{
	static const char *msgs[] = {
		"  %10d  <----/|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |\\---->  %10d  [%d:%03d]\n",
		"                    |                                |\\-+----->  %10d  [%d:%03d]\n",
		"                    |            [%10d]        |  |                    [%d:%03d]\n",
	};

	if (verbose > 4)
		print_triple_int(child, msgs, value, child, state);
}

void
print_ti_ioctl(int child, int cmd, intptr_t arg)
{
	static const char *msgs[] = {
		"--ioctl(2)--------->|       %16s         |  |                    [%d:%03d]\n",
		"                    |       %16s         |  |<---ioctl(2)------  [%d:%03d]\n",
		"                    |       %16s         |<-+----ioctl(2)------  [%d:%03d]\n",
		"                    |       %16s ioctl(2)|  |                    [%d:%03d]\n",
	};

	if (verbose > 0)
		print_string_state(child, msgs, ioctl_string(cmd, arg));
}

void
print_ioctl(int child, int cmd, intptr_t arg)
{
	if (verbose > 4)
		print_ti_ioctl(child, cmd, arg);
}

void
print_datcall(int child, const char *command, size_t bytes)
{
	static const char *msgs[] = {
		"  %1$16s->|- -%2$5d bytes- - - - - - - - ->|->|                    [%3$d:%4$03d]\n",
		"                    |< -%2$5d bytes- - - - - - - - - |- |<-%1$16s  [%3$d:%4$03d]\n",
		"                    |< -%2$5d bytes- - - - - - - - - |<-+--%1$16s  [%3$d:%4$03d]\n",
		"                    |- -%2$5d bytes %1$16s |  |                    [%3$d:%4$03d]\n",
	};

	if (verbose > 4)
		print_string_int_state(child, msgs, command, bytes);
}

void
print_libcall(int child, const char *command)
{
	static const char *msgs[] = {
		"  %-16s->|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |<-%16s  [%d:%03d]\n",
		"                    |                                |<-+--%16s  [%d:%03d]\n",
		"                    |        [%16s]      |  |                    [%d:%03d]\n",
	};

	if (verbose > 0)
		print_string_state(child, msgs, command);
}

#if 1
void
print_terror(int child, long error, long terror)
{
	static const char *msgs[] = {
		"  %-14s<--/|                                |  |                    [%d:%03d]\n",
		"                    |                                |  |\\-->%14s  [%d:%03d]\n",
		"                    |                                |\\-+--->%14s  [%d:%03d]\n",
		"                    |          [%14s]      |  |                    [%d:%03d]\n",
	};

	if (verbose > 0)
		print_string_state(child, msgs, t_errno_string(terror, error));
}
#endif

void
print_expect(int child, int want)
{
	static const char *msgs[] = {
		" (%-16s) |- - - - - -[Expected]- - - - - -|  |                    [%d:%03d]\n",
		"                    |- - - - - -[Expected]- - - - - -|  | (%-16s) [%d:%03d]\n",
		"                    |- - - - - -[Expected]- - - - - -|- | (%-16s) [%d:%03d]\n",
		"                    |- [Expected %-16s ] -|- |                    [%d:%03d]\n",
	};

	if ((verbose && show) || verbose > 4)
		print_string_state(child, msgs, event_string(want));
}

void
print_string(int child, const char *string)
{
	static const char *msgs[] = {
		"%-20s|                                |  |                    \n",
		"                    |                                |  |%-20s\n",
		"                    |                                |   %-20s\n",
		"                    |       %-20s     |  |                    \n",
	};

	if ((verbose && show) || verbose > 4)
		print_simple_string(child, msgs, string);
}

void
print_time_state(int child, const char *msgs[], ulong time)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], time, child, state);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_waiting(int child, ulong time)
{
	static const char *msgs[] = {
		"/ / / / / / / / / / | / / / Waiting %03lu seconds / / /|  |                    [%d:%03d]\n",
		"                    | / / / Waiting %03lu seconds / / /|  | / / / / / / / / /  [%d:%03d]\n",
		"                    | / / / Waiting %03lu seconds / / /|/ | / / / / / / / / /  [%d:%03d]\n",
		"/ / / / / / / / / / | / / / Waiting %03lu seconds / / /|/ | / / / / / / / / /  [%d:%03d]\n",
	};

	if ((verbose && show) || verbose > 4)
		print_time_state(child, msgs, time);
}

void
print_float_state(int child, const char *msgs[], float time)
{
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, msgs[child], time, child, state);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

void
print_mwaiting(int child, struct timespec *time)
{
	static const char *msgs[] = {
		"/ / / / / / / / / / | / / Waiting %8.4f seconds / |  |                    [%d:%03d]\n",
		"                    | / / Waiting %8.4f seconds / |  | / / / / / / / / /  [%d:%03d]\n",
		"                    | / / Waiting %8.4f seconds / |/ | / / / / / / / / /  [%d:%03d]\n",
		"/ / / / / / / / / / | / / Waiting %8.4f seconds / |/ | / / / / / / / / /  [%d:%03d]\n",
	};

	if ((verbose && show) || verbose > 4) {
		float delay;

		delay = time->tv_nsec;
		delay = delay / 1000000000;
		delay = delay + time->tv_sec;
		print_float_state(child, msgs, delay);
	}
}

void
print_mgmtflag(int child, t_uscalar_t flag)
{
	print_string(child, mgmtflag_string(flag));
}

#if 1
void
print_opt_level(int child, struct t_opthdr *oh)
{
	char *level = level_string(oh);

	if (level)
		print_string(child, level);
}

void
print_opt_name(int child, struct t_opthdr *oh)
{
	char *name = name_string(oh);

	if (name)
		print_string(child, name);
}

void
print_opt_status(int child, struct t_opthdr *oh)
{
	char *status = status_string(oh);

	if (status)
		print_string(child, status);
}

void
print_opt_length(int child, struct t_opthdr *oh)
{
	int len = oh->len - sizeof(*oh);

	if (len) {
		char buf[32];

		snprintf(buf, sizeof(buf), "(len=%d)", len);
		print_string(child, buf);
	}
}
void
print_opt_value(int child, struct t_opthdr *oh)
{
	char *value = value_string(child, oh);

	if (value)
		print_string(child, value);
}
#endif

void
print_options(int child, const char *cmd_buf, size_t opt_ofs, size_t opt_len)
{
	struct t_opthdr *oh;
	const char *opt_ptr = cmd_buf + opt_ofs;
	char buf[64];

	if (verbose < 4)
		return;
	if (opt_len == 0) {
		snprintf(buf, sizeof(buf), "(no options)");
		print_string(child, buf);
		return;
	}
	snprintf(buf, sizeof(buf), "opt len = %lu", (ulong) opt_len);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "opt ofs = %lu", (ulong) opt_ofs);
	print_string(child, buf);
	oh = _T_OPT_FIRSTHDR_OFS(opt_ptr, opt_len, 0);
	if (oh) {
		for (; oh; oh = _T_OPT_NEXTHDR_OFS(opt_ptr, opt_len, oh, 0)) {
			int len = oh->len - sizeof(*oh);

			print_opt_level(child, oh);
			print_opt_name(child, oh);
			print_opt_status(child, oh);
			print_opt_length(child, oh);
			if (len < 0)
				break;
			print_opt_value(child, oh);
		}
	} else {
		oh = (typeof(oh)) opt_ptr;
		print_opt_level(child, oh);
		print_opt_name(child, oh);
		print_opt_status(child, oh);
		print_opt_length(child, oh);
	}
}

void
print_info(int child, struct T_info_ack *info)
{
	char buf[64];

	if (verbose < 4)
		return;
	snprintf(buf, sizeof(buf), "TSDU  = %ld", (long) info->TSDU_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "ETSDU = %ld", (long) info->ETSDU_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "CDATA = %ld", (long) info->CDATA_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "DDATA = %ld", (long) info->DDATA_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "ADDR  = %ld", (long) info->ADDR_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "OPT   = %ld", (long) info->OPT_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "TIDU  = %ld", (long) info->TIDU_size);
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "<%s>", service_type(info->SERV_type));
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "<%s>", state_string(info->CURRENT_state));
	print_string(child, buf);
	snprintf(buf, sizeof(buf), "PROV  = %ld", (long) info->PROVIDER_flag);
	print_string(child, buf);
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Driver actions.
 *
 *  -------------------------------------------------------------------------
 */
int
test_ioctl(int child, int cmd, intptr_t arg)
{
	print_ioctl(child, cmd, arg);
	for (;;) {
		if ((last_retval = ioctl(test_fd[child], cmd, arg)) == -1) {
			print_errno(child, (last_errno = errno));
			if (last_errno == EINTR || last_errno == ERESTART)
				continue;
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		return (__RESULT_SUCCESS);
	}
}

int
test_insertfd(int child, int resfd, int offset, struct strbuf *ctrl, struct strbuf *data, int flags)
{
	struct strfdinsert fdi;

	if (ctrl) {
		fdi.ctlbuf.maxlen = ctrl->maxlen;
		fdi.ctlbuf.len = ctrl->len;
		fdi.ctlbuf.buf = ctrl->buf;
	} else {
		fdi.ctlbuf.maxlen = -1;
		fdi.ctlbuf.len = 0;
		fdi.ctlbuf.buf = NULL;
	}
	if (data) {
		fdi.databuf.maxlen = data->maxlen;
		fdi.databuf.len = data->len;
		fdi.databuf.buf = data->buf;
	} else {
		fdi.databuf.maxlen = -1;
		fdi.databuf.len = 0;
		fdi.databuf.buf = NULL;
	}
	fdi.flags = flags;
	fdi.fildes = resfd;
	fdi.offset = offset;
	if (verbose > 4) {
		int i;

		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "fdinsert to %d: [%d,%d]\n", child, ctrl ? ctrl->len : -1, data ? data->len : -1);
		fprintf(stdout, "[");
		for (i = 0; i < (ctrl ? ctrl->len : 0); i++)
			fprintf(stdout, "%02X", ctrl->buf[i]);
		fprintf(stdout, "]\n");
		fprintf(stdout, "[");
		for (i = 0; i < (data ? data->len : 0); i++)
			fprintf(stdout, "%02X", data->buf[i]);
		fprintf(stdout, "]\n");
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	if (test_ioctl(child, I_FDINSERT, (intptr_t) & fdi) != __RESULT_SUCCESS)
		return __RESULT_FAILURE;
	return __RESULT_SUCCESS;
}

int
test_putpmsg(int child, struct strbuf *ctrl, struct strbuf *data, int band, int flags)
{
	if (flags & MSG_BAND || band) {
		if (verbose > 4) {
			int i;

			dummy = lockf(fileno(stdout), F_LOCK, 0);
			fprintf(stdout, "putpmsg to %d: [%d,%d]\n", child, ctrl ? ctrl->len : -1, data ? data->len : -1);
			fprintf(stdout, "[");
			for (i = 0; i < (ctrl ? ctrl->len : 0); i++)
				fprintf(stdout, "%02X", ctrl->buf[i]);
			fprintf(stdout, "]\n");
			fprintf(stdout, "[");
			for (i = 0; i < (data ? data->len : 0); i++)
				fprintf(stdout, "%02X", data->buf[i]);
			fprintf(stdout, "]\n");
			fflush(stdout);
			dummy = lockf(fileno(stdout), F_ULOCK, 0);
		}
		if (ctrl == NULL || data != NULL)
			print_datcall(child, "putpmsg(2)----", data ? data->len : 0);
		for (;;) {
			if ((last_retval = putpmsg(test_fd[child], ctrl, data, band, flags)) == -1) {
				if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
					continue;
				print_errno(child, (last_errno = errno));
				return (__RESULT_FAILURE);
			}
			print_success_value(child, last_retval);
			return (__RESULT_SUCCESS);
		}
	} else {
		if (verbose > 5) {
			dummy = lockf(fileno(stdout), F_LOCK, 0);
			fprintf(stdout, "putmsg to %d: [%d,%d]\n", child, ctrl ? ctrl->len : -1, data ? data->len : -1);
			dummy = lockf(fileno(stdout), F_ULOCK, 0);
			fflush(stdout);
		}
		if (ctrl == NULL || data != NULL)
			print_datcall(child, "putmsg(2)-----", data ? data->len : 0);
		for (;;) {
			if ((last_retval = putmsg(test_fd[child], ctrl, data, flags)) == -1) {
				if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
					continue;
				print_errno(child, (last_errno = errno));
				return (__RESULT_FAILURE);
			}
			print_success_value(child, last_retval);
			return (__RESULT_SUCCESS);
		}
	}
}

int
test_write(int child, const void *buf, size_t len)
{
	print_syscall(child, "write(2)------");
	for (;;) {
		if ((last_retval = write(test_fd[child], buf, len)) == -1) {
			if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
				continue;
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_writev(int child, const struct iovec *iov, int num)
{
	print_syscall(child, "writev(2)-----");
	for (;;) {
		if ((last_retval = writev(test_fd[child], iov, num)) == -1) {
			if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
				continue;
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_getmsg(int child, struct strbuf *ctrl, struct strbuf *data, int *flagp)
{
	print_syscall(child, "getmsg(2)-----");
	for (;;) {
		if ((last_retval = getmsg(test_fd[child], ctrl, data, flagp)) == -1) {
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_getpmsg(int child, struct strbuf *ctrl, struct strbuf *data, int *bandp, int *flagp)
{
	print_syscall(child, "getpmsg(2)----");
	for (;;) {
		if ((last_retval = getpmsg(test_fd[child], ctrl, data, bandp, flagp)) == -1) {
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_read(int child, void *buf, size_t count)
{
	print_syscall(child, "read(2)-------");
	for (;;) {
		if ((last_retval = read(test_fd[child], buf, count)) == -1) {
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_readv(int child, const struct iovec *iov, int count)
{
	print_syscall(child, "readv(2)------");
	for (;;) {
		if ((last_retval = readv(test_fd[child], iov, count)) == -1) {
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_ti_ioctl(int child, int cmd, intptr_t arg)
{
	int tpi_error;

	if (cmd == I_STR && verbose > 4) {
		struct strioctl *icp = (struct strioctl *) arg;

		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "ioctl from %d: cmd=%d, timout=%d, len=%d, dp=%p\n", child, icp->ic_cmd, icp->ic_timout, icp->ic_len, icp->ic_dp);
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	print_ti_ioctl(child, cmd, arg);
	for (;;) {
		if ((last_retval = ioctl(test_fd[child], cmd, arg)) == -1) {
			print_errno(child, (last_errno = errno));
			if (last_errno == EINTR || last_errno == ERESTART)
				continue;
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	if (cmd == I_STR && verbose > 4) {
		struct strioctl *icp = (struct strioctl *) arg;

		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "got ioctl from %d: cmd=%d, timout=%d, len=%d, dp=%p\n", child, icp->ic_cmd, icp->ic_timout, icp->ic_len, icp->ic_dp);
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	if (last_retval == 0)
		return __RESULT_SUCCESS;
	tpi_error = last_retval & 0x00ff;
	if (tpi_error == TSYSERR)
		last_errno = (last_retval >> 8) & 0x00ff;
	else
		last_errno = 0;
	if (verbose) {
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "***************ERROR: ioctl failed\n");
		if (verbose > 3)
			fprintf(stdout, "                    : %s; result = %d\n", __FUNCTION__, last_retval);
		fprintf(stdout, "                    : %s; TPI error = %d\n", __FUNCTION__, tpi_error);
		if (tpi_error == TSYSERR)
			fprintf(stdout, "                    : %s; %s\n", __FUNCTION__, strerror(last_errno));
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
		fflush(stdout);
	}
	return (__RESULT_FAILURE);
}

int
test_nonblock(int child)
{
	long flags;

	print_syscall(child, "fcntl(2)------");
	for (;;) {
		if ((flags = last_retval = fcntl(test_fd[child], F_GETFL)) == -1) {
			print_errno(child, (last_errno = errno));
			if (last_errno == EINTR || last_errno == ERESTART)
				continue;
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	print_syscall(child, "fcntl(2)------");
	for (;;) {
		if ((last_retval = fcntl(test_fd[child], F_SETFL, flags | O_NONBLOCK)) == -1) {
			print_errno(child, (last_errno = errno));
			if (last_errno == EINTR || last_errno == ERESTART)
				continue;
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_block(int child)
{
	long flags;

	print_syscall(child, "fcntl(2)------");
	for (;;) {
		if ((flags = last_retval = fcntl(test_fd[child], F_GETFL)) == -1) {
			print_errno(child, (last_errno = errno));
			if (last_errno == EINTR || last_errno == ERESTART)
				continue;
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	print_syscall(child, "fcntl(2)------");
	for (;;) {
		if ((last_retval = fcntl(test_fd[child], F_SETFL, flags & ~O_NONBLOCK)) == -1) {
			print_errno(child, (last_errno = errno));
			if (last_errno == EINTR || last_errno == ERESTART)
				continue;
			return (__RESULT_FAILURE);
		}
		print_success_value(child, last_retval);
		break;
	}
	return (__RESULT_SUCCESS);
}

int
test_isastream(int child)
{
	int result;

	print_syscall(child, "isastream(2)--");
	if ((result = last_retval = isastream(test_fd[child])) == -1) {
		print_errno(child, (last_errno = errno));
		return (__RESULT_FAILURE);
	}
	print_success_value(child, last_retval);
	return (__RESULT_SUCCESS);
}

#if 0
int
test_poll(int child, const short events, short *revents, long ms)
{
	struct pollfd pfd = { .fd = test_fd[child], .events = events, .revents = 0 };
	int result;

	print_poll(child, events);
	if ((result = last_retval = poll(&pfd, 1, ms)) == -1) {
		print_errno(child, (last_errno = errno));
		return (__RESULT_FAILURE);
	}
	print_poll_value(child, last_retval, pfd.revents);
	if (last_retval == 1 && revents)
		*revents = pfd.revents;
	return (__RESULT_SUCCESS);
}
#endif

int
test_pipe(int child)
{
	int fds[2];

	for (;;) {
		print_pipe(child);
		if (pipe(fds) >= 0) {
			test_fd[child + 0] = fds[0];
			test_fd[child + 1] = fds[1];
			print_success(child);
			return (__RESULT_SUCCESS);
		}
		if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
			continue;
		print_errno(child, (last_errno = errno));
		return (__RESULT_FAILURE);
	}
}

int
test_fopen(int child, const char *name, int flags)
{
	int fd;

	print_open(child, name);
	if ((fd = open(name, flags)) >= 0) {
		print_success(child);
		return (fd);
	}
	print_errno(child, (last_errno = errno));
	return (fd);
}

int
test_fclose(int child, int fd)
{
	print_close(child);
	if (close(fd) >= 0) {
		print_success(child);
		return __RESULT_SUCCESS;
	}
	print_errno(child, (last_errno = errno));
	return __RESULT_FAILURE;
}

int
test_open(int child, const char *name, int flags)
{
	int fd;

	for (;;) {
		print_open(child, name);
		if ((fd = open(name, flags)) >= 0) {
			test_fd[child] = fd;
			print_success(child);
			return (__RESULT_SUCCESS);
		}
		if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
			continue;
		print_errno(child, (last_errno = errno));
		return (__RESULT_FAILURE);
	}
}

int
test_close(int child)
{
	int fd = test_fd[child];

	test_fd[child] = 0;
	for (;;) {
		print_close(child);
		if (close(fd) >= 0) {
			print_success(child);
			return __RESULT_SUCCESS;
		}
		if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
			continue;
		print_errno(child, (last_errno = errno));
		return __RESULT_FAILURE;
	}
}

int
test_push(int child, const char *name)
{
	if (test_ioctl(child, I_PUSH, (intptr_t) name) != __RESULT_SUCCESS)
		return __RESULT_FAILURE;
	return __RESULT_SUCCESS;
}

int
test_pop(int child)
{
	if (test_ioctl(child, I_POP, (intptr_t) 0) != __RESULT_SUCCESS)
		return __RESULT_FAILURE;
	return __RESULT_SUCCESS;
}

/*
 *  -------------------------------------------------------------------------
 *
 *  STREAM Initialization
 *
 *  -------------------------------------------------------------------------
 */

static int
stream_start(int child, int index)
{
	int offset = 3 * index;
	int i;

	for (i = 0; i < anums[3]; i++) {
#ifndef SCTP_VERSION_2
		addrs[3].port = htons(ports[3] + offset);
		inet_aton(addr_strings[i], &addrs[child].addr[i]);
#else				/* SCTP_VERSION_2 */
		addrs[3][i].sin_family = AF_INET;
		addrs[3][i].sin_port = htons(ports[3] + offset);
		inet_aton(addr_strings[i], &addrs[3][i].sin_addr);
#endif				/* SCTP_VERSION_2 */
	}
	switch (child) {
	case 1:
	case 2:
	case 0:
		for (i = 0; i < anums[child]; i++) {
#ifndef SCTP_VERSION_2
			addrs[child].port = htons(ports[child] + offset);
			inet_aton(addr_strings[i], &addrs[child].addr[i]);
#else				/* SCTP_VERSION_2 */
			addrs[child][i].sin_family = AF_INET;
			if ((child == 0 && !client_port_specified) ||
			    ((child == 1 || child == 2) && !server_port_specified))
				addrs[child][i].sin_port = htons(ports[child] + offset);
			else
				addrs[child][i].sin_port = htons(ports[child]);
			if ((child == 0 && !client_host_specified) ||
			    ((child == 1 || child == 2) && !server_host_specified))
				inet_aton(addr_strings[i], &addrs[child][i].sin_addr);
#endif				/* SCTP_VERSION_2 */
		}
		if (test_open(child, devname, O_NONBLOCK | O_RDWR) != __RESULT_SUCCESS)
			return __RESULT_FAILURE;
		if (test_ioctl(child, I_SRDOPT, (intptr_t) RMSGD) != __RESULT_SUCCESS)
			return __RESULT_FAILURE;
		return __RESULT_SUCCESS;
	default:
		return __RESULT_FAILURE;
	}
}

static int
stream_stop(int child)
{
	switch (child) {
	case 1:
	case 2:
	case 0:
		if (test_close(child) != __RESULT_SUCCESS)
			return __RESULT_FAILURE;
		return __RESULT_SUCCESS;
	default:
		return __RESULT_FAILURE;
	}
}

void
test_sleep(int child, unsigned long t)
{
	print_waiting(child, t);
	sleep(t);
}

void
test_msleep(int child, unsigned long m)
{
	struct timespec time;

	time.tv_sec = m / 1000;
	time.tv_nsec = (m % 1000) * 1000000;
	print_mwaiting(child, &time);
	nanosleep(&time, NULL);
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Test harness initialization and termination.
 *
 *  -------------------------------------------------------------------------
 */

static int
begin_tests(int index)
{
	state = 0;
	if (stream_start(0, index) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (stream_start(1, index) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (stream_start(2, index) != __RESULT_SUCCESS)
		goto failure;
	state++;
	show_acks = 1;
	return __RESULT_SUCCESS;
      failure:
	return __RESULT_FAILURE;
}

static int
end_tests(int index)
{
	show_acks = 0;
	if (stream_stop(2) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (stream_stop(1) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (stream_stop(0) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return __RESULT_SUCCESS;
      failure:
	return __RESULT_FAILURE;
}

int
begin_tests_p(int index)
{
	if (begin_tests(index) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_push(0, "tpiperf") != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_push(1, "tpiperf") != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_push(2, "tpiperf") != __RESULT_SUCCESS)
		goto failure;
	state++;
	return __RESULT_SUCCESS;
      failure:
	return __RESULT_FAILURE;
}

int
end_tests_p(int index)
{
	if (test_pop(2) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_pop(1) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_pop(0) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (end_tests(index) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return __RESULT_SUCCESS;
      failure:
	return __RESULT_FAILURE;
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Injected event encoding and display functions.
 *
 *  -------------------------------------------------------------------------
 */

int
do_signal(int child, int action)
{
	struct strbuf ctrl_buf, data_buf, *ctrl = &ctrl_buf, *data = &data_buf;
	char cbuf[BUFSIZE], dbuf[BUFSIZE];
	union T_primitives *p = (typeof(p)) cbuf;
	struct strioctl ic;

	ic.ic_cmd = 0;
	ic.ic_timout = test_timout;
	ic.ic_len = sizeof(cbuf);
	ic.ic_dp = cbuf;
	ctrl->maxlen = 0;
	ctrl->buf = cbuf;
	data->maxlen = 0;
	data->buf = dbuf;
	test_pflags = MSG_BAND;
	test_pband = 0;
	switch (action) {
	case __TEST_WRITE:
		data->len = snprintf(dbuf, BUFSIZE, "%s", "Write test data.");
		return test_write(child, dbuf, data->len);
	case __TEST_WRITEV:
	{
		struct iovec vector[4];

		vector[0].iov_base = dbuf;
		vector[0].iov_len = sprintf(vector[0].iov_base, "Writev test datum for vector 0.");
		vector[1].iov_base = dbuf + vector[0].iov_len;
		vector[1].iov_len = sprintf(vector[1].iov_base, "Writev test datum for vector 1.");
		vector[2].iov_base = dbuf + vector[1].iov_len;
		vector[2].iov_len = sprintf(vector[2].iov_base, "Writev test datum for vector 2.");
		vector[3].iov_base = dbuf + vector[2].iov_len;
		vector[3].iov_len = sprintf(vector[3].iov_base, "Writev test datum for vector 3.");
		return test_writev(child, vector, 4);
	}
	}
	switch (action) {
	case __TEST_PUSH:
		return test_ti_ioctl(child, I_PUSH, (intptr_t) "tirdwr");
	case __TEST_POP:
		return test_ti_ioctl(child, I_POP, (intptr_t) NULL);
	case __TEST_PUTMSG_DATA:
		ctrl = NULL;
		data->len = snprintf(dbuf, BUFSIZE, "%s", "Putmsg test data.");
		test_pflags = MSG_BAND;
		test_pband = 0;
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_PUTPMSG_DATA:
		ctrl = NULL;
		data->len = snprintf(dbuf, BUFSIZE, "%s", "Putpmsg band test data.");
		test_pflags = MSG_BAND;
		test_pband = 1;
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_CONN_REQ:
		ctrl->len = sizeof(p->conn_req)
		    + (test_addr ? test_alen : 0)
		    + (test_opts ? test_olen : 0);
		p->conn_req.PRIM_type = T_CONN_REQ;
		p->conn_req.DEST_length = test_addr ? test_alen : 0;
		p->conn_req.DEST_offset = test_addr ? sizeof(p->conn_req) : 0;
		p->conn_req.OPT_length = test_opts ? test_olen : 0;
		p->conn_req.OPT_offset = test_opts ? sizeof(p->conn_req) + p->conn_req.DEST_length : 0;
		if (test_addr)
			bcopy(test_addr, ctrl->buf + p->conn_req.DEST_offset, p->conn_req.DEST_length);
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->conn_req.OPT_offset, p->conn_req.OPT_length);
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
		print_string(child, addr_string(cbuf + p->conn_req.DEST_offset, p->conn_req.DEST_length));
#else
		print_addrs(child, cbuf + p->conn_req.DEST_offset, p->conn_req.DEST_length);
#endif
		print_options(child, cbuf, p->conn_req.OPT_offset, p->conn_req.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_CONN_IND:
		ctrl->len = sizeof(p->conn_ind);
		p->conn_ind.PRIM_type = T_CONN_IND;
		p->conn_ind.SRC_length = 0;
		p->conn_ind.SRC_offset = 0;
		p->conn_ind.OPT_length = 0;
		p->conn_ind.OPT_offset = 0;
		p->conn_ind.SEQ_number = last_sequence;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_options(child, cbuf, p->conn_ind.OPT_offset, p->conn_ind.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_CONN_RES:
		ctrl->len = sizeof(p->conn_res)
		    + (test_opts ? test_olen : 0);
		p->conn_res.PRIM_type = T_CONN_RES;
		p->conn_res.ACCEPTOR_id = 0;
		p->conn_res.OPT_length = test_opts ? test_olen : 0;
		p->conn_res.OPT_offset = test_opts ? sizeof(p->conn_res) : 0;
		p->conn_res.SEQ_number = last_sequence;
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->conn_res.OPT_offset, p->conn_res.OPT_length);
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_options(child, cbuf, p->conn_res.OPT_offset, p->conn_res.OPT_length);
		if (test_resfd == -1)
			return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
		else
			return test_insertfd(child, test_resfd, 4, ctrl, data, 0);
	case __TEST_CONN_CON:
		ctrl->len = sizeof(p->conn_con);
		p->conn_con.PRIM_type = T_CONN_CON;
		p->conn_con.RES_length = 0;
		p->conn_con.RES_offset = 0;
		p->conn_con.OPT_length = 0;
		p->conn_con.OPT_offset = 0;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_options(child, cbuf, p->conn_con.OPT_offset, p->conn_con.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_DISCON_REQ:
		ctrl->len = sizeof(p->discon_req);
		p->discon_req.PRIM_type = T_DISCON_REQ;
		p->discon_req.SEQ_number = last_sequence;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_DISCON_IND:
		ctrl->len = sizeof(p->discon_ind);
		p->discon_ind.PRIM_type = T_DISCON_IND;
		p->discon_ind.DISCON_reason = 0;
		p->discon_ind.SEQ_number = last_sequence;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_DATA_REQ:
		ctrl->len = sizeof(p->data_req);
		p->data_req.PRIM_type = T_DATA_REQ;
		p->data_req.MORE_flag = MORE_flag;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		if ((verbose && show) || verbose > 4) {
			print_tx_prim(child, prim_string(p->type));
			if (data)
				print_tx_data(child, "M_DATA----------", data->len);
		}
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_DATA_IND:
		ctrl->len = sizeof(p->data_ind);
		p->data_ind.PRIM_type = T_DATA_IND;
		p->data_ind.MORE_flag = MORE_flag;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		if ((verbose && show) || verbose > 4)
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_EXDATA_REQ:
		ctrl->len = sizeof(p->exdata_req);
		p->exdata_req.PRIM_type = T_EXDATA_REQ;
		p->exdata_req.MORE_flag = MORE_flag;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 1;
		if ((verbose && show) || verbose > 4) {
			print_tx_prim(child, prim_string(p->type));
			if (data)
				print_tx_data(child, "M_DATA----------", data->len);
		}
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_EXDATA_IND:
		ctrl->len = sizeof(p->exdata_ind);
		p->data_ind.PRIM_type = T_EXDATA_IND;
		p->data_ind.MORE_flag = MORE_flag;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 1;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_INFO_REQ:
		ctrl->len = sizeof(p->info_req);
		p->info_req.PRIM_type = T_INFO_REQ;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_INFO_ACK:
		ctrl->len = sizeof(p->info_ack);
		p->info_ack.PRIM_type = T_INFO_ACK;
		p->info_ack.TSDU_size = test_bufsize;
		p->info_ack.ETSDU_size = test_bufsize;
		p->info_ack.CDATA_size = test_bufsize;
		p->info_ack.DDATA_size = test_bufsize;
		p->info_ack.ADDR_size = test_bufsize;
		p->info_ack.OPT_size = test_bufsize;
		p->info_ack.TIDU_size = test_tidu;
		p->info_ack.SERV_type = last_servtype;
		p->info_ack.CURRENT_state = last_tstate;
		p->info_ack.PROVIDER_flag = last_provflag;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_info(child, &p->info_ack);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_BIND_REQ:
		ctrl->len = sizeof(p->bind_req) + (test_addr ? test_alen : 0);
		p->bind_req.PRIM_type = T_BIND_REQ;
		p->bind_req.ADDR_length = test_addr ? test_alen : 0;
		p->bind_req.ADDR_offset = test_addr ? sizeof(p->bind_req) : 0;
		p->bind_req.CONIND_number = last_qlen;
		if (test_addr)
			bcopy(test_addr, ctrl->buf + p->bind_req.ADDR_offset, p->bind_req.ADDR_length);
		data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
		print_string(child, addr_string(cbuf + p->bind_ack.ADDR_offset, p->bind_ack.ADDR_length));
#else
		print_addrs(child, cbuf + p->bind_ack.ADDR_offset, p->bind_ack.ADDR_length);
#endif
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_BIND_ACK:
		ctrl->len = sizeof(p->bind_ack);
		p->bind_ack.PRIM_type = T_BIND_ACK;
		p->bind_ack.ADDR_length = 0;
		p->bind_ack.ADDR_offset = 0;
		p->bind_ack.CONIND_number = last_qlen;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
		print_string(child, addr_string(cbuf + p->bind_ack.ADDR_offset, p->bind_ack.ADDR_length));
#else
		print_addrs(child, cbuf + p->bind_ack.ADDR_offset, p->bind_ack.ADDR_length);
#endif
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_UNBIND_REQ:
		ctrl->len = sizeof(p->unbind_req);
		p->unbind_req.PRIM_type = T_UNBIND_REQ;
		data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_ERROR_ACK:
		ctrl->len = sizeof(p->error_ack);
		p->error_ack.PRIM_type = T_ERROR_ACK;
		p->error_ack.ERROR_prim = last_prim;
		p->error_ack.TLI_error = last_t_errno;
		p->error_ack.UNIX_error = last_errno;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_string(child, terrno_string(p->error_ack.TLI_error, p->error_ack.UNIX_error));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_OK_ACK:
		ctrl->len = sizeof(p->ok_ack);
		p->ok_ack.PRIM_type = T_OK_ACK;
		p->ok_ack.CORRECT_prim = 0;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_UNITDATA_REQ:
		ctrl->len = sizeof(p->unitdata_req)
		    + (test_addr ? test_alen : 0)
		    + (test_opts ? test_olen : 0);
		p->unitdata_req.PRIM_type = T_UNITDATA_REQ;
		p->unitdata_req.DEST_length = test_addr ? test_alen : 0;
		p->unitdata_req.DEST_offset = test_addr ? sizeof(p->unitdata_req) : 0;
		p->unitdata_req.OPT_length = test_opts ? test_olen : 0;
		p->unitdata_req.OPT_offset = test_opts ? sizeof(p->unitdata_req) + p->unitdata_req.DEST_length : 0;
		if (test_addr)
			bcopy(test_addr, ctrl->buf + p->unitdata_req.DEST_offset, p->unitdata_req.DEST_length);
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->unitdata_req.OPT_offset, p->unitdata_req.OPT_length);
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
		print_string(child, addr_string(cbuf + p->unitdata_req.DEST_offset, p->unitdata_req.DEST_length));
#else
		print_addrs(child, cbuf + p->unitdata_req.DEST_offset, p->unitdata_req.DEST_length);
#endif
		print_options(child, cbuf, p->unitdata_req.OPT_offset, p->unitdata_req.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_UNITDATA_IND:
		ctrl->len = sizeof(p->unitdata_ind);
		p->unitdata_ind.PRIM_type = T_UNITDATA_IND;
		p->unitdata_ind.SRC_length = 0;
		p->unitdata_ind.SRC_offset = 0;
		p->unitdata_ind.OPT_length = 0;
		p->unitdata_ind.OPT_offset = 0;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
		print_string(child, addr_string(cbuf + p->unitdata_ind.SRC_offset, p->unitdata_ind.SRC_length));
#else
		print_addrs(child, cbuf + p->unitdata_ind.SRC_offset, p->unitdata_ind.SRC_length);
#endif
		print_options(child, cbuf, p->unitdata_ind.OPT_offset, p->unitdata_ind.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_UDERROR_IND:
		ctrl->len = sizeof(p->uderror_ind);
		p->uderror_ind.PRIM_type = T_UDERROR_IND;
		p->uderror_ind.DEST_length = 0;
		p->uderror_ind.DEST_offset = 0;
		p->uderror_ind.OPT_length = 0;
		p->uderror_ind.OPT_offset = 0;
		p->uderror_ind.ERROR_type = 0;
		data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_OPTMGMT_REQ:
		ctrl->len = sizeof(p->optmgmt_req)
		    + (test_opts ? test_olen : 0);
		p->optmgmt_req.PRIM_type = T_OPTMGMT_REQ;
		p->optmgmt_req.OPT_length = test_opts ? test_olen : 0;
		p->optmgmt_req.OPT_offset = test_opts ? sizeof(p->optmgmt_req) : 0;
		p->optmgmt_req.MGMT_flags = test_mgmtflags;
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->optmgmt_req.OPT_offset, p->optmgmt_req.OPT_length);
		data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_mgmtflag(child, p->optmgmt_req.MGMT_flags);
		print_options(child, cbuf, p->optmgmt_req.OPT_offset, p->optmgmt_req.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_OPTMGMT_ACK:
		ctrl->len = sizeof(p->optmgmt_ack);
		p->optmgmt_ack.PRIM_type = T_OPTMGMT_ACK;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		print_mgmtflag(child, p->optmgmt_ack.MGMT_flags);
		print_options(child, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length);
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_ORDREL_REQ:
		ctrl->len = sizeof(p->ordrel_req);
		p->ordrel_req.PRIM_type = T_ORDREL_REQ;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_ORDREL_IND:
		ctrl->len = sizeof(p->ordrel_ind);
		p->ordrel_ind.PRIM_type = T_ORDREL_IND;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_OPTDATA_REQ:
		ctrl->len = sizeof(p->optdata_req)
		    + (test_opts ? test_olen : 0);
		p->optdata_req.PRIM_type = T_OPTDATA_REQ;
		p->optdata_req.DATA_flag = DATA_flag;
		p->optdata_req.OPT_length = test_opts ? test_olen : 0;
		p->optdata_req.OPT_offset = test_opts ? sizeof(p->optdata_req) : 0;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->optdata_req.OPT_offset, p->optdata_req.OPT_length);
		test_pflags = MSG_BAND;
		test_pband = (DATA_flag & T_ODF_EX) ? 1 : 0;
		if (p->optdata_req.DATA_flag & T_ODF_EX) {
			if ((verbose && show) || verbose > 4) {
				if (p->optdata_req.DATA_flag & T_ODF_MORE)
					print_tx_prim(child, "T_OPTDATA_REQ!+ ");
				else
					print_tx_prim(child, "T_OPTDATA_REQ!  ");
			}
		} else {
			if ((verbose && show) || verbose > 4) {
				if (p->optdata_req.DATA_flag & T_ODF_MORE)
					print_tx_prim(child, "T_OPTDATA_REQ+  ");
				else
					print_tx_prim(child, "T_OPTDATA_REQ   ");
			}
		}
		if ((verbose && show) || verbose > 4) {
			print_options(child, cbuf, p->optdata_req.OPT_offset, p->optdata_req.OPT_length);
			if (data)
				print_tx_data(child, "M_DATA----------", data->len);
		}
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_NRM_OPTDATA_IND:
		ctrl->len = sizeof(p->optdata_ind);
		p->optdata_ind.PRIM_type = T_OPTDATA_IND;
		p->optdata_ind.DATA_flag = 0;
		p->optdata_ind.OPT_length = 0;
		p->optdata_ind.OPT_offset = 0;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		if ((verbose && show) || verbose > 4) {
			if (p->optdata_ind.DATA_flag & T_ODF_MORE)
				print_tx_prim(child, "T_OPTDATA_IND+  ");
			else
				print_tx_prim(child, "T_OPTDATA_IND   ");
			print_options(child, cbuf, p->optdata_ind.OPT_offset, p->optdata_ind.OPT_length);
			if (data)
				print_tx_data(child, "M_DATA----------", data->len);
		}
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_EXP_OPTDATA_IND:
		ctrl->len = sizeof(p->optdata_ind);
		p->optdata_ind.PRIM_type = T_OPTDATA_IND;
		p->optdata_ind.DATA_flag = T_ODF_EX;
		p->optdata_ind.OPT_length = 0;
		p->optdata_ind.OPT_offset = 0;
		if (test_data)
			data->len = snprintf(dbuf, BUFSIZE, "%s", test_data);
		else
			data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 1;
		if ((verbose && show) || verbose > 4) {
			if (p->optdata_ind.DATA_flag & T_ODF_MORE)
				print_tx_prim(child, "T_OPTDATA_IND!+ ");
			else
				print_tx_prim(child, "T_OPTDATA_IND!  ");
			print_options(child, cbuf, p->optdata_ind.OPT_offset, p->optdata_ind.OPT_length);
			if (data)
				print_tx_data(child, "M_DATA----------", data->len);
		}
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_ADDR_REQ:
		ctrl->len = sizeof(p->addr_req);
		p->addr_req.PRIM_type = T_ADDR_REQ;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_ADDR_ACK:
		ctrl->len = sizeof(p->addr_ack);
		p->addr_ack.PRIM_type = T_ADDR_ACK;
		p->addr_ack.LOCADDR_length = 0;
		p->addr_ack.LOCADDR_offset = 0;
		p->addr_ack.REMADDR_length = 0;
		p->addr_ack.REMADDR_offset = 0;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
		print_string(child, addr_string(cbuf + p->addr_ack.LOCADDR_offset, p->addr_ack.LOCADDR_length));
		print_string(child, addr_string(cbuf + p->addr_ack.REMADDR_offset, p->addr_ack.REMADDR_length));
#else
		print_addrs(child, cbuf + p->addr_ack.LOCADDR_offset, p->addr_ack.LOCADDR_length);
		print_addrs(child, cbuf + p->addr_ack.REMADDR_offset, p->addr_ack.REMADDR_length);
#endif
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_CAPABILITY_REQ:
		ctrl->len = sizeof(p->capability_req);
		p->capability_req.PRIM_type = T_CAPABILITY_REQ;
		p->capability_req.CAP_bits1 = TC1_INFO | TC1_ACCEPTOR_ID;
		data = NULL;
		test_pflags = test_prio ? MSG_HIPRI : MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_CAPABILITY_ACK:
		ctrl->len = sizeof(p->capability_ack);
		p->capability_ack.PRIM_type = T_CAPABILITY_ACK;
		p->capability_ack.CAP_bits1 = TC1_INFO | TC1_ACCEPTOR_ID;
		p->capability_ack.INFO_ack.TSDU_size = test_bufsize;
		p->capability_ack.INFO_ack.ETSDU_size = test_bufsize;
		p->capability_ack.INFO_ack.CDATA_size = test_bufsize;
		p->capability_ack.INFO_ack.DDATA_size = test_bufsize;
		p->capability_ack.INFO_ack.ADDR_size = test_bufsize;
		p->capability_ack.INFO_ack.OPT_size = test_bufsize;
		p->capability_ack.INFO_ack.TIDU_size = test_tidu;
		p->capability_ack.INFO_ack.SERV_type = last_servtype;
		p->capability_ack.INFO_ack.CURRENT_state = last_tstate;
		p->capability_ack.INFO_ack.PROVIDER_flag = last_provflag;
		p->capability_ack.ACCEPTOR_id = 0;
		data = NULL;
		test_pflags = MSG_HIPRI;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_PRIM_TOO_SHORT:
		ctrl->len = sizeof(p->type);
		p->type = last_prim;
		data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_PRIM_WAY_TOO_SHORT:
		ctrl->len = sizeof(p->type) >> 1;
		p->type = last_prim;
		data = NULL;
		test_pflags = MSG_BAND;
		test_pband = 0;
		print_tx_prim(child, prim_string(p->type));
		return test_putpmsg(child, ctrl, data, test_pband, test_pflags);
	case __TEST_O_TI_GETINFO:
		ic.ic_cmd = O_TI_GETINFO;
		ic.ic_len = sizeof(p->info_ack);
		p->info_req.PRIM_type = T_INFO_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_O_TI_OPTMGMT:
		ic.ic_cmd = O_TI_OPTMGMT;
		ic.ic_len = sizeof(p->optmgmt_ack)
		    + (test_opts ? test_olen : 0);
		p->optmgmt_req.PRIM_type = T_OPTMGMT_REQ;
		p->optmgmt_req.OPT_length = test_opts ? test_olen : 0;
		p->optmgmt_req.OPT_offset = test_opts ? sizeof(p->optmgmt_req) : 0;
		p->optmgmt_req.MGMT_flags = test_mgmtflags;
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->optmgmt_req.OPT_offset, p->optmgmt_req.OPT_length);
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_O_TI_BIND:
		ic.ic_cmd = O_TI_BIND;
		ic.ic_len = sizeof(p->bind_ack);
		p->bind_req.PRIM_type = T_BIND_REQ;
		p->bind_req.ADDR_length = 0;
		p->bind_req.ADDR_offset = 0;
		p->bind_req.CONIND_number = last_qlen;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_O_TI_UNBIND:
		ic.ic_cmd = O_TI_UNBIND;
		ic.ic_len = sizeof(p->ok_ack);
		p->unbind_req.PRIM_type = T_UNBIND_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_GETINFO:
		ic.ic_cmd = _O_TI_GETINFO;
		ic.ic_len = sizeof(p->info_ack);
		p->info_req.PRIM_type = T_INFO_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_OPTMGMT:
		ic.ic_cmd = _O_TI_OPTMGMT;
		ic.ic_len = sizeof(p->optmgmt_ack)
		    + (test_opts ? test_olen : 0);
		p->optmgmt_req.PRIM_type = T_OPTMGMT_REQ;
		p->optmgmt_req.OPT_length = test_opts ? test_olen : 0;
		p->optmgmt_req.OPT_offset = test_opts ? sizeof(p->optmgmt_req) : 0;
		p->optmgmt_req.MGMT_flags = test_mgmtflags;
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->optmgmt_req.OPT_offset, p->optmgmt_req.OPT_length);
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_BIND:
		ic.ic_cmd = _O_TI_BIND;
		ic.ic_len = sizeof(p->bind_ack);
		p->bind_req.PRIM_type = T_BIND_REQ;
		p->bind_req.ADDR_length = 0;
		p->bind_req.ADDR_offset = 0;
		p->bind_req.CONIND_number = last_qlen;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_UNBIND:
		ic.ic_cmd = _O_TI_UNBIND;
		ic.ic_len = sizeof(p->ok_ack);
		p->unbind_req.PRIM_type = T_UNBIND_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_GETMYNAME:
		ic.ic_cmd = _O_TI_GETMYNAME;
		ic.ic_len = sizeof(p->addr_ack);
		p->addr_req.PRIM_type = T_ADDR_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_GETPEERNAME:
		ic.ic_cmd = _O_TI_GETPEERNAME;
		ic.ic_len = sizeof(p->addr_ack);
		p->addr_req.PRIM_type = T_ADDR_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_XTI_HELLO:
		ic.ic_cmd = _O_TI_XTI_HELLO;
		ic.ic_len = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_XTI_GET_STATE:
		ic.ic_cmd = _O_TI_XTI_GET_STATE;
		ic.ic_len = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_XTI_CLEAR_EVENT:
		ic.ic_cmd = _O_TI_XTI_CLEAR_EVENT;
		ic.ic_len = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_XTI_MODE:
		ic.ic_cmd = _O_TI_XTI_MODE;
		ic.ic_len = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST__O_TI_TLI_MODE:
		ic.ic_cmd = _O_TI_TLI_MODE;
		ic.ic_len = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_GETINFO:
		ic.ic_cmd = TI_GETINFO;
		ic.ic_len = sizeof(p->info_ack);
		p->info_req.PRIM_type = T_INFO_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_OPTMGMT:
		ic.ic_cmd = TI_OPTMGMT;
		ic.ic_len = sizeof(p->optmgmt_ack)
		    + (test_opts ? test_olen : 0);
		p->optmgmt_req.PRIM_type = T_OPTMGMT_REQ;
		p->optmgmt_req.OPT_length = test_opts ? test_olen : 0;
		p->optmgmt_req.OPT_offset = test_opts ? sizeof(p->optmgmt_req) : 0;
		p->optmgmt_req.MGMT_flags = test_mgmtflags;
		if (test_opts)
			bcopy(test_opts, ctrl->buf + p->optmgmt_req.OPT_offset, p->optmgmt_req.OPT_length);
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_BIND:
		ic.ic_cmd = TI_BIND;
		ic.ic_len = sizeof(p->bind_ack);
		p->bind_req.PRIM_type = T_BIND_REQ;
		p->bind_req.ADDR_length = 0;
		p->bind_req.ADDR_offset = 0;
		p->bind_req.CONIND_number = last_qlen;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_UNBIND:
		ic.ic_cmd = TI_UNBIND;
		ic.ic_len = sizeof(p->ok_ack);
		p->unbind_req.PRIM_type = T_UNBIND_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_GETMYNAME:
		ic.ic_cmd = TI_GETMYNAME;
		ic.ic_len = sizeof(p->addr_ack);
		p->addr_req.PRIM_type = T_ADDR_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_GETPEERNAME:
		ic.ic_cmd = TI_GETPEERNAME;
		ic.ic_len = sizeof(p->addr_ack);
		p->addr_req.PRIM_type = T_ADDR_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETMYNAME:
		ic.ic_cmd = TI_SETMYNAME;
		ic.ic_len = sizeof(p->conn_res);
		p->conn_res.PRIM_type = T_CONN_RES;
		p->conn_res.ACCEPTOR_id = 0;
		p->conn_res.OPT_length = 0;
		p->conn_res.OPT_offset = 0;
		p->conn_res.SEQ_number = last_sequence;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETPEERNAME:
		ic.ic_cmd = TI_SETPEERNAME;
		ic.ic_len = sizeof(p->conn_req);
		p->conn_req.PRIM_type = T_CONN_REQ;
		p->conn_req.DEST_length = 0;
		p->conn_req.DEST_offset = 0;
		p->conn_req.OPT_length = 0;
		p->conn_req.OPT_offset = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETMYNAME_DISC:
		ic.ic_cmd = TI_SETMYNAME;
		ic.ic_len = sizeof(p->discon_req);
		p->discon_req.PRIM_type = T_DISCON_REQ;
		p->discon_req.SEQ_number = last_sequence;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETPEERNAME_DISC:
		ic.ic_cmd = TI_SETPEERNAME;
		ic.ic_len = sizeof(p->discon_req);
		p->discon_req.PRIM_type = T_DISCON_REQ;
		p->discon_req.SEQ_number = last_sequence;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETMYNAME_DATA:
		ic.ic_cmd = TI_SETMYNAME;
		ic.ic_len = sizeof(p->conn_res) + sprintf(cbuf + sizeof(p->conn_res), "IO control test data.");
		p->conn_res.PRIM_type = T_CONN_RES;
		p->conn_res.ACCEPTOR_id = 0;
		p->conn_res.OPT_length = 0;
		p->conn_res.OPT_offset = 0;
		p->conn_res.SEQ_number = last_sequence;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETPEERNAME_DATA:
		ic.ic_cmd = TI_SETPEERNAME;
		ic.ic_len = sizeof(p->conn_req) + sprintf(cbuf + sizeof(p->conn_res), "IO control test data.");
		p->conn_req.PRIM_type = T_CONN_REQ;
		p->conn_req.DEST_length = 0;
		p->conn_req.DEST_offset = 0;
		p->conn_req.OPT_length = 0;
		p->conn_req.OPT_offset = 0;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETMYNAME_DISC_DATA:
		ic.ic_cmd = TI_SETMYNAME;
		ic.ic_len = sizeof(p->discon_req) + sprintf(cbuf + sizeof(p->conn_res), "IO control test data.");
		p->discon_req.PRIM_type = T_DISCON_REQ;
		p->discon_req.SEQ_number = last_sequence;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SETPEERNAME_DISC_DATA:
		ic.ic_cmd = TI_SETPEERNAME;
		ic.ic_len = sizeof(p->discon_req) + sprintf(cbuf + sizeof(p->conn_res), "IO control test data.");
		p->discon_req.PRIM_type = T_DISCON_REQ;
		p->discon_req.SEQ_number = last_sequence;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_SYNC:
	{
		union {
			struct ti_sync_req req;
			struct ti_sync_ack ack;
		} *s = (typeof(s)) p;

		ic.ic_cmd = TI_SYNC;
		ic.ic_len = sizeof(*s);
		s->req.tsr_flags = TSRF_INFO_REQ | TSRF_IS_EXP_IN_RCVBUF | TSRF_QLEN_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	}
	case __TEST_TI_GETADDRS:
		ic.ic_cmd = TI_GETADDRS;
		ic.ic_len = sizeof(p->addr_ack);
		p->addr_req.PRIM_type = T_ADDR_REQ;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	case __TEST_TI_CAPABILITY:
		ic.ic_cmd = TI_CAPABILITY;
		ic.ic_len = sizeof(p->capability_ack);
		p->capability_req.PRIM_type = T_CAPABILITY_REQ;
		p->capability_req.CAP_bits1 = TC1_INFO | TC1_ACCEPTOR_ID;
		return test_ti_ioctl(child, I_STR, (intptr_t) & ic);
	default:
		return __RESULT_SCRIPT_ERROR;
	}
	return __RESULT_SCRIPT_ERROR;
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Received event decoding and display functions.
 *
 *  -------------------------------------------------------------------------
 */

static int
do_decode_data(int child, struct strbuf *ctrl, struct strbuf *data)
{
	int event = __RESULT_DECODE_ERROR;

	if (data->len >= 0) {
		event = __TEST_DATA;
		print_rx_data(child, "M_DATA----------", data->len);
	}
	return ((last_event = event));
}

static int
do_decode_ctrl(int child, struct strbuf *ctrl, struct strbuf *data)
{
	int event = __RESULT_DECODE_ERROR;
	union T_primitives *p = (union T_primitives *) ctrl->buf;

	if (ctrl->len >= sizeof(p->type)) {
		switch ((last_prim = p->type)) {
		case T_CONN_REQ:
			event = __TEST_CONN_REQ;
			print_rx_prim(child, prim_string(p->type));
			print_options(child, cbuf, p->conn_req.OPT_offset, p->conn_req.OPT_length);
			break;
		case T_CONN_RES:
			event = __TEST_CONN_RES;
			print_rx_prim(child, prim_string(p->type));
			print_options(child, cbuf, p->conn_res.OPT_offset, p->conn_res.OPT_length);
			break;
		case T_DISCON_REQ:
			event = __TEST_DISCON_REQ;
			last_sequence = p->discon_req.SEQ_number;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_DATA_REQ:
			event = __TEST_DATA_REQ;
			MORE_flag = p->data_req.MORE_flag;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_EXDATA_REQ:
			event = __TEST_EXDATA_REQ;
			MORE_flag = p->data_req.MORE_flag;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_INFO_REQ:
			event = __TEST_INFO_REQ;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_BIND_REQ:
			event = __TEST_BIND_REQ;
			last_qlen = p->bind_req.CONIND_number;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_UNBIND_REQ:
			event = __TEST_UNBIND_REQ;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_UNITDATA_REQ:
			event = __TEST_UNITDATA_REQ;
			print_rx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
			print_string(child, addr_string(cbuf + p->unitdata_req.DEST_offset, p->unitdata_req.DEST_length));
#else
			print_addrs(child, cbuf + p->unitdata_req.DEST_offset, p->unitdata_req.DEST_length);
#endif
			print_options(child, cbuf, p->unitdata_req.OPT_offset, p->unitdata_req.OPT_length);
			break;
		case T_OPTMGMT_REQ:
			event = __TEST_OPTMGMT_REQ;
			print_rx_prim(child, prim_string(p->type));
			print_mgmtflag(child, p->optmgmt_req.MGMT_flags);
			print_options(child, cbuf, p->optmgmt_req.OPT_offset, p->optmgmt_req.OPT_length);
			break;
		case T_ORDREL_REQ:
			event = __TEST_ORDREL_REQ;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_OPTDATA_REQ:
			event = __TEST_OPTDATA_REQ;
			if (p->optdata_req.DATA_flag & T_ODF_EX) {
				if (p->optdata_req.DATA_flag & T_ODF_MORE)
					print_rx_prim(child, "T_OPTDATA_REQ!+ ");
				else
					print_rx_prim(child, "T_OPTDATA_REQ!  ");
			} else {
				if (p->optdata_req.DATA_flag & T_ODF_MORE)
					print_rx_prim(child, "T_OPTDATA_REQ+  ");
				else
					print_rx_prim(child, "T_OPTDATA_REQ   ");
			}
			print_options(child, cbuf, p->optdata_req.OPT_offset, p->optdata_req.OPT_length);
			break;
		case T_ADDR_REQ:
			event = __TEST_ADDR_REQ;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_CAPABILITY_REQ:
			event = __TEST_CAPABILITY_REQ;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_CONN_IND:
			event = __TEST_CONN_IND;
			last_sequence = p->conn_ind.SEQ_number;
			print_rx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
			print_string(child, addr_string(cbuf + p->conn_ind.SRC_offset, p->conn_ind.SRC_length));
#else
			print_addrs(child, cbuf + p->conn_ind.SRC_offset, p->conn_ind.SRC_length);
#endif
			print_options(child, cbuf, p->conn_ind.OPT_offset, p->conn_ind.OPT_length);
			break;
		case T_CONN_CON:
			event = __TEST_CONN_CON;
			print_rx_prim(child, prim_string(p->type));
			print_options(child, cbuf, p->conn_con.OPT_offset, p->conn_con.OPT_length);
			break;
		case T_DISCON_IND:
			event = __TEST_DISCON_IND;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_DATA_IND:
			event = __TEST_DATA_IND;
			if ((verbose && show) || verbose > 4)
				print_rx_prim(child, prim_string(p->type));
			break;
		case T_EXDATA_IND:
			event = __TEST_EXDATA_IND;
			if ((verbose && show) || verbose > 4)
				print_rx_prim(child, prim_string(p->type));
			break;
		case T_INFO_ACK:
			event = __TEST_INFO_ACK;
			last_info = p->info_ack;
			print_ack_prim(child, prim_string(p->type));
			print_info(child, &p->info_ack);
			break;
		case T_BIND_ACK:
			event = __TEST_BIND_ACK;
			last_qlen = p->bind_ack.CONIND_number;
			print_ack_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
			print_string(child, addr_string(cbuf + p->bind_ack.ADDR_offset, p->bind_ack.ADDR_length));
#else
			print_addrs(child, cbuf + p->bind_ack.ADDR_offset, p->bind_ack.ADDR_length);
#endif
			break;
		case T_ERROR_ACK:
			event = __TEST_ERROR_ACK;
			last_t_errno = p->error_ack.TLI_error;
			last_errno = p->error_ack.UNIX_error;
			print_ack_prim(child, prim_string(p->type));
			print_string(child, terrno_string(p->error_ack.TLI_error, p->error_ack.UNIX_error));
			break;
		case T_OK_ACK:
			event = __TEST_OK_ACK;
			print_ack_prim(child, prim_string(p->type));
			break;
		case T_UNITDATA_IND:
			event = __TEST_UNITDATA_IND;
			print_rx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
			print_string(child, addr_string(cbuf + p->unitdata_ind.SRC_offset, p->unitdata_ind.SRC_length));
#else
			print_addrs(child, cbuf + p->unitdata_ind.SRC_offset, p->unitdata_ind.SRC_length);
#endif
			print_options(child, cbuf, p->unitdata_ind.OPT_offset, p->unitdata_ind.OPT_length);
			break;
		case T_UDERROR_IND:
			event = __TEST_UDERROR_IND;
			print_rx_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
			print_string(child, addr_string(cbuf + p->uderror_ind.DEST_offset, p->uderror_ind.DEST_length));
#else
			print_addrs(child, cbuf + p->uderror_ind.DEST_offset, p->uderror_ind.DEST_length);
#endif
			print_options(child, cbuf, p->uderror_ind.OPT_offset, p->uderror_ind.OPT_length);
			print_string(child, etype_string(p->uderror_ind.ERROR_type));
			break;
		case T_OPTMGMT_ACK:
			event = __TEST_OPTMGMT_ACK;
			test_mgmtflags = p->optmgmt_ack.MGMT_flags;
			print_ack_prim(child, prim_string(p->type));
			print_mgmtflag(child, p->optmgmt_ack.MGMT_flags);
			print_options(child, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length);
			break;
		case T_ORDREL_IND:
			event = __TEST_ORDREL_IND;
			print_rx_prim(child, prim_string(p->type));
			break;
		case T_OPTDATA_IND:
			test_dlen = data ? data->len : 0;
			if (p->optdata_ind.DATA_flag & T_ODF_EX) {
				event = __TEST_EXP_OPTDATA_IND;
				if ((verbose && show) || verbose > 4) {
					if (p->optdata_ind.DATA_flag & T_ODF_MORE)
						print_rx_prim(child, "T_OPTDATA_IND!+ ");
					else
						print_rx_prim(child, "T_OPTDATA_IND!  ");
				}
			} else {
				event = __TEST_NRM_OPTDATA_IND;
				if ((verbose && show) || verbose > 4) {
					if (p->optdata_ind.DATA_flag & T_ODF_MORE)
						print_rx_prim(child, "T_OPTDATA_IND+  ");
					else
						print_rx_prim(child, "T_OPTDATA_IND   ");
				}
			}
			if (p->optdata_ind.OPT_length) {
				struct t_opthdr *oh;
				unsigned char *op = (unsigned char *)p + p->optdata_ind.OPT_offset;
				int olen = p->optdata_ind.OPT_length;

				for (oh = _T_OPT_FIRSTHDR_OFS(op, olen, 0); oh; oh = _T_OPT_NEXTHDR_OFS(op, olen, oh, 0)) {
					if (oh->level == T_INET_SCTP) {
						switch (oh->name) {
						case T_SCTP_SID:
							sid[child]= (*((t_scalar_t *)(oh +1))) & 0xffff;
							opt_data.sid_val = sid[child];
							break;
						case T_SCTP_PPI:
							ppi[child]= (*((t_scalar_t *)(oh +1))) & 0xffffffff;
							opt_data.ppi_val = ppi[child];
							break;
						}
					}
				}
			}
			if ((verbose && show) || verbose > 4)
				print_options(child, cbuf, p->optdata_ind.OPT_offset, p->optdata_ind.OPT_length);
			break;
		case T_ADDR_ACK:
			event = __TEST_ADDR_ACK;
			print_ack_prim(child, prim_string(p->type));
#ifndef SCTP_VERSION_2
			print_string(child, addr_string(cbuf + p->addr_ack.LOCADDR_offset, p->addr_ack.LOCADDR_length));
			print_string(child, addr_string(cbuf + p->addr_ack.REMADDR_offset, p->addr_ack.REMADDR_length));
#else
			print_addrs(child, cbuf + p->addr_ack.LOCADDR_offset, p->addr_ack.LOCADDR_length);
			print_addrs(child, cbuf + p->addr_ack.REMADDR_offset, p->addr_ack.REMADDR_length);
#endif
			break;
		case T_CAPABILITY_ACK:
			event = __TEST_CAPABILITY_ACK;
			last_info = p->capability_ack.INFO_ack;
			print_ack_prim(child, prim_string(p->type));
			break;
		default:
			event = __EVENT_UNKNOWN;
			print_no_prim(child, p->type);
			break;
		}
		if (data && data->len >= 0)
			if (do_decode_data(child, ctrl, data) != __TEST_DATA)
				event = __RESULT_FAILURE;
	}
	return ((last_event = event));
}

static int
do_decode_msg(int child, struct strbuf *ctrl, struct strbuf *data)
{
	if (ctrl->len > 0) {
		if ((last_event = do_decode_ctrl(child, ctrl, data)) != __EVENT_UNKNOWN)
			return time_event(child, last_event);
	} else if (data->len > 0) {
		if ((last_event = do_decode_data(child, ctrl, data)) != __EVENT_UNKNOWN)
			return time_event(child, last_event);
	}
	return ((last_event = __EVENT_NO_MSG));
}

int
wait_event(int child, int wait)
{
	while (1) {
		struct pollfd pfd[] = { {test_fd[child], POLLIN | POLLPRI, 0} };

		if (timer_timeout) {
			timer_timeout = 0;
			print_timeout(child);
			last_event = __EVENT_TIMEOUT;
			return time_event(child, __EVENT_TIMEOUT);
		}
		if (verbose > 4)
			print_syscall(child, "poll()");
		pfd[0].fd = test_fd[child];
		pfd[0].events = POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND | POLLMSG | POLLERR | POLLHUP;
		pfd[0].revents = 0;
		switch (poll(pfd, 1, wait)) {
		case -1:
			if (last_errno == EAGAIN || last_errno == EINTR || last_errno == ERESTART)
				break;
			print_errno(child, (last_errno = errno));
			return (__RESULT_FAILURE);
		case 0:
			if (verbose > 4)
				print_success(child);
			print_nothing(child);
			last_event = __EVENT_NO_MSG;
			return time_event(child, __EVENT_NO_MSG);
		case 1:
			if (verbose > 4)
				print_success(child);
			if (pfd[0].revents) {
				int ret;

				ctrl.maxlen = BUFSIZE;
				ctrl.len = -1;
				ctrl.buf = cbuf;
				data.maxlen = BUFSIZE;
				data.len = -1;
				data.buf = dbuf;
				flags = 0;
				for (;;) {
					if ((verbose > 3 && show) || (verbose > 5 && show_msg))
						print_syscall(child, "getmsg()");
					if ((ret = getmsg(test_fd[child], &ctrl, &data, &flags)) >= 0)
						break;
					if (last_errno == EINTR || last_errno == ERESTART)
						continue;
					print_errno(child, (last_errno = errno));
					if (last_errno == EAGAIN)
						break;
					return __RESULT_FAILURE;
				}
				if (ret < 0)
					break;
				if (ret == 0) {
					if ((verbose > 3 && show) || (verbose > 5 && show_msg))
						print_success(child);
					if ((verbose > 3 && show) || (verbose > 5 && show_msg)) {
						int i;

						dummy = lockf(fileno(stdout), F_LOCK, 0);
						fprintf(stdout, "gotmsg from %d [%d,%d]:\n", child, ctrl.len, data.len);
						fprintf(stdout, "[");
						for (i = 0; i < ctrl.len; i++)
							fprintf(stdout, "%02X", ctrl.buf[i]);
						fprintf(stdout, "]\n");
						fprintf(stdout, "[");
						for (i = 0; i < data.len; i++)
							fprintf(stdout, "%02X", data.buf[i]);
						fprintf(stdout, "]\n");
						fflush(stdout);
						dummy = lockf(fileno(stdout), F_ULOCK, 0);
					}
					last_prio = (flags == RS_HIPRI);
					if ((last_event = do_decode_msg(child, &ctrl, &data)) != __EVENT_NO_MSG)
						return time_event(child, last_event);
				}
			}
		default:
			break;
		}
	}
	return __EVENT_UNKNOWN;
}

int
get_event(int child)
{
	return wait_event(child, -1);
}

int
get_data(int child, int action)
{
	int ret = 0;

	switch (action) {
	case __TEST_READ:
	{
		char buf[BUFSIZE];

		test_read(child, buf, BUFSIZE);
		ret = last_retval;
		break;
	}
	case __TEST_READV:
	{
		char buf[BUFSIZE];
		static const size_t count = 4;
		struct iovec vector[] = {
			{buf, (BUFSIZE >> 2)},
			{buf + (BUFSIZE >> 2), (BUFSIZE >> 2)},
			{buf + (BUFSIZE >> 2) + (BUFSIZE >> 2), (BUFSIZE >> 2)},
			{buf + (BUFSIZE >> 2) + (BUFSIZE >> 2) + (BUFSIZE >> 2), (BUFSIZE >> 2)}
		};

		test_readv(child, vector, count);
		ret = last_retval;
		break;
	}
	case __TEST_GETMSG:
	{
		char buf[BUFSIZE];
		struct strbuf data = { BUFSIZE, 0, buf };

		if (test_getmsg(child, NULL, &data, &test_gflags) == __RESULT_FAILURE) {
			ret = last_retval;
			break;
		}
		ret = data.len;
		break;
	}
	case __TEST_GETPMSG:
	{
		char buf[BUFSIZE];
		struct strbuf data = { BUFSIZE, 0, buf };

		if (test_getpmsg(child, NULL, &data, &test_gband, &test_gflags) == __RESULT_FAILURE) {
			ret = last_retval;
			break;
		}
		ret = data.len;
		break;
	}
	}
	return (ret);
}

int
expect(int child, int wait, int want)
{
	if ((last_event = wait_event(child, wait)) == want)
		return (__RESULT_SUCCESS);
	print_expect(child, want);
	return (__RESULT_FAILURE);
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Preambles and postambles
 *
 *  -------------------------------------------------------------------------
 */
static int
preamble_0(int child)
{
	return (__RESULT_SUCCESS);
}

static int
postamble_0(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			break;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}

static int
preamble_1(int child)
{
#if 0
	test_mgmtflags = T_NEGOTIATE;
	test_opts = &opt_optm;
	test_olen = sizeof(opt_optm);
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_mgmtflags != T_SUCCESS)
		goto failure;
	state++;
#endif
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
preamble_1s(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
postamble_1(int child)
{
	int failed = -1;
	const char *fail_string = NULL;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			fail_string = (fail_string == NULL) ? "Cannot get message" : fail_string;
			break;
		default:
			failed = (failed == -1) ? state : failed;
			fail_string = (fail_string == NULL) ? "Unexpected event" : fail_string;
			state++;
			continue;
		}
		break;
	}
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS) {
		failed = (failed == -1) ? state : failed;
		fail_string = (fail_string == NULL) ? "Cannot unbind." : fail_string;
	}
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS) {
		failed = (failed == -1) ? state : failed;
		fail_string = (fail_string == NULL) ? "No T_OK_ACK." : fail_string;
	}
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	failure_string = (failure_string == NULL) ? fail_string : failure_string;
	return (__RESULT_FAILURE);
}

#if 0
static int
postamble_1e(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			break;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) == __RESULT_SUCCESS || last_errno != EPROTO) {
		expect(child, SHORT_WAIT, __TEST_OK_ACK);
		failed = (failed == -1) ? state : failed;
	}
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}
#endif

static int
preamble_2_conn(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
preamble_2_resp(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
preamble_2_list(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
postamble_2_conn(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			break;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (postamble_1(child) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}

static int
postamble_2_resp(int child)
{
	int failed = -1;
	const char *fail_string = NULL;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			fail_string = (fail_string == NULL) ? "Cannot get message" : fail_string;
			break;
		case __TEST_DISCON_IND:
			goto got_disconnect;
		default:
			failed = (failed == -1) ? state : failed;
			fail_string = (fail_string == NULL) ? "Unexpected event" : fail_string;
			state++;
			continue;
		}
		break;
	}
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS) {
		failed = (failed == -1) ? state : failed;
		fail_string = (fail_string == NULL) ? "No T_DISCON_IND." : fail_string;
	}
      got_disconnect:
	state++;
	if (postamble_1(child) != __RESULT_SUCCESS) {
		failed = (failed == -1) ? state : failed;
		fail_string = (fail_string == NULL) ? "Postamble 1 failed." : fail_string;
	}
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	failure_string = (failure_string == NULL) ? fail_string : failure_string;
	return (__RESULT_FAILURE);
}

static int
postamble_2_list(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			break;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	if (postamble_1(child) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}

#if 1
static int
preamble_2b_conn(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = "Hello World";
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
preamble_2b_resp(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
preamble_2b_list(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = "Hello There!";
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

static int
postamble_3_conn(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			break;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (failed != -1) {
		state += 10;
		if (postamble_2_conn(child) != __RESULT_SUCCESS)
			failed = (failed == -1) ? state : failed;
	} else {
		if (postamble_1(child) != __RESULT_SUCCESS)
			failed = (failed == -1) ? state : failed;
	}
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}

static int
postamble_3_resp(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			break;
		case __TEST_ORDREL_IND:
			goto got_release;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
      got_release:
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (failed != -1) {
		state += 10;
		if (postamble_2_resp(child) != __RESULT_SUCCESS)
			failed = (failed == -1) ? state : failed;
	} else {
		if (postamble_1(child) != __RESULT_SUCCESS)
			failed = (failed == -1) ? state : failed;
	}
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}

static int
postamble_3_list(int child)
{
	return postamble_2_list(child);
}

static int
preamble_3b_conn(int child)
{
	opt_optm.rcv_val = T_YES;
	opt_optm.ist_val = 32;
	opt_optm.ost_val = 32;
	opt_conn.ist_val = 32;
	opt_conn.ost_val = 32;
	return preamble_2_conn(child);
}
static int
preamble_3b_resp(int child)
{
	opt_optm.rcv_val = T_YES;
	opt_optm.ist_val = 32;
	opt_optm.ost_val = 32;
	opt_conn.ist_val = 32;
	opt_conn.ost_val = 32;
	return preamble_2_resp(child);
}
static int
preamble_3b_list(int child)
{
	opt_optm.rcv_val = T_YES;
	opt_optm.ist_val = 32;
	opt_optm.ost_val = 32;
	opt_conn.ist_val = 32;
	opt_conn.ost_val = 32;
	return preamble_2_list(child);
}

static int
preamble_4_conn(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_DROPPING;
	return preamble_2_conn(child);
}
static int
preamble_4_list(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_DROPPING;
	return preamble_2_list(child);
}
static int
preamble_4_resp(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_DROPPING;
	return preamble_2_resp(child);
}

static int
preamble_4b_conn(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_RANDOM;
	return preamble_2_conn(child);
}
static int
preamble_4b_list(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_RANDOM;
	return preamble_2_list(child);
}
static int
preamble_4b_resp(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_RANDOM;
	return preamble_2_resp(child);
}

static int
preamble_5_conn(int child)
{
	// opt_optm.dbg_val = SCTP_OPTION_BREAK|SCTP_OPTION_DBREAK|SCTP_OPTION_DROPPING;
	opt_optm.dbg_val = SCTP_OPTION_BREAK;
	return preamble_2_conn(child);
}
static int
preamble_5_list(int child)
{
	// opt_optm.dbg_val = SCTP_OPTION_BREAK|SCTP_OPTION_DBREAK|SCTP_OPTION_DROPPING;
	opt_optm.dbg_val = SCTP_OPTION_BREAK;
	return preamble_2_list(child);
}
static int
preamble_5_resp(int child)
{
	// opt_optm.dbg_val = SCTP_OPTION_BREAK|SCTP_OPTION_DBREAK|SCTP_OPTION_DROPPING;
	opt_optm.dbg_val = SCTP_OPTION_BREAK;
	return preamble_2_resp(child);
}

static int
preamble_6_conn(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_RANDOM;
	return preamble_3b_conn(child);
}
static int
preamble_6_list(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_RANDOM;
	return preamble_3b_list(child);
}
static int
preamble_6_resp(int child)
{
	opt_optm.dbg_val = SCTP_OPTION_RANDOM;
	return preamble_3b_resp(child);
}

static int
preamble_7_conn(int child)
{
	opt_optm.mac_val = T_SCTP_HMAC_SHA1;
	return preamble_1(child);
}
static int
preamble_7_list(int child)
{
	opt_optm.mac_val = T_SCTP_HMAC_SHA1;
	return preamble_1(child);
}
static int
preamble_7_resp(int child)
{
	opt_optm.mac_val = T_SCTP_HMAC_SHA1;
	return preamble_1(child);
}

static int
preamble_8_conn(int child)
{
	opt_optm.mac_val = T_SCTP_HMAC_MD5;
	return preamble_1(child);
}
static int
preamble_8_list(int child)
{
	opt_optm.mac_val = T_SCTP_HMAC_MD5;
	return preamble_1(child);
}
static int
preamble_8_resp(int child)
{
	opt_optm.mac_val = T_SCTP_HMAC_MD5;
	return preamble_1(child);
}
#endif

/*
 *  =========================================================================
 *
 *  The Test Cases...
 *
 *  =========================================================================
 */

struct test_stream {
	int (*preamble) (int);		/* test preamble */
	int (*testcase) (int);		/* test case */
	int (*postamble) (int);		/* test postamble */
};

/*
 *  Check test case guard timer.
 */
#define test_group_0 "Sanity checks"
#define tgrp_case_0_1 test_group_0
#define numb_case_0_1 "0.1"
#define name_case_0_1 "Check test case guard timer."
#define sref_case_0_1 "(none)"
#define desc_case_0_1 "\
Checks that the test case guard timer will fire and bring down the children."

int
test_case_0_1(int child)
{
	test_msleep(child, TEST_DURATION<<1);
	return (__RESULT_SUCCESS);
}

#define preamble_0_1		preamble_0
#define postamble_0_1		postamble_0

struct test_stream test_0_1_conn = { &preamble_0_1, &test_case_0_1, &postamble_0_1 };
struct test_stream test_0_1_resp = { &preamble_0_1, &test_case_0_1, &postamble_0_1 };
struct test_stream test_0_1_list = { &preamble_0_1, &test_case_0_1, &postamble_0_1 };

/*
 *  Open and Close 3 streams.
 */
#define test_group_1 "Local management"
#define tgrp_case_1_1 test_group_1
#define numb_case_1_1 "1.1"
#define name_case_1_1 "Open and close 3 streams"
#define sref_case_1_1 "(none)"
#define desc_case_1_1 "\
Checks that three streams can be opened and closed."

int
test_case_1_1(int child)
{
	return (__RESULT_SUCCESS);
}

#define test_case_1_1_conn	test_case_1_1
#define test_case_1_1_resp	test_case_1_1
#define test_case_1_1_list	test_case_1_1

#define preamble_1_1_conn	preamble_0
#define preamble_1_1_resp	preamble_0
#define preamble_1_1_list	preamble_0

#define postamble_1_1_conn	postamble_0
#define postamble_1_1_resp	postamble_0
#define postamble_1_1_list	postamble_0

struct test_stream test_1_1_conn = { &preamble_1_1_conn, &test_case_1_1_conn, &postamble_1_1_conn };
struct test_stream test_1_1_resp = { &preamble_1_1_resp, &test_case_1_1_resp, &postamble_1_1_resp };
struct test_stream test_1_1_list = { &preamble_1_1_list, &test_case_1_1_list, &postamble_1_1_list };

/*
 *  Request information.
 */
#define tgrp_case_1_2 test_group_1
#define numb_case_1_2 "1.2"
#define name_case_1_2 "Request information."
#define sref_case_1_2 "TPI Rev 1.5 Sections 2.1.1.1, 2.1.2.1"
#define desc_case_1_2 "\
Checks that information can be requested on each of three streams,\n\
and that the returned information is appropriate for each stream."

int
test_case_1_2(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.PRIM_type != T_INFO_ACK)
		goto failure;
	state++;
	switch (test_level) {
	case T_INET_IP:
		if (last_info.TSDU_size != 65515)
			goto failure;
		state++;
		if (last_info.ETSDU_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.CDATA_size != T_INVALID && last_info.CDATA_size != 65515)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID && last_info.DDATA_size != 65515)
			goto failure;
		state++;
		if (last_info.ADDR_size != sizeof(struct sockaddr_in) && last_info.ADDR_size != 8 * sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE && last_info.OPT_size != 65535)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65515)
			goto failure;
		state++;
		if (last_info.SERV_type != T_CLTS)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	case T_INET_UDP:
		if (last_info.TSDU_size != 65507)
			goto failure;
		state++;
		if (last_info.ETSDU_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.CDATA_size != T_INVALID && last_info.CDATA_size != 65507)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID && last_info.DDATA_size != 65507)
			goto failure;
		state++;
		if (last_info.ADDR_size != sizeof(struct sockaddr_in) && last_info.ADDR_size != 8 * sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE && last_info.OPT_size != 65535)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65507)
			goto failure;
		state++;
		if (last_info.SERV_type != T_CLTS)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	case T_INET_TCP:
		if (last_info.TSDU_size != 0)
			goto failure;
		state++;
		if (last_info.ETSDU_size != 1)
			goto failure;
		state++;
		if (last_info.CDATA_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.ADDR_size != sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65535)
			goto failure;
		state++;
		if (last_info.SERV_type != T_COTS_ORD)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	case T_INET_SCTP:
		if (last_info.TSDU_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.ETSDU_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.CDATA_size != 536)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.ADDR_size != T_INFINITE && last_info.ADDR_size != 8 * sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65535)
			goto failure;
		state++;
		if (last_info.SERV_type != T_COTS_ORD)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_2_conn	test_case_1_2
#define test_case_1_2_resp	test_case_1_2
#define test_case_1_2_list	test_case_1_2

#define preamble_1_2_conn	preamble_0
#define preamble_1_2_resp	preamble_0
#define preamble_1_2_list	preamble_0

#define postamble_1_2_conn	postamble_0
#define postamble_1_2_resp	postamble_0
#define postamble_1_2_list	postamble_0

struct test_stream test_1_2_conn = { &preamble_1_2_conn, &test_case_1_2_conn, &postamble_1_2_conn };
struct test_stream test_1_2_resp = { &preamble_1_2_resp, &test_case_1_2_resp, &postamble_1_2_resp };
struct test_stream test_1_2_list = { &preamble_1_2_list, &test_case_1_2_list, &postamble_1_2_list };

/*
 *  Request capabilities.
 */
#define tgrp_case_1_3_1 test_group_1
#define numb_case_1_3_1 "1.3.1"
#define name_case_1_3_1 "Request capabilities."
#define sref_case_1_3_1 "TPI Version 2 Draft 2 -- Chapter 6 -- T_CAPABILITY_REQ"
#define desc_case_1_3_1 "\
Checks that capabilities can be requested on each of three streams,\n\
and that the returned information is appropriate for each stream."

int
test_case_1_3_1(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_CAPABILITY_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_CAPABILITY_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->capability_ack.PRIM_type != T_CAPABILITY_ACK)
		goto failure;
	state++;
	if (!(p->capability_ack.CAP_bits1 & TC1_INFO))
		goto failure;
	state++;
	if (!(p->capability_ack.CAP_bits1 & TC1_ACCEPTOR_ID))
		goto failure;
	state++;
	if (p->capability_ack.CAP_bits1 & TCI_CAP_BITS2)
		goto failure;
	state++;
	if (last_info.PRIM_type != T_INFO_ACK)
		goto failure;
	state++;
	switch (test_level) {
	case T_INET_IP:
		if (last_info.TSDU_size != 65515)
			goto failure;
		state++;
		if (last_info.ETSDU_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.CDATA_size != T_INVALID && last_info.CDATA_size != 65515)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID && last_info.DDATA_size != 65515)
			goto failure;
		state++;
		if (last_info.ADDR_size != sizeof(struct sockaddr_in) && last_info.ADDR_size != 8 * sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE && last_info.OPT_size != 65535)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65515)
			goto failure;
		state++;
		if (last_info.SERV_type != T_CLTS)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	case T_INET_UDP:
		if (last_info.TSDU_size != 65507)
			goto failure;
		state++;
		if (last_info.ETSDU_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.CDATA_size != T_INVALID && last_info.CDATA_size != 65507)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID && last_info.DDATA_size != 65507)
			goto failure;
		state++;
		if (last_info.ADDR_size != sizeof(struct sockaddr_in) && last_info.ADDR_size != 8 * sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE && last_info.OPT_size != 65535)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65507)
			goto failure;
		state++;
		if (last_info.SERV_type != T_CLTS)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	case T_INET_TCP:
		if (last_info.TSDU_size != 0)
			goto failure;
		state++;
		if (last_info.ETSDU_size != 1)
			goto failure;
		state++;
		if (last_info.CDATA_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.ADDR_size != sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65535)
			goto failure;
		state++;
		if (last_info.SERV_type != T_COTS_ORD)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	case T_INET_SCTP:
		if (last_info.TSDU_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.ETSDU_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.CDATA_size != 536)
			goto failure;
		state++;
		if (last_info.DDATA_size != T_INVALID)
			goto failure;
		state++;
		if (last_info.ADDR_size != 8 * sizeof(struct sockaddr_in))
			goto failure;
		state++;
		if (last_info.OPT_size != T_INFINITE)
			goto failure;
		state++;
		if (last_info.TIDU_size != 65535)
			goto failure;
		state++;
		if (last_info.SERV_type != T_COTS_ORD)
			goto failure;
		state++;
		if (last_info.CURRENT_state != TS_UNBND)
			goto failure;
		state++;
		if (last_info.PROVIDER_flag != T_XPG4_1)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	if (p->capability_ack.ACCEPTOR_id == 0)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_3_1_conn	test_case_1_3_1
#define test_case_1_3_1_resp	test_case_1_3_1
#define test_case_1_3_1_list	test_case_1_3_1

#define preamble_1_3_1_conn	preamble_0
#define preamble_1_3_1_resp	preamble_0
#define preamble_1_3_1_list	preamble_0

#define postamble_1_3_1_conn	postamble_0
#define postamble_1_3_1_resp	postamble_0
#define postamble_1_3_1_list	postamble_0

struct test_stream test_1_3_1_conn = { &preamble_1_3_1_conn, &test_case_1_3_1_conn, &postamble_1_3_1_conn };
struct test_stream test_1_3_1_resp = { &preamble_1_3_1_resp, &test_case_1_3_1_resp, &postamble_1_3_1_resp };
struct test_stream test_1_3_1_list = { &preamble_1_3_1_list, &test_case_1_3_1_list, &postamble_1_3_1_list };

#define tgrp_case_1_3_2 test_group_1
#define numb_case_1_3_2 "1.3.2"
#define name_case_1_3_2 "Request capabilities -- primitive in error."
#define sref_case_1_3_2 "TPI Version 2 Draft 2 -- Chapter 6 -- T_CAPABILITY_REQ"
#define desc_case_1_3_2 "\
Checks that a T_CAPABILITY_REQ primitive in error (too short) results in\n\
failure.  The specifications do not state what to do in the event that a\n\
primitive that is too short is received."

int
test_case_1_3_2(int child)
{
	last_prim = T_CAPABILITY_REQ;
	if (do_signal(child, __TEST_PRIM_TOO_SHORT) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (wait_event(child, NORMAL_WAIT)) {
	case __TEST_ERROR_ACK:
		state++;
		if (last_t_errno != TSYSERR || last_errno != EINVAL)
			goto failure;
		break;
	case __RESULT_FAILURE:
		state++;
		if (last_errno != EPROTO)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_3_2_conn	test_case_1_3_2
#define test_case_1_3_2_resp	test_case_1_3_2
#define test_case_1_3_2_list	test_case_1_3_2

#define preamble_1_3_2_conn	preamble_0
#define preamble_1_3_2_resp	preamble_0
#define preamble_1_3_2_list	preamble_0

#define postamble_1_3_2_conn	postamble_0
#define postamble_1_3_2_resp	postamble_0
#define postamble_1_3_2_list	postamble_0

struct test_stream test_1_3_2_conn = { &preamble_1_3_2_conn, &test_case_1_3_2_conn, &postamble_1_3_2_conn };
struct test_stream test_1_3_2_resp = { &preamble_1_3_2_resp, &test_case_1_3_2_resp, &postamble_1_3_2_resp };
struct test_stream test_1_3_2_list = { &preamble_1_3_2_list, &test_case_1_3_2_list, &postamble_1_3_1_list };

#define tgrp_case_1_3_3 test_group_1
#define numb_case_1_3_3 "1.3.3"
#define name_case_1_3_3 "Request capabilities -- M_PCPROTO"
#define sref_case_1_3_3 "TPI Version 2 Draft 2 -- Chapter 6 -- T_CAPABILITY_REQ"
#define desc_case_1_3_3 "\
Checks that a T_CAPABILITY_REQ sent as a M_PCPROTO is replied to with a\n\
T_CAPABILITY_ACK as a M_PCPROTO.  The TPI specification says that a\n\
T_CAPABILITY_REQ sent as a M_PCPROTO must be replied to with a T_CAPABILITY_ACK\n\
that is also a M_PCPROTO; and a T_CAPABILITY_REQ as a M_PROTO, with a\n\
T_CAPABILITY_ACK as a M_PROTO.  This test case verifies the M_PCPROTO behavior."

int
test_case_1_3_3(int child)
{
	test_prio = 1;
	if (do_signal(child, __TEST_CAPABILITY_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_CAPABILITY_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_prio == 0)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_3_3_conn	test_case_1_3_3
#define test_case_1_3_3_resp	test_case_1_3_3
#define test_case_1_3_3_list	test_case_1_3_3

#define preamble_1_3_3_conn	preamble_0
#define preamble_1_3_3_resp	preamble_0
#define preamble_1_3_3_list	preamble_0

#define postamble_1_3_3_conn	postamble_0
#define postamble_1_3_3_resp	postamble_0
#define postamble_1_3_3_list	postamble_0

struct test_stream test_1_3_3_conn = { &preamble_1_3_3_conn, &test_case_1_3_3_conn, &postamble_1_3_3_conn };
struct test_stream test_1_3_3_resp = { &preamble_1_3_3_resp, &test_case_1_3_3_resp, &postamble_1_3_3_resp };
struct test_stream test_1_3_3_list = { &preamble_1_3_3_list, &test_case_1_3_3_list, &postamble_1_3_3_list };

#define tgrp_case_1_3_4 test_group_1
#define numb_case_1_3_4 "1.3.4"
#define name_case_1_3_4 "Request capabilities -- M_PROTO"
#define sref_case_1_3_4 "TPI Version 2 Draft 2 -- Chapter 6 -- T_CAPABILITY_REQ"
#define desc_case_1_3_4 "\
Checks that a T_CAPABILITY_REQ sent as a M_PROTO is replied to with a\n\
T_CAPABILITY_ACK as a M_PROTO.  The TPI specification says that a\n\
T_CAPABILITY_REQ sent as a M_PCPROTO must be replied to with a T_CAPABILITY_ACK\n\
that is also a M_PCPROTO; and a T_CAPABILITY_REQ as a M_PROTO, with a\n\
T_CAPABILITY_ACK as a M_PROTO.  This test case verifies the M_PROTO behavior."

int
test_case_1_3_4(int child)
{
	test_prio = 0;
	if (do_signal(child, __TEST_CAPABILITY_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_CAPABILITY_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_prio != 0)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_3_4_conn	test_case_1_3_4
#define test_case_1_3_4_resp	test_case_1_3_4
#define test_case_1_3_4_list	test_case_1_3_4

#define preamble_1_3_4_conn	preamble_0
#define preamble_1_3_4_resp	preamble_0
#define preamble_1_3_4_list	preamble_0

#define postamble_1_3_4_conn	postamble_0
#define postamble_1_3_4_resp	postamble_0
#define postamble_1_3_4_list	postamble_0

struct test_stream test_1_3_4_conn = { &preamble_1_3_4_conn, &test_case_1_3_4_conn, &postamble_1_3_4_conn };
struct test_stream test_1_3_4_resp = { &preamble_1_3_4_resp, &test_case_1_3_4_resp, &postamble_1_3_4_resp };
struct test_stream test_1_3_4_list = { &preamble_1_3_4_list, &test_case_1_3_4_list, &postamble_1_3_4_list };

/*
 *  Request addresses.
 */
#define tgrp_case_1_4_1 test_group_1
#define numb_case_1_4_1 "1.4.1"
#define name_case_1_4_1 "Request addresses -- unbound state."
#define sref_case_1_4_1 "TPI Rev 1.5 Sections 2.1.1.5, 2.1.2.6"
#define desc_case_1_4_1 "\
Checks that addresses can be requested on each of three streams.  Because we are\n\
in the unbound state, neither local nor remote address should be returned."

int
test_case_1_4_1(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->addr_ack.PRIM_type != T_ADDR_ACK)
		goto failure;
	state++;
	if (p->addr_ack.LOCADDR_length != 0)
		goto failure;
	state++;
	if (p->addr_ack.REMADDR_length != 0)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_4_1_conn	test_case_1_4_1
#define test_case_1_4_1_resp	test_case_1_4_1
#define test_case_1_4_1_list	test_case_1_4_1

#define preamble_1_4_1_conn	preamble_0
#define preamble_1_4_1_resp	preamble_0
#define preamble_1_4_1_list	preamble_0

#define postamble_1_4_1_conn	postamble_0
#define postamble_1_4_1_resp	postamble_0
#define postamble_1_4_1_list	postamble_0

struct test_stream test_1_4_1_conn = { &preamble_1_4_1_conn, &test_case_1_4_1_conn, &postamble_1_4_1_conn };
struct test_stream test_1_4_1_resp = { &preamble_1_4_1_resp, &test_case_1_4_1_resp, &postamble_1_4_1_resp };
struct test_stream test_1_4_1_list = { &preamble_1_4_1_list, &test_case_1_4_1_list, &postamble_1_4_1_list };

#define tgrp_case_1_4_2 test_group_1
#define numb_case_1_4_2 "1.4.2"
#define name_case_1_4_2 "Request addresses -- bound state."
#define sref_case_1_4_2 "TPI Rev 1.5 Sections 2.1.1.5, 2.1.2.6"
#define desc_case_1_4_2 "\
Checks that addresses can be requested on each of three streams.  Because we are\n\
in the bound state, local but not remote addresses should be returned."

int
test_case_1_4_2(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->addr_ack.PRIM_type != T_ADDR_ACK)
		goto failure;
	state++;
	switch (test_level) {
	case T_INET_SCTP:
		/* SCTP returns multiple addresses */
		if (p->addr_ack.LOCADDR_length == 0)
			goto failure;
		state++;
		if ((p->addr_ack.LOCADDR_length % sizeof(struct sockaddr_in)) != 0)
			goto failure;
		break;
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		/* others return single address */
		if (p->addr_ack.LOCADDR_length != sizeof(struct sockaddr_in))
			goto failure;
		break;
	}
	state++;
	if (p->addr_ack.REMADDR_length != 0)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_4_2_conn	test_case_1_4_2
#define test_case_1_4_2_resp	test_case_1_4_2
#define test_case_1_4_2_list	test_case_1_4_2

#define preamble_1_4_2_conn	preamble_1
#define preamble_1_4_2_resp	preamble_1
#define preamble_1_4_2_list	preamble_1

#define postamble_1_4_2_conn	postamble_1
#define postamble_1_4_2_resp	postamble_1
#define postamble_1_4_2_list	postamble_1

struct test_stream test_1_4_2_conn = { &preamble_1_4_2_conn, &test_case_1_4_2_conn, &postamble_1_4_2_conn };
struct test_stream test_1_4_2_resp = { &preamble_1_4_2_resp, &test_case_1_4_2_resp, &postamble_1_4_2_resp };
struct test_stream test_1_4_2_list = { &preamble_1_4_2_list, &test_case_1_4_2_list, &postamble_1_4_2_list };

#define tgrp_case_1_4_3 test_group_1
#define numb_case_1_4_3 "1.4.3"
#define name_case_1_4_3 "Request addresses -- connected state."
#define sref_case_1_4_3 "TPI Rev 1.5 Sections 2.1.1.5, 2.1.2.6"
#define desc_case_1_4_3 "\
Checks that addresses can be requested on each of three streams.  Because we are\n\
in the connected state, local and remote addresses should be returned."

int
test_case_1_4_3(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->addr_ack.PRIM_type != T_ADDR_ACK)
		goto failure;
	state++;
	switch (test_level) {
	case T_INET_SCTP:
		/* SCTP returns multiple addresses */
		if (p->addr_ack.LOCADDR_length == 0) {
			failure_string = "LOCADDR_length == 0";
			goto failure;
		}
		state++;
		if ((p->addr_ack.LOCADDR_length % sizeof(struct sockaddr_in)) != 0) {
			failure_string = "LOCADDR_length % sockaddr_in";
			goto failure;
		}
		break;
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		/* others return single address */
		if (p->addr_ack.LOCADDR_length != sizeof(struct sockaddr_in)) {
			failure_string = "LOCADDR_length != sockaddr_in";
			goto failure;
		}
		break;
	}
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (p->addr_ack.REMADDR_length != 0) {
			failure_string = "REMADDR_length != 0";
			goto failure;
		}
		break;
	case T_COTS:
	case T_COTS_ORD:
		switch (test_level) {
		case T_INET_SCTP:
			/* SCTP returns multiple addresses */
			if (p->addr_ack.REMADDR_length == 0) {
				failure_string = "REMADDR_length == 0";
				goto failure;
			}
			state++;
			if ((p->addr_ack.REMADDR_length % sizeof(struct sockaddr_in)) != 0) {
				failure_string = "REMADDR_length % sockaddr_in";
				goto failure;
			}
			break;
		case T_INET_IP:
		case T_INET_UDP:
		case T_INET_TCP:
			/* others return single address */
			if (p->addr_ack.REMADDR_length != sizeof(struct sockaddr_in)) {
				failure_string = "REMADDR_length != sockaddr_in";
				goto failure;
			}
			break;
		}
		break;
	default:
		goto failure;
	}
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_4_3_conn(int child)
{
	if (last_info.SERV_type != T_CLTS) {
		if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
			goto failure;
		state++;
		test_data = "Synchornization test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	if (test_case_1_4_3(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_4_3_resp(int child)
{
	if (last_info.SERV_type != T_CLTS) {
		if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	if (test_case_1_4_3(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_4_3_list(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->addr_ack.PRIM_type != T_ADDR_ACK) {
		failure_string = "PRIM_type != T_ADDR_ACK";
		goto failure;
	}
	state++;
	switch (test_level) {
	case T_INET_SCTP:
		/* SCTP returns multiple addresses */
		if (p->addr_ack.LOCADDR_length == 0) {
			failure_string = "LOCADDR_length == 0";
			goto failure;
		}
		state++;
		if ((p->addr_ack.LOCADDR_length % sizeof(struct sockaddr_in)) != 0) {
			failure_string = "LOCADDR_length % sockaddr_in";
			goto failure;
		}
		break;
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		/* others return single address */
		if (p->addr_ack.LOCADDR_length != sizeof(struct sockaddr_in)) {
			failure_string = "LOCADDR_length != sockaddr_in";
			goto failure;
		}
		break;
	}
	state++;
	if (p->addr_ack.REMADDR_length != 0) {
		failure_string = "REMADDR_length != 0";
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
preamble_1_4_3_conn(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		return preamble_1(child);
	return preamble_2_conn(child);
      failure:
	return (__RESULT_FAILURE);
}

int
preamble_1_4_3_resp(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		return preamble_1(child);
	return preamble_2_resp(child);
      failure:
	return (__RESULT_FAILURE);
}

int
preamble_1_4_3_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		return preamble_1(child);
	return preamble_2_list(child);
      failure:
	return (__RESULT_FAILURE);
}

int
postamble_1_4_3_conn(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_1(child);
	return postamble_2_conn(child);
}

int
postamble_1_4_3_resp(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_1(child);
	return postamble_2_resp(child);
}

int
postamble_1_4_3_list(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_1(child);
	return postamble_2_list(child);
}

struct test_stream test_1_4_3_conn = { &preamble_1_4_3_conn, &test_case_1_4_3_conn, &postamble_1_4_3_conn };
struct test_stream test_1_4_3_resp = { &preamble_1_4_3_resp, &test_case_1_4_3_resp, &postamble_1_4_3_resp };
struct test_stream test_1_4_3_list = { &preamble_1_4_3_list, &test_case_1_4_3_list, &postamble_1_4_3_list };

/*
 *  Do options management.
 */
#define test_group_1_5 "Options management - T_DEFAULT"
#define tgrp_case_1_5 test_group_1_5
#define numb_case_1_5 "1.5"
#define name_case_1_5 "Perform options management."
#define sref_case_1_5 "TPI Rev 1.5 Sections 2.1.1.4, 2.1.2.3"
#define desc_case_1_5 "\
Checks that options management can be performed on several streams."

int
test_case_1_5(int child, ulong result)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags != result)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_5_xfail(int child, int terror, int error)
{
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != terror || (last_t_errno == TSYSERR && last_errno != error))
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_5_xti(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_5(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_5_ip(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_5(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_5_udp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_UDP:
		return test_case_1_5(child, result);
	case T_INET_IP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_5_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_5_tcp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_TCP:
		return test_case_1_5(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_SCTP:
		return test_case_1_5_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_5_sctp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_SCTP:
		return test_case_1_5(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		return test_case_1_5_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

#define preamble_1_5_conn	preamble_0
#define preamble_1_5_resp	preamble_0
#define preamble_1_5_list	preamble_0

#define postamble_1_5_conn	postamble_0
#define postamble_1_5_resp	postamble_0
#define postamble_1_5_list	postamble_0

#define test_group_1_5_1 "Local management -- XTI options management"
#define tgrp_case_1_5_1_1 test_group_1_5_1
#define numb_case_1_5_1_1 "1.5.1.1"
#define name_case_1_5_1_1 "Perform options management -- all options"
#define sref_case_1_5_1_1 sref_case_1_5
#define desc_case_1_5_1_1 "\
Checks that options management can be performed on several streams\n\
for all options."

int
test_case_1_5_1_1(int child)
{
	test_opts = &opt_optm;
	test_olen = sizeof(opt_optm);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5(child, T_SUCCESS);
}

#define test_case_1_5_1_1_conn test_case_1_5_1_1
#define test_case_1_5_1_1_resp test_case_1_5_1_1
#define test_case_1_5_1_1_list test_case_1_5_1_1

struct test_stream test_1_5_1_1_conn = { &preamble_1_5_conn, &test_case_1_5_1_1_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_1_resp = { &preamble_1_5_resp, &test_case_1_5_1_1_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_1_list = { &preamble_1_5_list, &test_case_1_5_1_1_list, &postamble_1_5_list };

#define tgrp_case_1_5_1_2 test_group_1_5_1
#define numb_case_1_5_1_2 "1.5.1.2"
#define name_case_1_5_1_2 "Perform options management -- XTI_DEBUG"
#define sref_case_1_5_1_2 sref_case_1_5
#define desc_case_1_5_1_2 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_DEBUG."

int
test_case_1_5_1_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_1_2_conn test_case_1_5_1_2
#define test_case_1_5_1_2_resp test_case_1_5_1_2
#define test_case_1_5_1_2_list test_case_1_5_1_2

struct test_stream test_1_5_1_2_conn = { &preamble_1_5_conn, &test_case_1_5_1_2_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_2_resp = { &preamble_1_5_resp, &test_case_1_5_1_2_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_2_list = { &preamble_1_5_list, &test_case_1_5_1_2_list, &postamble_1_5_list };

#define tgrp_case_1_5_1_3 test_group_1_5_1
#define numb_case_1_5_1_3 "1.5.1.3"
#define name_case_1_5_1_3 "Perform options management -- XTI_LINGER"
#define sref_case_1_5_1_3 sref_case_1_5
#define desc_case_1_5_1_3 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_LINGER."

int
test_case_1_5_1_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_1_3_conn test_case_1_5_1_3
#define test_case_1_5_1_3_resp test_case_1_5_1_3
#define test_case_1_5_1_3_list test_case_1_5_1_3

struct test_stream test_1_5_1_3_conn = { &preamble_1_5_conn, &test_case_1_5_1_3_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_3_resp = { &preamble_1_5_resp, &test_case_1_5_1_3_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_3_list = { &preamble_1_5_list, &test_case_1_5_1_3_list, &postamble_1_5_list };

#define tgrp_case_1_5_1_4 test_group_1_5_1
#define numb_case_1_5_1_4 "1.5.1.4"
#define name_case_1_5_1_4 "Perform options management -- XTI_RCVBUF"
#define sref_case_1_5_1_4 sref_case_1_5
#define desc_case_1_5_1_4 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVBUF."

int
test_case_1_5_1_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_1_4_conn test_case_1_5_1_4
#define test_case_1_5_1_4_resp test_case_1_5_1_4
#define test_case_1_5_1_4_list test_case_1_5_1_4

struct test_stream test_1_5_1_4_conn = { &preamble_1_5_conn, &test_case_1_5_1_4_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_4_resp = { &preamble_1_5_resp, &test_case_1_5_1_4_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_4_list = { &preamble_1_5_list, &test_case_1_5_1_4_list, &postamble_1_5_list };

#define tgrp_case_1_5_1_5 test_group_1_5_1
#define numb_case_1_5_1_5 "1.5.1.5"
#define name_case_1_5_1_5 "Perform options management -- XTI_RCVLOWAT"
#define sref_case_1_5_1_5 sref_case_1_5
#define desc_case_1_5_1_5 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVLOWAT."

int
test_case_1_5_1_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_1_5_conn test_case_1_5_1_5
#define test_case_1_5_1_5_resp test_case_1_5_1_5
#define test_case_1_5_1_5_list test_case_1_5_1_5

struct test_stream test_1_5_1_5_conn = { &preamble_1_5_conn, &test_case_1_5_1_5_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_5_resp = { &preamble_1_5_resp, &test_case_1_5_1_5_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_5_list = { &preamble_1_5_list, &test_case_1_5_1_5_list, &postamble_1_5_list };

#define tgrp_case_1_5_1_6 test_group_1_5_1
#define numb_case_1_5_1_6 "1.5.1.6"
#define name_case_1_5_1_6 "Perform options management -- XTI_SNDBUF"
#define sref_case_1_5_1_6 sref_case_1_5
#define desc_case_1_5_1_6 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDBUF."

int
test_case_1_5_1_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_1_6_conn test_case_1_5_1_6
#define test_case_1_5_1_6_resp test_case_1_5_1_6
#define test_case_1_5_1_6_list test_case_1_5_1_6

struct test_stream test_1_5_1_6_conn = { &preamble_1_5_conn, &test_case_1_5_1_6_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_6_resp = { &preamble_1_5_resp, &test_case_1_5_1_6_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_6_list = { &preamble_1_5_list, &test_case_1_5_1_6_list, &postamble_1_5_list };

#define tgrp_case_1_5_1_7 test_group_1_5_1
#define numb_case_1_5_1_7 "1.5.1.7"
#define name_case_1_5_1_7 "Perform options management -- XTI_SNDLOWAT"
#define sref_case_1_5_1_7 sref_case_1_5
#define desc_case_1_5_1_7 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDLOWAT."

int
test_case_1_5_1_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_1_7_conn test_case_1_5_1_7
#define test_case_1_5_1_7_resp test_case_1_5_1_7
#define test_case_1_5_1_7_list test_case_1_5_1_7

struct test_stream test_1_5_1_7_conn = { &preamble_1_5_conn, &test_case_1_5_1_7_conn, &postamble_1_5_conn };
struct test_stream test_1_5_1_7_resp = { &preamble_1_5_resp, &test_case_1_5_1_7_resp, &postamble_1_5_resp };
struct test_stream test_1_5_1_7_list = { &preamble_1_5_list, &test_case_1_5_1_7_list, &postamble_1_5_list };

#define test_group_1_5_2 "Local management -- IP options management"
#define tgrp_case_1_5_2_1 test_group_1_5_2
#define numb_case_1_5_2_1 "1.5.2.1"
#define name_case_1_5_2_1 "Perform options management -- T_IP_TOS"
#define sref_case_1_5_2_1 sref_case_1_5
#define desc_case_1_5_2_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TOS."

int
test_case_1_5_2_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_2_1_conn test_case_1_5_2_1
#define test_case_1_5_2_1_resp test_case_1_5_2_1
#define test_case_1_5_2_1_list test_case_1_5_2_1

struct test_stream test_1_5_2_1_conn = { &preamble_1_5_conn, &test_case_1_5_2_1_conn, &postamble_1_5_conn };
struct test_stream test_1_5_2_1_resp = { &preamble_1_5_resp, &test_case_1_5_2_1_resp, &postamble_1_5_resp };
struct test_stream test_1_5_2_1_list = { &preamble_1_5_list, &test_case_1_5_2_1_list, &postamble_1_5_list };

#define tgrp_case_1_5_2_2 test_group_1_5_2
#define numb_case_1_5_2_2 "1.5.2.2"
#define name_case_1_5_2_2 "Perform options management -- T_IP_TTL"
#define sref_case_1_5_2_2 sref_case_1_5
#define desc_case_1_5_2_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TTL."

int
test_case_1_5_2_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_2_2_conn test_case_1_5_2_2
#define test_case_1_5_2_2_resp test_case_1_5_2_2
#define test_case_1_5_2_2_list test_case_1_5_2_2

struct test_stream test_1_5_2_2_conn = { &preamble_1_5_conn, &test_case_1_5_2_2_conn, &postamble_1_5_conn };
struct test_stream test_1_5_2_2_resp = { &preamble_1_5_resp, &test_case_1_5_2_2_resp, &postamble_1_5_resp };
struct test_stream test_1_5_2_2_list = { &preamble_1_5_list, &test_case_1_5_2_2_list, &postamble_1_5_list };

#define tgrp_case_1_5_2_3 test_group_1_5_2
#define numb_case_1_5_2_3 "1.5.2.3"
#define name_case_1_5_2_3 "Perform options management -- T_IP_DONTROUTE"
#define sref_case_1_5_2_3 sref_case_1_5
#define desc_case_1_5_2_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_DONTROUTE."

int
test_case_1_5_2_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_2_3_conn test_case_1_5_2_3
#define test_case_1_5_2_3_resp test_case_1_5_2_3
#define test_case_1_5_2_3_list test_case_1_5_2_3

struct test_stream test_1_5_2_3_conn = { &preamble_1_5_conn, &test_case_1_5_2_3_conn, &postamble_1_5_conn };
struct test_stream test_1_5_2_3_resp = { &preamble_1_5_resp, &test_case_1_5_2_3_resp, &postamble_1_5_resp };
struct test_stream test_1_5_2_3_list = { &preamble_1_5_list, &test_case_1_5_2_3_list, &postamble_1_5_list };

#define tgrp_case_1_5_2_4 test_group_1_5_2
#define numb_case_1_5_2_4 "1.5.2.4"
#define name_case_1_5_2_4 "Perform options management -- T_IP_BROADCAST"
#define sref_case_1_5_2_4 sref_case_1_5
#define desc_case_1_5_2_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_BROADCAST."

int
test_case_1_5_2_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_2_4_conn test_case_1_5_2_4
#define test_case_1_5_2_4_resp test_case_1_5_2_4
#define test_case_1_5_2_4_list test_case_1_5_2_4

struct test_stream test_1_5_2_4_conn = { &preamble_1_5_conn, &test_case_1_5_2_4_conn, &postamble_1_5_conn };
struct test_stream test_1_5_2_4_resp = { &preamble_1_5_resp, &test_case_1_5_2_4_resp, &postamble_1_5_resp };
struct test_stream test_1_5_2_4_list = { &preamble_1_5_list, &test_case_1_5_2_4_list, &postamble_1_5_list };

#define tgrp_case_1_5_2_5 test_group_1_5_2
#define numb_case_1_5_2_5 "1.5.2.5"
#define name_case_1_5_2_5 "Perform options management -- T_IP_REUSEADDR"
#define sref_case_1_5_2_5 sref_case_1_5
#define desc_case_1_5_2_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_REUSEADDR."

int
test_case_1_5_2_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_2_5_conn test_case_1_5_2_5
#define test_case_1_5_2_5_resp test_case_1_5_2_5
#define test_case_1_5_2_5_list test_case_1_5_2_5

struct test_stream test_1_5_2_5_conn = { &preamble_1_5_conn, &test_case_1_5_2_5_conn, &postamble_1_5_conn };
struct test_stream test_1_5_2_5_resp = { &preamble_1_5_resp, &test_case_1_5_2_5_resp, &postamble_1_5_resp };
struct test_stream test_1_5_2_5_list = { &preamble_1_5_list, &test_case_1_5_2_5_list, &postamble_1_5_list };

#define test_group_1_5_3 "Local management -- UDP options management"
#define tgrp_case_1_5_3_1 test_group_1_5_3
#define numb_case_1_5_3_1 "1.5.3.1"
#define name_case_1_5_3_1 "Perform options management -- T_UDP_CHECKSUM"
#define sref_case_1_5_3_1 sref_case_1_5
#define desc_case_1_5_3_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_UDP option T_UDP_CHECKSUM."

int
test_case_1_5_3_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_udp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_3_1_conn test_case_1_5_3_1
#define test_case_1_5_3_1_resp test_case_1_5_3_1
#define test_case_1_5_3_1_list test_case_1_5_3_1

struct test_stream test_1_5_3_1_conn = { &preamble_1_5_conn, &test_case_1_5_3_1_conn, &postamble_1_5_conn };
struct test_stream test_1_5_3_1_resp = { &preamble_1_5_resp, &test_case_1_5_3_1_resp, &postamble_1_5_resp };
struct test_stream test_1_5_3_1_list = { &preamble_1_5_list, &test_case_1_5_3_1_list, &postamble_1_5_list };

#define test_group_1_5_4 "Local management -- TCP options management"
#define tgrp_case_1_5_4_1 test_group_1_5_4
#define numb_case_1_5_4_1 "1.5.4.1"
#define name_case_1_5_4_1 "Perform options management -- T_TCP_NODELAY"
#define sref_case_1_5_4_1 sref_case_1_5
#define desc_case_1_5_4_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_NODELAY."

int
test_case_1_5_4_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_1_conn test_case_1_5_4_1
#define test_case_1_5_4_1_resp test_case_1_5_4_1
#define test_case_1_5_4_1_list test_case_1_5_4_1

struct test_stream test_1_5_4_1_conn = { &preamble_1_5_conn, &test_case_1_5_4_1_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_1_resp = { &preamble_1_5_resp, &test_case_1_5_4_1_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_1_list = { &preamble_1_5_list, &test_case_1_5_4_1_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_2 test_group_1_5_4
#define numb_case_1_5_4_2 "1.5.4.2"
#define name_case_1_5_4_2 "Perform options management -- T_TCP_MAXSEG"
#define sref_case_1_5_4_2 sref_case_1_5
#define desc_case_1_5_4_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_MAXSEG."

int
test_case_1_5_4_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_2_conn test_case_1_5_4_2
#define test_case_1_5_4_2_resp test_case_1_5_4_2
#define test_case_1_5_4_2_list test_case_1_5_4_2

struct test_stream test_1_5_4_2_conn = { &preamble_1_5_conn, &test_case_1_5_4_2_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_2_resp = { &preamble_1_5_resp, &test_case_1_5_4_2_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_2_list = { &preamble_1_5_list, &test_case_1_5_4_2_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_3 test_group_1_5_4
#define numb_case_1_5_4_3 "1.5.4.3"
#define name_case_1_5_4_3 "Perform options management -- T_TCP_KEEPALIVE"
#define sref_case_1_5_4_3 sref_case_1_5
#define desc_case_1_5_4_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPALIVE."

int
test_case_1_5_4_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_3_conn test_case_1_5_4_3
#define test_case_1_5_4_3_resp test_case_1_5_4_3
#define test_case_1_5_4_3_list test_case_1_5_4_3

struct test_stream test_1_5_4_3_conn = { &preamble_1_5_conn, &test_case_1_5_4_3_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_3_resp = { &preamble_1_5_resp, &test_case_1_5_4_3_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_3_list = { &preamble_1_5_list, &test_case_1_5_4_3_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_4 test_group_1_5_4
#define numb_case_1_5_4_4 "1.5.4.4"
#define name_case_1_5_4_4 "Perform options management -- T_TCP_CORK"
#define sref_case_1_5_4_4 sref_case_1_5
#define desc_case_1_5_4_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_CORK."

int
test_case_1_5_4_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_4_conn test_case_1_5_4_4
#define test_case_1_5_4_4_resp test_case_1_5_4_4
#define test_case_1_5_4_4_list test_case_1_5_4_4

struct test_stream test_1_5_4_4_conn = { &preamble_1_5_conn, &test_case_1_5_4_4_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_4_resp = { &preamble_1_5_resp, &test_case_1_5_4_4_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_4_list = { &preamble_1_5_list, &test_case_1_5_4_4_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_5 test_group_1_5_4
#define numb_case_1_5_4_5 "1.5.4.5"
#define name_case_1_5_4_5 "Perform options management -- T_TCP_KEEPIDLE"
#define sref_case_1_5_4_5 sref_case_1_5
#define desc_case_1_5_4_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPIDLE."

int
test_case_1_5_4_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_5_conn test_case_1_5_4_5
#define test_case_1_5_4_5_resp test_case_1_5_4_5
#define test_case_1_5_4_5_list test_case_1_5_4_5

struct test_stream test_1_5_4_5_conn = { &preamble_1_5_conn, &test_case_1_5_4_5_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_5_resp = { &preamble_1_5_resp, &test_case_1_5_4_5_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_5_list = { &preamble_1_5_list, &test_case_1_5_4_5_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_6 test_group_1_5_4
#define numb_case_1_5_4_6 "1.5.4.6"
#define name_case_1_5_4_6 "Perform options management -- T_TCP_KEEPINTVL"
#define sref_case_1_5_4_6 sref_case_1_5
#define desc_case_1_5_4_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPINTVL."

int
test_case_1_5_4_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_6_conn test_case_1_5_4_6
#define test_case_1_5_4_6_resp test_case_1_5_4_6
#define test_case_1_5_4_6_list test_case_1_5_4_6

struct test_stream test_1_5_4_6_conn = { &preamble_1_5_conn, &test_case_1_5_4_6_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_6_resp = { &preamble_1_5_resp, &test_case_1_5_4_6_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_6_list = { &preamble_1_5_list, &test_case_1_5_4_6_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_7 test_group_1_5_4
#define numb_case_1_5_4_7 "1.5.4.7"
#define name_case_1_5_4_7 "Perform options management -- T_TCP_KEEPCNT"
#define sref_case_1_5_4_7 sref_case_1_5
#define desc_case_1_5_4_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPCNT."

int
test_case_1_5_4_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_7_conn test_case_1_5_4_7
#define test_case_1_5_4_7_resp test_case_1_5_4_7
#define test_case_1_5_4_7_list test_case_1_5_4_7

struct test_stream test_1_5_4_7_conn = { &preamble_1_5_conn, &test_case_1_5_4_7_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_7_resp = { &preamble_1_5_resp, &test_case_1_5_4_7_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_7_list = { &preamble_1_5_list, &test_case_1_5_4_7_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_8 test_group_1_5_4
#define numb_case_1_5_4_8 "1.5.4.8"
#define name_case_1_5_4_8 "Perform options management -- T_TCP_SYNCNT"
#define sref_case_1_5_4_8 sref_case_1_5
#define desc_case_1_5_4_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_SYNCNT."

int
test_case_1_5_4_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_8_conn test_case_1_5_4_8
#define test_case_1_5_4_8_resp test_case_1_5_4_8
#define test_case_1_5_4_8_list test_case_1_5_4_8

struct test_stream test_1_5_4_8_conn = { &preamble_1_5_conn, &test_case_1_5_4_8_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_8_resp = { &preamble_1_5_resp, &test_case_1_5_4_8_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_8_list = { &preamble_1_5_list, &test_case_1_5_4_8_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_9 test_group_1_5_4
#define numb_case_1_5_4_9 "1.5.4.9"
#define name_case_1_5_4_9 "Perform options management -- T_TCP_LINGER2"
#define sref_case_1_5_4_9 sref_case_1_5
#define desc_case_1_5_4_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_LINGER2."

int
test_case_1_5_4_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_9_conn test_case_1_5_4_9
#define test_case_1_5_4_9_resp test_case_1_5_4_9
#define test_case_1_5_4_9_list test_case_1_5_4_9

struct test_stream test_1_5_4_9_conn = { &preamble_1_5_conn, &test_case_1_5_4_9_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_9_resp = { &preamble_1_5_resp, &test_case_1_5_4_9_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_9_list = { &preamble_1_5_list, &test_case_1_5_4_9_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_10 test_group_1_5_4
#define numb_case_1_5_4_10 "1.5.4.10"
#define name_case_1_5_4_10 "Perform options management -- T_TCP_DEFER_ACCEPT"
#define sref_case_1_5_4_10 sref_case_1_5
#define desc_case_1_5_4_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_DEFER_ACCEPT."

int
test_case_1_5_4_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_10_conn test_case_1_5_4_10
#define test_case_1_5_4_10_resp test_case_1_5_4_10
#define test_case_1_5_4_10_list test_case_1_5_4_10

struct test_stream test_1_5_4_10_conn = { &preamble_1_5_conn, &test_case_1_5_4_10_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_10_resp = { &preamble_1_5_resp, &test_case_1_5_4_10_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_10_list = { &preamble_1_5_list, &test_case_1_5_4_10_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_11 test_group_1_5_4
#define numb_case_1_5_4_11 "1.5.4.11"
#define name_case_1_5_4_11 "Perform options management -- T_TCP_WINDOW_CLAMP"
#define sref_case_1_5_4_11 sref_case_1_5
#define desc_case_1_5_4_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_WINDOW_CLAMP."

int
test_case_1_5_4_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_11_conn test_case_1_5_4_11
#define test_case_1_5_4_11_resp test_case_1_5_4_11
#define test_case_1_5_4_11_list test_case_1_5_4_11

struct test_stream test_1_5_4_11_conn = { &preamble_1_5_conn, &test_case_1_5_4_11_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_11_resp = { &preamble_1_5_resp, &test_case_1_5_4_11_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_11_list = { &preamble_1_5_list, &test_case_1_5_4_11_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_12 test_group_1_5_4
#define numb_case_1_5_4_12 "1.5.4.12"
#define name_case_1_5_4_12 "Perform options management -- T_TCP_INFO"
#define sref_case_1_5_4_12 sref_case_1_5
#define desc_case_1_5_4_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_INFO."

int
test_case_1_5_4_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_5_4_12_conn test_case_1_5_4_12
#define test_case_1_5_4_12_resp test_case_1_5_4_12
#define test_case_1_5_4_12_list test_case_1_5_4_12

struct test_stream test_1_5_4_12_conn = { &preamble_1_5_conn, &test_case_1_5_4_12_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_12_resp = { &preamble_1_5_resp, &test_case_1_5_4_12_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_12_list = { &preamble_1_5_list, &test_case_1_5_4_12_list, &postamble_1_5_list };

#define tgrp_case_1_5_4_13 test_group_1_5_4
#define numb_case_1_5_4_13 "1.5.4.13"
#define name_case_1_5_4_13 "Perform options management -- T_TCP_QUICKACK"
#define sref_case_1_5_4_13 sref_case_1_5
#define desc_case_1_5_4_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_QUICKACK."

int
test_case_1_5_4_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_4_13_conn test_case_1_5_4_13
#define test_case_1_5_4_13_resp test_case_1_5_4_13
#define test_case_1_5_4_13_list test_case_1_5_4_13

struct test_stream test_1_5_4_13_conn = { &preamble_1_5_conn, &test_case_1_5_4_13_conn, &postamble_1_5_conn };
struct test_stream test_1_5_4_13_resp = { &preamble_1_5_resp, &test_case_1_5_4_13_resp, &postamble_1_5_resp };
struct test_stream test_1_5_4_13_list = { &preamble_1_5_list, &test_case_1_5_4_13_list, &postamble_1_5_list };

#define test_group_1_5_5 "Local management -- SCTP options management"
/*
 *  Perform options management -- T_SCTP_NODELAY
 */
#define tgrp_case_1_5_5_1 test_group_1_5_5
#define numb_case_1_5_5_1 "1.5.5.1"
#define name_case_1_5_5_1 "Perform options management -- T_SCTP_NODELAY"
#define sref_case_1_5_5_1 sref_case_1_5
#define desc_case_1_5_5_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_NODELAY."

int
test_case_1_5_5_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_1_conn test_case_1_5_5_1
#define test_case_1_5_5_1_resp test_case_1_5_5_1
#define test_case_1_5_5_1_list test_case_1_5_5_1

struct test_stream test_1_5_5_1_conn = { &preamble_1_5_conn, &test_case_1_5_5_1_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_1_resp = { &preamble_1_5_resp, &test_case_1_5_5_1_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_1_list = { &preamble_1_5_list, &test_case_1_5_5_1_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_CORK
 */
#define tgrp_case_1_5_5_2 test_group_1_5_5
#define numb_case_1_5_5_2 "1.5.5.2"
#define name_case_1_5_5_2 "Perform options management -- T_SCTP_CORK"
#define sref_case_1_5_5_2 sref_case_1_5
#define desc_case_1_5_5_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CORK."

int
test_case_1_5_5_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_2_conn test_case_1_5_5_2
#define test_case_1_5_5_2_resp test_case_1_5_5_2
#define test_case_1_5_5_2_list test_case_1_5_5_2

struct test_stream test_1_5_5_2_conn = { &preamble_1_5_conn, &test_case_1_5_5_2_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_2_resp = { &preamble_1_5_resp, &test_case_1_5_5_2_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_2_list = { &preamble_1_5_list, &test_case_1_5_5_2_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_PPI
 */
#define tgrp_case_1_5_5_3 test_group_1_5_5
#define numb_case_1_5_5_3 "1.5.5.3"
#define name_case_1_5_5_3 "Perform options management -- T_SCTP_PPI"
#define sref_case_1_5_5_3 sref_case_1_5
#define desc_case_1_5_5_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PPI."

int
test_case_1_5_5_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_3_conn test_case_1_5_5_3
#define test_case_1_5_5_3_resp test_case_1_5_5_3
#define test_case_1_5_5_3_list test_case_1_5_5_3

struct test_stream test_1_5_5_3_conn = { &preamble_1_5_conn, &test_case_1_5_5_3_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_3_resp = { &preamble_1_5_resp, &test_case_1_5_5_3_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_3_list = { &preamble_1_5_list, &test_case_1_5_5_3_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_SID
 */
#define tgrp_case_1_5_5_4 test_group_1_5_5
#define numb_case_1_5_5_4 "1.5.5.4"
#define name_case_1_5_5_4 "Perform options management -- T_SCTP_SID"
#define sref_case_1_5_5_4 sref_case_1_5
#define desc_case_1_5_5_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SID."

int
test_case_1_5_5_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_4_conn test_case_1_5_5_4
#define test_case_1_5_5_4_resp test_case_1_5_5_4
#define test_case_1_5_5_4_list test_case_1_5_5_4

struct test_stream test_1_5_5_4_conn = { &preamble_1_5_conn, &test_case_1_5_5_4_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_4_resp = { &preamble_1_5_resp, &test_case_1_5_5_4_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_4_list = { &preamble_1_5_list, &test_case_1_5_5_4_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_SSN
 */
#define tgrp_case_1_5_5_5 test_group_1_5_5
#define numb_case_1_5_5_5 "1.5.5.5"
#define name_case_1_5_5_5 "Perform options management -- T_SCTP_SSN"
#define sref_case_1_5_5_5 sref_case_1_5
#define desc_case_1_5_5_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SSN."

int
test_case_1_5_5_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_5_5_5_conn test_case_1_5_5_5
#define test_case_1_5_5_5_resp test_case_1_5_5_5
#define test_case_1_5_5_5_list test_case_1_5_5_5

struct test_stream test_1_5_5_5_conn = { &preamble_1_5_conn, &test_case_1_5_5_5_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_5_resp = { &preamble_1_5_resp, &test_case_1_5_5_5_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_5_list = { &preamble_1_5_list, &test_case_1_5_5_5_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_TSN
 */
#define tgrp_case_1_5_5_6 test_group_1_5_5
#define numb_case_1_5_5_6 "1.5.5.6"
#define name_case_1_5_5_6 "Perform options management -- T_SCTP_TSN"
#define sref_case_1_5_5_6 sref_case_1_5
#define desc_case_1_5_5_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_TSN."

int
test_case_1_5_5_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_5_5_6_conn test_case_1_5_5_6
#define test_case_1_5_5_6_resp test_case_1_5_5_6
#define test_case_1_5_5_6_list test_case_1_5_5_6

struct test_stream test_1_5_5_6_conn = { &preamble_1_5_conn, &test_case_1_5_5_6_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_6_resp = { &preamble_1_5_resp, &test_case_1_5_5_6_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_6_list = { &preamble_1_5_list, &test_case_1_5_5_6_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_RECVOPT
 */
#define tgrp_case_1_5_5_7 test_group_1_5_5
#define numb_case_1_5_5_7 "1.5.5.7"
#define name_case_1_5_5_7 "Perform options management -- T_SCTP_RECVOPT"
#define sref_case_1_5_5_7 sref_case_1_5
#define desc_case_1_5_5_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RECVOPT."

int
test_case_1_5_5_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_7_conn test_case_1_5_5_7
#define test_case_1_5_5_7_resp test_case_1_5_5_7
#define test_case_1_5_5_7_list test_case_1_5_5_7

struct test_stream test_1_5_5_7_conn = { &preamble_1_5_conn, &test_case_1_5_5_7_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_7_resp = { &preamble_1_5_resp, &test_case_1_5_5_7_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_7_list = { &preamble_1_5_list, &test_case_1_5_5_7_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_LIFE
 */
#define tgrp_case_1_5_5_8 test_group_1_5_5
#define numb_case_1_5_5_8 "1.5.5.8"
#define name_case_1_5_5_8 "Perform options management -- T_SCTP_COOKIE_LIFE"
#define sref_case_1_5_5_8 sref_case_1_5
#define desc_case_1_5_5_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_LIFE."

int
test_case_1_5_5_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_8_conn test_case_1_5_5_8
#define test_case_1_5_5_8_resp test_case_1_5_5_8
#define test_case_1_5_5_8_list test_case_1_5_5_8

struct test_stream test_1_5_5_8_conn = { &preamble_1_5_conn, &test_case_1_5_5_8_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_8_resp = { &preamble_1_5_resp, &test_case_1_5_5_8_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_8_list = { &preamble_1_5_list, &test_case_1_5_5_8_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_SACK_DELAY
 */
#define tgrp_case_1_5_5_9 test_group_1_5_5
#define numb_case_1_5_5_9 "1.5.5.9"
#define name_case_1_5_5_9 "Perform options management -- T_SCTP_SACK_DELAY"
#define sref_case_1_5_5_9 sref_case_1_5
#define desc_case_1_5_5_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SACK_DELAY."

int
test_case_1_5_5_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_9_conn test_case_1_5_5_9
#define test_case_1_5_5_9_resp test_case_1_5_5_9
#define test_case_1_5_5_9_list test_case_1_5_5_9

struct test_stream test_1_5_5_9_conn = { &preamble_1_5_conn, &test_case_1_5_5_9_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_9_resp = { &preamble_1_5_resp, &test_case_1_5_5_9_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_9_list = { &preamble_1_5_list, &test_case_1_5_5_9_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_PATH_MAX_RETRANS
 */
#define tgrp_case_1_5_5_10 test_group_1_5_5
#define numb_case_1_5_5_10 "1.5.5.10"
#define name_case_1_5_5_10 "Perform options management -- T_SCTP_PATH_MAX_RETRANS"
#define sref_case_1_5_5_10 sref_case_1_5
#define desc_case_1_5_5_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PATH_MAX_RETRANS."

int
test_case_1_5_5_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_10_conn test_case_1_5_5_10
#define test_case_1_5_5_10_resp test_case_1_5_5_10
#define test_case_1_5_5_10_list test_case_1_5_5_10

struct test_stream test_1_5_5_10_conn = { &preamble_1_5_conn, &test_case_1_5_5_10_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_10_resp = { &preamble_1_5_resp, &test_case_1_5_5_10_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_10_list = { &preamble_1_5_list, &test_case_1_5_5_10_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_ASSOC_MAX_RETRANS
 */
#define tgrp_case_1_5_5_11 test_group_1_5_5
#define numb_case_1_5_5_11 "1.5.5.11"
#define name_case_1_5_5_11 "Perform options management -- T_SCTP_ASSOC_MAX_RETRANS"
#define sref_case_1_5_5_11 sref_case_1_5
#define desc_case_1_5_5_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ASSOC_MAX_RETRANS."

int
test_case_1_5_5_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_11_conn test_case_1_5_5_11
#define test_case_1_5_5_11_resp test_case_1_5_5_11
#define test_case_1_5_5_11_list test_case_1_5_5_11

struct test_stream test_1_5_5_11_conn = { &preamble_1_5_conn, &test_case_1_5_5_11_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_11_resp = { &preamble_1_5_resp, &test_case_1_5_5_11_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_11_list = { &preamble_1_5_list, &test_case_1_5_5_11_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_MAX_INIT_RETRIES
 */
#define tgrp_case_1_5_5_12 test_group_1_5_5
#define numb_case_1_5_5_12 "1.5.5.12"
#define name_case_1_5_5_12 "Perform options management -- T_SCTP_MAX_INIT_RETRIES"
#define sref_case_1_5_5_12 sref_case_1_5
#define desc_case_1_5_5_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_INIT_RETRIES."

int
test_case_1_5_5_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_12_conn test_case_1_5_5_12
#define test_case_1_5_5_12_resp test_case_1_5_5_12
#define test_case_1_5_5_12_list test_case_1_5_5_12

struct test_stream test_1_5_5_12_conn = { &preamble_1_5_conn, &test_case_1_5_5_12_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_12_resp = { &preamble_1_5_resp, &test_case_1_5_5_12_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_12_list = { &preamble_1_5_list, &test_case_1_5_5_12_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_HEARTBEAT_ITVL
 */
#define tgrp_case_1_5_5_13 test_group_1_5_5
#define numb_case_1_5_5_13 "1.5.5.13"
#define name_case_1_5_5_13 "Perform options management -- T_SCTP_HEARTBEAT_ITVL"
#define sref_case_1_5_5_13 sref_case_1_5
#define desc_case_1_5_5_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HEARTBEAT_ITVL."

int
test_case_1_5_5_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_13_conn test_case_1_5_5_13
#define test_case_1_5_5_13_resp test_case_1_5_5_13
#define test_case_1_5_5_13_list test_case_1_5_5_13

struct test_stream test_1_5_5_13_conn = { &preamble_1_5_conn, &test_case_1_5_5_13_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_13_resp = { &preamble_1_5_resp, &test_case_1_5_5_13_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_13_list = { &preamble_1_5_list, &test_case_1_5_5_13_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_RTO_INITIAL
 */
#define tgrp_case_1_5_5_14 test_group_1_5_5
#define numb_case_1_5_5_14 "1.5.5.14"
#define name_case_1_5_5_14 "Perform options management -- T_SCTP_RTO_INITIAL"
#define sref_case_1_5_5_14 sref_case_1_5
#define desc_case_1_5_5_14 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_INITIAL."

int
test_case_1_5_5_14(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_14_conn test_case_1_5_5_14
#define test_case_1_5_5_14_resp test_case_1_5_5_14
#define test_case_1_5_5_14_list test_case_1_5_5_14

struct test_stream test_1_5_5_14_conn = { &preamble_1_5_conn, &test_case_1_5_5_14_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_14_resp = { &preamble_1_5_resp, &test_case_1_5_5_14_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_14_list = { &preamble_1_5_list, &test_case_1_5_5_14_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_RTO_MIN
 */
#define tgrp_case_1_5_5_15 test_group_1_5_5
#define numb_case_1_5_5_15 "1.5.5.15"
#define name_case_1_5_5_15 "Perform options management -- T_SCTP_RTO_MIN"
#define sref_case_1_5_5_15 sref_case_1_5
#define desc_case_1_5_5_15 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MIN."

int
test_case_1_5_5_15(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_15_conn test_case_1_5_5_15
#define test_case_1_5_5_15_resp test_case_1_5_5_15
#define test_case_1_5_5_15_list test_case_1_5_5_15

struct test_stream test_1_5_5_15_conn = { &preamble_1_5_conn, &test_case_1_5_5_15_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_15_resp = { &preamble_1_5_resp, &test_case_1_5_5_15_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_15_list = { &preamble_1_5_list, &test_case_1_5_5_15_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_RTO_MAX
 */
#define tgrp_case_1_5_5_16 test_group_1_5_5
#define numb_case_1_5_5_16 "1.5.5.16"
#define name_case_1_5_5_16 "Perform options management -- T_SCTP_RTO_MAX"
#define sref_case_1_5_5_16 sref_case_1_5
#define desc_case_1_5_5_16 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MAX."

int
test_case_1_5_5_16(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_16_conn test_case_1_5_5_16
#define test_case_1_5_5_16_resp test_case_1_5_5_16
#define test_case_1_5_5_16_list test_case_1_5_5_16

struct test_stream test_1_5_5_16_conn = { &preamble_1_5_conn, &test_case_1_5_5_16_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_16_resp = { &preamble_1_5_resp, &test_case_1_5_5_16_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_16_list = { &preamble_1_5_list, &test_case_1_5_5_16_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_OSTREAMS
 */
#define tgrp_case_1_5_5_17 test_group_1_5_5
#define numb_case_1_5_5_17 "1.5.5.17"
#define name_case_1_5_5_17 "Perform options management -- T_SCTP_OSTREAMS"
#define sref_case_1_5_5_17 sref_case_1_5
#define desc_case_1_5_5_17 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_OSTREAMS."

int
test_case_1_5_5_17(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_17_conn test_case_1_5_5_17
#define test_case_1_5_5_17_resp test_case_1_5_5_17
#define test_case_1_5_5_17_list test_case_1_5_5_17

struct test_stream test_1_5_5_17_conn = { &preamble_1_5_conn, &test_case_1_5_5_17_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_17_resp = { &preamble_1_5_resp, &test_case_1_5_5_17_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_17_list = { &preamble_1_5_list, &test_case_1_5_5_17_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_ISTREAMS
 */
#define tgrp_case_1_5_5_18 test_group_1_5_5
#define numb_case_1_5_5_18 "1.5.5.18"
#define name_case_1_5_5_18 "Perform options management -- T_SCTP_ISTREAMS"
#define sref_case_1_5_5_18 sref_case_1_5
#define desc_case_1_5_5_18 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ISTREAMS."

int
test_case_1_5_5_18(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_18_conn test_case_1_5_5_18
#define test_case_1_5_5_18_resp test_case_1_5_5_18
#define test_case_1_5_5_18_list test_case_1_5_5_18

struct test_stream test_1_5_5_18_conn = { &preamble_1_5_conn, &test_case_1_5_5_18_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_18_resp = { &preamble_1_5_resp, &test_case_1_5_5_18_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_18_list = { &preamble_1_5_list, &test_case_1_5_5_18_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_INC
 */
#define tgrp_case_1_5_5_19 test_group_1_5_5
#define numb_case_1_5_5_19 "1.5.5.19"
#define name_case_1_5_5_19 "Perform options management -- T_SCTP_COOKIE_INC"
#define sref_case_1_5_5_19 sref_case_1_5
#define desc_case_1_5_5_19 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_INC."

int
test_case_1_5_5_19(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_19_conn test_case_1_5_5_19
#define test_case_1_5_5_19_resp test_case_1_5_5_19
#define test_case_1_5_5_19_list test_case_1_5_5_19

struct test_stream test_1_5_5_19_conn = { &preamble_1_5_conn, &test_case_1_5_5_19_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_19_resp = { &preamble_1_5_resp, &test_case_1_5_5_19_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_19_list = { &preamble_1_5_list, &test_case_1_5_5_19_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_THROTTLE_ITVL
 */
#define tgrp_case_1_5_5_20 test_group_1_5_5
#define numb_case_1_5_5_20 "1.5.5.20"
#define name_case_1_5_5_20 "Perform options management -- T_SCTP_THROTTLE_ITVL"
#define sref_case_1_5_5_20 sref_case_1_5
#define desc_case_1_5_5_20 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_THROTTLE_ITVL."

int
test_case_1_5_5_20(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_20_conn test_case_1_5_5_20
#define test_case_1_5_5_20_resp test_case_1_5_5_20
#define test_case_1_5_5_20_list test_case_1_5_5_20

struct test_stream test_1_5_5_20_conn = { &preamble_1_5_conn, &test_case_1_5_5_20_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_20_resp = { &preamble_1_5_resp, &test_case_1_5_5_20_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_20_list = { &preamble_1_5_list, &test_case_1_5_5_20_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_MAC_TYPE
 */
#define tgrp_case_1_5_5_21 test_group_1_5_5
#define numb_case_1_5_5_21 "1.5.5.21"
#define name_case_1_5_5_21 "Perform options management -- T_SCTP_MAC_TYPE"
#define sref_case_1_5_5_21 sref_case_1_5
#define desc_case_1_5_5_21 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAC_TYPE."

int
test_case_1_5_5_21(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_21_conn test_case_1_5_5_21
#define test_case_1_5_5_21_resp test_case_1_5_5_21
#define test_case_1_5_5_21_list test_case_1_5_5_21

struct test_stream test_1_5_5_21_conn = { &preamble_1_5_conn, &test_case_1_5_5_21_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_21_resp = { &preamble_1_5_resp, &test_case_1_5_5_21_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_21_list = { &preamble_1_5_list, &test_case_1_5_5_21_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_CKSUM_TYPE
 */
#define tgrp_case_1_5_5_22 test_group_1_5_5
#define numb_case_1_5_5_22 "1.5.5.22"
#define name_case_1_5_5_22 "Perform options management -- T_SCTP_CKSUM_TYPE"
#define sref_case_1_5_5_22 sref_case_1_5
#define desc_case_1_5_5_22 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CKSUM_TYPE."

int
test_case_1_5_5_22(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_22_conn test_case_1_5_5_22
#define test_case_1_5_5_22_resp test_case_1_5_5_22
#define test_case_1_5_5_22_list test_case_1_5_5_22

struct test_stream test_1_5_5_22_conn = { &preamble_1_5_conn, &test_case_1_5_5_22_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_22_resp = { &preamble_1_5_resp, &test_case_1_5_5_22_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_22_list = { &preamble_1_5_list, &test_case_1_5_5_22_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_ECN
 */
#define tgrp_case_1_5_5_23 test_group_1_5_5
#define numb_case_1_5_5_23 "1.5.5.23"
#define name_case_1_5_5_23 "Perform options management -- T_SCTP_ECN"
#define sref_case_1_5_5_23 sref_case_1_5
#define desc_case_1_5_5_23 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ECN."

int
test_case_1_5_5_23(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_23_conn test_case_1_5_5_23
#define test_case_1_5_5_23_resp test_case_1_5_5_23
#define test_case_1_5_5_23_list test_case_1_5_5_23

struct test_stream test_1_5_5_23_conn = { &preamble_1_5_conn, &test_case_1_5_5_23_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_23_resp = { &preamble_1_5_resp, &test_case_1_5_5_23_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_23_list = { &preamble_1_5_list, &test_case_1_5_5_23_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_ALI
 */
#define tgrp_case_1_5_5_24 test_group_1_5_5
#define numb_case_1_5_5_24 "1.5.5.24"
#define name_case_1_5_5_24 "Perform options management -- T_SCTP_ALI"
#define sref_case_1_5_5_24 sref_case_1_5
#define desc_case_1_5_5_24 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ALI."

int
test_case_1_5_5_24(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_24_conn test_case_1_5_5_24
#define test_case_1_5_5_24_resp test_case_1_5_5_24
#define test_case_1_5_5_24_list test_case_1_5_5_24

struct test_stream test_1_5_5_24_conn = { &preamble_1_5_conn, &test_case_1_5_5_24_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_24_resp = { &preamble_1_5_resp, &test_case_1_5_5_24_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_24_list = { &preamble_1_5_list, &test_case_1_5_5_24_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_ADD
 */
#define tgrp_case_1_5_5_25 test_group_1_5_5
#define numb_case_1_5_5_25 "1.5.5.25"
#define name_case_1_5_5_25 "Perform options management -- T_SCTP_ADD"
#define sref_case_1_5_5_25 sref_case_1_5
#define desc_case_1_5_5_25 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD."

int
test_case_1_5_5_25(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_25_conn test_case_1_5_5_25
#define test_case_1_5_5_25_resp test_case_1_5_5_25
#define test_case_1_5_5_25_list test_case_1_5_5_25

struct test_stream test_1_5_5_25_conn = { &preamble_1_5_conn, &test_case_1_5_5_25_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_25_resp = { &preamble_1_5_resp, &test_case_1_5_5_25_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_25_list = { &preamble_1_5_list, &test_case_1_5_5_25_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_SET
 */
#define tgrp_case_1_5_5_26 test_group_1_5_5
#define numb_case_1_5_5_26 "1.5.5.26"
#define name_case_1_5_5_26 "Perform options management -- T_SCTP_SET"
#define sref_case_1_5_5_26 sref_case_1_5
#define desc_case_1_5_5_26 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET."

int
test_case_1_5_5_26(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_26_conn test_case_1_5_5_26
#define test_case_1_5_5_26_resp test_case_1_5_5_26
#define test_case_1_5_5_26_list test_case_1_5_5_26

struct test_stream test_1_5_5_26_conn = { &preamble_1_5_conn, &test_case_1_5_5_26_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_26_resp = { &preamble_1_5_resp, &test_case_1_5_5_26_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_26_list = { &preamble_1_5_list, &test_case_1_5_5_26_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_ADD_IP
 */
#define tgrp_case_1_5_5_27 test_group_1_5_5
#define numb_case_1_5_5_27 "1.5.5.27"
#define name_case_1_5_5_27 "Perform options management -- T_SCTP_ADD_IP"
#define sref_case_1_5_5_27 sref_case_1_5
#define desc_case_1_5_5_27 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD_IP."

int
test_case_1_5_5_27(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_27_conn test_case_1_5_5_27
#define test_case_1_5_5_27_resp test_case_1_5_5_27
#define test_case_1_5_5_27_list test_case_1_5_5_27

struct test_stream test_1_5_5_27_conn = { &preamble_1_5_conn, &test_case_1_5_5_27_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_27_resp = { &preamble_1_5_resp, &test_case_1_5_5_27_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_27_list = { &preamble_1_5_list, &test_case_1_5_5_27_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_DEL_IP
 */
#define tgrp_case_1_5_5_28 test_group_1_5_5
#define numb_case_1_5_5_28 "1.5.5.28"
#define name_case_1_5_5_28 "Perform options management -- T_SCTP_DEL_IP"
#define sref_case_1_5_5_28 sref_case_1_5
#define desc_case_1_5_5_28 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DEL_IP."

int
test_case_1_5_5_28(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_28_conn test_case_1_5_5_28
#define test_case_1_5_5_28_resp test_case_1_5_5_28
#define test_case_1_5_5_28_list test_case_1_5_5_28

struct test_stream test_1_5_5_28_conn = { &preamble_1_5_conn, &test_case_1_5_5_28_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_28_resp = { &preamble_1_5_resp, &test_case_1_5_5_28_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_28_list = { &preamble_1_5_list, &test_case_1_5_5_28_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_SET_IP
 */
#define tgrp_case_1_5_5_29 test_group_1_5_5
#define numb_case_1_5_5_29 "1.5.5.29"
#define name_case_1_5_5_29 "Perform options management -- T_SCTP_SET_IP"
#define sref_case_1_5_5_29 sref_case_1_5
#define desc_case_1_5_5_29 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET_IP."

int
test_case_1_5_5_29(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_29_conn test_case_1_5_5_29
#define test_case_1_5_5_29_resp test_case_1_5_5_29
#define test_case_1_5_5_29_list test_case_1_5_5_29

struct test_stream test_1_5_5_29_conn = { &preamble_1_5_conn, &test_case_1_5_5_29_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_29_resp = { &preamble_1_5_resp, &test_case_1_5_5_29_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_29_list = { &preamble_1_5_list, &test_case_1_5_5_29_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_PR
 */
#define tgrp_case_1_5_5_30 test_group_1_5_5
#define numb_case_1_5_5_30 "1.5.5.30"
#define name_case_1_5_5_30 "Perform options management -- T_SCTP_PR"
#define sref_case_1_5_5_30 sref_case_1_5
#define desc_case_1_5_5_30 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PR."

int
test_case_1_5_5_30(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_30_conn test_case_1_5_5_30
#define test_case_1_5_5_30_resp test_case_1_5_5_30
#define test_case_1_5_5_30_list test_case_1_5_5_30

struct test_stream test_1_5_5_30_conn = { &preamble_1_5_conn, &test_case_1_5_5_30_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_30_resp = { &preamble_1_5_resp, &test_case_1_5_5_30_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_30_list = { &preamble_1_5_list, &test_case_1_5_5_30_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_LIFETIME
 */
#define tgrp_case_1_5_5_31 test_group_1_5_5
#define numb_case_1_5_5_31 "1.5.5.31"
#define name_case_1_5_5_31 "Perform options management -- T_SCTP_LIFETIME"
#define sref_case_1_5_5_31 sref_case_1_5
#define desc_case_1_5_5_31 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_LIFETIME."

int
test_case_1_5_5_31(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_31_conn test_case_1_5_5_31
#define test_case_1_5_5_31_resp test_case_1_5_5_31
#define test_case_1_5_5_31_list test_case_1_5_5_31

struct test_stream test_1_5_5_31_conn = { &preamble_1_5_conn, &test_case_1_5_5_31_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_31_resp = { &preamble_1_5_resp, &test_case_1_5_5_31_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_31_list = { &preamble_1_5_list, &test_case_1_5_5_31_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_DISPOSITION
 */
#define tgrp_case_1_5_5_32 test_group_1_5_5
#define numb_case_1_5_5_32 "1.5.5.32"
#define name_case_1_5_5_32 "Perform options management -- T_SCTP_DISPOSITION"
#define sref_case_1_5_5_32 sref_case_1_5
#define desc_case_1_5_5_32 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DISPOSITION."

int
test_case_1_5_5_32(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_32_conn test_case_1_5_5_32
#define test_case_1_5_5_32_resp test_case_1_5_5_32
#define test_case_1_5_5_32_list test_case_1_5_5_32

struct test_stream test_1_5_5_32_conn = { &preamble_1_5_conn, &test_case_1_5_5_32_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_32_resp = { &preamble_1_5_resp, &test_case_1_5_5_32_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_32_list = { &preamble_1_5_list, &test_case_1_5_5_32_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_MAX_BURST
 */
#define tgrp_case_1_5_5_33 test_group_1_5_5
#define numb_case_1_5_5_33 "1.5.5.33"
#define name_case_1_5_5_33 "Perform options management -- T_SCTP_MAX_BURST"
#define sref_case_1_5_5_33 sref_case_1_5
#define desc_case_1_5_5_33 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_BURST."

int
test_case_1_5_5_33(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_33_conn test_case_1_5_5_33
#define test_case_1_5_5_33_resp test_case_1_5_5_33
#define test_case_1_5_5_33_list test_case_1_5_5_33

struct test_stream test_1_5_5_33_conn = { &preamble_1_5_conn, &test_case_1_5_5_33_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_33_resp = { &preamble_1_5_resp, &test_case_1_5_5_33_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_33_list = { &preamble_1_5_list, &test_case_1_5_5_33_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_HB
 */
#define tgrp_case_1_5_5_34 test_group_1_5_5
#define numb_case_1_5_5_34 "1.5.5.34"
#define name_case_1_5_5_34 "Perform options management -- T_SCTP_HB"
#define sref_case_1_5_5_34 sref_case_1_5
#define desc_case_1_5_5_34 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HB."

int
test_case_1_5_5_34(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_34_conn test_case_1_5_5_34
#define test_case_1_5_5_34_resp test_case_1_5_5_34
#define test_case_1_5_5_34_list test_case_1_5_5_34

struct test_stream test_1_5_5_34_conn = { &preamble_1_5_conn, &test_case_1_5_5_34_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_34_resp = { &preamble_1_5_resp, &test_case_1_5_5_34_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_34_list = { &preamble_1_5_list, &test_case_1_5_5_34_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_RTO
 */
#define tgrp_case_1_5_5_35 test_group_1_5_5
#define numb_case_1_5_5_35 "1.5.5.35"
#define name_case_1_5_5_35 "Perform options management -- T_SCTP_RTO"
#define sref_case_1_5_5_35 sref_case_1_5
#define desc_case_1_5_5_35 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO."

int
test_case_1_5_5_35(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_35_conn test_case_1_5_5_35
#define test_case_1_5_5_35_resp test_case_1_5_5_35
#define test_case_1_5_5_35_list test_case_1_5_5_35

struct test_stream test_1_5_5_35_conn = { &preamble_1_5_conn, &test_case_1_5_5_35_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_35_resp = { &preamble_1_5_resp, &test_case_1_5_5_35_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_35_list = { &preamble_1_5_list, &test_case_1_5_5_35_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_MAXSEG
 */
#define tgrp_case_1_5_5_36 test_group_1_5_5
#define numb_case_1_5_5_36 "1.5.5.36"
#define name_case_1_5_5_36 "Perform options management -- T_SCTP_MAXSEG"
#define sref_case_1_5_5_36 sref_case_1_5
#define desc_case_1_5_5_36 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAXSEG."

int
test_case_1_5_5_36(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_36_conn test_case_1_5_5_36
#define test_case_1_5_5_36_resp test_case_1_5_5_36
#define test_case_1_5_5_36_list test_case_1_5_5_36

struct test_stream test_1_5_5_36_conn = { &preamble_1_5_conn, &test_case_1_5_5_36_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_36_resp = { &preamble_1_5_resp, &test_case_1_5_5_36_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_36_list = { &preamble_1_5_list, &test_case_1_5_5_36_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_STATUS
 */
#define tgrp_case_1_5_5_37 test_group_1_5_5
#define numb_case_1_5_5_37 "1.5.5.37"
#define name_case_1_5_5_37 "Perform options management -- T_SCTP_STATUS"
#define sref_case_1_5_5_37 sref_case_1_5
#define desc_case_1_5_5_37 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_STATUS."

int
test_case_1_5_5_37(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_5_5_37_conn test_case_1_5_5_37
#define test_case_1_5_5_37_resp test_case_1_5_5_37
#define test_case_1_5_5_37_list test_case_1_5_5_37

struct test_stream test_1_5_5_37_conn = { &preamble_1_5_conn, &test_case_1_5_5_37_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_37_resp = { &preamble_1_5_resp, &test_case_1_5_5_37_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_37_list = { &preamble_1_5_list, &test_case_1_5_5_37_list, &postamble_1_5_list };

/*
 *  Perform options management -- T_SCTP_DEBUG
 */
#define tgrp_case_1_5_5_38 test_group_1_5_5
#define numb_case_1_5_5_38 "1.5.5.38"
#define name_case_1_5_5_38 "Perform options management -- T_SCTP_DEBUG"
#define sref_case_1_5_5_38 sref_case_1_5
#define desc_case_1_5_5_38 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DEBUG."

int
test_case_1_5_5_38(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	return test_case_1_5_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_5_5_38_conn test_case_1_5_5_38
#define test_case_1_5_5_38_resp test_case_1_5_5_38
#define test_case_1_5_5_38_list test_case_1_5_5_38

struct test_stream test_1_5_5_38_conn = { &preamble_1_5_conn, &test_case_1_5_5_38_conn, &postamble_1_5_conn };
struct test_stream test_1_5_5_38_resp = { &preamble_1_5_resp, &test_case_1_5_5_38_resp, &postamble_1_5_resp };
struct test_stream test_1_5_5_38_list = { &preamble_1_5_list, &test_case_1_5_5_38_list, &postamble_1_5_list };

/*
 *  Do options management.
 */
#define test_group_1_6 "Options management - T_CURRENT"
#define tgrp_case_1_6 test_group_1_6
#define numb_case_1_6 "1.5"
#define name_case_1_6 "Perform options management."
#define sref_case_1_6 "TPI Rev 1.5 Sections 2.1.1.4, 2.1.2.3"
#define desc_case_1_6 "\
Checks that options management can be performed on several streams."

int
test_case_1_6(int child, ulong result)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags != result)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_6_xfail(int child, int terror, int error)
{
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != terror || (last_t_errno == TSYSERR && last_errno != error))
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_6_xti(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_6(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_6_ip(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_6(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_6_udp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_UDP:
		return test_case_1_6(child, result);
	case T_INET_IP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_6_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_6_tcp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_TCP:
		return test_case_1_6(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_SCTP:
		return test_case_1_6_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_6_sctp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_SCTP:
		return test_case_1_6(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		return test_case_1_6_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

#define test_case_1_6_conn	test_case_1_6
#define test_case_1_6_resp	test_case_1_6
#define test_case_1_6_list	test_case_1_6

#define preamble_1_6_conn	preamble_0
#define preamble_1_6_resp	preamble_0
#define preamble_1_6_list	preamble_0

#define postamble_1_6_conn	postamble_0
#define postamble_1_6_resp	postamble_0
#define postamble_1_6_list	postamble_0

//struct test_stream test_1_6_conn = { &preamble_1_6_conn, &test_case_1_6_conn, &postamble_1_6_conn };
//struct test_stream test_1_6_resp = { &preamble_1_6_resp, &test_case_1_6_resp, &postamble_1_6_resp };
//struct test_stream test_1_6_list = { &preamble_1_6_list, &test_case_1_6_list, &postamble_1_6_list };

#define test_group_1_6_1 "Local management -- XTI options management"
#define tgrp_case_1_6_1_1 test_group_1_6_1
#define numb_case_1_6_1_1 "1.6.1.1"
#define name_case_1_6_1_1 "Perform options management -- all options"
#define sref_case_1_6_1_1 sref_case_1_6
#define desc_case_1_6_1_1 "\
Checks that options management can be performed on several streams\n\
for all options."

int
test_case_1_6_1_1(int child)
{
	test_opts = &opt_optm;
	test_olen = sizeof(opt_optm);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_1_conn test_case_1_6_1_1
#define test_case_1_6_1_1_resp test_case_1_6_1_1
#define test_case_1_6_1_1_list test_case_1_6_1_1

struct test_stream test_1_6_1_1_conn = { &preamble_1_6_conn, &test_case_1_6_1_1_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_1_resp = { &preamble_1_6_resp, &test_case_1_6_1_1_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_1_list = { &preamble_1_6_list, &test_case_1_6_1_1_list, &postamble_1_6_list };

#define tgrp_case_1_6_1_2 test_group_1_6_1
#define numb_case_1_6_1_2 "1.6.1.2"
#define name_case_1_6_1_2 "Perform options management -- XTI_DEBUG"
#define sref_case_1_6_1_2 sref_case_1_6
#define desc_case_1_6_1_2 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_DEBUG."

int
test_case_1_6_1_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_2_conn test_case_1_6_1_2
#define test_case_1_6_1_2_resp test_case_1_6_1_2
#define test_case_1_6_1_2_list test_case_1_6_1_2

struct test_stream test_1_6_1_2_conn = { &preamble_1_6_conn, &test_case_1_6_1_2_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_2_resp = { &preamble_1_6_resp, &test_case_1_6_1_2_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_2_list = { &preamble_1_6_list, &test_case_1_6_1_2_list, &postamble_1_6_list };

#define tgrp_case_1_6_1_3 test_group_1_6_1
#define numb_case_1_6_1_3 "1.6.1.3"
#define name_case_1_6_1_3 "Perform options management -- XTI_LINGER"
#define sref_case_1_6_1_3 sref_case_1_6
#define desc_case_1_6_1_3 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_LINGER."

int
test_case_1_6_1_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_3_conn test_case_1_6_1_3
#define test_case_1_6_1_3_resp test_case_1_6_1_3
#define test_case_1_6_1_3_list test_case_1_6_1_3

struct test_stream test_1_6_1_3_conn = { &preamble_1_6_conn, &test_case_1_6_1_3_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_3_resp = { &preamble_1_6_resp, &test_case_1_6_1_3_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_3_list = { &preamble_1_6_list, &test_case_1_6_1_3_list, &postamble_1_6_list };

#define tgrp_case_1_6_1_4 test_group_1_6_1
#define numb_case_1_6_1_4 "1.6.1.4"
#define name_case_1_6_1_4 "Perform options management -- XTI_RCVBUF"
#define sref_case_1_6_1_4 sref_case_1_6
#define desc_case_1_6_1_4 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVBUF."

int
test_case_1_6_1_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_4_conn test_case_1_6_1_4
#define test_case_1_6_1_4_resp test_case_1_6_1_4
#define test_case_1_6_1_4_list test_case_1_6_1_4

struct test_stream test_1_6_1_4_conn = { &preamble_1_6_conn, &test_case_1_6_1_4_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_4_resp = { &preamble_1_6_resp, &test_case_1_6_1_4_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_4_list = { &preamble_1_6_list, &test_case_1_6_1_4_list, &postamble_1_6_list };

#define tgrp_case_1_6_1_5 test_group_1_6_1
#define numb_case_1_6_1_5 "1.6.1.5"
#define name_case_1_6_1_5 "Perform options management -- XTI_RCVLOWAT"
#define sref_case_1_6_1_5 sref_case_1_6
#define desc_case_1_6_1_5 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVLOWAT."

int
test_case_1_6_1_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_5_conn test_case_1_6_1_5
#define test_case_1_6_1_5_resp test_case_1_6_1_5
#define test_case_1_6_1_5_list test_case_1_6_1_5

struct test_stream test_1_6_1_5_conn = { &preamble_1_6_conn, &test_case_1_6_1_5_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_5_resp = { &preamble_1_6_resp, &test_case_1_6_1_5_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_5_list = { &preamble_1_6_list, &test_case_1_6_1_5_list, &postamble_1_6_list };

#define tgrp_case_1_6_1_6 test_group_1_6_1
#define numb_case_1_6_1_6 "1.6.1.6"
#define name_case_1_6_1_6 "Perform options management -- XTI_SNDBUF"
#define sref_case_1_6_1_6 sref_case_1_6
#define desc_case_1_6_1_6 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDBUF."

int
test_case_1_6_1_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_6_conn test_case_1_6_1_6
#define test_case_1_6_1_6_resp test_case_1_6_1_6
#define test_case_1_6_1_6_list test_case_1_6_1_6

struct test_stream test_1_6_1_6_conn = { &preamble_1_6_conn, &test_case_1_6_1_6_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_6_resp = { &preamble_1_6_resp, &test_case_1_6_1_6_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_6_list = { &preamble_1_6_list, &test_case_1_6_1_6_list, &postamble_1_6_list };

#define tgrp_case_1_6_1_7 test_group_1_6_1
#define numb_case_1_6_1_7 "1.6.1.7"
#define name_case_1_6_1_7 "Perform options management -- XTI_SNDLOWAT"
#define sref_case_1_6_1_7 sref_case_1_6
#define desc_case_1_6_1_7 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDLOWAT."

int
test_case_1_6_1_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_1_7_conn test_case_1_6_1_7
#define test_case_1_6_1_7_resp test_case_1_6_1_7
#define test_case_1_6_1_7_list test_case_1_6_1_7

struct test_stream test_1_6_1_7_conn = { &preamble_1_6_conn, &test_case_1_6_1_7_conn, &postamble_1_6_conn };
struct test_stream test_1_6_1_7_resp = { &preamble_1_6_resp, &test_case_1_6_1_7_resp, &postamble_1_6_resp };
struct test_stream test_1_6_1_7_list = { &preamble_1_6_list, &test_case_1_6_1_7_list, &postamble_1_6_list };

#define test_group_1_6_2 "Local management -- IP options management"
#define tgrp_case_1_6_2_1 test_group_1_6_2
#define numb_case_1_6_2_1 "1.6.2.1"
#define name_case_1_6_2_1 "Perform options management -- T_IP_TOS"
#define sref_case_1_6_2_1 sref_case_1_6
#define desc_case_1_6_2_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TOS."

int
test_case_1_6_2_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_2_1_conn test_case_1_6_2_1
#define test_case_1_6_2_1_resp test_case_1_6_2_1
#define test_case_1_6_2_1_list test_case_1_6_2_1

struct test_stream test_1_6_2_1_conn = { &preamble_1_6_conn, &test_case_1_6_2_1_conn, &postamble_1_6_conn };
struct test_stream test_1_6_2_1_resp = { &preamble_1_6_resp, &test_case_1_6_2_1_resp, &postamble_1_6_resp };
struct test_stream test_1_6_2_1_list = { &preamble_1_6_list, &test_case_1_6_2_1_list, &postamble_1_6_list };

#define tgrp_case_1_6_2_2 test_group_1_6_2
#define numb_case_1_6_2_2 "1.6.2.2"
#define name_case_1_6_2_2 "Perform options management -- T_IP_TTL"
#define sref_case_1_6_2_2 sref_case_1_6
#define desc_case_1_6_2_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TTL."

int
test_case_1_6_2_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_2_2_conn test_case_1_6_2_2
#define test_case_1_6_2_2_resp test_case_1_6_2_2
#define test_case_1_6_2_2_list test_case_1_6_2_2

struct test_stream test_1_6_2_2_conn = { &preamble_1_6_conn, &test_case_1_6_2_2_conn, &postamble_1_6_conn };
struct test_stream test_1_6_2_2_resp = { &preamble_1_6_resp, &test_case_1_6_2_2_resp, &postamble_1_6_resp };
struct test_stream test_1_6_2_2_list = { &preamble_1_6_list, &test_case_1_6_2_2_list, &postamble_1_6_list };

#define tgrp_case_1_6_2_3 test_group_1_6_2
#define numb_case_1_6_2_3 "1.6.2.3"
#define name_case_1_6_2_3 "Perform options management -- T_IP_DONTROUTE"
#define sref_case_1_6_2_3 sref_case_1_6
#define desc_case_1_6_2_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_DONTROUTE."

int
test_case_1_6_2_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_2_3_conn test_case_1_6_2_3
#define test_case_1_6_2_3_resp test_case_1_6_2_3
#define test_case_1_6_2_3_list test_case_1_6_2_3

struct test_stream test_1_6_2_3_conn = { &preamble_1_6_conn, &test_case_1_6_2_3_conn, &postamble_1_6_conn };
struct test_stream test_1_6_2_3_resp = { &preamble_1_6_resp, &test_case_1_6_2_3_resp, &postamble_1_6_resp };
struct test_stream test_1_6_2_3_list = { &preamble_1_6_list, &test_case_1_6_2_3_list, &postamble_1_6_list };

#define tgrp_case_1_6_2_4 test_group_1_6_2
#define numb_case_1_6_2_4 "1.6.2.4"
#define name_case_1_6_2_4 "Perform options management -- T_IP_BROADCAST"
#define sref_case_1_6_2_4 sref_case_1_6
#define desc_case_1_6_2_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_BROADCAST."

int
test_case_1_6_2_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_2_4_conn test_case_1_6_2_4
#define test_case_1_6_2_4_resp test_case_1_6_2_4
#define test_case_1_6_2_4_list test_case_1_6_2_4

struct test_stream test_1_6_2_4_conn = { &preamble_1_6_conn, &test_case_1_6_2_4_conn, &postamble_1_6_conn };
struct test_stream test_1_6_2_4_resp = { &preamble_1_6_resp, &test_case_1_6_2_4_resp, &postamble_1_6_resp };
struct test_stream test_1_6_2_4_list = { &preamble_1_6_list, &test_case_1_6_2_4_list, &postamble_1_6_list };

#define tgrp_case_1_6_2_5 test_group_1_6_2
#define numb_case_1_6_2_5 "1.6.2.5"
#define name_case_1_6_2_5 "Perform options management -- T_IP_REUSEADDR"
#define sref_case_1_6_2_5 sref_case_1_6
#define desc_case_1_6_2_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_REUSEADDR."

int
test_case_1_6_2_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_2_5_conn test_case_1_6_2_5
#define test_case_1_6_2_5_resp test_case_1_6_2_5
#define test_case_1_6_2_5_list test_case_1_6_2_5

struct test_stream test_1_6_2_5_conn = { &preamble_1_6_conn, &test_case_1_6_2_5_conn, &postamble_1_6_conn };
struct test_stream test_1_6_2_5_resp = { &preamble_1_6_resp, &test_case_1_6_2_5_resp, &postamble_1_6_resp };
struct test_stream test_1_6_2_5_list = { &preamble_1_6_list, &test_case_1_6_2_5_list, &postamble_1_6_list };

#define test_group_1_6_3 "Local management -- UDP options management"
#define tgrp_case_1_6_3_1 test_group_1_6_3
#define numb_case_1_6_3_1 "1.6.3.1"
#define name_case_1_6_3_1 "Perform options management -- T_UDP_CHECKSUM"
#define sref_case_1_6_3_1 sref_case_1_6
#define desc_case_1_6_3_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_UDP option T_UDP_CHECKSUM."

int
test_case_1_6_3_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_udp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_3_1_conn test_case_1_6_3_1
#define test_case_1_6_3_1_resp test_case_1_6_3_1
#define test_case_1_6_3_1_list test_case_1_6_3_1

struct test_stream test_1_6_3_1_conn = { &preamble_1_6_conn, &test_case_1_6_3_1_conn, &postamble_1_6_conn };
struct test_stream test_1_6_3_1_resp = { &preamble_1_6_resp, &test_case_1_6_3_1_resp, &postamble_1_6_resp };
struct test_stream test_1_6_3_1_list = { &preamble_1_6_list, &test_case_1_6_3_1_list, &postamble_1_6_list };

#define test_group_1_6_4 "Local management -- TCP options management"
#define tgrp_case_1_6_4_1 test_group_1_6_4
#define numb_case_1_6_4_1 "1.6.4.1"
#define name_case_1_6_4_1 "Perform options management -- T_TCP_NODELAY"
#define sref_case_1_6_4_1 sref_case_1_6
#define desc_case_1_6_4_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_NODELAY."

int
test_case_1_6_4_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_1_conn test_case_1_6_4_1
#define test_case_1_6_4_1_resp test_case_1_6_4_1
#define test_case_1_6_4_1_list test_case_1_6_4_1

struct test_stream test_1_6_4_1_conn = { &preamble_1_6_conn, &test_case_1_6_4_1_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_1_resp = { &preamble_1_6_resp, &test_case_1_6_4_1_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_1_list = { &preamble_1_6_list, &test_case_1_6_4_1_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_2 test_group_1_6_4
#define numb_case_1_6_4_2 "1.6.4.2"
#define name_case_1_6_4_2 "Perform options management -- T_TCP_MAXSEG"
#define sref_case_1_6_4_2 sref_case_1_6
#define desc_case_1_6_4_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_MAXSEG."

int
test_case_1_6_4_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_2_conn test_case_1_6_4_2
#define test_case_1_6_4_2_resp test_case_1_6_4_2
#define test_case_1_6_4_2_list test_case_1_6_4_2

struct test_stream test_1_6_4_2_conn = { &preamble_1_6_conn, &test_case_1_6_4_2_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_2_resp = { &preamble_1_6_resp, &test_case_1_6_4_2_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_2_list = { &preamble_1_6_list, &test_case_1_6_4_2_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_3 test_group_1_6_4
#define numb_case_1_6_4_3 "1.6.4.3"
#define name_case_1_6_4_3 "Perform options management -- T_TCP_KEEPALIVE"
#define sref_case_1_6_4_3 sref_case_1_6
#define desc_case_1_6_4_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPALIVE."

int
test_case_1_6_4_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_3_conn test_case_1_6_4_3
#define test_case_1_6_4_3_resp test_case_1_6_4_3
#define test_case_1_6_4_3_list test_case_1_6_4_3

struct test_stream test_1_6_4_3_conn = { &preamble_1_6_conn, &test_case_1_6_4_3_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_3_resp = { &preamble_1_6_resp, &test_case_1_6_4_3_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_3_list = { &preamble_1_6_list, &test_case_1_6_4_3_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_4 test_group_1_6_4
#define numb_case_1_6_4_4 "1.6.4.4"
#define name_case_1_6_4_4 "Perform options management -- T_TCP_CORK"
#define sref_case_1_6_4_4 sref_case_1_6
#define desc_case_1_6_4_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_CORK."

int
test_case_1_6_4_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_4_conn test_case_1_6_4_4
#define test_case_1_6_4_4_resp test_case_1_6_4_4
#define test_case_1_6_4_4_list test_case_1_6_4_4

struct test_stream test_1_6_4_4_conn = { &preamble_1_6_conn, &test_case_1_6_4_4_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_4_resp = { &preamble_1_6_resp, &test_case_1_6_4_4_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_4_list = { &preamble_1_6_list, &test_case_1_6_4_4_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_5 test_group_1_6_4
#define numb_case_1_6_4_5 "1.6.4.5"
#define name_case_1_6_4_5 "Perform options management -- T_TCP_KEEPIDLE"
#define sref_case_1_6_4_5 sref_case_1_6
#define desc_case_1_6_4_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPIDLE."

int
test_case_1_6_4_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_5_conn test_case_1_6_4_5
#define test_case_1_6_4_5_resp test_case_1_6_4_5
#define test_case_1_6_4_5_list test_case_1_6_4_5

struct test_stream test_1_6_4_5_conn = { &preamble_1_6_conn, &test_case_1_6_4_5_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_5_resp = { &preamble_1_6_resp, &test_case_1_6_4_5_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_5_list = { &preamble_1_6_list, &test_case_1_6_4_5_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_6 test_group_1_6_4
#define numb_case_1_6_4_6 "1.6.4.6"
#define name_case_1_6_4_6 "Perform options management -- T_TCP_KEEPINTVL"
#define sref_case_1_6_4_6 sref_case_1_6
#define desc_case_1_6_4_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPINTVL."

int
test_case_1_6_4_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_6_conn test_case_1_6_4_6
#define test_case_1_6_4_6_resp test_case_1_6_4_6
#define test_case_1_6_4_6_list test_case_1_6_4_6

struct test_stream test_1_6_4_6_conn = { &preamble_1_6_conn, &test_case_1_6_4_6_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_6_resp = { &preamble_1_6_resp, &test_case_1_6_4_6_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_6_list = { &preamble_1_6_list, &test_case_1_6_4_6_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_7 test_group_1_6_4
#define numb_case_1_6_4_7 "1.6.4.7"
#define name_case_1_6_4_7 "Perform options management -- T_TCP_KEEPCNT"
#define sref_case_1_6_4_7 sref_case_1_6
#define desc_case_1_6_4_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPCNT."

int
test_case_1_6_4_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_7_conn test_case_1_6_4_7
#define test_case_1_6_4_7_resp test_case_1_6_4_7
#define test_case_1_6_4_7_list test_case_1_6_4_7

struct test_stream test_1_6_4_7_conn = { &preamble_1_6_conn, &test_case_1_6_4_7_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_7_resp = { &preamble_1_6_resp, &test_case_1_6_4_7_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_7_list = { &preamble_1_6_list, &test_case_1_6_4_7_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_8 test_group_1_6_4
#define numb_case_1_6_4_8 "1.6.4.8"
#define name_case_1_6_4_8 "Perform options management -- T_TCP_SYNCNT"
#define sref_case_1_6_4_8 sref_case_1_6
#define desc_case_1_6_4_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_SYNCNT."

int
test_case_1_6_4_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_8_conn test_case_1_6_4_8
#define test_case_1_6_4_8_resp test_case_1_6_4_8
#define test_case_1_6_4_8_list test_case_1_6_4_8

struct test_stream test_1_6_4_8_conn = { &preamble_1_6_conn, &test_case_1_6_4_8_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_8_resp = { &preamble_1_6_resp, &test_case_1_6_4_8_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_8_list = { &preamble_1_6_list, &test_case_1_6_4_8_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_9 test_group_1_6_4
#define numb_case_1_6_4_9 "1.6.4.9"
#define name_case_1_6_4_9 "Perform options management -- T_TCP_LINGER2"
#define sref_case_1_6_4_9 sref_case_1_6
#define desc_case_1_6_4_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_LINGER2."

int
test_case_1_6_4_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_9_conn test_case_1_6_4_9
#define test_case_1_6_4_9_resp test_case_1_6_4_9
#define test_case_1_6_4_9_list test_case_1_6_4_9

struct test_stream test_1_6_4_9_conn = { &preamble_1_6_conn, &test_case_1_6_4_9_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_9_resp = { &preamble_1_6_resp, &test_case_1_6_4_9_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_9_list = { &preamble_1_6_list, &test_case_1_6_4_9_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_10 test_group_1_6_4
#define numb_case_1_6_4_10 "1.6.4.10"
#define name_case_1_6_4_10 "Perform options management -- T_TCP_DEFER_ACCEPT"
#define sref_case_1_6_4_10 sref_case_1_6
#define desc_case_1_6_4_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_DEFER_ACCEPT."

int
test_case_1_6_4_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_10_conn test_case_1_6_4_10
#define test_case_1_6_4_10_resp test_case_1_6_4_10
#define test_case_1_6_4_10_list test_case_1_6_4_10

struct test_stream test_1_6_4_10_conn = { &preamble_1_6_conn, &test_case_1_6_4_10_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_10_resp = { &preamble_1_6_resp, &test_case_1_6_4_10_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_10_list = { &preamble_1_6_list, &test_case_1_6_4_10_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_11 test_group_1_6_4
#define numb_case_1_6_4_11 "1.6.4.11"
#define name_case_1_6_4_11 "Perform options management -- T_TCP_WINDOW_CLAMP"
#define sref_case_1_6_4_11 sref_case_1_6
#define desc_case_1_6_4_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_WINDOW_CLAMP."

int
test_case_1_6_4_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_11_conn test_case_1_6_4_11
#define test_case_1_6_4_11_resp test_case_1_6_4_11
#define test_case_1_6_4_11_list test_case_1_6_4_11

struct test_stream test_1_6_4_11_conn = { &preamble_1_6_conn, &test_case_1_6_4_11_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_11_resp = { &preamble_1_6_resp, &test_case_1_6_4_11_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_11_list = { &preamble_1_6_list, &test_case_1_6_4_11_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_12 test_group_1_6_4
#define numb_case_1_6_4_12 "1.6.4.12"
#define name_case_1_6_4_12 "Perform options management -- T_TCP_INFO"
#define sref_case_1_6_4_12 sref_case_1_6
#define desc_case_1_6_4_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_INFO."

int
test_case_1_6_4_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_12_conn test_case_1_6_4_12
#define test_case_1_6_4_12_resp test_case_1_6_4_12
#define test_case_1_6_4_12_list test_case_1_6_4_12

struct test_stream test_1_6_4_12_conn = { &preamble_1_6_conn, &test_case_1_6_4_12_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_12_resp = { &preamble_1_6_resp, &test_case_1_6_4_12_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_12_list = { &preamble_1_6_list, &test_case_1_6_4_12_list, &postamble_1_6_list };

#define tgrp_case_1_6_4_13 test_group_1_6_4
#define numb_case_1_6_4_13 "1.6.4.13"
#define name_case_1_6_4_13 "Perform options management -- T_TCP_QUICKACK"
#define sref_case_1_6_4_13 sref_case_1_6
#define desc_case_1_6_4_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_QUICKACK."

int
test_case_1_6_4_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_4_13_conn test_case_1_6_4_13
#define test_case_1_6_4_13_resp test_case_1_6_4_13
#define test_case_1_6_4_13_list test_case_1_6_4_13

struct test_stream test_1_6_4_13_conn = { &preamble_1_6_conn, &test_case_1_6_4_13_conn, &postamble_1_6_conn };
struct test_stream test_1_6_4_13_resp = { &preamble_1_6_resp, &test_case_1_6_4_13_resp, &postamble_1_6_resp };
struct test_stream test_1_6_4_13_list = { &preamble_1_6_list, &test_case_1_6_4_13_list, &postamble_1_6_list };

#define test_group_1_6_5 "Local management -- SCTP options management"
/*
 *  Perform options management -- T_SCTP_NODELAY
 */
#define tgrp_case_1_6_5_1 test_group_1_6_5
#define numb_case_1_6_5_1 "1.6.5.1"
#define name_case_1_6_5_1 "Perform options management -- T_SCTP_NODELAY"
#define sref_case_1_6_5_1 sref_case_1_6
#define desc_case_1_6_5_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_NODELAY."

int
test_case_1_6_5_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_1_conn test_case_1_6_5_1
#define test_case_1_6_5_1_resp test_case_1_6_5_1
#define test_case_1_6_5_1_list test_case_1_6_5_1

struct test_stream test_1_6_5_1_conn = { &preamble_1_6_conn, &test_case_1_6_5_1_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_1_resp = { &preamble_1_6_resp, &test_case_1_6_5_1_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_1_list = { &preamble_1_6_list, &test_case_1_6_5_1_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_CORK
 */
#define tgrp_case_1_6_5_2 test_group_1_6_5
#define numb_case_1_6_5_2 "1.6.5.2"
#define name_case_1_6_5_2 "Perform options management -- T_SCTP_CORK"
#define sref_case_1_6_5_2 sref_case_1_6
#define desc_case_1_6_5_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CORK."

int
test_case_1_6_5_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_2_conn test_case_1_6_5_2
#define test_case_1_6_5_2_resp test_case_1_6_5_2
#define test_case_1_6_5_2_list test_case_1_6_5_2

struct test_stream test_1_6_5_2_conn = { &preamble_1_6_conn, &test_case_1_6_5_2_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_2_resp = { &preamble_1_6_resp, &test_case_1_6_5_2_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_2_list = { &preamble_1_6_list, &test_case_1_6_5_2_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_PPI
 */
#define tgrp_case_1_6_5_3 test_group_1_6_5
#define numb_case_1_6_5_3 "1.6.5.3"
#define name_case_1_6_5_3 "Perform options management -- T_SCTP_PPI"
#define sref_case_1_6_5_3 sref_case_1_6
#define desc_case_1_6_5_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PPI."

int
test_case_1_6_5_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_3_conn test_case_1_6_5_3
#define test_case_1_6_5_3_resp test_case_1_6_5_3
#define test_case_1_6_5_3_list test_case_1_6_5_3

struct test_stream test_1_6_5_3_conn = { &preamble_1_6_conn, &test_case_1_6_5_3_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_3_resp = { &preamble_1_6_resp, &test_case_1_6_5_3_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_3_list = { &preamble_1_6_list, &test_case_1_6_5_3_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_SID
 */
#define tgrp_case_1_6_5_4 test_group_1_6_5
#define numb_case_1_6_5_4 "1.6.5.4"
#define name_case_1_6_5_4 "Perform options management -- T_SCTP_SID"
#define sref_case_1_6_5_4 sref_case_1_6
#define desc_case_1_6_5_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SID."

int
test_case_1_6_5_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_4_conn test_case_1_6_5_4
#define test_case_1_6_5_4_resp test_case_1_6_5_4
#define test_case_1_6_5_4_list test_case_1_6_5_4

struct test_stream test_1_6_5_4_conn = { &preamble_1_6_conn, &test_case_1_6_5_4_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_4_resp = { &preamble_1_6_resp, &test_case_1_6_5_4_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_4_list = { &preamble_1_6_list, &test_case_1_6_5_4_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_SSN
 */
#define tgrp_case_1_6_5_5 test_group_1_6_5
#define numb_case_1_6_5_5 "1.6.5.5"
#define name_case_1_6_5_5 "Perform options management -- T_SCTP_SSN"
#define sref_case_1_6_5_5 sref_case_1_6
#define desc_case_1_6_5_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SSN."

int
test_case_1_6_5_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_6_5_5_conn test_case_1_6_5_5
#define test_case_1_6_5_5_resp test_case_1_6_5_5
#define test_case_1_6_5_5_list test_case_1_6_5_5

struct test_stream test_1_6_5_5_conn = { &preamble_1_6_conn, &test_case_1_6_5_5_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_5_resp = { &preamble_1_6_resp, &test_case_1_6_5_5_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_5_list = { &preamble_1_6_list, &test_case_1_6_5_5_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_TSN
 */
#define tgrp_case_1_6_5_6 test_group_1_6_5
#define numb_case_1_6_5_6 "1.6.5.6"
#define name_case_1_6_5_6 "Perform options management -- T_SCTP_TSN"
#define sref_case_1_6_5_6 sref_case_1_6
#define desc_case_1_6_5_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_TSN."

int
test_case_1_6_5_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_6_5_6_conn test_case_1_6_5_6
#define test_case_1_6_5_6_resp test_case_1_6_5_6
#define test_case_1_6_5_6_list test_case_1_6_5_6

struct test_stream test_1_6_5_6_conn = { &preamble_1_6_conn, &test_case_1_6_5_6_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_6_resp = { &preamble_1_6_resp, &test_case_1_6_5_6_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_6_list = { &preamble_1_6_list, &test_case_1_6_5_6_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_RECVOPT
 */
#define tgrp_case_1_6_5_7 test_group_1_6_5
#define numb_case_1_6_5_7 "1.6.5.7"
#define name_case_1_6_5_7 "Perform options management -- T_SCTP_RECVOPT"
#define sref_case_1_6_5_7 sref_case_1_6
#define desc_case_1_6_5_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RECVOPT."

int
test_case_1_6_5_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_7_conn test_case_1_6_5_7
#define test_case_1_6_5_7_resp test_case_1_6_5_7
#define test_case_1_6_5_7_list test_case_1_6_5_7

struct test_stream test_1_6_5_7_conn = { &preamble_1_6_conn, &test_case_1_6_5_7_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_7_resp = { &preamble_1_6_resp, &test_case_1_6_5_7_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_7_list = { &preamble_1_6_list, &test_case_1_6_5_7_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_LIFE
 */
#define tgrp_case_1_6_5_8 test_group_1_6_5
#define numb_case_1_6_5_8 "1.6.5.8"
#define name_case_1_6_5_8 "Perform options management -- T_SCTP_COOKIE_LIFE"
#define sref_case_1_6_5_8 sref_case_1_6
#define desc_case_1_6_5_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_LIFE."

int
test_case_1_6_5_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_8_conn test_case_1_6_5_8
#define test_case_1_6_5_8_resp test_case_1_6_5_8
#define test_case_1_6_5_8_list test_case_1_6_5_8

struct test_stream test_1_6_5_8_conn = { &preamble_1_6_conn, &test_case_1_6_5_8_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_8_resp = { &preamble_1_6_resp, &test_case_1_6_5_8_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_8_list = { &preamble_1_6_list, &test_case_1_6_5_8_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_SACK_DELAY
 */
#define tgrp_case_1_6_5_9 test_group_1_6_5
#define numb_case_1_6_5_9 "1.6.5.9"
#define name_case_1_6_5_9 "Perform options management -- T_SCTP_SACK_DELAY"
#define sref_case_1_6_5_9 sref_case_1_6
#define desc_case_1_6_5_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SACK_DELAY."

int
test_case_1_6_5_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_9_conn test_case_1_6_5_9
#define test_case_1_6_5_9_resp test_case_1_6_5_9
#define test_case_1_6_5_9_list test_case_1_6_5_9

struct test_stream test_1_6_5_9_conn = { &preamble_1_6_conn, &test_case_1_6_5_9_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_9_resp = { &preamble_1_6_resp, &test_case_1_6_5_9_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_9_list = { &preamble_1_6_list, &test_case_1_6_5_9_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_PATH_MAX_RETRANS
 */
#define tgrp_case_1_6_5_10 test_group_1_6_5
#define numb_case_1_6_5_10 "1.6.5.10"
#define name_case_1_6_5_10 "Perform options management -- T_SCTP_PATH_MAX_RETRANS"
#define sref_case_1_6_5_10 sref_case_1_6
#define desc_case_1_6_5_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PATH_MAX_RETRANS."

int
test_case_1_6_5_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_10_conn test_case_1_6_5_10
#define test_case_1_6_5_10_resp test_case_1_6_5_10
#define test_case_1_6_5_10_list test_case_1_6_5_10

struct test_stream test_1_6_5_10_conn = { &preamble_1_6_conn, &test_case_1_6_5_10_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_10_resp = { &preamble_1_6_resp, &test_case_1_6_5_10_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_10_list = { &preamble_1_6_list, &test_case_1_6_5_10_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_ASSOC_MAX_RETRANS
 */
#define tgrp_case_1_6_5_11 test_group_1_6_5
#define numb_case_1_6_5_11 "1.6.5.11"
#define name_case_1_6_5_11 "Perform options management -- T_SCTP_ASSOC_MAX_RETRANS"
#define sref_case_1_6_5_11 sref_case_1_6
#define desc_case_1_6_5_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ASSOC_MAX_RETRANS."

int
test_case_1_6_5_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_11_conn test_case_1_6_5_11
#define test_case_1_6_5_11_resp test_case_1_6_5_11
#define test_case_1_6_5_11_list test_case_1_6_5_11

struct test_stream test_1_6_5_11_conn = { &preamble_1_6_conn, &test_case_1_6_5_11_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_11_resp = { &preamble_1_6_resp, &test_case_1_6_5_11_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_11_list = { &preamble_1_6_list, &test_case_1_6_5_11_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_MAX_INIT_RETRIES
 */
#define tgrp_case_1_6_5_12 test_group_1_6_5
#define numb_case_1_6_5_12 "1.6.5.12"
#define name_case_1_6_5_12 "Perform options management -- T_SCTP_MAX_INIT_RETRIES"
#define sref_case_1_6_5_12 sref_case_1_6
#define desc_case_1_6_5_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_INIT_RETRIES."

int
test_case_1_6_5_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_12_conn test_case_1_6_5_12
#define test_case_1_6_5_12_resp test_case_1_6_5_12
#define test_case_1_6_5_12_list test_case_1_6_5_12

struct test_stream test_1_6_5_12_conn = { &preamble_1_6_conn, &test_case_1_6_5_12_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_12_resp = { &preamble_1_6_resp, &test_case_1_6_5_12_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_12_list = { &preamble_1_6_list, &test_case_1_6_5_12_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_HEARTBEAT_ITVL
 */
#define tgrp_case_1_6_5_13 test_group_1_6_5
#define numb_case_1_6_5_13 "1.6.5.13"
#define name_case_1_6_5_13 "Perform options management -- T_SCTP_HEARTBEAT_ITVL"
#define sref_case_1_6_5_13 sref_case_1_6
#define desc_case_1_6_5_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HEARTBEAT_ITVL."

int
test_case_1_6_5_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_13_conn test_case_1_6_5_13
#define test_case_1_6_5_13_resp test_case_1_6_5_13
#define test_case_1_6_5_13_list test_case_1_6_5_13

struct test_stream test_1_6_5_13_conn = { &preamble_1_6_conn, &test_case_1_6_5_13_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_13_resp = { &preamble_1_6_resp, &test_case_1_6_5_13_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_13_list = { &preamble_1_6_list, &test_case_1_6_5_13_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_RTO_INITIAL
 */
#define tgrp_case_1_6_5_14 test_group_1_6_5
#define numb_case_1_6_5_14 "1.6.5.14"
#define name_case_1_6_5_14 "Perform options management -- T_SCTP_RTO_INITIAL"
#define sref_case_1_6_5_14 sref_case_1_6
#define desc_case_1_6_5_14 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_INITIAL."

int
test_case_1_6_5_14(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_14_conn test_case_1_6_5_14
#define test_case_1_6_5_14_resp test_case_1_6_5_14
#define test_case_1_6_5_14_list test_case_1_6_5_14

struct test_stream test_1_6_5_14_conn = { &preamble_1_6_conn, &test_case_1_6_5_14_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_14_resp = { &preamble_1_6_resp, &test_case_1_6_5_14_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_14_list = { &preamble_1_6_list, &test_case_1_6_5_14_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_RTO_MIN
 */
#define tgrp_case_1_6_5_15 test_group_1_6_5
#define numb_case_1_6_5_15 "1.6.5.15"
#define name_case_1_6_5_15 "Perform options management -- T_SCTP_RTO_MIN"
#define sref_case_1_6_5_15 sref_case_1_6
#define desc_case_1_6_5_15 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MIN."

int
test_case_1_6_5_15(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_15_conn test_case_1_6_5_15
#define test_case_1_6_5_15_resp test_case_1_6_5_15
#define test_case_1_6_5_15_list test_case_1_6_5_15

struct test_stream test_1_6_5_15_conn = { &preamble_1_6_conn, &test_case_1_6_5_15_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_15_resp = { &preamble_1_6_resp, &test_case_1_6_5_15_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_15_list = { &preamble_1_6_list, &test_case_1_6_5_15_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_RTO_MAX
 */
#define tgrp_case_1_6_5_16 test_group_1_6_5
#define numb_case_1_6_5_16 "1.6.5.16"
#define name_case_1_6_5_16 "Perform options management -- T_SCTP_RTO_MAX"
#define sref_case_1_6_5_16 sref_case_1_6
#define desc_case_1_6_5_16 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MAX."

int
test_case_1_6_5_16(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_16_conn test_case_1_6_5_16
#define test_case_1_6_5_16_resp test_case_1_6_5_16
#define test_case_1_6_5_16_list test_case_1_6_5_16

struct test_stream test_1_6_5_16_conn = { &preamble_1_6_conn, &test_case_1_6_5_16_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_16_resp = { &preamble_1_6_resp, &test_case_1_6_5_16_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_16_list = { &preamble_1_6_list, &test_case_1_6_5_16_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_OSTREAMS
 */
#define tgrp_case_1_6_5_17 test_group_1_6_5
#define numb_case_1_6_5_17 "1.6.5.17"
#define name_case_1_6_5_17 "Perform options management -- T_SCTP_OSTREAMS"
#define sref_case_1_6_5_17 sref_case_1_6
#define desc_case_1_6_5_17 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_OSTREAMS."

int
test_case_1_6_5_17(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_17_conn test_case_1_6_5_17
#define test_case_1_6_5_17_resp test_case_1_6_5_17
#define test_case_1_6_5_17_list test_case_1_6_5_17

struct test_stream test_1_6_5_17_conn = { &preamble_1_6_conn, &test_case_1_6_5_17_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_17_resp = { &preamble_1_6_resp, &test_case_1_6_5_17_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_17_list = { &preamble_1_6_list, &test_case_1_6_5_17_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_ISTREAMS
 */
#define tgrp_case_1_6_5_18 test_group_1_6_5
#define numb_case_1_6_5_18 "1.6.5.18"
#define name_case_1_6_5_18 "Perform options management -- T_SCTP_ISTREAMS"
#define sref_case_1_6_5_18 sref_case_1_6
#define desc_case_1_6_5_18 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ISTREAMS."

int
test_case_1_6_5_18(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_18_conn test_case_1_6_5_18
#define test_case_1_6_5_18_resp test_case_1_6_5_18
#define test_case_1_6_5_18_list test_case_1_6_5_18

struct test_stream test_1_6_5_18_conn = { &preamble_1_6_conn, &test_case_1_6_5_18_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_18_resp = { &preamble_1_6_resp, &test_case_1_6_5_18_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_18_list = { &preamble_1_6_list, &test_case_1_6_5_18_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_INC
 */
#define tgrp_case_1_6_5_19 test_group_1_6_5
#define numb_case_1_6_5_19 "1.6.5.19"
#define name_case_1_6_5_19 "Perform options management -- T_SCTP_COOKIE_INC"
#define sref_case_1_6_5_19 sref_case_1_6
#define desc_case_1_6_5_19 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_INC."

int
test_case_1_6_5_19(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_19_conn test_case_1_6_5_19
#define test_case_1_6_5_19_resp test_case_1_6_5_19
#define test_case_1_6_5_19_list test_case_1_6_5_19

struct test_stream test_1_6_5_19_conn = { &preamble_1_6_conn, &test_case_1_6_5_19_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_19_resp = { &preamble_1_6_resp, &test_case_1_6_5_19_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_19_list = { &preamble_1_6_list, &test_case_1_6_5_19_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_THROTTLE_ITVL
 */
#define tgrp_case_1_6_5_20 test_group_1_6_5
#define numb_case_1_6_5_20 "1.6.5.20"
#define name_case_1_6_5_20 "Perform options management -- T_SCTP_THROTTLE_ITVL"
#define sref_case_1_6_5_20 sref_case_1_6
#define desc_case_1_6_5_20 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_THROTTLE_ITVL."

int
test_case_1_6_5_20(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_20_conn test_case_1_6_5_20
#define test_case_1_6_5_20_resp test_case_1_6_5_20
#define test_case_1_6_5_20_list test_case_1_6_5_20

struct test_stream test_1_6_5_20_conn = { &preamble_1_6_conn, &test_case_1_6_5_20_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_20_resp = { &preamble_1_6_resp, &test_case_1_6_5_20_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_20_list = { &preamble_1_6_list, &test_case_1_6_5_20_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_MAC_TYPE
 */
#define tgrp_case_1_6_5_21 test_group_1_6_5
#define numb_case_1_6_5_21 "1.6.5.21"
#define name_case_1_6_5_21 "Perform options management -- T_SCTP_MAC_TYPE"
#define sref_case_1_6_5_21 sref_case_1_6
#define desc_case_1_6_5_21 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAC_TYPE."

int
test_case_1_6_5_21(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_21_conn test_case_1_6_5_21
#define test_case_1_6_5_21_resp test_case_1_6_5_21
#define test_case_1_6_5_21_list test_case_1_6_5_21

struct test_stream test_1_6_5_21_conn = { &preamble_1_6_conn, &test_case_1_6_5_21_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_21_resp = { &preamble_1_6_resp, &test_case_1_6_5_21_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_21_list = { &preamble_1_6_list, &test_case_1_6_5_21_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_CKSUM_TYPE
 */
#define tgrp_case_1_6_5_22 test_group_1_6_5
#define numb_case_1_6_5_22 "1.6.5.22"
#define name_case_1_6_5_22 "Perform options management -- T_SCTP_CKSUM_TYPE"
#define sref_case_1_6_5_22 sref_case_1_6
#define desc_case_1_6_5_22 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CKSUM_TYPE."

int
test_case_1_6_5_22(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_22_conn test_case_1_6_5_22
#define test_case_1_6_5_22_resp test_case_1_6_5_22
#define test_case_1_6_5_22_list test_case_1_6_5_22

struct test_stream test_1_6_5_22_conn = { &preamble_1_6_conn, &test_case_1_6_5_22_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_22_resp = { &preamble_1_6_resp, &test_case_1_6_5_22_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_22_list = { &preamble_1_6_list, &test_case_1_6_5_22_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_ECN
 */
#define tgrp_case_1_6_5_23 test_group_1_6_5
#define numb_case_1_6_5_23 "1.6.5.23"
#define name_case_1_6_5_23 "Perform options management -- T_SCTP_ECN"
#define sref_case_1_6_5_23 sref_case_1_6
#define desc_case_1_6_5_23 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ECN."

int
test_case_1_6_5_23(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_23_conn test_case_1_6_5_23
#define test_case_1_6_5_23_resp test_case_1_6_5_23
#define test_case_1_6_5_23_list test_case_1_6_5_23

struct test_stream test_1_6_5_23_conn = { &preamble_1_6_conn, &test_case_1_6_5_23_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_23_resp = { &preamble_1_6_resp, &test_case_1_6_5_23_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_23_list = { &preamble_1_6_list, &test_case_1_6_5_23_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_ALI
 */
#define tgrp_case_1_6_5_24 test_group_1_6_5
#define numb_case_1_6_5_24 "1.6.5.24"
#define name_case_1_6_5_24 "Perform options management -- T_SCTP_ALI"
#define sref_case_1_6_5_24 sref_case_1_6
#define desc_case_1_6_5_24 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ALI."

int
test_case_1_6_5_24(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_24_conn test_case_1_6_5_24
#define test_case_1_6_5_24_resp test_case_1_6_5_24
#define test_case_1_6_5_24_list test_case_1_6_5_24

struct test_stream test_1_6_5_24_conn = { &preamble_1_6_conn, &test_case_1_6_5_24_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_24_resp = { &preamble_1_6_resp, &test_case_1_6_5_24_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_24_list = { &preamble_1_6_list, &test_case_1_6_5_24_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_ADD
 */
#define tgrp_case_1_6_5_25 test_group_1_6_5
#define numb_case_1_6_5_25 "1.6.5.25"
#define name_case_1_6_5_25 "Perform options management -- T_SCTP_ADD"
#define sref_case_1_6_5_25 sref_case_1_6
#define desc_case_1_6_5_25 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD."

int
test_case_1_6_5_25(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_25_conn test_case_1_6_5_25
#define test_case_1_6_5_25_resp test_case_1_6_5_25
#define test_case_1_6_5_25_list test_case_1_6_5_25

struct test_stream test_1_6_5_25_conn = { &preamble_1_6_conn, &test_case_1_6_5_25_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_25_resp = { &preamble_1_6_resp, &test_case_1_6_5_25_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_25_list = { &preamble_1_6_list, &test_case_1_6_5_25_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_SET
 */
#define tgrp_case_1_6_5_26 test_group_1_6_5
#define numb_case_1_6_5_26 "1.6.5.26"
#define name_case_1_6_5_26 "Perform options management -- T_SCTP_SET"
#define sref_case_1_6_5_26 sref_case_1_6
#define desc_case_1_6_5_26 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET."

int
test_case_1_6_5_26(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_26_conn test_case_1_6_5_26
#define test_case_1_6_5_26_resp test_case_1_6_5_26
#define test_case_1_6_5_26_list test_case_1_6_5_26

struct test_stream test_1_6_5_26_conn = { &preamble_1_6_conn, &test_case_1_6_5_26_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_26_resp = { &preamble_1_6_resp, &test_case_1_6_5_26_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_26_list = { &preamble_1_6_list, &test_case_1_6_5_26_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_ADD_IP
 */
#define tgrp_case_1_6_5_27 test_group_1_6_5
#define numb_case_1_6_5_27 "1.6.5.27"
#define name_case_1_6_5_27 "Perform options management -- T_SCTP_ADD_IP"
#define sref_case_1_6_5_27 sref_case_1_6
#define desc_case_1_6_5_27 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD_IP."

int
test_case_1_6_5_27(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_27_conn test_case_1_6_5_27
#define test_case_1_6_5_27_resp test_case_1_6_5_27
#define test_case_1_6_5_27_list test_case_1_6_5_27

struct test_stream test_1_6_5_27_conn = { &preamble_1_6_conn, &test_case_1_6_5_27_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_27_resp = { &preamble_1_6_resp, &test_case_1_6_5_27_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_27_list = { &preamble_1_6_list, &test_case_1_6_5_27_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_DEL_IP
 */
#define tgrp_case_1_6_5_28 test_group_1_6_5
#define numb_case_1_6_5_28 "1.6.5.28"
#define name_case_1_6_5_28 "Perform options management -- T_SCTP_DEL_IP"
#define sref_case_1_6_5_28 sref_case_1_6
#define desc_case_1_6_5_28 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DEL_IP."

int
test_case_1_6_5_28(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_28_conn test_case_1_6_5_28
#define test_case_1_6_5_28_resp test_case_1_6_5_28
#define test_case_1_6_5_28_list test_case_1_6_5_28

struct test_stream test_1_6_5_28_conn = { &preamble_1_6_conn, &test_case_1_6_5_28_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_28_resp = { &preamble_1_6_resp, &test_case_1_6_5_28_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_28_list = { &preamble_1_6_list, &test_case_1_6_5_28_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_SET_IP
 */
#define tgrp_case_1_6_5_29 test_group_1_6_5
#define numb_case_1_6_5_29 "1.6.5.29"
#define name_case_1_6_5_29 "Perform options management -- T_SCTP_SET_IP"
#define sref_case_1_6_5_29 sref_case_1_6
#define desc_case_1_6_5_29 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET_IP."

int
test_case_1_6_5_29(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_29_conn test_case_1_6_5_29
#define test_case_1_6_5_29_resp test_case_1_6_5_29
#define test_case_1_6_5_29_list test_case_1_6_5_29

struct test_stream test_1_6_5_29_conn = { &preamble_1_6_conn, &test_case_1_6_5_29_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_29_resp = { &preamble_1_6_resp, &test_case_1_6_5_29_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_29_list = { &preamble_1_6_list, &test_case_1_6_5_29_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_PR
 */
#define tgrp_case_1_6_5_30 test_group_1_6_5
#define numb_case_1_6_5_30 "1.6.5.30"
#define name_case_1_6_5_30 "Perform options management -- T_SCTP_PR"
#define sref_case_1_6_5_30 sref_case_1_6
#define desc_case_1_6_5_30 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PR."

int
test_case_1_6_5_30(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_30_conn test_case_1_6_5_30
#define test_case_1_6_5_30_resp test_case_1_6_5_30
#define test_case_1_6_5_30_list test_case_1_6_5_30

struct test_stream test_1_6_5_30_conn = { &preamble_1_6_conn, &test_case_1_6_5_30_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_30_resp = { &preamble_1_6_resp, &test_case_1_6_5_30_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_30_list = { &preamble_1_6_list, &test_case_1_6_5_30_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_LIFETIME
 */
#define tgrp_case_1_6_5_31 test_group_1_6_5
#define numb_case_1_6_5_31 "1.6.5.31"
#define name_case_1_6_5_31 "Perform options management -- T_SCTP_LIFETIME"
#define sref_case_1_6_5_31 sref_case_1_6
#define desc_case_1_6_5_31 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_LIFETIME."

int
test_case_1_6_5_31(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_INFINITE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_31_conn test_case_1_6_5_31
#define test_case_1_6_5_31_resp test_case_1_6_5_31
#define test_case_1_6_5_31_list test_case_1_6_5_31

struct test_stream test_1_6_5_31_conn = { &preamble_1_6_conn, &test_case_1_6_5_31_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_31_resp = { &preamble_1_6_resp, &test_case_1_6_5_31_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_31_list = { &preamble_1_6_list, &test_case_1_6_5_31_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_DISPOSITION
 */
#define tgrp_case_1_6_5_32 test_group_1_6_5
#define numb_case_1_6_5_32 "1.6.5.32"
#define name_case_1_6_5_32 "Perform options management -- T_SCTP_DISPOSITION"
#define sref_case_1_6_5_32 sref_case_1_6
#define desc_case_1_6_5_32 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DISPOSITION."

int
test_case_1_6_5_32(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_32_conn test_case_1_6_5_32
#define test_case_1_6_5_32_resp test_case_1_6_5_32
#define test_case_1_6_5_32_list test_case_1_6_5_32

struct test_stream test_1_6_5_32_conn = { &preamble_1_6_conn, &test_case_1_6_5_32_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_32_resp = { &preamble_1_6_resp, &test_case_1_6_5_32_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_32_list = { &preamble_1_6_list, &test_case_1_6_5_32_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_MAX_BURST
 */
#define tgrp_case_1_6_5_33 test_group_1_6_5
#define numb_case_1_6_5_33 "1.6.5.33"
#define name_case_1_6_5_33 "Perform options management -- T_SCTP_MAX_BURST"
#define sref_case_1_6_5_33 sref_case_1_6
#define desc_case_1_6_5_33 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_BURST."

int
test_case_1_6_5_33(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_33_conn test_case_1_6_5_33
#define test_case_1_6_5_33_resp test_case_1_6_5_33
#define test_case_1_6_5_33_list test_case_1_6_5_33

struct test_stream test_1_6_5_33_conn = { &preamble_1_6_conn, &test_case_1_6_5_33_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_33_resp = { &preamble_1_6_resp, &test_case_1_6_5_33_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_33_list = { &preamble_1_6_list, &test_case_1_6_5_33_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_HB
 */
#define tgrp_case_1_6_5_34 test_group_1_6_5
#define numb_case_1_6_5_34 "1.6.5.34"
#define name_case_1_6_5_34 "Perform options management -- T_SCTP_HB"
#define sref_case_1_6_5_34 sref_case_1_6
#define desc_case_1_6_5_34 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HB."

int
test_case_1_6_5_34(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_34_conn test_case_1_6_5_34
#define test_case_1_6_5_34_resp test_case_1_6_5_34
#define test_case_1_6_5_34_list test_case_1_6_5_34

struct test_stream test_1_6_5_34_conn = { &preamble_1_6_conn, &test_case_1_6_5_34_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_34_resp = { &preamble_1_6_resp, &test_case_1_6_5_34_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_34_list = { &preamble_1_6_list, &test_case_1_6_5_34_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_RTO
 */
#define tgrp_case_1_6_5_35 test_group_1_6_5
#define numb_case_1_6_5_35 "1.6.5.35"
#define name_case_1_6_5_35 "Perform options management -- T_SCTP_RTO"
#define sref_case_1_6_5_35 sref_case_1_6
#define desc_case_1_6_5_35 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO."

int
test_case_1_6_5_35(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_35_conn test_case_1_6_5_35
#define test_case_1_6_5_35_resp test_case_1_6_5_35
#define test_case_1_6_5_35_list test_case_1_6_5_35

struct test_stream test_1_6_5_35_conn = { &preamble_1_6_conn, &test_case_1_6_5_35_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_35_resp = { &preamble_1_6_resp, &test_case_1_6_5_35_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_35_list = { &preamble_1_6_list, &test_case_1_6_5_35_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_MAXSEG
 */
#define tgrp_case_1_6_5_36 test_group_1_6_5
#define numb_case_1_6_5_36 "1.6.5.36"
#define name_case_1_6_5_36 "Perform options management -- T_SCTP_MAXSEG"
#define sref_case_1_6_5_36 sref_case_1_6
#define desc_case_1_6_5_36 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAXSEG."

int
test_case_1_6_5_36(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_36_conn test_case_1_6_5_36
#define test_case_1_6_5_36_resp test_case_1_6_5_36
#define test_case_1_6_5_36_list test_case_1_6_5_36

struct test_stream test_1_6_5_36_conn = { &preamble_1_6_conn, &test_case_1_6_5_36_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_36_resp = { &preamble_1_6_resp, &test_case_1_6_5_36_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_36_list = { &preamble_1_6_list, &test_case_1_6_5_36_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_STATUS
 */
#define tgrp_case_1_6_5_37 test_group_1_6_5
#define numb_case_1_6_5_37 "1.6.5.37"
#define name_case_1_6_5_37 "Perform options management -- T_SCTP_STATUS"
#define sref_case_1_6_5_37 sref_case_1_6
#define desc_case_1_6_5_37 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_SCTP_STATUS."

int
test_case_1_6_5_37(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_6_5_37_conn test_case_1_6_5_37
#define test_case_1_6_5_37_resp test_case_1_6_5_37
#define test_case_1_6_5_37_list test_case_1_6_5_37

struct test_stream test_1_6_5_37_conn = { &preamble_1_6_conn, &test_case_1_6_5_37_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_37_resp = { &preamble_1_6_resp, &test_case_1_6_5_37_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_37_list = { &preamble_1_6_list, &test_case_1_6_5_37_list, &postamble_1_6_list };

/*
 *  Perform options management -- T_SCTP_DEBUG
 */
#define tgrp_case_1_6_5_38 test_group_1_6_5
#define numb_case_1_6_5_38 "1.6.5.38"
#define name_case_1_6_5_38 "Perform options management -- T_SCTP_DEBUG"
#define sref_case_1_6_5_38 sref_case_1_6
#define desc_case_1_6_5_38 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_SCTP_DEBUG."

int
test_case_1_6_5_38(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CURRENT;
	return test_case_1_6_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_6_5_38_conn test_case_1_6_5_38
#define test_case_1_6_5_38_resp test_case_1_6_5_38
#define test_case_1_6_5_38_list test_case_1_6_5_38

struct test_stream test_1_6_5_38_conn = { &preamble_1_6_conn, &test_case_1_6_5_38_conn, &postamble_1_6_conn };
struct test_stream test_1_6_5_38_resp = { &preamble_1_6_resp, &test_case_1_6_5_38_resp, &postamble_1_6_resp };
struct test_stream test_1_6_5_38_list = { &preamble_1_6_list, &test_case_1_6_5_38_list, &postamble_1_6_list };

/*
 *  Do options management.
 */
#define test_group_1_7 "Options management - T_CHECK"
#define tgrp_case_1_7 test_group_1_7
#define numb_case_1_7 "1.7"
#define name_case_1_7 "Perform options management."
#define sref_case_1_7 "TPI Rev 1.5 Sections 2.1.1.4, 2.1.2.3"
#define desc_case_1_7 "\
Checks that options management can be performed on several streams."

int
test_case_1_7(int child, ulong result)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags != result)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_7_xfail(int child, int terror, int error)
{
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != terror || (last_t_errno == TSYSERR && last_errno != error))
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_7_xti(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_7(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_7_ip(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_7(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_7_udp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_UDP:
		return test_case_1_7(child, result);
	case T_INET_IP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_7_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_7_tcp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_TCP:
		return test_case_1_7(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_SCTP:
		return test_case_1_7_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_7_sctp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_SCTP:
		return test_case_1_7(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		return test_case_1_7_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

#define test_case_1_7_conn	test_case_1_7
#define test_case_1_7_resp	test_case_1_7
#define test_case_1_7_list	test_case_1_7

#define preamble_1_7_conn	preamble_0
#define preamble_1_7_resp	preamble_0
#define preamble_1_7_list	preamble_0

#define postamble_1_7_conn	postamble_0
#define postamble_1_7_resp	postamble_0
#define postamble_1_7_list	postamble_0

//struct test_stream test_1_7_conn = { &preamble_1_7_conn, &test_case_1_7_conn, &postamble_1_7_conn };
//struct test_stream test_1_7_resp = { &preamble_1_7_resp, &test_case_1_7_resp, &postamble_1_7_resp };
//struct test_stream test_1_7_list = { &preamble_1_7_list, &test_case_1_7_list, &postamble_1_7_list };

#define test_group_1_7_1 "Local management -- XTI options management"
#define tgrp_case_1_7_1_1 test_group_1_7_1
#define numb_case_1_7_1_1 "1.7.1.1"
#define name_case_1_7_1_1 "Perform options management -- all options"
#define sref_case_1_7_1_1 sref_case_1_7
#define desc_case_1_7_1_1 "\
Checks that options management can be performed on several streams\n\
for all options."

int
test_case_1_7_1_1(int child)
{
	test_opts = &opt_optm;
	test_olen = sizeof(opt_optm);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_1_conn test_case_1_7_1_1
#define test_case_1_7_1_1_resp test_case_1_7_1_1
#define test_case_1_7_1_1_list test_case_1_7_1_1

struct test_stream test_1_7_1_1_conn = { &preamble_1_7_conn, &test_case_1_7_1_1_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_1_resp = { &preamble_1_7_resp, &test_case_1_7_1_1_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_1_list = { &preamble_1_7_list, &test_case_1_7_1_1_list, &postamble_1_7_list };

#define tgrp_case_1_7_1_2 test_group_1_7_1
#define numb_case_1_7_1_2 "1.7.1.2"
#define name_case_1_7_1_2 "Perform options management -- XTI_DEBUG"
#define sref_case_1_7_1_2 sref_case_1_7
#define desc_case_1_7_1_2 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_DEBUG."

int
test_case_1_7_1_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_2_conn test_case_1_7_1_2
#define test_case_1_7_1_2_resp test_case_1_7_1_2
#define test_case_1_7_1_2_list test_case_1_7_1_2

struct test_stream test_1_7_1_2_conn = { &preamble_1_7_conn, &test_case_1_7_1_2_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_2_resp = { &preamble_1_7_resp, &test_case_1_7_1_2_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_2_list = { &preamble_1_7_list, &test_case_1_7_1_2_list, &postamble_1_7_list };

#define tgrp_case_1_7_1_3 test_group_1_7_1
#define numb_case_1_7_1_3 "1.7.1.3"
#define name_case_1_7_1_3 "Perform options management -- XTI_LINGER"
#define sref_case_1_7_1_3 sref_case_1_7
#define desc_case_1_7_1_3 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_LINGER."

int
test_case_1_7_1_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_3_conn test_case_1_7_1_3
#define test_case_1_7_1_3_resp test_case_1_7_1_3
#define test_case_1_7_1_3_list test_case_1_7_1_3

struct test_stream test_1_7_1_3_conn = { &preamble_1_7_conn, &test_case_1_7_1_3_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_3_resp = { &preamble_1_7_resp, &test_case_1_7_1_3_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_3_list = { &preamble_1_7_list, &test_case_1_7_1_3_list, &postamble_1_7_list };

#define tgrp_case_1_7_1_4 test_group_1_7_1
#define numb_case_1_7_1_4 "1.7.1.4"
#define name_case_1_7_1_4 "Perform options management -- XTI_RCVBUF"
#define sref_case_1_7_1_4 sref_case_1_7
#define desc_case_1_7_1_4 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVBUF."

int
test_case_1_7_1_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_4_conn test_case_1_7_1_4
#define test_case_1_7_1_4_resp test_case_1_7_1_4
#define test_case_1_7_1_4_list test_case_1_7_1_4

struct test_stream test_1_7_1_4_conn = { &preamble_1_7_conn, &test_case_1_7_1_4_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_4_resp = { &preamble_1_7_resp, &test_case_1_7_1_4_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_4_list = { &preamble_1_7_list, &test_case_1_7_1_4_list, &postamble_1_7_list };

#define tgrp_case_1_7_1_5 test_group_1_7_1
#define numb_case_1_7_1_5 "1.7.1.5"
#define name_case_1_7_1_5 "Perform options management -- XTI_RCVLOWAT"
#define sref_case_1_7_1_5 sref_case_1_7
#define desc_case_1_7_1_5 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVLOWAT."

int
test_case_1_7_1_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_5_conn test_case_1_7_1_5
#define test_case_1_7_1_5_resp test_case_1_7_1_5
#define test_case_1_7_1_5_list test_case_1_7_1_5

struct test_stream test_1_7_1_5_conn = { &preamble_1_7_conn, &test_case_1_7_1_5_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_5_resp = { &preamble_1_7_resp, &test_case_1_7_1_5_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_5_list = { &preamble_1_7_list, &test_case_1_7_1_5_list, &postamble_1_7_list };

#define tgrp_case_1_7_1_6 test_group_1_7_1
#define numb_case_1_7_1_6 "1.7.1.6"
#define name_case_1_7_1_6 "Perform options management -- XTI_SNDBUF"
#define sref_case_1_7_1_6 sref_case_1_7
#define desc_case_1_7_1_6 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDBUF."

int
test_case_1_7_1_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_6_conn test_case_1_7_1_6
#define test_case_1_7_1_6_resp test_case_1_7_1_6
#define test_case_1_7_1_6_list test_case_1_7_1_6

struct test_stream test_1_7_1_6_conn = { &preamble_1_7_conn, &test_case_1_7_1_6_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_6_resp = { &preamble_1_7_resp, &test_case_1_7_1_6_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_6_list = { &preamble_1_7_list, &test_case_1_7_1_6_list, &postamble_1_7_list };

#define tgrp_case_1_7_1_7 test_group_1_7_1
#define numb_case_1_7_1_7 "1.7.1.7"
#define name_case_1_7_1_7 "Perform options management -- XTI_SNDLOWAT"
#define sref_case_1_7_1_7 sref_case_1_7
#define desc_case_1_7_1_7 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDLOWAT."

int
test_case_1_7_1_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_1_7_conn test_case_1_7_1_7
#define test_case_1_7_1_7_resp test_case_1_7_1_7
#define test_case_1_7_1_7_list test_case_1_7_1_7

struct test_stream test_1_7_1_7_conn = { &preamble_1_7_conn, &test_case_1_7_1_7_conn, &postamble_1_7_conn };
struct test_stream test_1_7_1_7_resp = { &preamble_1_7_resp, &test_case_1_7_1_7_resp, &postamble_1_7_resp };
struct test_stream test_1_7_1_7_list = { &preamble_1_7_list, &test_case_1_7_1_7_list, &postamble_1_7_list };

#define test_group_1_7_2 "Local management -- IP options management"
#define tgrp_case_1_7_2_1 test_group_1_7_2
#define numb_case_1_7_2_1 "1.7.2.1"
#define name_case_1_7_2_1 "Perform options management -- T_IP_TOS"
#define sref_case_1_7_2_1 sref_case_1_7
#define desc_case_1_7_2_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TOS."

int
test_case_1_7_2_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_2_1_conn test_case_1_7_2_1
#define test_case_1_7_2_1_resp test_case_1_7_2_1
#define test_case_1_7_2_1_list test_case_1_7_2_1

struct test_stream test_1_7_2_1_conn = { &preamble_1_7_conn, &test_case_1_7_2_1_conn, &postamble_1_7_conn };
struct test_stream test_1_7_2_1_resp = { &preamble_1_7_resp, &test_case_1_7_2_1_resp, &postamble_1_7_resp };
struct test_stream test_1_7_2_1_list = { &preamble_1_7_list, &test_case_1_7_2_1_list, &postamble_1_7_list };

#define tgrp_case_1_7_2_2 test_group_1_7_2
#define numb_case_1_7_2_2 "1.7.2.2"
#define name_case_1_7_2_2 "Perform options management -- T_IP_TTL"
#define sref_case_1_7_2_2 sref_case_1_7
#define desc_case_1_7_2_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TTL."

int
test_case_1_7_2_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_2_2_conn test_case_1_7_2_2
#define test_case_1_7_2_2_resp test_case_1_7_2_2
#define test_case_1_7_2_2_list test_case_1_7_2_2

struct test_stream test_1_7_2_2_conn = { &preamble_1_7_conn, &test_case_1_7_2_2_conn, &postamble_1_7_conn };
struct test_stream test_1_7_2_2_resp = { &preamble_1_7_resp, &test_case_1_7_2_2_resp, &postamble_1_7_resp };
struct test_stream test_1_7_2_2_list = { &preamble_1_7_list, &test_case_1_7_2_2_list, &postamble_1_7_list };

#define tgrp_case_1_7_2_3 test_group_1_7_2
#define numb_case_1_7_2_3 "1.7.2.3"
#define name_case_1_7_2_3 "Perform options management -- T_IP_DONTROUTE"
#define sref_case_1_7_2_3 sref_case_1_7
#define desc_case_1_7_2_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_DONTROUTE."

int
test_case_1_7_2_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_2_3_conn test_case_1_7_2_3
#define test_case_1_7_2_3_resp test_case_1_7_2_3
#define test_case_1_7_2_3_list test_case_1_7_2_3

struct test_stream test_1_7_2_3_conn = { &preamble_1_7_conn, &test_case_1_7_2_3_conn, &postamble_1_7_conn };
struct test_stream test_1_7_2_3_resp = { &preamble_1_7_resp, &test_case_1_7_2_3_resp, &postamble_1_7_resp };
struct test_stream test_1_7_2_3_list = { &preamble_1_7_list, &test_case_1_7_2_3_list, &postamble_1_7_list };

#define tgrp_case_1_7_2_4 test_group_1_7_2
#define numb_case_1_7_2_4 "1.7.2.4"
#define name_case_1_7_2_4 "Perform options management -- T_IP_BROADCAST"
#define sref_case_1_7_2_4 sref_case_1_7
#define desc_case_1_7_2_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_BROADCAST."

int
test_case_1_7_2_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_2_4_conn test_case_1_7_2_4
#define test_case_1_7_2_4_resp test_case_1_7_2_4
#define test_case_1_7_2_4_list test_case_1_7_2_4

struct test_stream test_1_7_2_4_conn = { &preamble_1_7_conn, &test_case_1_7_2_4_conn, &postamble_1_7_conn };
struct test_stream test_1_7_2_4_resp = { &preamble_1_7_resp, &test_case_1_7_2_4_resp, &postamble_1_7_resp };
struct test_stream test_1_7_2_4_list = { &preamble_1_7_list, &test_case_1_7_2_4_list, &postamble_1_7_list };

#define tgrp_case_1_7_2_5 test_group_1_7_2
#define numb_case_1_7_2_5 "1.7.2.5"
#define name_case_1_7_2_5 "Perform options management -- T_IP_REUSEADDR"
#define sref_case_1_7_2_5 sref_case_1_7
#define desc_case_1_7_2_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_REUSEADDR."

int
test_case_1_7_2_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_2_5_conn test_case_1_7_2_5
#define test_case_1_7_2_5_resp test_case_1_7_2_5
#define test_case_1_7_2_5_list test_case_1_7_2_5

struct test_stream test_1_7_2_5_conn = { &preamble_1_7_conn, &test_case_1_7_2_5_conn, &postamble_1_7_conn };
struct test_stream test_1_7_2_5_resp = { &preamble_1_7_resp, &test_case_1_7_2_5_resp, &postamble_1_7_resp };
struct test_stream test_1_7_2_5_list = { &preamble_1_7_list, &test_case_1_7_2_5_list, &postamble_1_7_list };

#define test_group_1_7_3 "Local management -- UDP options management"
#define tgrp_case_1_7_3_1 test_group_1_7_3
#define numb_case_1_7_3_1 "1.7.3.1"
#define name_case_1_7_3_1 "Perform options management -- T_UDP_CHECKSUM"
#define sref_case_1_7_3_1 sref_case_1_7
#define desc_case_1_7_3_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_UDP option T_UDP_CHECKSUM."

int
test_case_1_7_3_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_udp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_3_1_conn test_case_1_7_3_1
#define test_case_1_7_3_1_resp test_case_1_7_3_1
#define test_case_1_7_3_1_list test_case_1_7_3_1

struct test_stream test_1_7_3_1_conn = { &preamble_1_7_conn, &test_case_1_7_3_1_conn, &postamble_1_7_conn };
struct test_stream test_1_7_3_1_resp = { &preamble_1_7_resp, &test_case_1_7_3_1_resp, &postamble_1_7_resp };
struct test_stream test_1_7_3_1_list = { &preamble_1_7_list, &test_case_1_7_3_1_list, &postamble_1_7_list };

#define test_group_1_7_4 "Local management -- TCP options management"
#define tgrp_case_1_7_4_1 test_group_1_7_4
#define numb_case_1_7_4_1 "1.7.4.1"
#define name_case_1_7_4_1 "Perform options management -- T_TCP_NODELAY"
#define sref_case_1_7_4_1 sref_case_1_7
#define desc_case_1_7_4_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_NODELAY."

int
test_case_1_7_4_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_1_conn test_case_1_7_4_1
#define test_case_1_7_4_1_resp test_case_1_7_4_1
#define test_case_1_7_4_1_list test_case_1_7_4_1

struct test_stream test_1_7_4_1_conn = { &preamble_1_7_conn, &test_case_1_7_4_1_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_1_resp = { &preamble_1_7_resp, &test_case_1_7_4_1_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_1_list = { &preamble_1_7_list, &test_case_1_7_4_1_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_2 test_group_1_7_4
#define numb_case_1_7_4_2 "1.7.4.2"
#define name_case_1_7_4_2 "Perform options management -- T_TCP_MAXSEG"
#define sref_case_1_7_4_2 sref_case_1_7
#define desc_case_1_7_4_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_MAXSEG."

int
test_case_1_7_4_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_2_conn test_case_1_7_4_2
#define test_case_1_7_4_2_resp test_case_1_7_4_2
#define test_case_1_7_4_2_list test_case_1_7_4_2

struct test_stream test_1_7_4_2_conn = { &preamble_1_7_conn, &test_case_1_7_4_2_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_2_resp = { &preamble_1_7_resp, &test_case_1_7_4_2_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_2_list = { &preamble_1_7_list, &test_case_1_7_4_2_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_3 test_group_1_7_4
#define numb_case_1_7_4_3 "1.7.4.3"
#define name_case_1_7_4_3 "Perform options management -- T_TCP_KEEPALIVE"
#define sref_case_1_7_4_3 sref_case_1_7
#define desc_case_1_7_4_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPALIVE."

int
test_case_1_7_4_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_3_conn test_case_1_7_4_3
#define test_case_1_7_4_3_resp test_case_1_7_4_3
#define test_case_1_7_4_3_list test_case_1_7_4_3

struct test_stream test_1_7_4_3_conn = { &preamble_1_7_conn, &test_case_1_7_4_3_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_3_resp = { &preamble_1_7_resp, &test_case_1_7_4_3_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_3_list = { &preamble_1_7_list, &test_case_1_7_4_3_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_4 test_group_1_7_4
#define numb_case_1_7_4_4 "1.7.4.4"
#define name_case_1_7_4_4 "Perform options management -- T_TCP_CORK"
#define sref_case_1_7_4_4 sref_case_1_7
#define desc_case_1_7_4_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_CORK."

int
test_case_1_7_4_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_4_conn test_case_1_7_4_4
#define test_case_1_7_4_4_resp test_case_1_7_4_4
#define test_case_1_7_4_4_list test_case_1_7_4_4

struct test_stream test_1_7_4_4_conn = { &preamble_1_7_conn, &test_case_1_7_4_4_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_4_resp = { &preamble_1_7_resp, &test_case_1_7_4_4_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_4_list = { &preamble_1_7_list, &test_case_1_7_4_4_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_5 test_group_1_7_4
#define numb_case_1_7_4_5 "1.7.4.5"
#define name_case_1_7_4_5 "Perform options management -- T_TCP_KEEPIDLE"
#define sref_case_1_7_4_5 sref_case_1_7
#define desc_case_1_7_4_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPIDLE."

int
test_case_1_7_4_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_PARTSUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_5_conn test_case_1_7_4_5
#define test_case_1_7_4_5_resp test_case_1_7_4_5
#define test_case_1_7_4_5_list test_case_1_7_4_5

struct test_stream test_1_7_4_5_conn = { &preamble_1_7_conn, &test_case_1_7_4_5_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_5_resp = { &preamble_1_7_resp, &test_case_1_7_4_5_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_5_list = { &preamble_1_7_list, &test_case_1_7_4_5_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_6 test_group_1_7_4
#define numb_case_1_7_4_6 "1.7.4.6"
#define name_case_1_7_4_6 "Perform options management -- T_TCP_KEEPINTVL"
#define sref_case_1_7_4_6 sref_case_1_7
#define desc_case_1_7_4_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPINTVL."

int
test_case_1_7_4_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_PARTSUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_6_conn test_case_1_7_4_6
#define test_case_1_7_4_6_resp test_case_1_7_4_6
#define test_case_1_7_4_6_list test_case_1_7_4_6

struct test_stream test_1_7_4_6_conn = { &preamble_1_7_conn, &test_case_1_7_4_6_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_6_resp = { &preamble_1_7_resp, &test_case_1_7_4_6_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_6_list = { &preamble_1_7_list, &test_case_1_7_4_6_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_7 test_group_1_7_4
#define numb_case_1_7_4_7 "1.7.4.7"
#define name_case_1_7_4_7 "Perform options management -- T_TCP_KEEPCNT"
#define sref_case_1_7_4_7 sref_case_1_7
#define desc_case_1_7_4_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPCNT."

int
test_case_1_7_4_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_PARTSUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_7_conn test_case_1_7_4_7
#define test_case_1_7_4_7_resp test_case_1_7_4_7
#define test_case_1_7_4_7_list test_case_1_7_4_7

struct test_stream test_1_7_4_7_conn = { &preamble_1_7_conn, &test_case_1_7_4_7_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_7_resp = { &preamble_1_7_resp, &test_case_1_7_4_7_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_7_list = { &preamble_1_7_list, &test_case_1_7_4_7_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_8 test_group_1_7_4
#define numb_case_1_7_4_8 "1.7.4.8"
#define name_case_1_7_4_8 "Perform options management -- T_TCP_SYNCNT"
#define sref_case_1_7_4_8 sref_case_1_7
#define desc_case_1_7_4_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_SYNCNT."

int
test_case_1_7_4_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_PARTSUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_8_conn test_case_1_7_4_8
#define test_case_1_7_4_8_resp test_case_1_7_4_8
#define test_case_1_7_4_8_list test_case_1_7_4_8

struct test_stream test_1_7_4_8_conn = { &preamble_1_7_conn, &test_case_1_7_4_8_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_8_resp = { &preamble_1_7_resp, &test_case_1_7_4_8_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_8_list = { &preamble_1_7_list, &test_case_1_7_4_8_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_9 test_group_1_7_4
#define numb_case_1_7_4_9 "1.7.4.9"
#define name_case_1_7_4_9 "Perform options management -- T_TCP_LINGER2"
#define sref_case_1_7_4_9 sref_case_1_7
#define desc_case_1_7_4_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_LINGER2."

int
test_case_1_7_4_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_9_conn test_case_1_7_4_9
#define test_case_1_7_4_9_resp test_case_1_7_4_9
#define test_case_1_7_4_9_list test_case_1_7_4_9

struct test_stream test_1_7_4_9_conn = { &preamble_1_7_conn, &test_case_1_7_4_9_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_9_resp = { &preamble_1_7_resp, &test_case_1_7_4_9_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_9_list = { &preamble_1_7_list, &test_case_1_7_4_9_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_10 test_group_1_7_4
#define numb_case_1_7_4_10 "1.7.4.10"
#define name_case_1_7_4_10 "Perform options management -- T_TCP_DEFER_ACCEPT"
#define sref_case_1_7_4_10 sref_case_1_7
#define desc_case_1_7_4_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_DEFER_ACCEPT."

int
test_case_1_7_4_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_10_conn test_case_1_7_4_10
#define test_case_1_7_4_10_resp test_case_1_7_4_10
#define test_case_1_7_4_10_list test_case_1_7_4_10

struct test_stream test_1_7_4_10_conn = { &preamble_1_7_conn, &test_case_1_7_4_10_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_10_resp = { &preamble_1_7_resp, &test_case_1_7_4_10_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_10_list = { &preamble_1_7_list, &test_case_1_7_4_10_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_11 test_group_1_7_4
#define numb_case_1_7_4_11 "1.7.4.11"
#define name_case_1_7_4_11 "Perform options management -- T_TCP_WINDOW_CLAMP"
#define sref_case_1_7_4_11 sref_case_1_7
#define desc_case_1_7_4_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_WINDOW_CLAMP."

int
test_case_1_7_4_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_PARTSUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_11_conn test_case_1_7_4_11
#define test_case_1_7_4_11_resp test_case_1_7_4_11
#define test_case_1_7_4_11_list test_case_1_7_4_11

struct test_stream test_1_7_4_11_conn = { &preamble_1_7_conn, &test_case_1_7_4_11_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_11_resp = { &preamble_1_7_resp, &test_case_1_7_4_11_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_11_list = { &preamble_1_7_list, &test_case_1_7_4_11_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_12 test_group_1_7_4
#define numb_case_1_7_4_12 "1.7.4.12"
#define name_case_1_7_4_12 "Perform options management -- T_TCP_INFO"
#define sref_case_1_7_4_12 sref_case_1_7
#define desc_case_1_7_4_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_INFO."

int
test_case_1_7_4_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_7_4_12_conn test_case_1_7_4_12
#define test_case_1_7_4_12_resp test_case_1_7_4_12
#define test_case_1_7_4_12_list test_case_1_7_4_12

struct test_stream test_1_7_4_12_conn = { &preamble_1_7_conn, &test_case_1_7_4_12_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_12_resp = { &preamble_1_7_resp, &test_case_1_7_4_12_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_12_list = { &preamble_1_7_list, &test_case_1_7_4_12_list, &postamble_1_7_list };

#define tgrp_case_1_7_4_13 test_group_1_7_4
#define numb_case_1_7_4_13 "1.7.4.13"
#define name_case_1_7_4_13 "Perform options management -- T_TCP_QUICKACK"
#define sref_case_1_7_4_13 sref_case_1_7
#define desc_case_1_7_4_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_QUICKACK."

int
test_case_1_7_4_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_4_13_conn test_case_1_7_4_13
#define test_case_1_7_4_13_resp test_case_1_7_4_13
#define test_case_1_7_4_13_list test_case_1_7_4_13

struct test_stream test_1_7_4_13_conn = { &preamble_1_7_conn, &test_case_1_7_4_13_conn, &postamble_1_7_conn };
struct test_stream test_1_7_4_13_resp = { &preamble_1_7_resp, &test_case_1_7_4_13_resp, &postamble_1_7_resp };
struct test_stream test_1_7_4_13_list = { &preamble_1_7_list, &test_case_1_7_4_13_list, &postamble_1_7_list };

#define test_group_1_7_5 "Local management -- SCTP options management"
/*
 *  Perform options management -- T_SCTP_NODELAY
 */
#define tgrp_case_1_7_5_1 test_group_1_7_5
#define numb_case_1_7_5_1 "1.7.5.1"
#define name_case_1_7_5_1 "Perform options management -- T_SCTP_NODELAY"
#define sref_case_1_7_5_1 sref_case_1_7
#define desc_case_1_7_5_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_NODELAY."

int
test_case_1_7_5_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_1_conn test_case_1_7_5_1
#define test_case_1_7_5_1_resp test_case_1_7_5_1
#define test_case_1_7_5_1_list test_case_1_7_5_1

struct test_stream test_1_7_5_1_conn = { &preamble_1_7_conn, &test_case_1_7_5_1_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_1_resp = { &preamble_1_7_resp, &test_case_1_7_5_1_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_1_list = { &preamble_1_7_list, &test_case_1_7_5_1_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_CORK
 */
#define tgrp_case_1_7_5_2 test_group_1_7_5
#define numb_case_1_7_5_2 "1.7.5.2"
#define name_case_1_7_5_2 "Perform options management -- T_SCTP_CORK"
#define sref_case_1_7_5_2 sref_case_1_7
#define desc_case_1_7_5_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CORK."

int
test_case_1_7_5_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_2_conn test_case_1_7_5_2
#define test_case_1_7_5_2_resp test_case_1_7_5_2
#define test_case_1_7_5_2_list test_case_1_7_5_2

struct test_stream test_1_7_5_2_conn = { &preamble_1_7_conn, &test_case_1_7_5_2_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_2_resp = { &preamble_1_7_resp, &test_case_1_7_5_2_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_2_list = { &preamble_1_7_list, &test_case_1_7_5_2_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_PPI
 */
#define tgrp_case_1_7_5_3 test_group_1_7_5
#define numb_case_1_7_5_3 "1.7.5.3"
#define name_case_1_7_5_3 "Perform options management -- T_SCTP_PPI"
#define sref_case_1_7_5_3 sref_case_1_7
#define desc_case_1_7_5_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PPI."

int
test_case_1_7_5_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_3_conn test_case_1_7_5_3
#define test_case_1_7_5_3_resp test_case_1_7_5_3
#define test_case_1_7_5_3_list test_case_1_7_5_3

struct test_stream test_1_7_5_3_conn = { &preamble_1_7_conn, &test_case_1_7_5_3_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_3_resp = { &preamble_1_7_resp, &test_case_1_7_5_3_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_3_list = { &preamble_1_7_list, &test_case_1_7_5_3_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_SID
 */
#define tgrp_case_1_7_5_4 test_group_1_7_5
#define numb_case_1_7_5_4 "1.7.5.4"
#define name_case_1_7_5_4 "Perform options management -- T_SCTP_SID"
#define sref_case_1_7_5_4 sref_case_1_7
#define desc_case_1_7_5_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SID."

int
test_case_1_7_5_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_4_conn test_case_1_7_5_4
#define test_case_1_7_5_4_resp test_case_1_7_5_4
#define test_case_1_7_5_4_list test_case_1_7_5_4

struct test_stream test_1_7_5_4_conn = { &preamble_1_7_conn, &test_case_1_7_5_4_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_4_resp = { &preamble_1_7_resp, &test_case_1_7_5_4_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_4_list = { &preamble_1_7_list, &test_case_1_7_5_4_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_SSN
 */
#define tgrp_case_1_7_5_5 test_group_1_7_5
#define numb_case_1_7_5_5 "1.7.5.5"
#define name_case_1_7_5_5 "Perform options management -- T_SCTP_SSN"
#define sref_case_1_7_5_5 sref_case_1_7
#define desc_case_1_7_5_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SSN."

int
test_case_1_7_5_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_7_5_5_conn test_case_1_7_5_5
#define test_case_1_7_5_5_resp test_case_1_7_5_5
#define test_case_1_7_5_5_list test_case_1_7_5_5

struct test_stream test_1_7_5_5_conn = { &preamble_1_7_conn, &test_case_1_7_5_5_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_5_resp = { &preamble_1_7_resp, &test_case_1_7_5_5_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_5_list = { &preamble_1_7_list, &test_case_1_7_5_5_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_TSN
 */
#define tgrp_case_1_7_5_6 test_group_1_7_5
#define numb_case_1_7_5_6 "1.7.5.6"
#define name_case_1_7_5_6 "Perform options management -- T_SCTP_TSN"
#define sref_case_1_7_5_6 sref_case_1_7
#define desc_case_1_7_5_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_TSN."

int
test_case_1_7_5_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_7_5_6_conn test_case_1_7_5_6
#define test_case_1_7_5_6_resp test_case_1_7_5_6
#define test_case_1_7_5_6_list test_case_1_7_5_6

struct test_stream test_1_7_5_6_conn = { &preamble_1_7_conn, &test_case_1_7_5_6_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_6_resp = { &preamble_1_7_resp, &test_case_1_7_5_6_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_6_list = { &preamble_1_7_list, &test_case_1_7_5_6_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_RECVOPT
 */
#define tgrp_case_1_7_5_7 test_group_1_7_5
#define numb_case_1_7_5_7 "1.7.5.7"
#define name_case_1_7_5_7 "Perform options management -- T_SCTP_RECVOPT"
#define sref_case_1_7_5_7 sref_case_1_7
#define desc_case_1_7_5_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RECVOPT."

int
test_case_1_7_5_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_7_conn test_case_1_7_5_7
#define test_case_1_7_5_7_resp test_case_1_7_5_7
#define test_case_1_7_5_7_list test_case_1_7_5_7

struct test_stream test_1_7_5_7_conn = { &preamble_1_7_conn, &test_case_1_7_5_7_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_7_resp = { &preamble_1_7_resp, &test_case_1_7_5_7_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_7_list = { &preamble_1_7_list, &test_case_1_7_5_7_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_LIFE
 */
#define tgrp_case_1_7_5_8 test_group_1_7_5
#define numb_case_1_7_5_8 "1.7.5.8"
#define name_case_1_7_5_8 "Perform options management -- T_SCTP_COOKIE_LIFE"
#define sref_case_1_7_5_8 sref_case_1_7
#define desc_case_1_7_5_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_LIFE."

int
test_case_1_7_5_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_8_conn test_case_1_7_5_8
#define test_case_1_7_5_8_resp test_case_1_7_5_8
#define test_case_1_7_5_8_list test_case_1_7_5_8

struct test_stream test_1_7_5_8_conn = { &preamble_1_7_conn, &test_case_1_7_5_8_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_8_resp = { &preamble_1_7_resp, &test_case_1_7_5_8_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_8_list = { &preamble_1_7_list, &test_case_1_7_5_8_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_SACK_DELAY
 */
#define tgrp_case_1_7_5_9 test_group_1_7_5
#define numb_case_1_7_5_9 "1.7.5.9"
#define name_case_1_7_5_9 "Perform options management -- T_SCTP_SACK_DELAY"
#define sref_case_1_7_5_9 sref_case_1_7
#define desc_case_1_7_5_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SACK_DELAY."

int
test_case_1_7_5_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_9_conn test_case_1_7_5_9
#define test_case_1_7_5_9_resp test_case_1_7_5_9
#define test_case_1_7_5_9_list test_case_1_7_5_9

struct test_stream test_1_7_5_9_conn = { &preamble_1_7_conn, &test_case_1_7_5_9_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_9_resp = { &preamble_1_7_resp, &test_case_1_7_5_9_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_9_list = { &preamble_1_7_list, &test_case_1_7_5_9_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_PATH_MAX_RETRANS
 */
#define tgrp_case_1_7_5_10 test_group_1_7_5
#define numb_case_1_7_5_10 "1.7.5.10"
#define name_case_1_7_5_10 "Perform options management -- T_SCTP_PATH_MAX_RETRANS"
#define sref_case_1_7_5_10 sref_case_1_7
#define desc_case_1_7_5_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PATH_MAX_RETRANS."

int
test_case_1_7_5_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_10_conn test_case_1_7_5_10
#define test_case_1_7_5_10_resp test_case_1_7_5_10
#define test_case_1_7_5_10_list test_case_1_7_5_10

struct test_stream test_1_7_5_10_conn = { &preamble_1_7_conn, &test_case_1_7_5_10_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_10_resp = { &preamble_1_7_resp, &test_case_1_7_5_10_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_10_list = { &preamble_1_7_list, &test_case_1_7_5_10_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_ASSOC_MAX_RETRANS
 */
#define tgrp_case_1_7_5_11 test_group_1_7_5
#define numb_case_1_7_5_11 "1.7.5.11"
#define name_case_1_7_5_11 "Perform options management -- T_SCTP_ASSOC_MAX_RETRANS"
#define sref_case_1_7_5_11 sref_case_1_7
#define desc_case_1_7_5_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ASSOC_MAX_RETRANS."

int
test_case_1_7_5_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_11_conn test_case_1_7_5_11
#define test_case_1_7_5_11_resp test_case_1_7_5_11
#define test_case_1_7_5_11_list test_case_1_7_5_11

struct test_stream test_1_7_5_11_conn = { &preamble_1_7_conn, &test_case_1_7_5_11_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_11_resp = { &preamble_1_7_resp, &test_case_1_7_5_11_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_11_list = { &preamble_1_7_list, &test_case_1_7_5_11_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_MAX_INIT_RETRIES
 */
#define tgrp_case_1_7_5_12 test_group_1_7_5
#define numb_case_1_7_5_12 "1.7.5.12"
#define name_case_1_7_5_12 "Perform options management -- T_SCTP_MAX_INIT_RETRIES"
#define sref_case_1_7_5_12 sref_case_1_7
#define desc_case_1_7_5_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_INIT_RETRIES."

int
test_case_1_7_5_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_12_conn test_case_1_7_5_12
#define test_case_1_7_5_12_resp test_case_1_7_5_12
#define test_case_1_7_5_12_list test_case_1_7_5_12

struct test_stream test_1_7_5_12_conn = { &preamble_1_7_conn, &test_case_1_7_5_12_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_12_resp = { &preamble_1_7_resp, &test_case_1_7_5_12_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_12_list = { &preamble_1_7_list, &test_case_1_7_5_12_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_HEARTBEAT_ITVL
 */
#define tgrp_case_1_7_5_13 test_group_1_7_5
#define numb_case_1_7_5_13 "1.7.5.13"
#define name_case_1_7_5_13 "Perform options management -- T_SCTP_HEARTBEAT_ITVL"
#define sref_case_1_7_5_13 sref_case_1_7
#define desc_case_1_7_5_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HEARTBEAT_ITVL."

int
test_case_1_7_5_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_13_conn test_case_1_7_5_13
#define test_case_1_7_5_13_resp test_case_1_7_5_13
#define test_case_1_7_5_13_list test_case_1_7_5_13

struct test_stream test_1_7_5_13_conn = { &preamble_1_7_conn, &test_case_1_7_5_13_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_13_resp = { &preamble_1_7_resp, &test_case_1_7_5_13_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_13_list = { &preamble_1_7_list, &test_case_1_7_5_13_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_RTO_INITIAL
 */
#define tgrp_case_1_7_5_14 test_group_1_7_5
#define numb_case_1_7_5_14 "1.7.5.14"
#define name_case_1_7_5_14 "Perform options management -- T_SCTP_RTO_INITIAL"
#define sref_case_1_7_5_14 sref_case_1_7
#define desc_case_1_7_5_14 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_INITIAL."

int
test_case_1_7_5_14(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_14_conn test_case_1_7_5_14
#define test_case_1_7_5_14_resp test_case_1_7_5_14
#define test_case_1_7_5_14_list test_case_1_7_5_14

struct test_stream test_1_7_5_14_conn = { &preamble_1_7_conn, &test_case_1_7_5_14_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_14_resp = { &preamble_1_7_resp, &test_case_1_7_5_14_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_14_list = { &preamble_1_7_list, &test_case_1_7_5_14_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_RTO_MIN
 */
#define tgrp_case_1_7_5_15 test_group_1_7_5
#define numb_case_1_7_5_15 "1.7.5.15"
#define name_case_1_7_5_15 "Perform options management -- T_SCTP_RTO_MIN"
#define sref_case_1_7_5_15 sref_case_1_7
#define desc_case_1_7_5_15 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MIN."

int
test_case_1_7_5_15(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_15_conn test_case_1_7_5_15
#define test_case_1_7_5_15_resp test_case_1_7_5_15
#define test_case_1_7_5_15_list test_case_1_7_5_15

struct test_stream test_1_7_5_15_conn = { &preamble_1_7_conn, &test_case_1_7_5_15_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_15_resp = { &preamble_1_7_resp, &test_case_1_7_5_15_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_15_list = { &preamble_1_7_list, &test_case_1_7_5_15_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_RTO_MAX
 */
#define tgrp_case_1_7_5_16 test_group_1_7_5
#define numb_case_1_7_5_16 "1.7.5.16"
#define name_case_1_7_5_16 "Perform options management -- T_SCTP_RTO_MAX"
#define sref_case_1_7_5_16 sref_case_1_7
#define desc_case_1_7_5_16 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MAX."

int
test_case_1_7_5_16(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_16_conn test_case_1_7_5_16
#define test_case_1_7_5_16_resp test_case_1_7_5_16
#define test_case_1_7_5_16_list test_case_1_7_5_16

struct test_stream test_1_7_5_16_conn = { &preamble_1_7_conn, &test_case_1_7_5_16_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_16_resp = { &preamble_1_7_resp, &test_case_1_7_5_16_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_16_list = { &preamble_1_7_list, &test_case_1_7_5_16_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_OSTREAMS
 */
#define tgrp_case_1_7_5_17 test_group_1_7_5
#define numb_case_1_7_5_17 "1.7.5.17"
#define name_case_1_7_5_17 "Perform options management -- T_SCTP_OSTREAMS"
#define sref_case_1_7_5_17 sref_case_1_7
#define desc_case_1_7_5_17 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_OSTREAMS."

int
test_case_1_7_5_17(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_17_conn test_case_1_7_5_17
#define test_case_1_7_5_17_resp test_case_1_7_5_17
#define test_case_1_7_5_17_list test_case_1_7_5_17

struct test_stream test_1_7_5_17_conn = { &preamble_1_7_conn, &test_case_1_7_5_17_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_17_resp = { &preamble_1_7_resp, &test_case_1_7_5_17_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_17_list = { &preamble_1_7_list, &test_case_1_7_5_17_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_ISTREAMS
 */
#define tgrp_case_1_7_5_18 test_group_1_7_5
#define numb_case_1_7_5_18 "1.7.5.18"
#define name_case_1_7_5_18 "Perform options management -- T_SCTP_ISTREAMS"
#define sref_case_1_7_5_18 sref_case_1_7
#define desc_case_1_7_5_18 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ISTREAMS."

int
test_case_1_7_5_18(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_18_conn test_case_1_7_5_18
#define test_case_1_7_5_18_resp test_case_1_7_5_18
#define test_case_1_7_5_18_list test_case_1_7_5_18

struct test_stream test_1_7_5_18_conn = { &preamble_1_7_conn, &test_case_1_7_5_18_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_18_resp = { &preamble_1_7_resp, &test_case_1_7_5_18_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_18_list = { &preamble_1_7_list, &test_case_1_7_5_18_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_INC
 */
#define tgrp_case_1_7_5_19 test_group_1_7_5
#define numb_case_1_7_5_19 "1.7.5.19"
#define name_case_1_7_5_19 "Perform options management -- T_SCTP_COOKIE_INC"
#define sref_case_1_7_5_19 sref_case_1_7
#define desc_case_1_7_5_19 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_INC."

int
test_case_1_7_5_19(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_19_conn test_case_1_7_5_19
#define test_case_1_7_5_19_resp test_case_1_7_5_19
#define test_case_1_7_5_19_list test_case_1_7_5_19

struct test_stream test_1_7_5_19_conn = { &preamble_1_7_conn, &test_case_1_7_5_19_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_19_resp = { &preamble_1_7_resp, &test_case_1_7_5_19_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_19_list = { &preamble_1_7_list, &test_case_1_7_5_19_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_THROTTLE_ITVL
 */
#define tgrp_case_1_7_5_20 test_group_1_7_5
#define numb_case_1_7_5_20 "1.7.5.20"
#define name_case_1_7_5_20 "Perform options management -- T_SCTP_THROTTLE_ITVL"
#define sref_case_1_7_5_20 sref_case_1_7
#define desc_case_1_7_5_20 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_THROTTLE_ITVL."

int
test_case_1_7_5_20(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_20_conn test_case_1_7_5_20
#define test_case_1_7_5_20_resp test_case_1_7_5_20
#define test_case_1_7_5_20_list test_case_1_7_5_20

struct test_stream test_1_7_5_20_conn = { &preamble_1_7_conn, &test_case_1_7_5_20_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_20_resp = { &preamble_1_7_resp, &test_case_1_7_5_20_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_20_list = { &preamble_1_7_list, &test_case_1_7_5_20_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_MAC_TYPE
 */
#define tgrp_case_1_7_5_21 test_group_1_7_5
#define numb_case_1_7_5_21 "1.7.5.21"
#define name_case_1_7_5_21 "Perform options management -- T_SCTP_MAC_TYPE"
#define sref_case_1_7_5_21 sref_case_1_7
#define desc_case_1_7_5_21 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAC_TYPE."

int
test_case_1_7_5_21(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_21_conn test_case_1_7_5_21
#define test_case_1_7_5_21_resp test_case_1_7_5_21
#define test_case_1_7_5_21_list test_case_1_7_5_21

struct test_stream test_1_7_5_21_conn = { &preamble_1_7_conn, &test_case_1_7_5_21_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_21_resp = { &preamble_1_7_resp, &test_case_1_7_5_21_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_21_list = { &preamble_1_7_list, &test_case_1_7_5_21_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_CKSUM_TYPE
 */
#define tgrp_case_1_7_5_22 test_group_1_7_5
#define numb_case_1_7_5_22 "1.7.5.22"
#define name_case_1_7_5_22 "Perform options management -- T_SCTP_CKSUM_TYPE"
#define sref_case_1_7_5_22 sref_case_1_7
#define desc_case_1_7_5_22 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CKSUM_TYPE."

int
test_case_1_7_5_22(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_22_conn test_case_1_7_5_22
#define test_case_1_7_5_22_resp test_case_1_7_5_22
#define test_case_1_7_5_22_list test_case_1_7_5_22

struct test_stream test_1_7_5_22_conn = { &preamble_1_7_conn, &test_case_1_7_5_22_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_22_resp = { &preamble_1_7_resp, &test_case_1_7_5_22_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_22_list = { &preamble_1_7_list, &test_case_1_7_5_22_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_ECN
 */
#define tgrp_case_1_7_5_23 test_group_1_7_5
#define numb_case_1_7_5_23 "1.7.5.23"
#define name_case_1_7_5_23 "Perform options management -- T_SCTP_ECN"
#define sref_case_1_7_5_23 sref_case_1_7
#define desc_case_1_7_5_23 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ECN."

int
test_case_1_7_5_23(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_23_conn test_case_1_7_5_23
#define test_case_1_7_5_23_resp test_case_1_7_5_23
#define test_case_1_7_5_23_list test_case_1_7_5_23

struct test_stream test_1_7_5_23_conn = { &preamble_1_7_conn, &test_case_1_7_5_23_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_23_resp = { &preamble_1_7_resp, &test_case_1_7_5_23_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_23_list = { &preamble_1_7_list, &test_case_1_7_5_23_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_ALI
 */
#define tgrp_case_1_7_5_24 test_group_1_7_5
#define numb_case_1_7_5_24 "1.7.5.24"
#define name_case_1_7_5_24 "Perform options management -- T_SCTP_ALI"
#define sref_case_1_7_5_24 sref_case_1_7
#define desc_case_1_7_5_24 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ALI."

int
test_case_1_7_5_24(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_24_conn test_case_1_7_5_24
#define test_case_1_7_5_24_resp test_case_1_7_5_24
#define test_case_1_7_5_24_list test_case_1_7_5_24

struct test_stream test_1_7_5_24_conn = { &preamble_1_7_conn, &test_case_1_7_5_24_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_24_resp = { &preamble_1_7_resp, &test_case_1_7_5_24_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_24_list = { &preamble_1_7_list, &test_case_1_7_5_24_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_ADD
 */
#define tgrp_case_1_7_5_25 test_group_1_7_5
#define numb_case_1_7_5_25 "1.7.5.25"
#define name_case_1_7_5_25 "Perform options management -- T_SCTP_ADD"
#define sref_case_1_7_5_25 sref_case_1_7
#define desc_case_1_7_5_25 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD."

int
test_case_1_7_5_25(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_25_conn test_case_1_7_5_25
#define test_case_1_7_5_25_resp test_case_1_7_5_25
#define test_case_1_7_5_25_list test_case_1_7_5_25

struct test_stream test_1_7_5_25_conn = { &preamble_1_7_conn, &test_case_1_7_5_25_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_25_resp = { &preamble_1_7_resp, &test_case_1_7_5_25_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_25_list = { &preamble_1_7_list, &test_case_1_7_5_25_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_SET
 */
#define tgrp_case_1_7_5_26 test_group_1_7_5
#define numb_case_1_7_5_26 "1.7.5.26"
#define name_case_1_7_5_26 "Perform options management -- T_SCTP_SET"
#define sref_case_1_7_5_26 sref_case_1_7
#define desc_case_1_7_5_26 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET."

int
test_case_1_7_5_26(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_26_conn test_case_1_7_5_26
#define test_case_1_7_5_26_resp test_case_1_7_5_26
#define test_case_1_7_5_26_list test_case_1_7_5_26

struct test_stream test_1_7_5_26_conn = { &preamble_1_7_conn, &test_case_1_7_5_26_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_26_resp = { &preamble_1_7_resp, &test_case_1_7_5_26_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_26_list = { &preamble_1_7_list, &test_case_1_7_5_26_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_ADD_IP
 */
#define tgrp_case_1_7_5_27 test_group_1_7_5
#define numb_case_1_7_5_27 "1.7.5.27"
#define name_case_1_7_5_27 "Perform options management -- T_SCTP_ADD_IP"
#define sref_case_1_7_5_27 sref_case_1_7
#define desc_case_1_7_5_27 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD_IP."

int
test_case_1_7_5_27(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_27_conn test_case_1_7_5_27
#define test_case_1_7_5_27_resp test_case_1_7_5_27
#define test_case_1_7_5_27_list test_case_1_7_5_27

struct test_stream test_1_7_5_27_conn = { &preamble_1_7_conn, &test_case_1_7_5_27_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_27_resp = { &preamble_1_7_resp, &test_case_1_7_5_27_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_27_list = { &preamble_1_7_list, &test_case_1_7_5_27_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_DEL_IP
 */
#define tgrp_case_1_7_5_28 test_group_1_7_5
#define numb_case_1_7_5_28 "1.7.5.28"
#define name_case_1_7_5_28 "Perform options management -- T_SCTP_DEL_IP"
#define sref_case_1_7_5_28 sref_case_1_7
#define desc_case_1_7_5_28 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DEL_IP."

int
test_case_1_7_5_28(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_28_conn test_case_1_7_5_28
#define test_case_1_7_5_28_resp test_case_1_7_5_28
#define test_case_1_7_5_28_list test_case_1_7_5_28

struct test_stream test_1_7_5_28_conn = { &preamble_1_7_conn, &test_case_1_7_5_28_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_28_resp = { &preamble_1_7_resp, &test_case_1_7_5_28_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_28_list = { &preamble_1_7_list, &test_case_1_7_5_28_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_SET_IP
 */
#define tgrp_case_1_7_5_29 test_group_1_7_5
#define numb_case_1_7_5_29 "1.7.5.29"
#define name_case_1_7_5_29 "Perform options management -- T_SCTP_SET_IP"
#define sref_case_1_7_5_29 sref_case_1_7
#define desc_case_1_7_5_29 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET_IP."

int
test_case_1_7_5_29(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_29_conn test_case_1_7_5_29
#define test_case_1_7_5_29_resp test_case_1_7_5_29
#define test_case_1_7_5_29_list test_case_1_7_5_29

struct test_stream test_1_7_5_29_conn = { &preamble_1_7_conn, &test_case_1_7_5_29_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_29_resp = { &preamble_1_7_resp, &test_case_1_7_5_29_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_29_list = { &preamble_1_7_list, &test_case_1_7_5_29_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_PR
 */
#define tgrp_case_1_7_5_30 test_group_1_7_5
#define numb_case_1_7_5_30 "1.7.5.30"
#define name_case_1_7_5_30 "Perform options management -- T_SCTP_PR"
#define sref_case_1_7_5_30 sref_case_1_7
#define desc_case_1_7_5_30 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PR."

int
test_case_1_7_5_30(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_30_conn test_case_1_7_5_30
#define test_case_1_7_5_30_resp test_case_1_7_5_30
#define test_case_1_7_5_30_list test_case_1_7_5_30

struct test_stream test_1_7_5_30_conn = { &preamble_1_7_conn, &test_case_1_7_5_30_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_30_resp = { &preamble_1_7_resp, &test_case_1_7_5_30_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_30_list = { &preamble_1_7_list, &test_case_1_7_5_30_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_LIFETIME
 */
#define tgrp_case_1_7_5_31 test_group_1_7_5
#define numb_case_1_7_5_31 "1.7.5.31"
#define name_case_1_7_5_31 "Perform options management -- T_SCTP_LIFETIME"
#define sref_case_1_7_5_31 sref_case_1_7
#define desc_case_1_7_5_31 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_LIFETIME."

int
test_case_1_7_5_31(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_INFINITE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_31_conn test_case_1_7_5_31
#define test_case_1_7_5_31_resp test_case_1_7_5_31
#define test_case_1_7_5_31_list test_case_1_7_5_31

struct test_stream test_1_7_5_31_conn = { &preamble_1_7_conn, &test_case_1_7_5_31_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_31_resp = { &preamble_1_7_resp, &test_case_1_7_5_31_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_31_list = { &preamble_1_7_list, &test_case_1_7_5_31_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_DISPOSITION
 */
#define tgrp_case_1_7_5_32 test_group_1_7_5
#define numb_case_1_7_5_32 "1.7.5.32"
#define name_case_1_7_5_32 "Perform options management -- T_SCTP_DISPOSITION"
#define sref_case_1_7_5_32 sref_case_1_7
#define desc_case_1_7_5_32 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DISPOSITION."

int
test_case_1_7_5_32(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_32_conn test_case_1_7_5_32
#define test_case_1_7_5_32_resp test_case_1_7_5_32
#define test_case_1_7_5_32_list test_case_1_7_5_32

struct test_stream test_1_7_5_32_conn = { &preamble_1_7_conn, &test_case_1_7_5_32_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_32_resp = { &preamble_1_7_resp, &test_case_1_7_5_32_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_32_list = { &preamble_1_7_list, &test_case_1_7_5_32_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_MAX_BURST
 */
#define tgrp_case_1_7_5_33 test_group_1_7_5
#define numb_case_1_7_5_33 "1.7.5.33"
#define name_case_1_7_5_33 "Perform options management -- T_SCTP_MAX_BURST"
#define sref_case_1_7_5_33 sref_case_1_7
#define desc_case_1_7_5_33 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_BURST."

int
test_case_1_7_5_33(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_33_conn test_case_1_7_5_33
#define test_case_1_7_5_33_resp test_case_1_7_5_33
#define test_case_1_7_5_33_list test_case_1_7_5_33

struct test_stream test_1_7_5_33_conn = { &preamble_1_7_conn, &test_case_1_7_5_33_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_33_resp = { &preamble_1_7_resp, &test_case_1_7_5_33_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_33_list = { &preamble_1_7_list, &test_case_1_7_5_33_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_HB
 */
#define tgrp_case_1_7_5_34 test_group_1_7_5
#define numb_case_1_7_5_34 "1.7.5.34"
#define name_case_1_7_5_34 "Perform options management -- T_SCTP_HB"
#define sref_case_1_7_5_34 sref_case_1_7
#define desc_case_1_7_5_34 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HB."

int
test_case_1_7_5_34(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_34_conn test_case_1_7_5_34
#define test_case_1_7_5_34_resp test_case_1_7_5_34
#define test_case_1_7_5_34_list test_case_1_7_5_34

struct test_stream test_1_7_5_34_conn = { &preamble_1_7_conn, &test_case_1_7_5_34_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_34_resp = { &preamble_1_7_resp, &test_case_1_7_5_34_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_34_list = { &preamble_1_7_list, &test_case_1_7_5_34_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_RTO
 */
#define tgrp_case_1_7_5_35 test_group_1_7_5
#define numb_case_1_7_5_35 "1.7.5.35"
#define name_case_1_7_5_35 "Perform options management -- T_SCTP_RTO"
#define sref_case_1_7_5_35 sref_case_1_7
#define desc_case_1_7_5_35 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO."

int
test_case_1_7_5_35(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_35_conn test_case_1_7_5_35
#define test_case_1_7_5_35_resp test_case_1_7_5_35
#define test_case_1_7_5_35_list test_case_1_7_5_35

struct test_stream test_1_7_5_35_conn = { &preamble_1_7_conn, &test_case_1_7_5_35_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_35_resp = { &preamble_1_7_resp, &test_case_1_7_5_35_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_35_list = { &preamble_1_7_list, &test_case_1_7_5_35_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_MAXSEG
 */
#define tgrp_case_1_7_5_36 test_group_1_7_5
#define numb_case_1_7_5_36 "1.7.5.36"
#define name_case_1_7_5_36 "Perform options management -- T_SCTP_MAXSEG"
#define sref_case_1_7_5_36 sref_case_1_7
#define desc_case_1_7_5_36 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAXSEG."

int
test_case_1_7_5_36(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_36_conn test_case_1_7_5_36
#define test_case_1_7_5_36_resp test_case_1_7_5_36
#define test_case_1_7_5_36_list test_case_1_7_5_36

struct test_stream test_1_7_5_36_conn = { &preamble_1_7_conn, &test_case_1_7_5_36_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_36_resp = { &preamble_1_7_resp, &test_case_1_7_5_36_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_36_list = { &preamble_1_7_list, &test_case_1_7_5_36_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_STATUS
 */
#define tgrp_case_1_7_5_37 test_group_1_7_5
#define numb_case_1_7_5_37 "1.7.5.37"
#define name_case_1_7_5_37 "Perform options management -- T_SCTP_STATUS"
#define sref_case_1_7_5_37 sref_case_1_7
#define desc_case_1_7_5_37 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_SCTP_STATUS."

int
test_case_1_7_5_37(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_7_5_37_conn test_case_1_7_5_37
#define test_case_1_7_5_37_resp test_case_1_7_5_37
#define test_case_1_7_5_37_list test_case_1_7_5_37

struct test_stream test_1_7_5_37_conn = { &preamble_1_7_conn, &test_case_1_7_5_37_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_37_resp = { &preamble_1_7_resp, &test_case_1_7_5_37_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_37_list = { &preamble_1_7_list, &test_case_1_7_5_37_list, &postamble_1_7_list };

/*
 *  Perform options management -- T_SCTP_DEBUG
 */
#define tgrp_case_1_7_5_38 test_group_1_7_5
#define numb_case_1_7_5_38 "1.7.5.38"
#define name_case_1_7_5_38 "Perform options management -- T_SCTP_DEBUG"
#define sref_case_1_7_5_38 sref_case_1_7
#define desc_case_1_7_5_38 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_SCTP_DEBUG."

int
test_case_1_7_5_38(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_CHECK;
	return test_case_1_7_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_7_5_38_conn test_case_1_7_5_38
#define test_case_1_7_5_38_resp test_case_1_7_5_38
#define test_case_1_7_5_38_list test_case_1_7_5_38

struct test_stream test_1_7_5_38_conn = { &preamble_1_7_conn, &test_case_1_7_5_38_conn, &postamble_1_7_conn };
struct test_stream test_1_7_5_38_resp = { &preamble_1_7_resp, &test_case_1_7_5_38_resp, &postamble_1_7_resp };
struct test_stream test_1_7_5_38_list = { &preamble_1_7_list, &test_case_1_7_5_38_list, &postamble_1_7_list };

/*
 *  Do options management.
 */
#define test_group_1_8 "Options management - T_NEGOTIATE"
#define tgrp_case_1_8 test_group_1_8
#define numb_case_1_8 "1.8"
#define name_case_1_8 "Perform options management."
#define sref_case_1_8 "TPI Rev 1.5 Sections 2.1.1.4, 2.1.2.3"
#define desc_case_1_8 "\
Checks that options management can be performed on several streams."

int
test_case_1_8(int child, ulong result)
{
	union T_primitives *p = (typeof(p)) cbuf;

	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags != result)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_8_xfail(int child, int terror, int error)
{
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != terror || (last_t_errno == TSYSERR && last_errno != error))
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_8_xti(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_8(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_8_ip(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_8(child, result);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_8_udp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_UDP:
		return test_case_1_8(child, result);
	case T_INET_IP:
	case T_INET_TCP:
	case T_INET_SCTP:
		return test_case_1_8_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_8_tcp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_TCP:
		return test_case_1_8(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_SCTP:
		return test_case_1_8_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

int
test_case_1_8_sctp(int child, ulong result, int terror, int error)
{
	switch (test_level) {
	case T_INET_SCTP:
		return test_case_1_8(child, result);
	case T_INET_IP:
	case T_INET_UDP:
	case T_INET_TCP:
		return test_case_1_8_xfail(child, terror, error);
	}
	return (__RESULT_FAILURE);
}

#define test_case_1_8_conn	test_case_1_8
#define test_case_1_8_resp	test_case_1_8
#define test_case_1_8_list	test_case_1_8

#define preamble_1_8_conn	preamble_1
#define preamble_1_8_resp	preamble_1
#define preamble_1_8_list	preamble_1

#define postamble_1_8_conn	postamble_1
#define postamble_1_8_resp	postamble_1
#define postamble_1_8_list	postamble_1

//struct test_stream test_1_8_conn = { &preamble_1_8_conn, &test_case_1_8_conn, &postamble_1_8_conn };
//struct test_stream test_1_8_resp = { &preamble_1_8_resp, &test_case_1_8_resp, &postamble_1_8_resp };
//struct test_stream test_1_8_list = { &preamble_1_8_list, &test_case_1_8_list, &postamble_1_8_list };

#define test_group_1_8_1 "Local management -- XTI options management"
#define tgrp_case_1_8_1_1 test_group_1_8_1
#define numb_case_1_8_1_1 "1.8.1.1"
#define name_case_1_8_1_1 "Perform options management -- all options"
#define sref_case_1_8_1_1 sref_case_1_8
#define desc_case_1_8_1_1 "\
Checks that options management can be performed on several streams\n\
for all options."

int
test_case_1_8_1_1(int child)
{
	test_opts = &opt_optm;
	test_olen = sizeof(opt_optm);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_1_conn test_case_1_8_1_1
#define test_case_1_8_1_1_resp test_case_1_8_1_1
#define test_case_1_8_1_1_list test_case_1_8_1_1

struct test_stream test_1_8_1_1_conn = { &preamble_1_8_conn, &test_case_1_8_1_1_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_1_resp = { &preamble_1_8_resp, &test_case_1_8_1_1_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_1_list = { &preamble_1_8_list, &test_case_1_8_1_1_list, &postamble_1_8_list };

#define tgrp_case_1_8_1_2 test_group_1_8_1
#define numb_case_1_8_1_2 "1.8.1.2"
#define name_case_1_8_1_2 "Perform options management -- XTI_DEBUG"
#define sref_case_1_8_1_2 sref_case_1_8
#define desc_case_1_8_1_2 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_DEBUG."

int
test_case_1_8_1_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_2_conn test_case_1_8_1_2
#define test_case_1_8_1_2_resp test_case_1_8_1_2
#define test_case_1_8_1_2_list test_case_1_8_1_2

struct test_stream test_1_8_1_2_conn = { &preamble_1_8_conn, &test_case_1_8_1_2_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_2_resp = { &preamble_1_8_resp, &test_case_1_8_1_2_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_2_list = { &preamble_1_8_list, &test_case_1_8_1_2_list, &postamble_1_8_list };

#define tgrp_case_1_8_1_3 test_group_1_8_1
#define numb_case_1_8_1_3 "1.8.1.3"
#define name_case_1_8_1_3 "Perform options management -- XTI_LINGER"
#define sref_case_1_8_1_3 sref_case_1_8
#define desc_case_1_8_1_3 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_LINGER."

int
test_case_1_8_1_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_3_conn test_case_1_8_1_3
#define test_case_1_8_1_3_resp test_case_1_8_1_3
#define test_case_1_8_1_3_list test_case_1_8_1_3

struct test_stream test_1_8_1_3_conn = { &preamble_1_8_conn, &test_case_1_8_1_3_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_3_resp = { &preamble_1_8_resp, &test_case_1_8_1_3_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_3_list = { &preamble_1_8_list, &test_case_1_8_1_3_list, &postamble_1_8_list };

#define tgrp_case_1_8_1_4 test_group_1_8_1
#define numb_case_1_8_1_4 "1.8.1.4"
#define name_case_1_8_1_4 "Perform options management -- XTI_RCVBUF"
#define sref_case_1_8_1_4 sref_case_1_8
#define desc_case_1_8_1_4 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVBUF."

int
test_case_1_8_1_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_4_conn test_case_1_8_1_4
#define test_case_1_8_1_4_resp test_case_1_8_1_4
#define test_case_1_8_1_4_list test_case_1_8_1_4

struct test_stream test_1_8_1_4_conn = { &preamble_1_8_conn, &test_case_1_8_1_4_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_4_resp = { &preamble_1_8_resp, &test_case_1_8_1_4_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_4_list = { &preamble_1_8_list, &test_case_1_8_1_4_list, &postamble_1_8_list };

#define tgrp_case_1_8_1_5 test_group_1_8_1
#define numb_case_1_8_1_5 "1.8.1.5"
#define name_case_1_8_1_5 "Perform options management -- XTI_RCVLOWAT"
#define sref_case_1_8_1_5 sref_case_1_8
#define desc_case_1_8_1_5 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_RCVLOWAT."

int
test_case_1_8_1_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_5_conn test_case_1_8_1_5
#define test_case_1_8_1_5_resp test_case_1_8_1_5
#define test_case_1_8_1_5_list test_case_1_8_1_5

struct test_stream test_1_8_1_5_conn = { &preamble_1_8_conn, &test_case_1_8_1_5_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_5_resp = { &preamble_1_8_resp, &test_case_1_8_1_5_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_5_list = { &preamble_1_8_list, &test_case_1_8_1_5_list, &postamble_1_8_list };

#define tgrp_case_1_8_1_6 test_group_1_8_1
#define numb_case_1_8_1_6 "1.8.1.6"
#define name_case_1_8_1_6 "Perform options management -- XTI_SNDBUF"
#define sref_case_1_8_1_6 sref_case_1_8
#define desc_case_1_8_1_6 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDBUF."

int
test_case_1_8_1_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_6_conn test_case_1_8_1_6
#define test_case_1_8_1_6_resp test_case_1_8_1_6
#define test_case_1_8_1_6_list test_case_1_8_1_6

struct test_stream test_1_8_1_6_conn = { &preamble_1_8_conn, &test_case_1_8_1_6_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_6_resp = { &preamble_1_8_resp, &test_case_1_8_1_6_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_6_list = { &preamble_1_8_list, &test_case_1_8_1_6_list, &postamble_1_8_list };

#define tgrp_case_1_8_1_7 test_group_1_8_1
#define numb_case_1_8_1_7 "1.8.1.7"
#define name_case_1_8_1_7 "Perform options management -- XTI_SNDLOWAT"
#define sref_case_1_8_1_7 sref_case_1_8
#define desc_case_1_8_1_7 "\
Checks that options management can be performed on several streams\n\
for XTI_GENERIC option XTI_SNDLOWAT."

int
test_case_1_8_1_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_xti(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_1_7_conn test_case_1_8_1_7
#define test_case_1_8_1_7_resp test_case_1_8_1_7
#define test_case_1_8_1_7_list test_case_1_8_1_7

struct test_stream test_1_8_1_7_conn = { &preamble_1_8_conn, &test_case_1_8_1_7_conn, &postamble_1_8_conn };
struct test_stream test_1_8_1_7_resp = { &preamble_1_8_resp, &test_case_1_8_1_7_resp, &postamble_1_8_resp };
struct test_stream test_1_8_1_7_list = { &preamble_1_8_list, &test_case_1_8_1_7_list, &postamble_1_8_list };

#define test_group_1_8_2 "Local management -- IP options management"
#define tgrp_case_1_8_2_1 test_group_1_8_2
#define numb_case_1_8_2_1 "1.8.2.1"
#define name_case_1_8_2_1 "Perform options management -- T_IP_TOS"
#define sref_case_1_8_2_1 sref_case_1_8
#define desc_case_1_8_2_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TOS."

int
test_case_1_8_2_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_2_1_conn test_case_1_8_2_1
#define test_case_1_8_2_1_resp test_case_1_8_2_1
#define test_case_1_8_2_1_list test_case_1_8_2_1

struct test_stream test_1_8_2_1_conn = { &preamble_1_8_conn, &test_case_1_8_2_1_conn, &postamble_1_8_conn };
struct test_stream test_1_8_2_1_resp = { &preamble_1_8_resp, &test_case_1_8_2_1_resp, &postamble_1_8_resp };
struct test_stream test_1_8_2_1_list = { &preamble_1_8_list, &test_case_1_8_2_1_list, &postamble_1_8_list };

#define tgrp_case_1_8_2_2 test_group_1_8_2
#define numb_case_1_8_2_2 "1.8.2.2"
#define name_case_1_8_2_2 "Perform options management -- T_IP_TTL"
#define sref_case_1_8_2_2 sref_case_1_8
#define desc_case_1_8_2_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_TTL."

int
test_case_1_8_2_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_2_2_conn test_case_1_8_2_2
#define test_case_1_8_2_2_resp test_case_1_8_2_2
#define test_case_1_8_2_2_list test_case_1_8_2_2

struct test_stream test_1_8_2_2_conn = { &preamble_1_8_conn, &test_case_1_8_2_2_conn, &postamble_1_8_conn };
struct test_stream test_1_8_2_2_resp = { &preamble_1_8_resp, &test_case_1_8_2_2_resp, &postamble_1_8_resp };
struct test_stream test_1_8_2_2_list = { &preamble_1_8_list, &test_case_1_8_2_2_list, &postamble_1_8_list };

#define tgrp_case_1_8_2_3 test_group_1_8_2
#define numb_case_1_8_2_3 "1.8.2.3"
#define name_case_1_8_2_3 "Perform options management -- T_IP_DONTROUTE"
#define sref_case_1_8_2_3 sref_case_1_8
#define desc_case_1_8_2_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_DONTROUTE."

int
test_case_1_8_2_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_2_3_conn test_case_1_8_2_3
#define test_case_1_8_2_3_resp test_case_1_8_2_3
#define test_case_1_8_2_3_list test_case_1_8_2_3

struct test_stream test_1_8_2_3_conn = { &preamble_1_8_conn, &test_case_1_8_2_3_conn, &postamble_1_8_conn };
struct test_stream test_1_8_2_3_resp = { &preamble_1_8_resp, &test_case_1_8_2_3_resp, &postamble_1_8_resp };
struct test_stream test_1_8_2_3_list = { &preamble_1_8_list, &test_case_1_8_2_3_list, &postamble_1_8_list };

#define tgrp_case_1_8_2_4 test_group_1_8_2
#define numb_case_1_8_2_4 "1.8.2.4"
#define name_case_1_8_2_4 "Perform options management -- T_IP_BROADCAST"
#define sref_case_1_8_2_4 sref_case_1_8
#define desc_case_1_8_2_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_BROADCAST."

int
test_case_1_8_2_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_2_4_conn test_case_1_8_2_4
#define test_case_1_8_2_4_resp test_case_1_8_2_4
#define test_case_1_8_2_4_list test_case_1_8_2_4

struct test_stream test_1_8_2_4_conn = { &preamble_1_8_conn, &test_case_1_8_2_4_conn, &postamble_1_8_conn };
struct test_stream test_1_8_2_4_resp = { &preamble_1_8_resp, &test_case_1_8_2_4_resp, &postamble_1_8_resp };
struct test_stream test_1_8_2_4_list = { &preamble_1_8_list, &test_case_1_8_2_4_list, &postamble_1_8_list };

#define tgrp_case_1_8_2_5 test_group_1_8_2
#define numb_case_1_8_2_5 "1.8.2.5"
#define name_case_1_8_2_5 "Perform options management -- T_IP_REUSEADDR"
#define sref_case_1_8_2_5 sref_case_1_8
#define desc_case_1_8_2_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_IP option T_IP_REUSEADDR."

int
test_case_1_8_2_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_ip(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_2_5_conn test_case_1_8_2_5
#define test_case_1_8_2_5_resp test_case_1_8_2_5
#define test_case_1_8_2_5_list test_case_1_8_2_5

struct test_stream test_1_8_2_5_conn = { &preamble_1_8_conn, &test_case_1_8_2_5_conn, &postamble_1_8_conn };
struct test_stream test_1_8_2_5_resp = { &preamble_1_8_resp, &test_case_1_8_2_5_resp, &postamble_1_8_resp };
struct test_stream test_1_8_2_5_list = { &preamble_1_8_list, &test_case_1_8_2_5_list, &postamble_1_8_list };

#define test_group_1_8_3 "Local management -- UDP options management"
#define tgrp_case_1_8_3_1 test_group_1_8_3
#define numb_case_1_8_3_1 "1.8.3.1"
#define name_case_1_8_3_1 "Perform options management -- T_UDP_CHECKSUM"
#define sref_case_1_8_3_1 sref_case_1_8
#define desc_case_1_8_3_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_UDP option T_UDP_CHECKSUM."

int
test_case_1_8_3_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_udp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_3_1_conn test_case_1_8_3_1
#define test_case_1_8_3_1_resp test_case_1_8_3_1
#define test_case_1_8_3_1_list test_case_1_8_3_1

struct test_stream test_1_8_3_1_conn = { &preamble_1_8_conn, &test_case_1_8_3_1_conn, &postamble_1_8_conn };
struct test_stream test_1_8_3_1_resp = { &preamble_1_8_resp, &test_case_1_8_3_1_resp, &postamble_1_8_resp };
struct test_stream test_1_8_3_1_list = { &preamble_1_8_list, &test_case_1_8_3_1_list, &postamble_1_8_list };

#define test_group_1_8_4 "Local management -- TCP options management"
#define tgrp_case_1_8_4_1 test_group_1_8_4
#define numb_case_1_8_4_1 "1.8.4.1"
#define name_case_1_8_4_1 "Perform options management -- T_TCP_NODELAY"
#define sref_case_1_8_4_1 sref_case_1_8
#define desc_case_1_8_4_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_NODELAY."

int
test_case_1_8_4_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_1_conn test_case_1_8_4_1
#define test_case_1_8_4_1_resp test_case_1_8_4_1
#define test_case_1_8_4_1_list test_case_1_8_4_1

struct test_stream test_1_8_4_1_conn = { &preamble_1_8_conn, &test_case_1_8_4_1_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_1_resp = { &preamble_1_8_resp, &test_case_1_8_4_1_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_1_list = { &preamble_1_8_list, &test_case_1_8_4_1_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_2 test_group_1_8_4
#define numb_case_1_8_4_2 "1.8.4.2"
#define name_case_1_8_4_2 "Perform options management -- T_TCP_MAXSEG"
#define sref_case_1_8_4_2 sref_case_1_8
#define desc_case_1_8_4_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_MAXSEG."

int
test_case_1_8_4_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_2_conn test_case_1_8_4_2
#define test_case_1_8_4_2_resp test_case_1_8_4_2
#define test_case_1_8_4_2_list test_case_1_8_4_2

struct test_stream test_1_8_4_2_conn = { &preamble_1_8_conn, &test_case_1_8_4_2_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_2_resp = { &preamble_1_8_resp, &test_case_1_8_4_2_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_2_list = { &preamble_1_8_list, &test_case_1_8_4_2_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_3 test_group_1_8_4
#define numb_case_1_8_4_3 "1.8.4.3"
#define name_case_1_8_4_3 "Perform options management -- T_TCP_KEEPALIVE"
#define sref_case_1_8_4_3 sref_case_1_8
#define desc_case_1_8_4_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPALIVE."

int
test_case_1_8_4_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_3_conn test_case_1_8_4_3
#define test_case_1_8_4_3_resp test_case_1_8_4_3
#define test_case_1_8_4_3_list test_case_1_8_4_3

struct test_stream test_1_8_4_3_conn = { &preamble_1_8_conn, &test_case_1_8_4_3_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_3_resp = { &preamble_1_8_resp, &test_case_1_8_4_3_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_3_list = { &preamble_1_8_list, &test_case_1_8_4_3_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_4 test_group_1_8_4
#define numb_case_1_8_4_4 "1.8.4.4"
#define name_case_1_8_4_4 "Perform options management -- T_TCP_CORK"
#define sref_case_1_8_4_4 sref_case_1_8
#define desc_case_1_8_4_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_CORK."

int
test_case_1_8_4_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_4_conn test_case_1_8_4_4
#define test_case_1_8_4_4_resp test_case_1_8_4_4
#define test_case_1_8_4_4_list test_case_1_8_4_4

struct test_stream test_1_8_4_4_conn = { &preamble_1_8_conn, &test_case_1_8_4_4_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_4_resp = { &preamble_1_8_resp, &test_case_1_8_4_4_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_4_list = { &preamble_1_8_list, &test_case_1_8_4_4_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_5 test_group_1_8_4
#define numb_case_1_8_4_5 "1.8.4.5"
#define name_case_1_8_4_5 "Perform options management -- T_TCP_KEEPIDLE"
#define sref_case_1_8_4_5 sref_case_1_8
#define desc_case_1_8_4_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPIDLE."

int
test_case_1_8_4_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_5_conn test_case_1_8_4_5
#define test_case_1_8_4_5_resp test_case_1_8_4_5
#define test_case_1_8_4_5_list test_case_1_8_4_5

struct test_stream test_1_8_4_5_conn = { &preamble_1_8_conn, &test_case_1_8_4_5_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_5_resp = { &preamble_1_8_resp, &test_case_1_8_4_5_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_5_list = { &preamble_1_8_list, &test_case_1_8_4_5_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_6 test_group_1_8_4
#define numb_case_1_8_4_6 "1.8.4.6"
#define name_case_1_8_4_6 "Perform options management -- T_TCP_KEEPINTVL"
#define sref_case_1_8_4_6 sref_case_1_8
#define desc_case_1_8_4_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPINTVL."

int
test_case_1_8_4_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_6_conn test_case_1_8_4_6
#define test_case_1_8_4_6_resp test_case_1_8_4_6
#define test_case_1_8_4_6_list test_case_1_8_4_6

struct test_stream test_1_8_4_6_conn = { &preamble_1_8_conn, &test_case_1_8_4_6_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_6_resp = { &preamble_1_8_resp, &test_case_1_8_4_6_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_6_list = { &preamble_1_8_list, &test_case_1_8_4_6_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_7 test_group_1_8_4
#define numb_case_1_8_4_7 "1.8.4.7"
#define name_case_1_8_4_7 "Perform options management -- T_TCP_KEEPCNT"
#define sref_case_1_8_4_7 sref_case_1_8
#define desc_case_1_8_4_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_KEEPCNT."

int
test_case_1_8_4_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_7_conn test_case_1_8_4_7
#define test_case_1_8_4_7_resp test_case_1_8_4_7
#define test_case_1_8_4_7_list test_case_1_8_4_7

struct test_stream test_1_8_4_7_conn = { &preamble_1_8_conn, &test_case_1_8_4_7_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_7_resp = { &preamble_1_8_resp, &test_case_1_8_4_7_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_7_list = { &preamble_1_8_list, &test_case_1_8_4_7_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_8 test_group_1_8_4
#define numb_case_1_8_4_8 "1.8.4.8"
#define name_case_1_8_4_8 "Perform options management -- T_TCP_SYNCNT"
#define sref_case_1_8_4_8 sref_case_1_8
#define desc_case_1_8_4_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_SYNCNT."

int
test_case_1_8_4_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_8_conn test_case_1_8_4_8
#define test_case_1_8_4_8_resp test_case_1_8_4_8
#define test_case_1_8_4_8_list test_case_1_8_4_8

struct test_stream test_1_8_4_8_conn = { &preamble_1_8_conn, &test_case_1_8_4_8_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_8_resp = { &preamble_1_8_resp, &test_case_1_8_4_8_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_8_list = { &preamble_1_8_list, &test_case_1_8_4_8_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_9 test_group_1_8_4
#define numb_case_1_8_4_9 "1.8.4.9"
#define name_case_1_8_4_9 "Perform options management -- T_TCP_LINGER2"
#define sref_case_1_8_4_9 sref_case_1_8
#define desc_case_1_8_4_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_LINGER2."

int
test_case_1_8_4_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_9_conn test_case_1_8_4_9
#define test_case_1_8_4_9_resp test_case_1_8_4_9
#define test_case_1_8_4_9_list test_case_1_8_4_9

struct test_stream test_1_8_4_9_conn = { &preamble_1_8_conn, &test_case_1_8_4_9_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_9_resp = { &preamble_1_8_resp, &test_case_1_8_4_9_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_9_list = { &preamble_1_8_list, &test_case_1_8_4_9_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_10 test_group_1_8_4
#define numb_case_1_8_4_10 "1.8.4.10"
#define name_case_1_8_4_10 "Perform options management -- T_TCP_DEFER_ACCEPT"
#define sref_case_1_8_4_10 sref_case_1_8
#define desc_case_1_8_4_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_DEFER_ACCEPT."

int
test_case_1_8_4_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_10_conn test_case_1_8_4_10
#define test_case_1_8_4_10_resp test_case_1_8_4_10
#define test_case_1_8_4_10_list test_case_1_8_4_10

struct test_stream test_1_8_4_10_conn = { &preamble_1_8_conn, &test_case_1_8_4_10_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_10_resp = { &preamble_1_8_resp, &test_case_1_8_4_10_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_10_list = { &preamble_1_8_list, &test_case_1_8_4_10_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_11 test_group_1_8_4
#define numb_case_1_8_4_11 "1.8.4.11"
#define name_case_1_8_4_11 "Perform options management -- T_TCP_WINDOW_CLAMP"
#define sref_case_1_8_4_11 sref_case_1_8
#define desc_case_1_8_4_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_WINDOW_CLAMP."

int
test_case_1_8_4_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_11_conn test_case_1_8_4_11
#define test_case_1_8_4_11_resp test_case_1_8_4_11
#define test_case_1_8_4_11_list test_case_1_8_4_11

struct test_stream test_1_8_4_11_conn = { &preamble_1_8_conn, &test_case_1_8_4_11_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_11_resp = { &preamble_1_8_resp, &test_case_1_8_4_11_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_11_list = { &preamble_1_8_list, &test_case_1_8_4_11_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_12 test_group_1_8_4
#define numb_case_1_8_4_12 "1.8.4.12"
#define name_case_1_8_4_12 "Perform options management -- T_TCP_INFO"
#define sref_case_1_8_4_12 sref_case_1_8
#define desc_case_1_8_4_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_INFO."

int
test_case_1_8_4_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_8_4_12_conn test_case_1_8_4_12
#define test_case_1_8_4_12_resp test_case_1_8_4_12
#define test_case_1_8_4_12_list test_case_1_8_4_12

struct test_stream test_1_8_4_12_conn = { &preamble_1_8_conn, &test_case_1_8_4_12_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_12_resp = { &preamble_1_8_resp, &test_case_1_8_4_12_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_12_list = { &preamble_1_8_list, &test_case_1_8_4_12_list, &postamble_1_8_list };

#define tgrp_case_1_8_4_13 test_group_1_8_4
#define numb_case_1_8_4_13 "1.8.4.13"
#define name_case_1_8_4_13 "Perform options management -- T_TCP_QUICKACK"
#define sref_case_1_8_4_13 sref_case_1_8
#define desc_case_1_8_4_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_TCP_QUICKACK."

int
test_case_1_8_4_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_tcp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_4_13_conn test_case_1_8_4_13
#define test_case_1_8_4_13_resp test_case_1_8_4_13
#define test_case_1_8_4_13_list test_case_1_8_4_13

struct test_stream test_1_8_4_13_conn = { &preamble_1_8_conn, &test_case_1_8_4_13_conn, &postamble_1_8_conn };
struct test_stream test_1_8_4_13_resp = { &preamble_1_8_resp, &test_case_1_8_4_13_resp, &postamble_1_8_resp };
struct test_stream test_1_8_4_13_list = { &preamble_1_8_list, &test_case_1_8_4_13_list, &postamble_1_8_list };

#define test_group_1_8_5 "Local management -- SCTP options management"
/*
 *  Perform options management -- T_SCTP_NODELAY
 */
#define tgrp_case_1_8_5_1 test_group_1_8_5
#define numb_case_1_8_5_1 "1.8.5.1"
#define name_case_1_8_5_1 "Perform options management -- T_SCTP_NODELAY"
#define sref_case_1_8_5_1 sref_case_1_8
#define desc_case_1_8_5_1 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_NODELAY."

int
test_case_1_8_5_1(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_1_conn test_case_1_8_5_1
#define test_case_1_8_5_1_resp test_case_1_8_5_1
#define test_case_1_8_5_1_list test_case_1_8_5_1

struct test_stream test_1_8_5_1_conn = { &preamble_1_8_conn, &test_case_1_8_5_1_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_1_resp = { &preamble_1_8_resp, &test_case_1_8_5_1_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_1_list = { &preamble_1_8_list, &test_case_1_8_5_1_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_CORK
 */
#define tgrp_case_1_8_5_2 test_group_1_8_5
#define numb_case_1_8_5_2 "1.8.5.2"
#define name_case_1_8_5_2 "Perform options management -- T_SCTP_CORK"
#define sref_case_1_8_5_2 sref_case_1_8
#define desc_case_1_8_5_2 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CORK."

int
test_case_1_8_5_2(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_2_conn test_case_1_8_5_2
#define test_case_1_8_5_2_resp test_case_1_8_5_2
#define test_case_1_8_5_2_list test_case_1_8_5_2

struct test_stream test_1_8_5_2_conn = { &preamble_1_8_conn, &test_case_1_8_5_2_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_2_resp = { &preamble_1_8_resp, &test_case_1_8_5_2_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_2_list = { &preamble_1_8_list, &test_case_1_8_5_2_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_PPI
 */
#define tgrp_case_1_8_5_3 test_group_1_8_5
#define numb_case_1_8_5_3 "1.8.5.3"
#define name_case_1_8_5_3 "Perform options management -- T_SCTP_PPI"
#define sref_case_1_8_5_3 sref_case_1_8
#define desc_case_1_8_5_3 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PPI."

int
test_case_1_8_5_3(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_3_conn test_case_1_8_5_3
#define test_case_1_8_5_3_resp test_case_1_8_5_3
#define test_case_1_8_5_3_list test_case_1_8_5_3

struct test_stream test_1_8_5_3_conn = { &preamble_1_8_conn, &test_case_1_8_5_3_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_3_resp = { &preamble_1_8_resp, &test_case_1_8_5_3_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_3_list = { &preamble_1_8_list, &test_case_1_8_5_3_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_SID
 */
#define tgrp_case_1_8_5_4 test_group_1_8_5
#define numb_case_1_8_5_4 "1.8.5.4"
#define name_case_1_8_5_4 "Perform options management -- T_SCTP_SID"
#define sref_case_1_8_5_4 sref_case_1_8
#define desc_case_1_8_5_4 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SID."

int
test_case_1_8_5_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_4_conn test_case_1_8_5_4
#define test_case_1_8_5_4_resp test_case_1_8_5_4
#define test_case_1_8_5_4_list test_case_1_8_5_4

struct test_stream test_1_8_5_4_conn = { &preamble_1_8_conn, &test_case_1_8_5_4_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_4_resp = { &preamble_1_8_resp, &test_case_1_8_5_4_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_4_list = { &preamble_1_8_list, &test_case_1_8_5_4_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_SSN
 */
#define tgrp_case_1_8_5_5 test_group_1_8_5
#define numb_case_1_8_5_5 "1.8.5.5"
#define name_case_1_8_5_5 "Perform options management -- T_SCTP_SSN"
#define sref_case_1_8_5_5 sref_case_1_8
#define desc_case_1_8_5_5 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SSN."

int
test_case_1_8_5_5(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_8_5_5_conn test_case_1_8_5_5
#define test_case_1_8_5_5_resp test_case_1_8_5_5
#define test_case_1_8_5_5_list test_case_1_8_5_5

struct test_stream test_1_8_5_5_conn = { &preamble_1_8_conn, &test_case_1_8_5_5_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_5_resp = { &preamble_1_8_resp, &test_case_1_8_5_5_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_5_list = { &preamble_1_8_list, &test_case_1_8_5_5_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_TSN
 */
#define tgrp_case_1_8_5_6 test_group_1_8_5
#define numb_case_1_8_5_6 "1.8.5.6"
#define name_case_1_8_5_6 "Perform options management -- T_SCTP_TSN"
#define sref_case_1_8_5_6 sref_case_1_8
#define desc_case_1_8_5_6 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_TSN."

int
test_case_1_8_5_6(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_8_5_6_conn test_case_1_8_5_6
#define test_case_1_8_5_6_resp test_case_1_8_5_6
#define test_case_1_8_5_6_list test_case_1_8_5_6

struct test_stream test_1_8_5_6_conn = { &preamble_1_8_conn, &test_case_1_8_5_6_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_6_resp = { &preamble_1_8_resp, &test_case_1_8_5_6_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_6_list = { &preamble_1_8_list, &test_case_1_8_5_6_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_RECVOPT
 */
#define tgrp_case_1_8_5_7 test_group_1_8_5
#define numb_case_1_8_5_7 "1.8.5.7"
#define name_case_1_8_5_7 "Perform options management -- T_SCTP_RECVOPT"
#define sref_case_1_8_5_7 sref_case_1_8
#define desc_case_1_8_5_7 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RECVOPT."

int
test_case_1_8_5_7(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_7_conn test_case_1_8_5_7
#define test_case_1_8_5_7_resp test_case_1_8_5_7
#define test_case_1_8_5_7_list test_case_1_8_5_7

struct test_stream test_1_8_5_7_conn = { &preamble_1_8_conn, &test_case_1_8_5_7_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_7_resp = { &preamble_1_8_resp, &test_case_1_8_5_7_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_7_list = { &preamble_1_8_list, &test_case_1_8_5_7_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_LIFE
 */
#define tgrp_case_1_8_5_8 test_group_1_8_5
#define numb_case_1_8_5_8 "1.8.5.8"
#define name_case_1_8_5_8 "Perform options management -- T_SCTP_COOKIE_LIFE"
#define sref_case_1_8_5_8 sref_case_1_8
#define desc_case_1_8_5_8 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_LIFE."

int
test_case_1_8_5_8(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_8_conn test_case_1_8_5_8
#define test_case_1_8_5_8_resp test_case_1_8_5_8
#define test_case_1_8_5_8_list test_case_1_8_5_8

struct test_stream test_1_8_5_8_conn = { &preamble_1_8_conn, &test_case_1_8_5_8_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_8_resp = { &preamble_1_8_resp, &test_case_1_8_5_8_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_8_list = { &preamble_1_8_list, &test_case_1_8_5_8_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_SACK_DELAY
 */
#define tgrp_case_1_8_5_9 test_group_1_8_5
#define numb_case_1_8_5_9 "1.8.5.9"
#define name_case_1_8_5_9 "Perform options management -- T_SCTP_SACK_DELAY"
#define sref_case_1_8_5_9 sref_case_1_8
#define desc_case_1_8_5_9 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SACK_DELAY."

int
test_case_1_8_5_9(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_9_conn test_case_1_8_5_9
#define test_case_1_8_5_9_resp test_case_1_8_5_9
#define test_case_1_8_5_9_list test_case_1_8_5_9

struct test_stream test_1_8_5_9_conn = { &preamble_1_8_conn, &test_case_1_8_5_9_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_9_resp = { &preamble_1_8_resp, &test_case_1_8_5_9_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_9_list = { &preamble_1_8_list, &test_case_1_8_5_9_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_PATH_MAX_RETRANS
 */
#define tgrp_case_1_8_5_10 test_group_1_8_5
#define numb_case_1_8_5_10 "1.8.5.10"
#define name_case_1_8_5_10 "Perform options management -- T_SCTP_PATH_MAX_RETRANS"
#define sref_case_1_8_5_10 sref_case_1_8
#define desc_case_1_8_5_10 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PATH_MAX_RETRANS."

int
test_case_1_8_5_10(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_10_conn test_case_1_8_5_10
#define test_case_1_8_5_10_resp test_case_1_8_5_10
#define test_case_1_8_5_10_list test_case_1_8_5_10

struct test_stream test_1_8_5_10_conn = { &preamble_1_8_conn, &test_case_1_8_5_10_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_10_resp = { &preamble_1_8_resp, &test_case_1_8_5_10_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_10_list = { &preamble_1_8_list, &test_case_1_8_5_10_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_ASSOC_MAX_RETRANS
 */
#define tgrp_case_1_8_5_11 test_group_1_8_5
#define numb_case_1_8_5_11 "1.8.5.11"
#define name_case_1_8_5_11 "Perform options management -- T_SCTP_ASSOC_MAX_RETRANS"
#define sref_case_1_8_5_11 sref_case_1_8
#define desc_case_1_8_5_11 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ASSOC_MAX_RETRANS."

int
test_case_1_8_5_11(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_11_conn test_case_1_8_5_11
#define test_case_1_8_5_11_resp test_case_1_8_5_11
#define test_case_1_8_5_11_list test_case_1_8_5_11

struct test_stream test_1_8_5_11_conn = { &preamble_1_8_conn, &test_case_1_8_5_11_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_11_resp = { &preamble_1_8_resp, &test_case_1_8_5_11_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_11_list = { &preamble_1_8_list, &test_case_1_8_5_11_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_MAX_INIT_RETRIES
 */
#define tgrp_case_1_8_5_12 test_group_1_8_5
#define numb_case_1_8_5_12 "1.8.5.12"
#define name_case_1_8_5_12 "Perform options management -- T_SCTP_MAX_INIT_RETRIES"
#define sref_case_1_8_5_12 sref_case_1_8
#define desc_case_1_8_5_12 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_INIT_RETRIES."

int
test_case_1_8_5_12(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_12_conn test_case_1_8_5_12
#define test_case_1_8_5_12_resp test_case_1_8_5_12
#define test_case_1_8_5_12_list test_case_1_8_5_12

struct test_stream test_1_8_5_12_conn = { &preamble_1_8_conn, &test_case_1_8_5_12_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_12_resp = { &preamble_1_8_resp, &test_case_1_8_5_12_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_12_list = { &preamble_1_8_list, &test_case_1_8_5_12_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_HEARTBEAT_ITVL
 */
#define tgrp_case_1_8_5_13 test_group_1_8_5
#define numb_case_1_8_5_13 "1.8.5.13"
#define name_case_1_8_5_13 "Perform options management -- T_SCTP_HEARTBEAT_ITVL"
#define sref_case_1_8_5_13 sref_case_1_8
#define desc_case_1_8_5_13 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HEARTBEAT_ITVL."

int
test_case_1_8_5_13(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_13_conn test_case_1_8_5_13
#define test_case_1_8_5_13_resp test_case_1_8_5_13
#define test_case_1_8_5_13_list test_case_1_8_5_13

struct test_stream test_1_8_5_13_conn = { &preamble_1_8_conn, &test_case_1_8_5_13_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_13_resp = { &preamble_1_8_resp, &test_case_1_8_5_13_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_13_list = { &preamble_1_8_list, &test_case_1_8_5_13_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_RTO_INITIAL
 */
#define tgrp_case_1_8_5_14 test_group_1_8_5
#define numb_case_1_8_5_14 "1.8.5.14"
#define name_case_1_8_5_14 "Perform options management -- T_SCTP_RTO_INITIAL"
#define sref_case_1_8_5_14 sref_case_1_8
#define desc_case_1_8_5_14 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_INITIAL."

int
test_case_1_8_5_14(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_14_conn test_case_1_8_5_14
#define test_case_1_8_5_14_resp test_case_1_8_5_14
#define test_case_1_8_5_14_list test_case_1_8_5_14

struct test_stream test_1_8_5_14_conn = { &preamble_1_8_conn, &test_case_1_8_5_14_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_14_resp = { &preamble_1_8_resp, &test_case_1_8_5_14_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_14_list = { &preamble_1_8_list, &test_case_1_8_5_14_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_RTO_MIN
 */
#define tgrp_case_1_8_5_15 test_group_1_8_5
#define numb_case_1_8_5_15 "1.8.5.15"
#define name_case_1_8_5_15 "Perform options management -- T_SCTP_RTO_MIN"
#define sref_case_1_8_5_15 sref_case_1_8
#define desc_case_1_8_5_15 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MIN."

int
test_case_1_8_5_15(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_15_conn test_case_1_8_5_15
#define test_case_1_8_5_15_resp test_case_1_8_5_15
#define test_case_1_8_5_15_list test_case_1_8_5_15

struct test_stream test_1_8_5_15_conn = { &preamble_1_8_conn, &test_case_1_8_5_15_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_15_resp = { &preamble_1_8_resp, &test_case_1_8_5_15_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_15_list = { &preamble_1_8_list, &test_case_1_8_5_15_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_RTO_MAX
 */
#define tgrp_case_1_8_5_16 test_group_1_8_5
#define numb_case_1_8_5_16 "1.8.5.16"
#define name_case_1_8_5_16 "Perform options management -- T_SCTP_RTO_MAX"
#define sref_case_1_8_5_16 sref_case_1_8
#define desc_case_1_8_5_16 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO_MAX."

int
test_case_1_8_5_16(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_16_conn test_case_1_8_5_16
#define test_case_1_8_5_16_resp test_case_1_8_5_16
#define test_case_1_8_5_16_list test_case_1_8_5_16

struct test_stream test_1_8_5_16_conn = { &preamble_1_8_conn, &test_case_1_8_5_16_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_16_resp = { &preamble_1_8_resp, &test_case_1_8_5_16_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_16_list = { &preamble_1_8_list, &test_case_1_8_5_16_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_OSTREAMS
 */
#define tgrp_case_1_8_5_17 test_group_1_8_5
#define numb_case_1_8_5_17 "1.8.5.17"
#define name_case_1_8_5_17 "Perform options management -- T_SCTP_OSTREAMS"
#define sref_case_1_8_5_17 sref_case_1_8
#define desc_case_1_8_5_17 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_OSTREAMS."

int
test_case_1_8_5_17(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_17_conn test_case_1_8_5_17
#define test_case_1_8_5_17_resp test_case_1_8_5_17
#define test_case_1_8_5_17_list test_case_1_8_5_17

struct test_stream test_1_8_5_17_conn = { &preamble_1_8_conn, &test_case_1_8_5_17_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_17_resp = { &preamble_1_8_resp, &test_case_1_8_5_17_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_17_list = { &preamble_1_8_list, &test_case_1_8_5_17_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_ISTREAMS
 */
#define tgrp_case_1_8_5_18 test_group_1_8_5
#define numb_case_1_8_5_18 "1.8.5.18"
#define name_case_1_8_5_18 "Perform options management -- T_SCTP_ISTREAMS"
#define sref_case_1_8_5_18 sref_case_1_8
#define desc_case_1_8_5_18 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ISTREAMS."

int
test_case_1_8_5_18(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_18_conn test_case_1_8_5_18
#define test_case_1_8_5_18_resp test_case_1_8_5_18
#define test_case_1_8_5_18_list test_case_1_8_5_18

struct test_stream test_1_8_5_18_conn = { &preamble_1_8_conn, &test_case_1_8_5_18_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_18_resp = { &preamble_1_8_resp, &test_case_1_8_5_18_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_18_list = { &preamble_1_8_list, &test_case_1_8_5_18_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_COOKIE_INC
 */
#define tgrp_case_1_8_5_19 test_group_1_8_5
#define numb_case_1_8_5_19 "1.8.5.19"
#define name_case_1_8_5_19 "Perform options management -- T_SCTP_COOKIE_INC"
#define sref_case_1_8_5_19 sref_case_1_8
#define desc_case_1_8_5_19 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_COOKIE_INC."

int
test_case_1_8_5_19(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_19_conn test_case_1_8_5_19
#define test_case_1_8_5_19_resp test_case_1_8_5_19
#define test_case_1_8_5_19_list test_case_1_8_5_19

struct test_stream test_1_8_5_19_conn = { &preamble_1_8_conn, &test_case_1_8_5_19_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_19_resp = { &preamble_1_8_resp, &test_case_1_8_5_19_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_19_list = { &preamble_1_8_list, &test_case_1_8_5_19_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_THROTTLE_ITVL
 */
#define tgrp_case_1_8_5_20 test_group_1_8_5
#define numb_case_1_8_5_20 "1.8.5.20"
#define name_case_1_8_5_20 "Perform options management -- T_SCTP_THROTTLE_ITVL"
#define sref_case_1_8_5_20 sref_case_1_8
#define desc_case_1_8_5_20 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_THROTTLE_ITVL."

int
test_case_1_8_5_20(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_20_conn test_case_1_8_5_20
#define test_case_1_8_5_20_resp test_case_1_8_5_20
#define test_case_1_8_5_20_list test_case_1_8_5_20

struct test_stream test_1_8_5_20_conn = { &preamble_1_8_conn, &test_case_1_8_5_20_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_20_resp = { &preamble_1_8_resp, &test_case_1_8_5_20_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_20_list = { &preamble_1_8_list, &test_case_1_8_5_20_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_MAC_TYPE
 */
#define tgrp_case_1_8_5_21 test_group_1_8_5
#define numb_case_1_8_5_21 "1.8.5.21"
#define name_case_1_8_5_21 "Perform options management -- T_SCTP_MAC_TYPE"
#define sref_case_1_8_5_21 sref_case_1_8
#define desc_case_1_8_5_21 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAC_TYPE."

int
test_case_1_8_5_21(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_21_conn test_case_1_8_5_21
#define test_case_1_8_5_21_resp test_case_1_8_5_21
#define test_case_1_8_5_21_list test_case_1_8_5_21

struct test_stream test_1_8_5_21_conn = { &preamble_1_8_conn, &test_case_1_8_5_21_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_21_resp = { &preamble_1_8_resp, &test_case_1_8_5_21_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_21_list = { &preamble_1_8_list, &test_case_1_8_5_21_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_CKSUM_TYPE
 */
#define tgrp_case_1_8_5_22 test_group_1_8_5
#define numb_case_1_8_5_22 "1.8.5.22"
#define name_case_1_8_5_22 "Perform options management -- T_SCTP_CKSUM_TYPE"
#define sref_case_1_8_5_22 sref_case_1_8
#define desc_case_1_8_5_22 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_CKSUM_TYPE."

int
test_case_1_8_5_22(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_22_conn test_case_1_8_5_22
#define test_case_1_8_5_22_resp test_case_1_8_5_22
#define test_case_1_8_5_22_list test_case_1_8_5_22

struct test_stream test_1_8_5_22_conn = { &preamble_1_8_conn, &test_case_1_8_5_22_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_22_resp = { &preamble_1_8_resp, &test_case_1_8_5_22_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_22_list = { &preamble_1_8_list, &test_case_1_8_5_22_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_ECN
 */
#define tgrp_case_1_8_5_23 test_group_1_8_5
#define numb_case_1_8_5_23 "1.8.5.23"
#define name_case_1_8_5_23 "Perform options management -- T_SCTP_ECN"
#define sref_case_1_8_5_23 sref_case_1_8
#define desc_case_1_8_5_23 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ECN."

int
test_case_1_8_5_23(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_23_conn test_case_1_8_5_23
#define test_case_1_8_5_23_resp test_case_1_8_5_23
#define test_case_1_8_5_23_list test_case_1_8_5_23

struct test_stream test_1_8_5_23_conn = { &preamble_1_8_conn, &test_case_1_8_5_23_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_23_resp = { &preamble_1_8_resp, &test_case_1_8_5_23_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_23_list = { &preamble_1_8_list, &test_case_1_8_5_23_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_ALI
 */
#define tgrp_case_1_8_5_24 test_group_1_8_5
#define numb_case_1_8_5_24 "1.8.5.24"
#define name_case_1_8_5_24 "Perform options management -- T_SCTP_ALI"
#define sref_case_1_8_5_24 sref_case_1_8
#define desc_case_1_8_5_24 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ALI."

int
test_case_1_8_5_24(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_24_conn test_case_1_8_5_24
#define test_case_1_8_5_24_resp test_case_1_8_5_24
#define test_case_1_8_5_24_list test_case_1_8_5_24

struct test_stream test_1_8_5_24_conn = { &preamble_1_8_conn, &test_case_1_8_5_24_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_24_resp = { &preamble_1_8_resp, &test_case_1_8_5_24_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_24_list = { &preamble_1_8_list, &test_case_1_8_5_24_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_ADD
 */
#define tgrp_case_1_8_5_25 test_group_1_8_5
#define numb_case_1_8_5_25 "1.8.5.25"
#define name_case_1_8_5_25 "Perform options management -- T_SCTP_ADD"
#define sref_case_1_8_5_25 sref_case_1_8
#define desc_case_1_8_5_25 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD."

int
test_case_1_8_5_25(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_25_conn test_case_1_8_5_25
#define test_case_1_8_5_25_resp test_case_1_8_5_25
#define test_case_1_8_5_25_list test_case_1_8_5_25

struct test_stream test_1_8_5_25_conn = { &preamble_1_8_conn, &test_case_1_8_5_25_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_25_resp = { &preamble_1_8_resp, &test_case_1_8_5_25_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_25_list = { &preamble_1_8_list, &test_case_1_8_5_25_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_SET
 */
#define tgrp_case_1_8_5_26 test_group_1_8_5
#define numb_case_1_8_5_26 "1.8.5.26"
#define name_case_1_8_5_26 "Perform options management -- T_SCTP_SET"
#define sref_case_1_8_5_26 sref_case_1_8
#define desc_case_1_8_5_26 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET."

int
test_case_1_8_5_26(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_26_conn test_case_1_8_5_26
#define test_case_1_8_5_26_resp test_case_1_8_5_26
#define test_case_1_8_5_26_list test_case_1_8_5_26

struct test_stream test_1_8_5_26_conn = { &preamble_1_8_conn, &test_case_1_8_5_26_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_26_resp = { &preamble_1_8_resp, &test_case_1_8_5_26_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_26_list = { &preamble_1_8_list, &test_case_1_8_5_26_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_ADD_IP
 */
#define tgrp_case_1_8_5_27 test_group_1_8_5
#define numb_case_1_8_5_27 "1.8.5.27"
#define name_case_1_8_5_27 "Perform options management -- T_SCTP_ADD_IP"
#define sref_case_1_8_5_27 sref_case_1_8
#define desc_case_1_8_5_27 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_ADD_IP."

int
test_case_1_8_5_27(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_27_conn test_case_1_8_5_27
#define test_case_1_8_5_27_resp test_case_1_8_5_27
#define test_case_1_8_5_27_list test_case_1_8_5_27

struct test_stream test_1_8_5_27_conn = { &preamble_1_8_conn, &test_case_1_8_5_27_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_27_resp = { &preamble_1_8_resp, &test_case_1_8_5_27_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_27_list = { &preamble_1_8_list, &test_case_1_8_5_27_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_DEL_IP
 */
#define tgrp_case_1_8_5_28 test_group_1_8_5
#define numb_case_1_8_5_28 "1.8.5.28"
#define name_case_1_8_5_28 "Perform options management -- T_SCTP_DEL_IP"
#define sref_case_1_8_5_28 sref_case_1_8
#define desc_case_1_8_5_28 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DEL_IP."

int
test_case_1_8_5_28(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_28_conn test_case_1_8_5_28
#define test_case_1_8_5_28_resp test_case_1_8_5_28
#define test_case_1_8_5_28_list test_case_1_8_5_28

struct test_stream test_1_8_5_28_conn = { &preamble_1_8_conn, &test_case_1_8_5_28_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_28_resp = { &preamble_1_8_resp, &test_case_1_8_5_28_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_28_list = { &preamble_1_8_list, &test_case_1_8_5_28_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_SET_IP
 */
#define tgrp_case_1_8_5_29 test_group_1_8_5
#define numb_case_1_8_5_29 "1.8.5.29"
#define name_case_1_8_5_29 "Perform options management -- T_SCTP_SET_IP"
#define sref_case_1_8_5_29 sref_case_1_8
#define desc_case_1_8_5_29 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_SET_IP."

int
test_case_1_8_5_29(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_29_conn test_case_1_8_5_29
#define test_case_1_8_5_29_resp test_case_1_8_5_29
#define test_case_1_8_5_29_list test_case_1_8_5_29

struct test_stream test_1_8_5_29_conn = { &preamble_1_8_conn, &test_case_1_8_5_29_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_29_resp = { &preamble_1_8_resp, &test_case_1_8_5_29_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_29_list = { &preamble_1_8_list, &test_case_1_8_5_29_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_PR
 */
#define tgrp_case_1_8_5_30 test_group_1_8_5
#define numb_case_1_8_5_30 "1.8.5.30"
#define name_case_1_8_5_30 "Perform options management -- T_SCTP_PR"
#define sref_case_1_8_5_30 sref_case_1_8
#define desc_case_1_8_5_30 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_PR."

int
test_case_1_8_5_30(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_30_conn test_case_1_8_5_30
#define test_case_1_8_5_30_resp test_case_1_8_5_30
#define test_case_1_8_5_30_list test_case_1_8_5_30

struct test_stream test_1_8_5_30_conn = { &preamble_1_8_conn, &test_case_1_8_5_30_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_30_resp = { &preamble_1_8_resp, &test_case_1_8_5_30_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_30_list = { &preamble_1_8_list, &test_case_1_8_5_30_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_LIFETIME
 */
#define tgrp_case_1_8_5_31 test_group_1_8_5
#define numb_case_1_8_5_31 "1.8.5.31"
#define name_case_1_8_5_31 "Perform options management -- T_SCTP_LIFETIME"
#define sref_case_1_8_5_31 sref_case_1_8
#define desc_case_1_8_5_31 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_LIFETIME."

int
test_case_1_8_5_31(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_INFINITE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_31_conn test_case_1_8_5_31
#define test_case_1_8_5_31_resp test_case_1_8_5_31
#define test_case_1_8_5_31_list test_case_1_8_5_31

struct test_stream test_1_8_5_31_conn = { &preamble_1_8_conn, &test_case_1_8_5_31_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_31_resp = { &preamble_1_8_resp, &test_case_1_8_5_31_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_31_list = { &preamble_1_8_list, &test_case_1_8_5_31_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_DISPOSITION
 */
#define tgrp_case_1_8_5_32 test_group_1_8_5
#define numb_case_1_8_5_32 "1.8.5.32"
#define name_case_1_8_5_32 "Perform options management -- T_SCTP_DISPOSITION"
#define sref_case_1_8_5_32 sref_case_1_8
#define desc_case_1_8_5_32 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_DISPOSITION."

int
test_case_1_8_5_32(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_32_conn test_case_1_8_5_32
#define test_case_1_8_5_32_resp test_case_1_8_5_32
#define test_case_1_8_5_32_list test_case_1_8_5_32

struct test_stream test_1_8_5_32_conn = { &preamble_1_8_conn, &test_case_1_8_5_32_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_32_resp = { &preamble_1_8_resp, &test_case_1_8_5_32_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_32_list = { &preamble_1_8_list, &test_case_1_8_5_32_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_MAX_BURST
 */
#define tgrp_case_1_8_5_33 test_group_1_8_5
#define numb_case_1_8_5_33 "1.8.5.33"
#define name_case_1_8_5_33 "Perform options management -- T_SCTP_MAX_BURST"
#define sref_case_1_8_5_33 sref_case_1_8
#define desc_case_1_8_5_33 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAX_BURST."

int
test_case_1_8_5_33(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_33_conn test_case_1_8_5_33
#define test_case_1_8_5_33_resp test_case_1_8_5_33
#define test_case_1_8_5_33_list test_case_1_8_5_33

struct test_stream test_1_8_5_33_conn = { &preamble_1_8_conn, &test_case_1_8_5_33_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_33_resp = { &preamble_1_8_resp, &test_case_1_8_5_33_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_33_list = { &preamble_1_8_list, &test_case_1_8_5_33_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_HB
 */
#define tgrp_case_1_8_5_34 test_group_1_8_5
#define numb_case_1_8_5_34 "1.8.5.34"
#define name_case_1_8_5_34 "Perform options management -- T_SCTP_HB"
#define sref_case_1_8_5_34 sref_case_1_8
#define desc_case_1_8_5_34 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_HB."

int
test_case_1_8_5_34(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_34_conn test_case_1_8_5_34
#define test_case_1_8_5_34_resp test_case_1_8_5_34
#define test_case_1_8_5_34_list test_case_1_8_5_34

struct test_stream test_1_8_5_34_conn = { &preamble_1_8_conn, &test_case_1_8_5_34_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_34_resp = { &preamble_1_8_resp, &test_case_1_8_5_34_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_34_list = { &preamble_1_8_list, &test_case_1_8_5_34_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_RTO
 */
#define tgrp_case_1_8_5_35 test_group_1_8_5
#define numb_case_1_8_5_35 "1.8.5.35"
#define name_case_1_8_5_35 "Perform options management -- T_SCTP_RTO"
#define sref_case_1_8_5_35 sref_case_1_8
#define desc_case_1_8_5_35 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_RTO."

int
test_case_1_8_5_35(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_35_conn test_case_1_8_5_35
#define test_case_1_8_5_35_resp test_case_1_8_5_35
#define test_case_1_8_5_35_list test_case_1_8_5_35

struct test_stream test_1_8_5_35_conn = { &preamble_1_8_conn, &test_case_1_8_5_35_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_35_resp = { &preamble_1_8_resp, &test_case_1_8_5_35_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_35_list = { &preamble_1_8_list, &test_case_1_8_5_35_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_MAXSEG
 */
#define tgrp_case_1_8_5_36 test_group_1_8_5
#define numb_case_1_8_5_36 "1.8.5.36"
#define name_case_1_8_5_36 "Perform options management -- T_SCTP_MAXSEG"
#define sref_case_1_8_5_36 sref_case_1_8
#define desc_case_1_8_5_36 "\
Checks that options management can be performed on several streams\n\
for T_INET_SCTP option T_SCTP_MAXSEG."

int
test_case_1_8_5_36(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_36_conn test_case_1_8_5_36
#define test_case_1_8_5_36_resp test_case_1_8_5_36
#define test_case_1_8_5_36_list test_case_1_8_5_36

struct test_stream test_1_8_5_36_conn = { &preamble_1_8_conn, &test_case_1_8_5_36_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_36_resp = { &preamble_1_8_resp, &test_case_1_8_5_36_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_36_list = { &preamble_1_8_list, &test_case_1_8_5_36_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_STATUS
 */
#define tgrp_case_1_8_5_37 test_group_1_8_5
#define numb_case_1_8_5_37 "1.8.5.37"
#define name_case_1_8_5_37 "Perform options management -- T_SCTP_STATUS"
#define sref_case_1_8_5_37 sref_case_1_8
#define desc_case_1_8_5_37 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_SCTP_STATUS."

int
test_case_1_8_5_37(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_READONLY, TBADOPT, 0);
}

#define test_case_1_8_5_37_conn test_case_1_8_5_37
#define test_case_1_8_5_37_resp test_case_1_8_5_37
#define test_case_1_8_5_37_list test_case_1_8_5_37

struct test_stream test_1_8_5_37_conn = { &preamble_1_8_conn, &test_case_1_8_5_37_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_37_resp = { &preamble_1_8_resp, &test_case_1_8_5_37_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_37_list = { &preamble_1_8_list, &test_case_1_8_5_37_list, &postamble_1_8_list };

/*
 *  Perform options management -- T_SCTP_DEBUG
 */
#define tgrp_case_1_8_5_38 test_group_1_8_5
#define numb_case_1_8_5_38 "1.8.5.38"
#define name_case_1_8_5_38 "Perform options management -- T_SCTP_DEBUG"
#define sref_case_1_8_5_38 sref_case_1_8
#define desc_case_1_8_5_38 "\
Checks that options management can be performed on several streams\n\
for T_INET_TCP option T_SCTP_DEBUG."

int
test_case_1_8_5_38(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_8_sctp(child, T_SUCCESS, TBADOPT, 0);
}

#define test_case_1_8_5_38_conn test_case_1_8_5_38
#define test_case_1_8_5_38_resp test_case_1_8_5_38
#define test_case_1_8_5_38_list test_case_1_8_5_38

struct test_stream test_1_8_5_38_conn = { &preamble_1_8_conn, &test_case_1_8_5_38_conn, &postamble_1_8_conn };
struct test_stream test_1_8_5_38_resp = { &preamble_1_8_resp, &test_case_1_8_5_38_resp, &postamble_1_8_resp };
struct test_stream test_1_8_5_38_list = { &preamble_1_8_list, &test_case_1_8_5_38_list, &postamble_1_8_list };

#define test_group_1_9_1 "Options management -- no options specified"

int
test_case_1_9_1(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;
	struct t_opthdr *oh;

	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags == T_FAILURE)
		goto failure;
	state++;
	if (p->optmgmt_ack.OPT_length == 0)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_DEBUG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_LINGER, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_RCVBUF, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_RCVLOWAT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_SNDBUF, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_SNDLOWAT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	if (!(oh = find_option(T_INET_IP, T_IP_OPTIONS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_TOS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_TTL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_REUSEADDR, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_DONTROUTE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_BROADCAST, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_ADDR, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (test_level == T_INET_UDP) {
		if (!(oh = find_option(T_INET_UDP, T_UDP_CHECKSUM, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
	}
	if (test_level == T_INET_TCP) {
		if (!(oh = find_option(T_INET_TCP, T_TCP_NODELAY, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_MAXSEG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPALIVE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_CORK, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPIDLE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPINTVL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPCNT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_SYNCNT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_LINGER2, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_DEFER_ACCEPT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_WINDOW_CLAMP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_INFO, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_QUICKACK, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
	}
	if (test_level == T_INET_SCTP) {
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_NODELAY, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_CORK, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_PPI, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SID, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SSN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_TSN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RECVOPT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_COOKIE_LIFE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SACK_DELAY, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO_INITIAL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO_MIN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO_MAX, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_OSTREAMS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ISTREAMS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_COOKIE_INC, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_THROTTLE_ITVL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAC_TYPE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_CKSUM_TYPE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ECN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ALI, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ADD, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SET, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ADD_IP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_DEL_IP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SET_IP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_PR, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_LIFETIME, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_DISPOSITION, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAX_BURST, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_HB, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAXSEG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_STATUS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_DEBUG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
	}
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define tgrp_case_1_9_1_1 test_group_1_9_1
#define numb_case_1_9_1_1 "1.9.1.1"
#define name_case_1_9_1_1 "Perform options management -- T_DEFAULT (none)"
#define sref_case_1_9_1_1 "OpenSS7 Extension"
#define desc_case_1_9_1_1 "\
Checks that all default options are returned when no options are specified in\n\
the T_OPTMGMT_REQ.  The specifications do not indicate what action is taken when\n\
T_DEFAULT is given and the OPT_length is zero.  This OpenSS7 extension returns\n\
all of the known default options as though each had been specified with no\n\
option value."

int
test_case_1_9_1_1(int child)
{
	test_mgmtflags = T_DEFAULT;
	return test_case_1_9_1(child);
}

#define test_case_1_9_1_1_conn	test_case_1_9_1_1
#define test_case_1_9_1_1_resp	test_case_1_9_1_1
#define test_case_1_9_1_1_list	test_case_1_9_1_1

#define preamble_1_9_1_1_conn	preamble_0
#define preamble_1_9_1_1_resp	preamble_0
#define preamble_1_9_1_1_list	preamble_0

#define postamble_1_9_1_1_conn	postamble_0
#define postamble_1_9_1_1_resp	postamble_0
#define postamble_1_9_1_1_list	postamble_0

struct test_stream test_1_9_1_1_conn = { &preamble_1_9_1_1_conn, &test_case_1_9_1_1_conn, &postamble_1_9_1_1_conn };
struct test_stream test_1_9_1_1_resp = { &preamble_1_9_1_1_resp, &test_case_1_9_1_1_resp, &postamble_1_9_1_1_resp };
struct test_stream test_1_9_1_1_list = { &preamble_1_9_1_1_list, &test_case_1_9_1_1_list, &postamble_1_9_1_1_list };

#define tgrp_case_1_9_1_2 test_group_1_9_1
#define numb_case_1_9_1_2 "1.9.1.2"
#define name_case_1_9_1_2 "Perform options management -- T_CURRENT (none)"
#define sref_case_1_9_1_2 "OpenSS7 Extension"
#define desc_case_1_9_1_2 "\
Checks that all current options are returned when no options are specified in\n\
the T_OPTMGMT_REQ.  The specifications do not indicate what action is taken\n\
when T_CURRENT is given and the OPT_length is zero.  This OpenSS7 extension\n\
returns all of the known current options as though each had been specified with\n\
no option value."

int
test_case_1_9_1_2(int child)
{
	test_mgmtflags = T_CURRENT;
	return test_case_1_9_1(child);
}

#define test_case_1_9_1_2_conn	test_case_1_9_1_2
#define test_case_1_9_1_2_resp	test_case_1_9_1_2
#define test_case_1_9_1_2_list	test_case_1_9_1_2

#define preamble_1_9_1_2_conn	preamble_0
#define preamble_1_9_1_2_resp	preamble_0
#define preamble_1_9_1_2_list	preamble_0

#define postamble_1_9_1_2_conn	postamble_0
#define postamble_1_9_1_2_resp	postamble_0
#define postamble_1_9_1_2_list	postamble_0

struct test_stream test_1_9_1_2_conn = { &preamble_1_9_1_2_conn, &test_case_1_9_1_2_conn, &postamble_1_9_1_2_conn };
struct test_stream test_1_9_1_2_resp = { &preamble_1_9_1_2_resp, &test_case_1_9_1_2_resp, &postamble_1_9_1_2_resp };
struct test_stream test_1_9_1_2_list = { &preamble_1_9_1_2_list, &test_case_1_9_1_2_list, &postamble_1_9_1_2_list };

#define tgrp_case_1_9_1_3 test_group_1_9_1
#define numb_case_1_9_1_3 "1.9.1.3"
#define name_case_1_9_1_3 "Perform options management -- T_CHECK (none)"
#define sref_case_1_9_1_3 "OpenSS7 Extension"
#define desc_case_1_9_1_3 "\
Checks that all checked options are returned when no options are specified in\n\
the T_OPTMGMT_REQ.  The specification does not indicate what action is taken\n\
when T_CHECK is given and the OPT_length is zero.  This OpenSS7 extension\n\
returns all of the known checkable options as though each had been specified\n\
with no option value."

int
test_case_1_9_1_3(int child)
{
	test_mgmtflags = T_CHECK;
	return test_case_1_9_1(child);
}

#define test_case_1_9_1_3_conn	test_case_1_9_1_3
#define test_case_1_9_1_3_resp	test_case_1_9_1_3
#define test_case_1_9_1_3_list	test_case_1_9_1_3

#define preamble_1_9_1_3_conn	preamble_0
#define preamble_1_9_1_3_resp	preamble_0
#define preamble_1_9_1_3_list	preamble_0

#define postamble_1_9_1_3_conn	postamble_0
#define postamble_1_9_1_3_resp	postamble_0
#define postamble_1_9_1_3_list	postamble_0

struct test_stream test_1_9_1_3_conn = { &preamble_1_9_1_3_conn, &test_case_1_9_1_3_conn, &postamble_1_9_1_3_conn };
struct test_stream test_1_9_1_3_resp = { &preamble_1_9_1_3_resp, &test_case_1_9_1_3_resp, &postamble_1_9_1_3_resp };
struct test_stream test_1_9_1_3_list = { &preamble_1_9_1_3_list, &test_case_1_9_1_3_list, &postamble_1_9_1_3_list };

#define tgrp_case_1_9_1_4 test_group_1_9_1
#define numb_case_1_9_1_4 "1.9.1.4"
#define name_case_1_9_1_4 "Perform options management -- T_NEGOTIATE (none)"
#define sref_case_1_9_1_4 "TPI Version 2 Draft 2 -- T_OPTMGMT_ACK"
#define desc_case_1_9_1_4 "\
Checks that all negotiated options are returned when no options are specified in\n\
the T_OPTMGMT_REQ.  The specifications say than when T_NEGOTIATE is given and\n\
the OPT_length is zero, that the transport provider is to negotiate and return\n\
the default values for all options."

int
test_case_1_9_1_4(int child)
{
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_9_1(child);
}

#define test_case_1_9_1_4_conn	test_case_1_9_1_4
#define test_case_1_9_1_4_resp	test_case_1_9_1_4
#define test_case_1_9_1_4_list	test_case_1_9_1_4

int
preamble_1_9_1_4(int child)
{
	if (test_level == T_INET_IP)
		return preamble_1(child);
	return preamble_0(child);
}

int
postamble_1_9_1_4(int child)
{
	if (test_level == T_INET_IP)
		return postamble_1(child);
	return postamble_0(child);
}

#define preamble_1_9_1_4_conn	preamble_1_9_1_4
#define preamble_1_9_1_4_resp	preamble_1_9_1_4
#define preamble_1_9_1_4_list	preamble_1_9_1_4

#define postamble_1_9_1_4_conn	postamble_1_9_1_4
#define postamble_1_9_1_4_resp	postamble_1_9_1_4
#define postamble_1_9_1_4_list	postamble_1_9_1_4

struct test_stream test_1_9_1_4_conn = { &preamble_1_9_1_4_conn, &test_case_1_9_1_4_conn, &postamble_1_9_1_4_conn };
struct test_stream test_1_9_1_4_resp = { &preamble_1_9_1_4_resp, &test_case_1_9_1_4_resp, &postamble_1_9_1_4_resp };
struct test_stream test_1_9_1_4_list = { &preamble_1_9_1_4_list, &test_case_1_9_1_4_list, &postamble_1_9_1_4_list };

#define test_group_1_9_2 "Options management -- T_ALLOPT"
#define sref_case_1_9_2 "XNS 5.2 -- Chapter 7 -- Section t_optmgmt"

int
test_case_1_9_2(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;
	struct t_opthdr *oh;
	struct {
		struct t_opthdr opt_hdr1;
		struct t_opthdr opt_hdr2;
#if 0
		struct t_opthdr opt_hdr3;
#endif
#if 1
		struct t_opthdr opt_hdr4;
#endif
#if 0
		struct t_opthdr opt_hdr5;
#endif
	} options = {
		{
		sizeof(struct t_opthdr), XTI_GENERIC, T_ALLOPT, T_SUCCESS}
		, {
		sizeof(struct t_opthdr), T_INET_IP, T_ALLOPT, T_SUCCESS}
#if 0
		, {
		sizeof(struct t_opthdr), T_INET_UDP, T_ALLOPT, T_SUCCESS}
#endif
#if 0
		, {
		sizeof(struct t_opthdr), T_INET_TCP, T_ALLOPT, T_SUCCESS}
#endif
#if 1
		, {
		sizeof(struct t_opthdr), T_INET_SCTP, T_ALLOPT, T_SUCCESS}
#endif
	};
	test_opts = &options;
	test_olen = sizeof(options);
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags == T_FAILURE)
		goto failure;
	state++;
	if (p->optmgmt_ack.OPT_length == 0)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_DEBUG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_LINGER, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_RCVBUF, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_RCVLOWAT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_SNDBUF, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(XTI_GENERIC, XTI_SNDLOWAT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	if (!(oh = find_option(T_INET_IP, T_IP_OPTIONS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_TOS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_TTL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_REUSEADDR, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_DONTROUTE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_BROADCAST, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (!(oh = find_option(T_INET_IP, T_IP_ADDR, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
		goto failure;
	state++;
	if (oh->status == T_FAILURE)
		goto failure;
	state++;
	if (test_level == T_INET_UDP) {
		if (!(oh = find_option(T_INET_UDP, T_UDP_CHECKSUM, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
	}
	if (test_level == T_INET_TCP) {
		if (!(oh = find_option(T_INET_TCP, T_TCP_NODELAY, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_MAXSEG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPALIVE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_CORK, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPIDLE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPINTVL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_KEEPCNT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_SYNCNT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_LINGER2, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_DEFER_ACCEPT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_WINDOW_CLAMP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_INFO, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_TCP, T_TCP_QUICKACK, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
	}
	if (test_level == T_INET_SCTP) {
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_NODELAY, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_CORK, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_PPI, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SID, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SSN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_TSN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RECVOPT, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_COOKIE_LIFE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SACK_DELAY, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO_INITIAL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO_MIN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO_MAX, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_OSTREAMS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ISTREAMS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_COOKIE_INC, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_THROTTLE_ITVL, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAC_TYPE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_CKSUM_TYPE, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ECN, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ALI, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ADD, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SET, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_ADD_IP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_DEL_IP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_SET_IP, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_PR, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_LIFETIME, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_DISPOSITION, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAX_BURST, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_HB, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_RTO, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_MAXSEG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_STATUS, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
		if (!(oh = find_option(T_INET_SCTP, T_SCTP_DEBUG, cbuf, p->optmgmt_ack.OPT_offset, p->optmgmt_ack.OPT_length)))
			goto failure;
		state++;
		if (oh->status == T_FAILURE)
			goto failure;
		state++;
	}
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define tgrp_case_1_9_2_1 test_group_1_9_2
#define numb_case_1_9_2_1 "1.9.2.1"
#define name_case_1_9_2_1 "Perform options management -- T_DEFAULT T_ALLOPT"
#define sref_case_1_9_2_1 sref_case_1_9_2
#define desc_case_1_9_2_1 "\
Checks that all default options under a level are returned when the option name\n\
T_ALLOPT is used.  The specification indicates that when T_ALLOPT is specified\n\
as an option name for a supported level, that the action corresponds to all\n\
known option at that level.  This test should return all known option defaults\n\
at the specified levels."

int
test_case_1_9_2_1(int child)
{
	test_mgmtflags = T_DEFAULT;
	return test_case_1_9_2(child);
}

#define test_case_1_9_2_1_conn	test_case_1_9_2_1
#define test_case_1_9_2_1_resp	test_case_1_9_2_1
#define test_case_1_9_2_1_list	test_case_1_9_2_1

#define preamble_1_9_2_1_conn	preamble_0
#define preamble_1_9_2_1_resp	preamble_0
#define preamble_1_9_2_1_list	preamble_0

#define postamble_1_9_2_1_conn	postamble_0
#define postamble_1_9_2_1_resp	postamble_0
#define postamble_1_9_2_1_list	postamble_0

struct test_stream test_1_9_2_1_conn = { &preamble_1_9_2_1_conn, &test_case_1_9_2_1_conn, &postamble_1_9_2_1_conn };
struct test_stream test_1_9_2_1_resp = { &preamble_1_9_2_1_resp, &test_case_1_9_2_1_resp, &postamble_1_9_2_1_resp };
struct test_stream test_1_9_2_1_list = { &preamble_1_9_2_1_list, &test_case_1_9_2_1_list, &postamble_1_9_2_1_list };

#define tgrp_case_1_9_2_2 test_group_1_9_2
#define numb_case_1_9_2_2 "1.9.2.2"
#define name_case_1_9_2_2 "Perform options management -- T_CURRENT T_ALLOPT"
#define sref_case_1_9_2_2 sref_case_1_9_2
#define desc_case_1_9_2_2 "\
Checks that all current options under a level are returned when the option name\n\
T_ALLOPT is used.  The specification indicates that when T_ALLOPT is specified\n\
as an option name for a supported level, that the action corresponds to all\n\
known option at that level.  This test should return all known option current\n\
at the specified levels."

int
test_case_1_9_2_2(int child)
{
	test_mgmtflags = T_CURRENT;
	return test_case_1_9_2(child);
}

#define test_case_1_9_2_2_conn	test_case_1_9_2_2
#define test_case_1_9_2_2_resp	test_case_1_9_2_2
#define test_case_1_9_2_2_list	test_case_1_9_2_2

#define preamble_1_9_2_2_conn	preamble_0
#define preamble_1_9_2_2_resp	preamble_0
#define preamble_1_9_2_2_list	preamble_0

#define postamble_1_9_2_2_conn	postamble_0
#define postamble_1_9_2_2_resp	postamble_0
#define postamble_1_9_2_2_list	postamble_0

struct test_stream test_1_9_2_2_conn = { &preamble_1_9_2_2_conn, &test_case_1_9_2_2_conn, &postamble_1_9_2_2_conn };
struct test_stream test_1_9_2_2_resp = { &preamble_1_9_2_2_resp, &test_case_1_9_2_2_resp, &postamble_1_9_2_2_resp };
struct test_stream test_1_9_2_2_list = { &preamble_1_9_2_2_list, &test_case_1_9_2_2_list, &postamble_1_9_2_2_list };

#define tgrp_case_1_9_2_3 test_group_1_9_2
#define numb_case_1_9_2_3 "1.9.2.3"
#define name_case_1_9_2_3 "Perform options management -- T_CHECK T_ALLOPT"
#define sref_case_1_9_2_3 sref_case_1_9_2
#define desc_case_1_9_2_3 "\
Checks that all checked options under a level are returned when the option name\n\
T_ALLOPT is used.  The specification indicates that whenever T_ALLOPT is\n\
specified with management flags T_CHECK that the response should be a\n\
T_ERROR_ACK primitive with error TBADOPT.  This implementation returns all of\n\
the checkable options at the specified level as though each were specified\n\
without a value in the T_OPTMGMT_REQ.  This is not standard behavior and should\n\
not be used by portable programs."

int
test_case_1_9_2_3(int child)
{
	test_mgmtflags = T_CHECK;
	return test_case_1_9_2(child);
}

#define test_case_1_9_2_3_conn	test_case_1_9_2_3
#define test_case_1_9_2_3_resp	test_case_1_9_2_3
#define test_case_1_9_2_3_list	test_case_1_9_2_3

#define preamble_1_9_2_3_conn	preamble_0
#define preamble_1_9_2_3_resp	preamble_0
#define preamble_1_9_2_3_list	preamble_0

#define postamble_1_9_2_3_conn	postamble_0
#define postamble_1_9_2_3_resp	postamble_0
#define postamble_1_9_2_3_list	postamble_0

struct test_stream test_1_9_2_3_conn = { &preamble_1_9_2_3_conn, &test_case_1_9_2_3_conn, &postamble_1_9_2_3_conn };
struct test_stream test_1_9_2_3_resp = { &preamble_1_9_2_3_resp, &test_case_1_9_2_3_resp, &postamble_1_9_2_3_resp };
struct test_stream test_1_9_2_3_list = { &preamble_1_9_2_3_list, &test_case_1_9_2_3_list, &postamble_1_9_2_3_list };

#define tgrp_case_1_9_2_4 test_group_1_9_2
#define numb_case_1_9_2_4 "1.9.2.4"
#define name_case_1_9_2_4 "Perform options management -- T_NEGOTIATE T_ALLOPT"
#define sref_case_1_9_2_4 sref_case_1_9_2
#define desc_case_1_9_2_4 "\
Checks that all negotiated options under a level are returned when the option name\n\
T_ALLOPT is used.  The specification indicates that when T_ALLOPT is specified\n\
as an option name for a supported level, that the action corresponds to all\n\
known option at that level.  This test should return all known option negotiated\n\
to the default values at the specified levels."

int
test_case_1_9_2_4(int child)
{
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_9_2(child);
}

#define test_case_1_9_2_4_conn	test_case_1_9_2_4
#define test_case_1_9_2_4_resp	test_case_1_9_2_4
#define test_case_1_9_2_4_list	test_case_1_9_2_4

int
preamble_1_9_2_4(int child)
{
	if (test_level == T_INET_IP)
		return preamble_1(child);
	return preamble_0(child);
}

int
postamble_1_9_2_4(int child)
{
	if (test_level == T_INET_IP)
		return postamble_1(child);
	return postamble_0(child);
}

#define preamble_1_9_2_4_conn	preamble_1_9_2_4
#define preamble_1_9_2_4_resp	preamble_1_9_2_4
#define preamble_1_9_2_4_list	preamble_1_9_2_4

#define postamble_1_9_2_4_conn	postamble_1_9_2_4
#define postamble_1_9_2_4_resp	postamble_1_9_2_4
#define postamble_1_9_2_4_list	postamble_1_9_2_4

struct test_stream test_1_9_2_4_conn = { &preamble_1_9_2_4_conn, &test_case_1_9_2_4_conn, &postamble_1_9_2_4_conn };
struct test_stream test_1_9_2_4_resp = { &preamble_1_9_2_4_resp, &test_case_1_9_2_4_resp, &postamble_1_9_2_4_resp };
struct test_stream test_1_9_2_4_list = { &preamble_1_9_2_4_list, &test_case_1_9_2_4_list, &postamble_1_9_2_4_list };

#define test_group_1_9_3 "Options management -- illegal options"
#define sref_case_1_9_3 "TPI 2.2 T_OPTMGMT_ACK, XNS 5.2 t_optmgmt"

int
test_case_1_9_3(int child)
{
	struct t_opthdr opt_hdr = { sizeof(struct t_opthdr) + 100, XTI_GENERIC, XTI_DEBUG, T_SUCCESS };

	test_opts = &opt_hdr;
	test_olen = sizeof(opt_hdr);
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADOPT)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define tgrp_case_1_9_3_1 test_group_1_9_3
#define numb_case_1_9_3_1 "1.9.3.1"
#define name_case_1_9_3_1 "Perform options management -- T_DEFAULT (illegal)"
#define sref_case_1_9_3_1 sref_case_1_9_3
#define desc_case_1_9_3_1 "\
Checks that T_DEFAULT given with an illegal option results in failure.\n\
According to the specification, when an illegal option is given in\n\
T_OPTMGMT_REQ, the result is a T_ERROR_ACK with an error of TBADOPT.\n\
The tests are separated by management flag because the implementation\n\
follows different code paths for each management flag."

int
test_case_1_9_3_1(int child)
{
	test_mgmtflags = T_DEFAULT;
	return test_case_1_9_3(child);
}

#define test_case_1_9_3_1_conn	test_case_1_9_3_1
#define test_case_1_9_3_1_resp	test_case_1_9_3_1
#define test_case_1_9_3_1_list	test_case_1_9_3_1

#define preamble_1_9_3_1_conn	preamble_0
#define preamble_1_9_3_1_resp	preamble_0
#define preamble_1_9_3_1_list	preamble_0

#define postamble_1_9_3_1_conn	postamble_0
#define postamble_1_9_3_1_resp	postamble_0
#define postamble_1_9_3_1_list	postamble_0

struct test_stream test_1_9_3_1_conn = { &preamble_1_9_3_1_conn, &test_case_1_9_3_1_conn, &postamble_1_9_3_1_conn };
struct test_stream test_1_9_3_1_resp = { &preamble_1_9_3_1_resp, &test_case_1_9_3_1_resp, &postamble_1_9_3_1_resp };
struct test_stream test_1_9_3_1_list = { &preamble_1_9_3_1_list, &test_case_1_9_3_1_list, &postamble_1_9_3_1_list };

#define test_group_1_9_3 "Options management -- illegal options"
#define tgrp_case_1_9_3_2 test_group_1_9_3
#define numb_case_1_9_3_2 "1.9.3.2"
#define name_case_1_9_3_2 "Perform options management -- T_CURRENT (illegal)"
#define sref_case_1_9_3_2 sref_case_1_9_3
#define desc_case_1_9_3_2 "\
Checks that T_CURRENT given with an illegal option results in failure.\n\
According to the specification, when an illegal option is given in\n\
T_OPTMGMT_REQ, the result is a T_ERROR_ACK with an error of TBADOPT.\n\
The tests are separated by management flag because the implementation\n\
follows different code paths for each management flag."

int
test_case_1_9_3_2(int child)
{
	test_mgmtflags = T_CURRENT;
	return test_case_1_9_3(child);
}

#define test_case_1_9_3_2_conn	test_case_1_9_3_2
#define test_case_1_9_3_2_resp	test_case_1_9_3_2
#define test_case_1_9_3_2_list	test_case_1_9_3_2

#define preamble_1_9_3_2_conn	preamble_0
#define preamble_1_9_3_2_resp	preamble_0
#define preamble_1_9_3_2_list	preamble_0

#define postamble_1_9_3_2_conn	postamble_0
#define postamble_1_9_3_2_resp	postamble_0
#define postamble_1_9_3_2_list	postamble_0

struct test_stream test_1_9_3_2_conn = { &preamble_1_9_3_2_conn, &test_case_1_9_3_2_conn, &postamble_1_9_3_2_conn };
struct test_stream test_1_9_3_2_resp = { &preamble_1_9_3_2_resp, &test_case_1_9_3_2_resp, &postamble_1_9_3_2_resp };
struct test_stream test_1_9_3_2_list = { &preamble_1_9_3_2_list, &test_case_1_9_3_2_list, &postamble_1_9_3_2_list };

#define test_group_1_9_3 "Options management -- illegal options"
#define tgrp_case_1_9_3_3 test_group_1_9_3
#define numb_case_1_9_3_3 "1.9.3.3"
#define name_case_1_9_3_3 "Perform options management -- T_CHECK (illegal)"
#define sref_case_1_9_3_3 sref_case_1_9_3
#define desc_case_1_9_3_3 "\
Checks that T_CHECK given with an illegal option results in failure.\n\
According to the specification, when an illegal option is given in\n\
T_OPTMGMT_REQ, the result is a T_ERROR_ACK with an error of TBADOPT.\n\
The tests are separated by management flag because the implementation\n\
follows different code paths for each management flag."

int
test_case_1_9_3_3(int child)
{
	test_mgmtflags = T_CHECK;
	return test_case_1_9_3(child);
}

#define test_case_1_9_3_3_conn	test_case_1_9_3_3
#define test_case_1_9_3_3_resp	test_case_1_9_3_3
#define test_case_1_9_3_3_list	test_case_1_9_3_3

#define preamble_1_9_3_3_conn	preamble_0
#define preamble_1_9_3_3_resp	preamble_0
#define preamble_1_9_3_3_list	preamble_0

#define postamble_1_9_3_3_conn	postamble_0
#define postamble_1_9_3_3_resp	postamble_0
#define postamble_1_9_3_3_list	postamble_0

struct test_stream test_1_9_3_3_conn = { &preamble_1_9_3_3_conn, &test_case_1_9_3_3_conn, &postamble_1_9_3_3_conn };
struct test_stream test_1_9_3_3_resp = { &preamble_1_9_3_3_resp, &test_case_1_9_3_3_resp, &postamble_1_9_3_3_resp };
struct test_stream test_1_9_3_3_list = { &preamble_1_9_3_3_list, &test_case_1_9_3_3_list, &postamble_1_9_3_3_list };

#define test_group_1_9_3 "Options management -- illegal options"
#define tgrp_case_1_9_3_4 test_group_1_9_3
#define numb_case_1_9_3_4 "1.9.3.4"
#define name_case_1_9_3_4 "Perform options management -- T_NEGOTIATE (illegal)"
#define sref_case_1_9_3_4 sref_case_1_9_3
#define desc_case_1_9_3_4 "\
Checks that T_NEGOTIATE given with an illegal option results in failure.\n\
According to the specification, when an illegal option is given in\n\
T_OPTMGMT_REQ, the result is a T_ERROR_ACK with an error of TBADOPT.\n\
The tests are separated by management flag because the implementation\n\
follows different code paths for each management flag."

int
test_case_1_9_3_4(int child)
{
	test_mgmtflags = T_NEGOTIATE;
	return test_case_1_9_3(child);
}

#define test_case_1_9_3_4_conn	test_case_1_9_3_4
#define test_case_1_9_3_4_resp	test_case_1_9_3_4
#define test_case_1_9_3_4_list	test_case_1_9_3_4

#define preamble_1_9_3_4_conn	preamble_0
#define preamble_1_9_3_4_resp	preamble_0
#define preamble_1_9_3_4_list	preamble_0

#define postamble_1_9_3_4_conn	postamble_0
#define postamble_1_9_3_4_resp	postamble_0
#define postamble_1_9_3_4_list	postamble_0

struct test_stream test_1_9_3_4_conn = { &preamble_1_9_3_4_conn, &test_case_1_9_3_4_conn, &postamble_1_9_3_4_conn };
struct test_stream test_1_9_3_4_resp = { &preamble_1_9_3_4_resp, &test_case_1_9_3_4_resp, &postamble_1_9_3_4_resp };
struct test_stream test_1_9_3_4_list = { &preamble_1_9_3_4_list, &test_case_1_9_3_4_list, &postamble_1_9_3_4_list };

/*
 *  Bind and unbind three streams.
 */
#define test_group_1_10 "Local management -- Bind and unbind."
#define sref_case_1_10 "TPI Rev 1.5 Sections 2.1.1.2, 2.1.2.2, 2.1.2.4"
#define tgrp_case_1_10_1 test_group_1_10
#define numb_case_1_10_1 "1.10.1"
#define name_case_1_10_1 "Bind and unbind three streams."
#define sref_case_1_10_1 sref_case_1_10
#define desc_case_1_10_1 "\
Checks that three streams can be bound and unbound.  One is bound to\n\
a normal address, another to a null address, the last to a wildcard\n\
address."

int
test_case_1_10_1(int child, struct sockaddr_in *addr, socklen_t len)
{
	test_addr = addr;
	test_alen = len;
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_10_1_conn(int child)
{
	return test_case_1_10_1(child, addrs[0], sizeof(addrs[0]));
}

int
test_case_1_10_1_resp(int child)
{
	if (test_level != T_INET_IP)
		return test_case_1_10_1(child, NULL, 0);
	else {
		union T_primitives *p = (typeof(p)) cbuf;

		test_addr = NULL;
		test_alen = 0;
		last_qlen = 0;
		if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, SHORT_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (p->error_ack.TLI_error != TNOADDR)
			goto failure;
		state++;
		if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, SHORT_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, SHORT_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (p->error_ack.TLI_error != TOUTSTATE)
			goto failure;
		state++;
		return (__RESULT_SUCCESS);
	      failure:
		return (__RESULT_FAILURE);
	}
}
int
test_case_1_10_1_list(int child)
{
	addrs[3][0].sin_addr.s_addr = INADDR_ANY;
	return test_case_1_10_1(child, addrs[3], sizeof(addrs[3][0]));
}

#define preamble_1_10_1_conn	preamble_0
#define preamble_1_10_1_resp	preamble_0
#define preamble_1_10_1_list	preamble_0

#define postamble_1_10_1_conn	postamble_0
#define postamble_1_10_1_resp	postamble_0
#define postamble_1_10_1_list	postamble_0

struct test_stream test_1_10_1_conn = { &preamble_1_10_1_conn, &test_case_1_10_1_conn, &postamble_1_10_1_conn };
struct test_stream test_1_10_1_resp = { &preamble_1_10_1_resp, &test_case_1_10_1_resp, &postamble_1_10_1_resp };
struct test_stream test_1_10_1_list = { &preamble_1_10_1_list, &test_case_1_10_1_list, &postamble_1_10_1_list };

#define tgrp_case_1_10_2 test_group_1_10
#define numb_case_1_10_2 "1.10.2"
#define name_case_1_10_2 "Bind three streams to same address without reuse."
#define sref_case_1_10_2 sref_case_1_10
#define desc_case_1_10_2 "\
Check that an attempt to bind three streams to the same address\n\
will result in one success and two failures.  Rawip streams do\n\
not care about reuse, so all streams will succeed for rawip."

int
test_case_1_10_2_conn(int child)
{
	test_addr = addrs[0];
	test_alen = anums[0]*sizeof(addrs[0][0]);
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	test_msleep(child, LONG_WAIT);
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_10_2_resp(int child)
{
	if (expect(child, SHORT_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[0];
	test_alen = anums[0]*sizeof(addrs[0][0]);
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_level == T_INET_IP) {
		if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
			goto failure;
	} else {
		if (expect(child, SHORT_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_1_10_2_list(int child)
{
	if (expect(child, SHORT_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[0];
	test_alen = anums[0]*sizeof(addrs[0][0]);
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_level == T_INET_IP) {
		if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
			goto failure;
	} else {
		if (expect(child, SHORT_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_1_10_2_conn	preamble_0
#define preamble_1_10_2_resp	preamble_0
#define preamble_1_10_2_list	preamble_0

#define postamble_1_10_2_conn	postamble_0
#define postamble_1_10_2_resp	postamble_0
#define postamble_1_10_2_list	postamble_0

struct test_stream test_1_10_2_conn = { &preamble_1_10_2_conn, &test_case_1_10_2_conn, &postamble_1_10_2_conn };
struct test_stream test_1_10_2_resp = { &preamble_1_10_2_resp, &test_case_1_10_2_resp, &postamble_1_10_2_resp };
struct test_stream test_1_10_2_list = { &preamble_1_10_2_list, &test_case_1_10_2_list, &postamble_1_10_2_list };

#define tgrp_case_1_10_3 test_group_1_10
#define numb_case_1_10_3 "1.10.3"
#define name_case_1_10_3 "Bind three streams to same address with reuse."
#define sref_case_1_10_3 sref_case_1_10
#define desc_case_1_10_3 "\
Check that an attempt to bind three streams to the same address\n\
with T_IP_REUSEADDR should result in three successes."

int
test_case_1_10_3(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_YES};
	if (test_level == T_INET_IP) {
		test_addr = addrs[0];
		test_alen = anums[0]*sizeof(addrs[0][0]);
		last_qlen = 0;
		if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	test_opts = &options;
	test_olen = sizeof(options);
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags != T_SUCCESS)
		goto failure;
	state++;
	if (test_level != T_INET_IP) {
		test_addr = addrs[0];
		test_alen = anums[0]*sizeof(addrs[0][0]);
		last_qlen = 0;
		if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.CURRENT_state != TS_IDLE)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	test_msleep(child, LONG_WAIT * 2);
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_3_conn test_case_1_10_3
#define test_case_1_10_3_resp test_case_1_10_3
#define test_case_1_10_3_list test_case_1_10_3

#define preamble_1_10_3_conn	preamble_0
#define preamble_1_10_3_resp	preamble_0
#define preamble_1_10_3_list	preamble_0

#define postamble_1_10_3_conn	postamble_0
#define postamble_1_10_3_resp	postamble_0
#define postamble_1_10_3_list	postamble_0

struct test_stream test_1_10_3_conn = { &preamble_1_10_3_conn, &test_case_1_10_3_conn, &postamble_1_10_3_conn };
struct test_stream test_1_10_3_resp = { &preamble_1_10_3_resp, &test_case_1_10_3_resp, &postamble_1_10_3_resp };
struct test_stream test_1_10_3_list = { &preamble_1_10_3_list, &test_case_1_10_3_list, &postamble_1_10_3_list };

#define tgrp_case_1_10_4 test_group_1_10
#define numb_case_1_10_4 "1.10.4"
#define name_case_1_10_4 "Double bind on three streams."
#define sref_case_1_10_4 "TPI Version 2 Draft 2 T_BIND_REQ [TOUTSTATE]"
#define desc_case_1_10_4 "\
Check that an attempt to bind three streams twice to each address results in\n\
failure.  This is a simple test of a common interface state violation."

int
test_case_1_10_4(int child)
{
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_4_conn test_case_1_10_4
#define test_case_1_10_4_resp test_case_1_10_4
#define test_case_1_10_4_list test_case_1_10_4

#define preamble_1_10_4_conn preamble_1
#define preamble_1_10_4_resp preamble_1
#define preamble_1_10_4_list preamble_1

#define postamble_1_10_4_conn postamble_1
#define postamble_1_10_4_resp postamble_1
#define postamble_1_10_4_list postamble_1

struct test_stream test_1_10_4_conn = { &preamble_1_10_4_conn, &test_case_1_10_4_conn, &postamble_1_10_4_conn };
struct test_stream test_1_10_4_resp = { &preamble_1_10_4_resp, &test_case_1_10_4_resp, &postamble_1_10_4_resp };
struct test_stream test_1_10_4_list = { &preamble_1_10_4_list, &test_case_1_10_4_list, &postamble_1_10_4_list };

#define tgrp_case_1_10_5 test_group_1_10
#define numb_case_1_10_5 "1.10.5"
#define name_case_1_10_5 "Double bind/unbind on three streams."
#define sref_case_1_10_5 sref_case_1_10
#define desc_case_1_10_5 "\
Check that an attempt to bind and unbind three streams twice to\n\
each address results in success."

int
test_case_1_10_5(int child)
{
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_5_conn test_case_1_10_5
#define test_case_1_10_5_resp test_case_1_10_5
#define test_case_1_10_5_list test_case_1_10_5

#define preamble_1_10_5_conn preamble_1
#define preamble_1_10_5_resp preamble_1
#define preamble_1_10_5_list preamble_1

#define postamble_1_10_5_conn postamble_1
#define postamble_1_10_5_resp postamble_1
#define postamble_1_10_5_list postamble_1

struct test_stream test_1_10_5_conn = { &preamble_1_10_5_conn, &test_case_1_10_5_conn, &postamble_1_10_5_conn };
struct test_stream test_1_10_5_resp = { &preamble_1_10_5_resp, &test_case_1_10_5_resp, &postamble_1_10_5_resp };
struct test_stream test_1_10_5_list = { &preamble_1_10_5_list, &test_case_1_10_5_list, &postamble_1_10_5_list };

#define tgrp_case_1_10_6 test_group_1_10
#define numb_case_1_10_6 "1.10.6"
#define name_case_1_10_6 "Unbind from unbound on three streams."
#define sref_case_1_10_6 "TPI Version 2 Draft 2 T_UNBIND_REQ [TOUTSTATE]"
#define desc_case_1_10_6 "\
Check that an attempt to and unbind three streams, already in the unbound\n\
state, results in failure.  This is a simple tests of a common interface\n\
state violation."

int
test_case_1_10_6(int child)
{
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_6_conn test_case_1_10_6
#define test_case_1_10_6_resp test_case_1_10_6
#define test_case_1_10_6_list test_case_1_10_6

#define preamble_1_10_6_conn preamble_0
#define preamble_1_10_6_resp preamble_0
#define preamble_1_10_6_list preamble_0

#define postamble_1_10_6_conn postamble_0
#define postamble_1_10_6_resp postamble_0
#define postamble_1_10_6_list postamble_0

struct test_stream test_1_10_6_conn = { &preamble_1_10_6_conn, &test_case_1_10_6_conn, &postamble_1_10_6_conn };
struct test_stream test_1_10_6_resp = { &preamble_1_10_6_resp, &test_case_1_10_6_resp, &postamble_1_10_6_resp };
struct test_stream test_1_10_6_list = { &preamble_1_10_6_list, &test_case_1_10_6_list, &postamble_1_10_6_list };

#define tgrp_case_1_10_7 test_group_1_10
#define numb_case_1_10_7 "1.10.7"
#define name_case_1_10_7 "Double bind/unbind on three streams."
#define sref_case_1_10_7 sref_case_1_10
#define desc_case_1_10_7 "\
Check that an attempt to bind and unbind three streams twice to\n\
each address results in success."

int
test_case_1_10_7(int child)
{
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_7_conn test_case_1_10_7
#define test_case_1_10_7_resp test_case_1_10_7
#define test_case_1_10_7_list test_case_1_10_7

#define preamble_1_10_7_conn preamble_1
#define preamble_1_10_7_resp preamble_1
#define preamble_1_10_7_list preamble_1

#define postamble_1_10_7_conn postamble_0
#define postamble_1_10_7_resp postamble_0
#define postamble_1_10_7_list postamble_0

struct test_stream test_1_10_7_conn = { &preamble_1_10_7_conn, &test_case_1_10_7_conn, &postamble_1_10_7_conn };
struct test_stream test_1_10_7_resp = { &preamble_1_10_7_resp, &test_case_1_10_7_resp, &postamble_1_10_7_resp };
struct test_stream test_1_10_7_list = { &preamble_1_10_7_list, &test_case_1_10_7_list, &postamble_1_10_7_list };

#define tgrp_case_1_10_8 test_group_1_10
#define numb_case_1_10_8 "1.10.8"
#define name_case_1_10_8 "Bind streams with a bad address -- too short"
#define sref_case_1_10_8 "TPI Version 2 Draft 2 T_BIND_REQ [TBADADDR]"
#define desc_case_1_10_8 "\
Checks that an attempt to bind a stream with an address that is too short will\n\
result in error TBADADDR.  The specification states that an address that is\n\
illegally formatted (e.g. too long or too short) will result in error TBADADDR.\n\
This test case is for too short.  We do not use a multiple of the socket address\n\
size because that is acceptable to SCTP."

int
test_case_1_10_8(int child)
{
	test_addr = addrs[child];
	test_alen = sizeof(addrs[child][0]) >> 1;
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TBADADDR)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_8_conn test_case_1_10_8
#define test_case_1_10_8_resp test_case_1_10_8
#define test_case_1_10_8_list test_case_1_10_8

#define preamble_1_10_8_conn preamble_0
#define preamble_1_10_8_resp preamble_0
#define preamble_1_10_8_list preamble_0

#define postamble_1_10_8_conn postamble_0
#define postamble_1_10_8_resp postamble_0
#define postamble_1_10_8_list postamble_0

struct test_stream test_1_10_8_conn = { &preamble_1_10_8_conn, &test_case_1_10_8_conn, &postamble_1_10_8_conn };
struct test_stream test_1_10_8_resp = { &preamble_1_10_8_resp, &test_case_1_10_8_resp, &postamble_1_10_8_resp };
struct test_stream test_1_10_8_list = { &preamble_1_10_8_list, &test_case_1_10_8_list, &postamble_1_10_8_list };

#define tgrp_case_1_10_9 test_group_1_10
#define numb_case_1_10_9 "1.10.9"
#define name_case_1_10_9 "Bind streams with a bad address -- too long"
#define sref_case_1_10_9 "TPI Version 2 Draft 2 T_BIND_REQ [TBADADDR]"
#define desc_case_1_10_9 "\
Checks that an attempt to bind a stream with an address that is too long will\n\
result in error TBADADDR.  The specification states that an address that is\n\
illegally formatted (e.g. too long or too short) will result in error TBADADDR.\n\
This test case is for too long.  We do not use a multiple of the socket address\n\
size because that is acceptable to SCTP."

int
test_case_1_10_9(int child)
{
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]) + 1;
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TBADADDR)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_9_conn test_case_1_10_9
#define test_case_1_10_9_resp test_case_1_10_9
#define test_case_1_10_9_list test_case_1_10_9

#define preamble_1_10_9_conn preamble_0
#define preamble_1_10_9_resp preamble_0
#define preamble_1_10_9_list preamble_0

#define postamble_1_10_9_conn postamble_0
#define postamble_1_10_9_resp postamble_0
#define postamble_1_10_9_list postamble_0

struct test_stream test_1_10_9_conn = { &preamble_1_10_9_conn, &test_case_1_10_9_conn, &postamble_1_10_9_conn };
struct test_stream test_1_10_9_resp = { &preamble_1_10_9_resp, &test_case_1_10_9_resp, &postamble_1_10_9_resp };
struct test_stream test_1_10_9_list = { &preamble_1_10_9_list, &test_case_1_10_9_list, &postamble_1_10_9_list };

#define tgrp_case_1_10_10 test_group_1_10
#define numb_case_1_10_10 "1.10.10"
#define name_case_1_10_10 "Bind streams to unassignable address -- TNOADDR"
#define sref_case_1_10_10 "TPI Version 2 Draft 2 T_BIND_REQ [TNOADDR]"
#define desc_case_1_10_10 "\
Checks that an attempt to bind to an unassignable address results in failure\n\
with error TNOADDR.  There are two ways of specifying an unassignable address\n\
for RAWIP: on is to provide an ADDR_length of zero; the other is to use a\n\
wildcard socket address as an address.  Both versions are tested.  For UDP and\n\
TCP there is no way to specify an unassignable address so the test is reversed\n\
for UDP and TCP."

int
test_case_1_10_10(int child)
{
	struct sockaddr_in addr = { AF_INET, 0, {0} };

	test_addr = NULL;
	test_alen = 0;
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_level == T_INET_IP) {
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (last_t_errno != TNOADDR)
			goto failure;
	} else {
		if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_addr = &addr;
	test_alen = sizeof(addr);
	last_qlen = 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (test_level == T_INET_IP) {
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (last_t_errno != TNOADDR)
			goto failure;
	} else {
		if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_10_conn	test_case_1_10_10
#define test_case_1_10_10_resp	test_case_1_10_10
#define test_case_1_10_10_list	test_case_1_10_10

#define preamble_1_10_10_conn	preamble_0
#define preamble_1_10_10_resp	preamble_0
#define preamble_1_10_10_list	preamble_0

#define postamble_1_10_10_conn	postamble_0
#define postamble_1_10_10_resp	postamble_0
#define postamble_1_10_10_list	postamble_0

struct test_stream test_1_10_10_conn = { &preamble_1_10_10_conn, &test_case_1_10_10_conn, &postamble_1_10_10_conn };
struct test_stream test_1_10_10_resp = { &preamble_1_10_10_resp, &test_case_1_10_10_resp, &postamble_1_10_10_resp };
struct test_stream test_1_10_10_list = { &preamble_1_10_10_list, &test_case_1_10_10_list, &postamble_1_10_10_list };

#define tgrp_case_1_10_11 test_group_1_10
#define numb_case_1_10_11 "1.10.11"
#define name_case_1_10_11 "Bind streams with non-zero CONNIND_number"
#define sref_case_1_10_11 "TPI Version 2 Draft 2 T_BIND_REQ [CONNIND_number]"
#define desc_case_1_10_11 "\
Checks that an attempt to bind to wildcard and non-wildcard addresses and with a\n\
non-zero CONNINND_number results in failure for T_COTS or T_COTS_ORD service,\n\
while it is successful for T_CLTS service."

int
test_case_1_10_11(int child)
{
	struct sockaddr_in addr = { AF_INET, addrs[child][0].sin_port,
		{child == 0 ? 0 : addrs[child][0].sin_addr.s_addr}
	};

	test_addr = &addr;
	test_alen = sizeof(addr);
	last_qlen = 5;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_1_10_11_conn	test_case_1_10_10
#define test_case_1_10_11_resp	test_case_1_10_10
#define test_case_1_10_11_list	test_case_1_10_10

#define preamble_1_10_11_conn	preamble_0
#define preamble_1_10_11_resp	preamble_0
#define preamble_1_10_11_list	preamble_0

#define postamble_1_10_11_conn	postamble_0
#define postamble_1_10_11_resp	postamble_0
#define postamble_1_10_11_list	postamble_0

struct test_stream test_1_10_11_conn = { &preamble_1_10_11_conn, &test_case_1_10_11_conn, &postamble_1_10_11_conn };
struct test_stream test_1_10_11_resp = { &preamble_1_10_11_resp, &test_case_1_10_11_resp, &postamble_1_10_11_resp };
struct test_stream test_1_10_11_list = { &preamble_1_10_11_list, &test_case_1_10_11_list, &postamble_1_10_11_list };

/*
 *  Transfer connectionless data.
 */
#define test_group_2 "Connectionless Data transfer"
#define tgrp_case_2_2 test_group_2
#define numb_case_2_2 "2.2"
#define name_case_2_2 "Transfer connectionless data."
#define sref_case_2_2 "XNS 5.2 -- Chapter 6 -- The Use of Options in XTI"
#define desc_case_2_2 "\
Attempts to transfer connectionless data."

int
test_case_2_2(int child, struct sockaddr_in *addr, socklen_t len)
{
	const char msg[] = "Unit test data.";

	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	test_addr = addr;
	test_alen = len;
	test_data = msg;
	if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (start_tt(TEST_DURATION) != __RESULT_SUCCESS)
		goto failure;
	for (;;) {
		state++;
		switch (wait_event(child, NORMAL_WAIT)) {
		case __EVENT_NO_MSG:
			continue;
		case __TEST_UNITDATA_IND:
			if (last_info.SERV_type != T_CLTS)
				goto failure;
			break;
		case __RESULT_FAILURE:
			if (last_info.SERV_type == T_CLTS)
				goto failure;
			state++;
			if (last_errno != EPROTO)
				goto failure;
			break;
		default:
			goto failure;
		}
		break;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_2_2_conn(int child)
{
	return test_case_2_2(child, addrs[1], sizeof(addrs[1]));
}

int
test_case_2_2_resp(int child)
{
	return test_case_2_2(child, addrs[2], sizeof(addrs[2]));
}

int
test_case_2_2_list(int child)
{
	return test_case_2_2(child, addrs[0], sizeof(addrs[0]));
}

int
postamble_2_2(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_0(child);
	else
		return postamble_1(child);
}

#define preamble_2_2_conn	preamble_1s
#define preamble_2_2_resp	preamble_1s
#define preamble_2_2_list	preamble_1s

#define postamble_2_2_conn	postamble_2_2
#define postamble_2_2_resp	postamble_2_2
#define postamble_2_2_list	postamble_2_2

struct test_stream test_2_2_conn = { &preamble_2_2_conn, &test_case_2_2_conn, &postamble_2_2_conn };
struct test_stream test_2_2_resp = { &preamble_2_2_resp, &test_case_2_2_resp, &postamble_2_2_resp };
struct test_stream test_2_2_list = { &preamble_2_2_list, &test_case_2_2_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- XTI_DEBUG
 */
#define test_group_2_2_1 "Connectionless Data Transfer -- XTI options"
#define tgrp_case_2_2_1_1 test_group_2_2_1
#define numb_case_2_2_1_1 "2.2.1.1"
#define name_case_2_2_1_1 "Transfer connectionless data with options -- XTI_DEBUG"
#define sref_case_2_2_1_1 sref_case_2_2
#define desc_case_2_2_1_1 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is XTI_DEBUG.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_1_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_1_1_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_1_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_1_1_conn = { &preamble_2_2_conn, &test_case_2_2_1_1_conn, &postamble_2_2_conn };
struct test_stream test_2_2_1_1_resp = { &preamble_2_2_resp, &test_case_2_2_1_1_resp, &postamble_2_2_resp };
struct test_stream test_2_2_1_1_list = { &preamble_2_2_list, &test_case_2_2_1_1_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- XTI_LINGER
 */
#define tgrp_case_2_2_1_2 test_group_2_2_1
#define numb_case_2_2_1_2 "2.2.1.2"
#define name_case_2_2_1_2 "Transfer connectionless data with options -- XTI_LINGER"
#define sref_case_2_2_1_2 sref_case_2_2
#define desc_case_2_2_1_2 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is XTI_LINGER.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_1_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_1_2_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_1_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_1_2_conn = { &preamble_2_2_conn, &test_case_2_2_1_2_conn, &postamble_2_2_conn };
struct test_stream test_2_2_1_2_resp = { &preamble_2_2_resp, &test_case_2_2_1_2_resp, &postamble_2_2_resp };
struct test_stream test_2_2_1_2_list = { &preamble_2_2_list, &test_case_2_2_1_2_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- XTI_RCVBUF
 */
#define tgrp_case_2_2_1_3 test_group_2_2_1
#define numb_case_2_2_1_3 "2.2.1.3"
#define name_case_2_2_1_3 "Transfer connectionless data with options -- XTI_RCVBUF"
#define sref_case_2_2_1_3 sref_case_2_2
#define desc_case_2_2_1_3 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is XTI_RCVBUF.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_1_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_1_3_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_1_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_1_3_conn = { &preamble_2_2_conn, &test_case_2_2_1_3_conn, &postamble_2_2_conn };
struct test_stream test_2_2_1_3_resp = { &preamble_2_2_resp, &test_case_2_2_1_3_resp, &postamble_2_2_resp };
struct test_stream test_2_2_1_3_list = { &preamble_2_2_list, &test_case_2_2_1_3_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- XTI_RCVLOWAT
 */
#define tgrp_case_2_2_1_4 test_group_2_2_1
#define numb_case_2_2_1_4 "2.2.1.4"
#define name_case_2_2_1_4 "Transfer connectionless data with options -- XTI_RCVLOWAT"
#define sref_case_2_2_1_4 sref_case_2_2
#define desc_case_2_2_1_4 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is XTI_RCVLOWAT.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_1_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_1_4_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_1_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_1_4_conn = { &preamble_2_2_conn, &test_case_2_2_1_4_conn, &postamble_2_2_conn };
struct test_stream test_2_2_1_4_resp = { &preamble_2_2_resp, &test_case_2_2_1_4_resp, &postamble_2_2_resp };
struct test_stream test_2_2_1_4_list = { &preamble_2_2_list, &test_case_2_2_1_4_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- XTI_SNDBUF
 */
#define tgrp_case_2_2_1_5 test_group_2_2_1
#define numb_case_2_2_1_5 "2.2.1.5"
#define name_case_2_2_1_5 "Transfer connectionless data with options -- XTI_SNDBUF"
#define sref_case_2_2_1_5 sref_case_2_2
#define desc_case_2_2_1_5 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is XTI_SNDBUF.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_1_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_1_5_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_1_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_1_5_conn = { &preamble_2_2_conn, &test_case_2_2_1_5_conn, &postamble_2_2_conn };
struct test_stream test_2_2_1_5_resp = { &preamble_2_2_resp, &test_case_2_2_1_5_resp, &postamble_2_2_resp };
struct test_stream test_2_2_1_5_list = { &preamble_2_2_list, &test_case_2_2_1_5_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- XTI_SNDLOWAT
 */
#define tgrp_case_2_2_1_6 test_group_2_2_1
#define numb_case_2_2_1_6 "2.2.1.6"
#define name_case_2_2_1_6 "Transfer connectionless data with options -- XTI_SNDLOWAT"
#define sref_case_2_2_1_6 sref_case_2_2
#define desc_case_2_2_1_6 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is XTI_SNDLOWAT.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_1_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_1_6_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_1_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_1_6_conn = { &preamble_2_2_conn, &test_case_2_2_1_6_conn, &postamble_2_2_conn };
struct test_stream test_2_2_1_6_resp = { &preamble_2_2_resp, &test_case_2_2_1_6_resp, &postamble_2_2_resp };
struct test_stream test_2_2_1_6_list = { &preamble_2_2_list, &test_case_2_2_1_6_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_IP_TOS
 */
#define test_group_2_2_2 "Connectionless data transfer -- IP options"
#define tgrp_case_2_2_2_1 test_group_2_2_2
#define numb_case_2_2_2_1 "2.2.2.1"
#define name_case_2_2_2_1 "Transfer connectionless data with options -- T_IP_TOS"
#define sref_case_2_2_2_1 sref_case_2_2
#define desc_case_2_2_2_1 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_IP_TOS.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_2_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_2_1_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_2_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, {
		.opt_val = 0x0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_2_1_conn = { &preamble_2_2_conn, &test_case_2_2_2_1_conn, &postamble_2_2_conn };
struct test_stream test_2_2_2_1_resp = { &preamble_2_2_resp, &test_case_2_2_2_1_resp, &postamble_2_2_resp };
struct test_stream test_2_2_2_1_list = { &preamble_2_2_list, &test_case_2_2_2_1_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_IP_TTL
 */
#define tgrp_case_2_2_2_2 test_group_2_2_2
#define numb_case_2_2_2_2 "2.2.2.2"
#define name_case_2_2_2_2 "Transfer connectionless data with options -- T_IP_TTL"
#define sref_case_2_2_2_2 sref_case_2_2
#define desc_case_2_2_2_2 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_IP_TTL.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_2_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_2_2_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_2_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		union {
			unsigned char opt_val;
			t_scalar_t opt_fil;
		} opt_u;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, {
		.opt_val = 64}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_2_2_conn = { &preamble_2_2_conn, &test_case_2_2_2_2_conn, &postamble_2_2_conn };
struct test_stream test_2_2_2_2_resp = { &preamble_2_2_resp, &test_case_2_2_2_2_resp, &postamble_2_2_resp };
struct test_stream test_2_2_2_2_list = { &preamble_2_2_list, &test_case_2_2_2_2_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_IP_DONTROUTE
 */
#define tgrp_case_2_2_2_3 test_group_2_2_2
#define numb_case_2_2_2_3 "2.2.2.3"
#define name_case_2_2_2_3 "Transfer connectionless data with options -- T_IP_DONTROUTE"
#define sref_case_2_2_2_3 sref_case_2_2
#define desc_case_2_2_2_3 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_IP_DONTROUTE.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_2_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_2_3_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_2_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_2_3_conn = { &preamble_2_2_conn, &test_case_2_2_2_3_conn, &postamble_2_2_conn };
struct test_stream test_2_2_2_3_resp = { &preamble_2_2_resp, &test_case_2_2_2_3_resp, &postamble_2_2_resp };
struct test_stream test_2_2_2_3_list = { &preamble_2_2_list, &test_case_2_2_2_3_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_IP_BROADCAST
 */
#define tgrp_case_2_2_2_4 test_group_2_2_2
#define numb_case_2_2_2_4 "2.2.2.4"
#define name_case_2_2_2_4 "Transfer connectionless data with options -- T_IP_BROADCAST"
#define sref_case_2_2_2_4 sref_case_2_2
#define desc_case_2_2_2_4 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_IP_BROADCAST.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_2_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_2_4_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_2_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_2_4_conn = { &preamble_2_2_conn, &test_case_2_2_2_4_conn, &postamble_2_2_conn };
struct test_stream test_2_2_2_4_resp = { &preamble_2_2_resp, &test_case_2_2_2_4_resp, &postamble_2_2_resp };
struct test_stream test_2_2_2_4_list = { &preamble_2_2_list, &test_case_2_2_2_4_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_IP_REUSEADDR
 */
#define tgrp_case_2_2_2_5 test_group_2_2_2
#define numb_case_2_2_2_5 "2.2.2.5"
#define name_case_2_2_2_5 "Transfer connectionless data with options -- T_IP_REUSEADDR"
#define sref_case_2_2_2_5 sref_case_2_2
#define desc_case_2_2_2_5 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_IP_REUSEADDR.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_2_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_2_5_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_2_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_2_5_conn = { &preamble_2_2_conn, &test_case_2_2_2_5_conn, &postamble_2_2_conn };
struct test_stream test_2_2_2_5_resp = { &preamble_2_2_resp, &test_case_2_2_2_5_resp, &postamble_2_2_resp };
struct test_stream test_2_2_2_5_list = { &preamble_2_2_list, &test_case_2_2_2_5_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_UDP_CHECKSUM
 */
#define test_group_2_2_3 "Connectionless data transfer -- UDP options"
#define tgrp_case_2_2_3_1 test_group_2_2_3
#define numb_case_2_2_3_1 "2.2.3.1"
#define name_case_2_2_3_1 "Transfer connectionless data with options -- T_UDP_CHECKSUM"
#define sref_case_2_2_3_1 sref_case_2_2
#define desc_case_2_2_3_1 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_UDP_CHECKSUM.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_3_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_3_1_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_3_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_3_1_conn = { &preamble_2_2_conn, &test_case_2_2_3_1_conn, &postamble_2_2_conn };
struct test_stream test_2_2_3_1_resp = { &preamble_2_2_resp, &test_case_2_2_3_1_resp, &postamble_2_2_resp };
struct test_stream test_2_2_3_1_list = { &preamble_2_2_list, &test_case_2_2_3_1_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_NODELAY
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_1 test_group_2_2_4
#define numb_case_2_2_4_1 "2.2.4.1"
#define name_case_2_2_4_1 "Transfer connectionless data with options -- T_TCP_NODELAY"
#define sref_case_2_2_4_1 sref_case_2_2
#define desc_case_2_2_4_1 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_NODELAY.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_1_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_1_conn = { &preamble_2_2_conn, &test_case_2_2_4_1_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_1_resp = { &preamble_2_2_resp, &test_case_2_2_4_1_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_1_list = { &preamble_2_2_list, &test_case_2_2_4_1_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_MAXSEG
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_2 test_group_2_2_4
#define numb_case_2_2_4_2 "2.2.4.2"
#define name_case_2_2_4_2 "Transfer connectionless data with options -- T_TCP_MAXSEG"
#define sref_case_2_2_4_2 sref_case_2_2
#define desc_case_2_2_4_2 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_MAXSEG.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_2_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_2_conn = { &preamble_2_2_conn, &test_case_2_2_4_2_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_2_resp = { &preamble_2_2_resp, &test_case_2_2_4_2_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_2_list = { &preamble_2_2_list, &test_case_2_2_4_2_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_KEEPALIVE
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_3 test_group_2_2_4
#define numb_case_2_2_4_3 "2.2.4.3"
#define name_case_2_2_4_3 "Transfer connectionless data with options -- T_TCP_KEEPALIVE"
#define sref_case_2_2_4_3 sref_case_2_2
#define desc_case_2_2_4_3 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_KEEPALIVE.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_3_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_3_conn = { &preamble_2_2_conn, &test_case_2_2_4_3_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_3_resp = { &preamble_2_2_resp, &test_case_2_2_4_3_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_3_list = { &preamble_2_2_list, &test_case_2_2_4_3_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_CORK
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_4 test_group_2_2_4
#define numb_case_2_2_4_4 "2.2.4.4"
#define name_case_2_2_4_4 "Transfer connectionless data with options -- T_TCP_CORK"
#define sref_case_2_2_4_4 sref_case_2_2
#define desc_case_2_2_4_4 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_CORK.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_4_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_4_conn = { &preamble_2_2_conn, &test_case_2_2_4_4_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_4_resp = { &preamble_2_2_resp, &test_case_2_2_4_4_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_4_list = { &preamble_2_2_list, &test_case_2_2_4_4_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_KEEPIDLE
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_5 test_group_2_2_4
#define numb_case_2_2_4_5 "2.2.4.5"
#define name_case_2_2_4_5 "Transfer connectionless data with options -- T_TCP_KEEPIDLE"
#define sref_case_2_2_4_5 sref_case_2_2
#define desc_case_2_2_4_5 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_KEEPIDLE.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_5_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_5_conn = { &preamble_2_2_conn, &test_case_2_2_4_5_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_5_resp = { &preamble_2_2_resp, &test_case_2_2_4_5_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_5_list = { &preamble_2_2_list, &test_case_2_2_4_5_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_KEEPINTVL
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_6 test_group_2_2_4
#define numb_case_2_2_4_6 "2.2.4.6"
#define name_case_2_2_4_6 "Transfer connectionless data with options -- T_TCP_KEEPINTVL"
#define sref_case_2_2_4_6 sref_case_2_2
#define desc_case_2_2_4_6 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_KEEPINTVL.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_6_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_6_conn = { &preamble_2_2_conn, &test_case_2_2_4_6_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_6_resp = { &preamble_2_2_resp, &test_case_2_2_4_6_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_6_list = { &preamble_2_2_list, &test_case_2_2_4_6_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_KEEPCNT
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_7 test_group_2_2_4
#define numb_case_2_2_4_7 "2.2.4.7"
#define name_case_2_2_4_7 "Transfer connectionless data with options -- T_TCP_KEEPCNT"
#define sref_case_2_2_4_7 sref_case_2_2
#define desc_case_2_2_4_7 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_KEEPCNT.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_7_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_7_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_7_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_7_conn = { &preamble_2_2_conn, &test_case_2_2_4_7_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_7_resp = { &preamble_2_2_resp, &test_case_2_2_4_7_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_7_list = { &preamble_2_2_list, &test_case_2_2_4_7_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_SYNCNT
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_8 test_group_2_2_4
#define numb_case_2_2_4_8 "2.2.4.8"
#define name_case_2_2_4_8 "Transfer connectionless data with options -- T_TCP_SYNCNT"
#define sref_case_2_2_4_8 sref_case_2_2
#define desc_case_2_2_4_8 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_SYNCNT.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_8_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_8_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_8_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_8_conn = { &preamble_2_2_conn, &test_case_2_2_4_8_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_8_resp = { &preamble_2_2_resp, &test_case_2_2_4_8_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_8_list = { &preamble_2_2_list, &test_case_2_2_4_8_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_LINGER2
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_9 test_group_2_2_4
#define numb_case_2_2_4_9 "2.2.4.9"
#define name_case_2_2_4_9 "Transfer connectionless data with options -- T_TCP_LINGER2"
#define sref_case_2_2_4_9 sref_case_2_2
#define desc_case_2_2_4_9 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_LINGER2.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_9_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_9_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_9_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_9_conn = { &preamble_2_2_conn, &test_case_2_2_4_9_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_9_resp = { &preamble_2_2_resp, &test_case_2_2_4_9_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_9_list = { &preamble_2_2_list, &test_case_2_2_4_9_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_DEFER_ACCEPT
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_10 test_group_2_2_4
#define numb_case_2_2_4_10 "2.2.4.10"
#define name_case_2_2_4_10 "Transfer connectionless data with options -- T_TCP_DEFER_ACCEPT"
#define sref_case_2_2_4_10 sref_case_2_2
#define desc_case_2_2_4_10 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_DEFER_ACCEPT.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_10_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_10_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_10_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_10_conn = { &preamble_2_2_conn, &test_case_2_2_4_10_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_10_resp = { &preamble_2_2_resp, &test_case_2_2_4_10_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_10_list = { &preamble_2_2_list, &test_case_2_2_4_10_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_WINDOW_CLAMP
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_11 test_group_2_2_4
#define numb_case_2_2_4_11 "2.2.4.11"
#define name_case_2_2_4_11 "Transfer connectionless data with options -- T_TCP_WINDOW_CLAMP"
#define sref_case_2_2_4_11 sref_case_2_2
#define desc_case_2_2_4_11 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_WINDOW_CLAMP.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_11_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_11_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_11_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_11_conn = { &preamble_2_2_conn, &test_case_2_2_4_11_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_11_resp = { &preamble_2_2_resp, &test_case_2_2_4_11_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_11_list = { &preamble_2_2_list, &test_case_2_2_4_11_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_INFO
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_12 test_group_2_2_4
#define numb_case_2_2_4_12 "2.2.4.12"
#define name_case_2_2_4_12 "Transfer connectionless data with options -- T_TCP_INFO"
#define sref_case_2_2_4_12 sref_case_2_2
#define desc_case_2_2_4_12 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_INFO.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_12_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_12_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_12_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_tcp_info opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(struct t_tcp_info), T_INET_TCP, T_TCP_INFO, T_SUCCESS},};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_12_conn = { &preamble_2_2_conn, &test_case_2_2_4_12_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_12_resp = { &preamble_2_2_resp, &test_case_2_2_4_12_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_12_list = { &preamble_2_2_list, &test_case_2_2_4_12_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_TCP_QUICKACK
 */
#define test_group_2_2_4 "Connectionless data transfer -- TCP options"
#define tgrp_case_2_2_4_13 test_group_2_2_4
#define numb_case_2_2_4_13 "2.2.4.13"
#define name_case_2_2_4_13 "Transfer connectionless data with options -- T_TCP_QUICKACK"
#define sref_case_2_2_4_13 sref_case_2_2
#define desc_case_2_2_4_13 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_TCP_QUICKACK.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_4_13_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_4_13_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_4_13_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_4_13_conn = { &preamble_2_2_conn, &test_case_2_2_4_13_conn, &postamble_2_2_conn };
struct test_stream test_2_2_4_13_resp = { &preamble_2_2_resp, &test_case_2_2_4_13_resp, &postamble_2_2_resp };
struct test_stream test_2_2_4_13_list = { &preamble_2_2_list, &test_case_2_2_4_13_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_NODELAY
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_1 test_group_2_2_5
#define numb_case_2_2_5_1 "2.2.5.1"
#define name_case_2_2_5_1 "Transfer connectionless data with options -- T_SCTP_NODELAY"
#define sref_case_2_2_5_1 sref_case_2_2
#define desc_case_2_2_5_1 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_NODELAY.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_1_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_1_conn = { &preamble_2_2_conn, &test_case_2_2_5_1_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_1_resp = { &preamble_2_2_resp, &test_case_2_2_5_1_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_1_list = { &preamble_2_2_list, &test_case_2_2_5_1_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_CORK
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_2 test_group_2_2_5
#define numb_case_2_2_5_2 "2.2.5.2"
#define name_case_2_2_5_2 "Transfer connectionless data with options -- T_SCTP_CORK"
#define sref_case_2_2_5_2 sref_case_2_2
#define desc_case_2_2_5_2 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_CORK.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_2_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_2_conn = { &preamble_2_2_conn, &test_case_2_2_5_2_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_2_resp = { &preamble_2_2_resp, &test_case_2_2_5_2_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_2_list = { &preamble_2_2_list, &test_case_2_2_5_2_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_PPI
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_3 test_group_2_2_5
#define numb_case_2_2_5_3 "2.2.5.3"
#define name_case_2_2_5_3 "Transfer connectionless data with options -- T_SCTP_PPI"
#define sref_case_2_2_5_3 sref_case_2_2
#define desc_case_2_2_5_3 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_PPI.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_3_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_3_conn = { &preamble_2_2_conn, &test_case_2_2_5_3_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_3_resp = { &preamble_2_2_resp, &test_case_2_2_5_3_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_3_list = { &preamble_2_2_list, &test_case_2_2_5_3_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_SID
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_4 test_group_2_2_5
#define numb_case_2_2_5_4 "2.2.5.4"
#define name_case_2_2_5_4 "Transfer connectionless data with options -- T_SCTP_SID"
#define sref_case_2_2_5_4 sref_case_2_2
#define desc_case_2_2_5_4 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_SID.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_4_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_4_conn = { &preamble_2_2_conn, &test_case_2_2_5_4_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_4_resp = { &preamble_2_2_resp, &test_case_2_2_5_4_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_4_list = { &preamble_2_2_list, &test_case_2_2_5_4_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_SSN
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_5 test_group_2_2_5
#define numb_case_2_2_5_5 "2.2.5.5"
#define name_case_2_2_5_5 "Transfer connectionless data with options -- T_SCTP_SSN"
#define sref_case_2_2_5_5 sref_case_2_2
#define desc_case_2_2_5_5 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_SSN.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_5_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_5_conn = { &preamble_2_2_conn, &test_case_2_2_5_5_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_5_resp = { &preamble_2_2_resp, &test_case_2_2_5_5_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_5_list = { &preamble_2_2_list, &test_case_2_2_5_5_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_TSN
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_6 test_group_2_2_5
#define numb_case_2_2_5_6 "2.2.5.6"
#define name_case_2_2_5_6 "Transfer connectionless data with options -- T_SCTP_TSN"
#define sref_case_2_2_5_6 sref_case_2_2
#define desc_case_2_2_5_6 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_TSN.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_6_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_6_conn = { &preamble_2_2_conn, &test_case_2_2_5_6_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_6_resp = { &preamble_2_2_resp, &test_case_2_2_5_6_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_6_list = { &preamble_2_2_list, &test_case_2_2_5_6_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_RECVOPT
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_7 test_group_2_2_5
#define numb_case_2_2_5_7 "2.2.5.7"
#define name_case_2_2_5_7 "Transfer connectionless data with options -- T_SCTP_RECVOPT"
#define sref_case_2_2_5_7 sref_case_2_2
#define desc_case_2_2_5_7 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_RECVOPT.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_7_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_7_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_7_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_7_conn = { &preamble_2_2_conn, &test_case_2_2_5_7_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_7_resp = { &preamble_2_2_resp, &test_case_2_2_5_7_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_7_list = { &preamble_2_2_list, &test_case_2_2_5_7_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_COOKIE_LIFE
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_8 test_group_2_2_5
#define numb_case_2_2_5_8 "2.2.5.8"
#define name_case_2_2_5_8 "Transfer connectionless data with options -- T_SCTP_COOKIE_LIFE"
#define sref_case_2_2_5_8 sref_case_2_2
#define desc_case_2_2_5_8 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_COOKIE_LIFE.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_8_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_8_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_8_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, 60000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_8_conn = { &preamble_2_2_conn, &test_case_2_2_5_8_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_8_resp = { &preamble_2_2_resp, &test_case_2_2_5_8_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_8_list = { &preamble_2_2_list, &test_case_2_2_5_8_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_SACK_DELAY
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_9 test_group_2_2_5
#define numb_case_2_2_5_9 "2.2.5.9"
#define name_case_2_2_5_9 "Transfer connectionless data with options -- T_SCTP_SACK_DELAY"
#define sref_case_2_2_5_9 sref_case_2_2
#define desc_case_2_2_5_9 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_SACK_DELAY.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_9_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_9_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_9_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_9_conn = { &preamble_2_2_conn, &test_case_2_2_5_9_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_9_resp = { &preamble_2_2_resp, &test_case_2_2_5_9_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_9_list = { &preamble_2_2_list, &test_case_2_2_5_9_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_PATH_MAX_RETRANS
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_10 test_group_2_2_5
#define numb_case_2_2_5_10 "2.2.5.10"
#define name_case_2_2_5_10 "Transfer connectionless data with options -- T_SCTP_PATH_MAX_RETRANS"
#define sref_case_2_2_5_10 sref_case_2_2
#define desc_case_2_2_5_10 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_PATH_MAX_RETRANS.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_10_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_10_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_10_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, 5};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_10_conn = { &preamble_2_2_conn, &test_case_2_2_5_10_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_10_resp = { &preamble_2_2_resp, &test_case_2_2_5_10_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_10_list = { &preamble_2_2_list, &test_case_2_2_5_10_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_ASSOC_MAX_RETRANS
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_11 test_group_2_2_5
#define numb_case_2_2_5_11 "2.2.5.11"
#define name_case_2_2_5_11 "Transfer connectionless data with options -- T_SCTP_ASSOC_MAX_RETRANS"
#define sref_case_2_2_5_11 sref_case_2_2
#define desc_case_2_2_5_11 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_ASSOC_MAX_RETRANS.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_11_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_11_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_11_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_11_conn = { &preamble_2_2_conn, &test_case_2_2_5_11_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_11_resp = { &preamble_2_2_resp, &test_case_2_2_5_11_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_11_list = { &preamble_2_2_list, &test_case_2_2_5_11_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_MAX_INIT_RETRIES
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_12 test_group_2_2_5
#define numb_case_2_2_5_12 "2.2.5.12"
#define name_case_2_2_5_12 "Transfer connectionless data with options -- T_SCTP_MAX_INIT_RETRIES"
#define sref_case_2_2_5_12 sref_case_2_2
#define desc_case_2_2_5_12 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_MAX_INIT_RETRIES.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_12_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_12_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_12_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, 12};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_12_conn = { &preamble_2_2_conn, &test_case_2_2_5_12_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_12_resp = { &preamble_2_2_resp, &test_case_2_2_5_12_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_12_list = { &preamble_2_2_list, &test_case_2_2_5_12_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_HEARTBEAT_ITVL
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_13 test_group_2_2_5
#define numb_case_2_2_5_13 "2.2.5.13"
#define name_case_2_2_5_13 "Transfer connectionless data with options -- T_SCTP_HEARTBEAT_ITVL"
#define sref_case_2_2_5_13 sref_case_2_2
#define desc_case_2_2_5_13 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_HEARTBEAT_ITVL.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_13_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_13_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_13_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_13_conn = { &preamble_2_2_conn, &test_case_2_2_5_13_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_13_resp = { &preamble_2_2_resp, &test_case_2_2_5_13_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_13_list = { &preamble_2_2_list, &test_case_2_2_5_13_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_RTO_INITIAL
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_14 test_group_2_2_5
#define numb_case_2_2_5_14 "2.2.5.14"
#define name_case_2_2_5_14 "Transfer connectionless data with options -- T_SCTP_RTO_INITIAL"
#define sref_case_2_2_5_14 sref_case_2_2
#define desc_case_2_2_5_14 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_RTO_INITIAL.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_14_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_14_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_14_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, 200};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_14_conn = { &preamble_2_2_conn, &test_case_2_2_5_14_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_14_resp = { &preamble_2_2_resp, &test_case_2_2_5_14_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_14_list = { &preamble_2_2_list, &test_case_2_2_5_14_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_RTO_MIN
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_15 test_group_2_2_5
#define numb_case_2_2_5_15 "2.2.5.15"
#define name_case_2_2_5_15 "Transfer connectionless data with options -- T_SCTP_RTO_MIN"
#define sref_case_2_2_5_15 sref_case_2_2
#define desc_case_2_2_5_15 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_RTO_MIN.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_15_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_15_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_15_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, 10};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_15_conn = { &preamble_2_2_conn, &test_case_2_2_5_15_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_15_resp = { &preamble_2_2_resp, &test_case_2_2_5_15_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_15_list = { &preamble_2_2_list, &test_case_2_2_5_15_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_RTO_MAX
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_16 test_group_2_2_5
#define numb_case_2_2_5_16 "2.2.5.16"
#define name_case_2_2_5_16 "Transfer connectionless data with options -- T_SCTP_RTO_MAX"
#define sref_case_2_2_5_16 sref_case_2_2
#define desc_case_2_2_5_16 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_RTO_MAX.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_16_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_16_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_16_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, 2000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_16_conn = { &preamble_2_2_conn, &test_case_2_2_5_16_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_16_resp = { &preamble_2_2_resp, &test_case_2_2_5_16_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_16_list = { &preamble_2_2_list, &test_case_2_2_5_16_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_OSTREAMS
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_17 test_group_2_2_5
#define numb_case_2_2_5_17 "2.2.5.17"
#define name_case_2_2_5_17 "Transfer connectionless data with options -- T_SCTP_OSTREAMS"
#define sref_case_2_2_5_17 sref_case_2_2
#define desc_case_2_2_5_17 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_OSTREAMS.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_17_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_17_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_17_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_17_conn = { &preamble_2_2_conn, &test_case_2_2_5_17_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_17_resp = { &preamble_2_2_resp, &test_case_2_2_5_17_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_17_list = { &preamble_2_2_list, &test_case_2_2_5_17_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_ISTREAMS
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_18 test_group_2_2_5
#define numb_case_2_2_5_18 "2.2.5.18"
#define name_case_2_2_5_18 "Transfer connectionless data with options -- T_SCTP_ISTREAMS"
#define sref_case_2_2_5_18 sref_case_2_2
#define desc_case_2_2_5_18 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_ISTREAMS.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_18_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_18_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_18_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_18_conn = { &preamble_2_2_conn, &test_case_2_2_5_18_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_18_resp = { &preamble_2_2_resp, &test_case_2_2_5_18_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_18_list = { &preamble_2_2_list, &test_case_2_2_5_18_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_COOKIE_INC
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_19 test_group_2_2_5
#define numb_case_2_2_5_19 "2.2.5.19"
#define name_case_2_2_5_19 "Transfer connectionless data with options -- T_SCTP_COOKIE_INC"
#define sref_case_2_2_5_19 sref_case_2_2
#define desc_case_2_2_5_19 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_COOKIE_INC.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider."

int
test_case_2_2_5_19_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_19_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_19_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, 1000};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_19_conn = { &preamble_2_2_conn, &test_case_2_2_5_19_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_19_resp = { &preamble_2_2_resp, &test_case_2_2_5_19_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_19_list = { &preamble_2_2_list, &test_case_2_2_5_19_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_THROTTLE_ITVL
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_20 test_group_2_2_5
#define numb_case_2_2_5_20 "2.2.5.20"
#define name_case_2_2_5_20 "Transfer connectionless data with options -- T_SCTP_THROTTLE_ITVL"
#define sref_case_2_2_5_20 sref_case_2_2
#define desc_case_2_2_5_20 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_THROTTLE_ITVL.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_20_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_20_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_20_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, 50};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_20_conn = { &preamble_2_2_conn, &test_case_2_2_5_20_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_20_resp = { &preamble_2_2_resp, &test_case_2_2_5_20_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_20_list = { &preamble_2_2_list, &test_case_2_2_5_20_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_MAC_TYPE
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_21 test_group_2_2_5
#define numb_case_2_2_5_21 "2.2.5.21"
#define name_case_2_2_5_21 "Transfer connectionless data with options -- T_SCTP_MAC_TYPE"
#define sref_case_2_2_5_21 sref_case_2_2
#define desc_case_2_2_5_21 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_MAC_TYPE.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_21_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_21_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_21_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_21_conn = { &preamble_2_2_conn, &test_case_2_2_5_21_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_21_resp = { &preamble_2_2_resp, &test_case_2_2_5_21_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_21_list = { &preamble_2_2_list, &test_case_2_2_5_21_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_CKSUM_TYPE
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_22 test_group_2_2_5
#define numb_case_2_2_5_22 "2.2.5.22"
#define name_case_2_2_5_22 "Transfer connectionless data with options -- T_SCTP_CKSUM_TYPE"
#define sref_case_2_2_5_22 sref_case_2_2
#define desc_case_2_2_5_22 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_CKSUM_TYPE.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_22_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_22_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_22_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_22_conn = { &preamble_2_2_conn, &test_case_2_2_5_22_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_22_resp = { &preamble_2_2_resp, &test_case_2_2_5_22_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_22_list = { &preamble_2_2_list, &test_case_2_2_5_22_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_ECN
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_23 test_group_2_2_5
#define numb_case_2_2_5_23 "2.2.5.23"
#define name_case_2_2_5_23 "Transfer connectionless data with options -- T_SCTP_ECN"
#define sref_case_2_2_5_23 sref_case_2_2
#define desc_case_2_2_5_23 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_ECN.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_23_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_23_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_23_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_23_conn = { &preamble_2_2_conn, &test_case_2_2_5_23_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_23_resp = { &preamble_2_2_resp, &test_case_2_2_5_23_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_23_list = { &preamble_2_2_list, &test_case_2_2_5_23_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_ALI
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_24 test_group_2_2_5
#define numb_case_2_2_5_24 "2.2.5.24"
#define name_case_2_2_5_24 "Transfer connectionless data with options -- T_SCTP_ALI"
#define sref_case_2_2_5_24 sref_case_2_2
#define desc_case_2_2_5_24 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_ALI.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_24_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_24_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_24_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_24_conn = { &preamble_2_2_conn, &test_case_2_2_5_24_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_24_resp = { &preamble_2_2_resp, &test_case_2_2_5_24_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_24_list = { &preamble_2_2_list, &test_case_2_2_5_24_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_ADD
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_25 test_group_2_2_5
#define numb_case_2_2_5_25 "2.2.5.25"
#define name_case_2_2_5_25 "Transfer connectionless data with options -- T_SCTP_ADD"
#define sref_case_2_2_5_25 sref_case_2_2
#define desc_case_2_2_5_25 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_ADD.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_25_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_25_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_25_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_25_conn = { &preamble_2_2_conn, &test_case_2_2_5_25_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_25_resp = { &preamble_2_2_resp, &test_case_2_2_5_25_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_25_list = { &preamble_2_2_list, &test_case_2_2_5_25_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_SET
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_26 test_group_2_2_5
#define numb_case_2_2_5_26 "2.2.5.26"
#define name_case_2_2_5_26 "Transfer connectionless data with options -- T_SCTP_SET"
#define sref_case_2_2_5_26 sref_case_2_2
#define desc_case_2_2_5_26 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_SET.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_26_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_26_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_26_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_26_conn = { &preamble_2_2_conn, &test_case_2_2_5_26_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_26_resp = { &preamble_2_2_resp, &test_case_2_2_5_26_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_26_list = { &preamble_2_2_list, &test_case_2_2_5_26_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_ADD_IP
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_27 test_group_2_2_5
#define numb_case_2_2_5_27 "2.2.5.27"
#define name_case_2_2_5_27 "Transfer connectionless data with options -- T_SCTP_ADD_IP"
#define sref_case_2_2_5_27 sref_case_2_2
#define desc_case_2_2_5_27 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_ADD_IP.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_27_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_27_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_27_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_27_conn = { &preamble_2_2_conn, &test_case_2_2_5_27_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_27_resp = { &preamble_2_2_resp, &test_case_2_2_5_27_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_27_list = { &preamble_2_2_list, &test_case_2_2_5_27_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_DEL_IP
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_28 test_group_2_2_5
#define numb_case_2_2_5_28 "2.2.5.28"
#define name_case_2_2_5_28 "Transfer connectionless data with options -- T_SCTP_DEL_IP"
#define sref_case_2_2_5_28 sref_case_2_2
#define desc_case_2_2_5_28 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_DEL_IP.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_28_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_28_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_28_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_28_conn = { &preamble_2_2_conn, &test_case_2_2_5_28_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_28_resp = { &preamble_2_2_resp, &test_case_2_2_5_28_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_28_list = { &preamble_2_2_list, &test_case_2_2_5_28_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_SET_IP
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_29 test_group_2_2_5
#define numb_case_2_2_5_29 "2.2.5.29"
#define name_case_2_2_5_29 "Transfer connectionless data with options -- T_SCTP_SET_IP"
#define sref_case_2_2_5_29 sref_case_2_2
#define desc_case_2_2_5_29 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_SET_IP.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_29_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_29_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_29_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct sockaddr_in opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct sockaddr_in), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}, {
			AF_INET, 0, {
		0x0500007f}}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_29_conn = { &preamble_2_2_conn, &test_case_2_2_5_29_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_29_resp = { &preamble_2_2_resp, &test_case_2_2_5_29_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_29_list = { &preamble_2_2_list, &test_case_2_2_5_29_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_PR
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_30 test_group_2_2_5
#define numb_case_2_2_5_30 "2.2.5.30"
#define name_case_2_2_5_30 "Transfer connectionless data with options -- T_SCTP_PR"
#define sref_case_2_2_5_30 sref_case_2_2
#define desc_case_2_2_5_30 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_PR.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_30_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_30_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_30_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_30_conn = { &preamble_2_2_conn, &test_case_2_2_5_30_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_30_resp = { &preamble_2_2_resp, &test_case_2_2_5_30_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_30_list = { &preamble_2_2_list, &test_case_2_2_5_30_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_LIFETIME
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_31 test_group_2_2_5
#define numb_case_2_2_5_31 "2.2.5.31"
#define name_case_2_2_5_31 "Transfer connectionless data with options -- T_SCTP_LIFETIME"
#define sref_case_2_2_5_31 sref_case_2_2
#define desc_case_2_2_5_31 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_LIFETIME.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_31_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_INFINITE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_31_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_INFINITE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_31_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_INFINITE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_31_conn = { &preamble_2_2_conn, &test_case_2_2_5_31_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_31_resp = { &preamble_2_2_resp, &test_case_2_2_5_31_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_31_list = { &preamble_2_2_list, &test_case_2_2_5_31_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_DISPOSITION
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_32 test_group_2_2_5
#define numb_case_2_2_5_32 "2.2.5.32"
#define name_case_2_2_5_32 "Transfer connectionless data with options -- T_SCTP_DISPOSITION"
#define sref_case_2_2_5_32 sref_case_2_2
#define desc_case_2_2_5_32 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_DISPOSITION.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_32_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_32_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_32_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_SCTP_DISPOSITION_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_32_conn = { &preamble_2_2_conn, &test_case_2_2_5_32_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_32_resp = { &preamble_2_2_resp, &test_case_2_2_5_32_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_32_list = { &preamble_2_2_list, &test_case_2_2_5_32_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_MAX_BURST
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_33 test_group_2_2_5
#define numb_case_2_2_5_33 "2.2.5.33"
#define name_case_2_2_5_33 "Transfer connectionless data with options -- T_SCTP_MAX_BURST"
#define sref_case_2_2_5_33 sref_case_2_2
#define desc_case_2_2_5_33 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_MAX_BURST.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_33_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_33_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_33_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_33_conn = { &preamble_2_2_conn, &test_case_2_2_5_33_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_33_resp = { &preamble_2_2_resp, &test_case_2_2_5_33_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_33_list = { &preamble_2_2_list, &test_case_2_2_5_33_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_HB
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_34 test_group_2_2_5
#define numb_case_2_2_5_34 "2.2.5.34"
#define name_case_2_2_5_34 "Transfer connectionless data with options -- T_SCTP_HB"
#define sref_case_2_2_5_34 sref_case_2_2
#define desc_case_2_2_5_34 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_HB.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_34_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_34_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_34_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_34_conn = { &preamble_2_2_conn, &test_case_2_2_5_34_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_34_resp = { &preamble_2_2_resp, &test_case_2_2_5_34_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_34_list = { &preamble_2_2_list, &test_case_2_2_5_34_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_RTO
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_35 test_group_2_2_5
#define numb_case_2_2_5_35 "2.2.5.35"
#define name_case_2_2_5_35 "Transfer connectionless data with options -- T_SCTP_RTO"
#define sref_case_2_2_5_35 sref_case_2_2
#define desc_case_2_2_5_35 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_RTO.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_35_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_35_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_35_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_35_conn = { &preamble_2_2_conn, &test_case_2_2_5_35_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_35_resp = { &preamble_2_2_resp, &test_case_2_2_5_35_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_35_list = { &preamble_2_2_list, &test_case_2_2_5_35_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_MAXSEG
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_36 test_group_2_2_5
#define numb_case_2_2_5_36 "2.2.5.36"
#define name_case_2_2_5_36 "Transfer connectionless data with options -- T_SCTP_MAXSEG"
#define sref_case_2_2_5_36 sref_case_2_2
#define desc_case_2_2_5_36 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_MAXSEG.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_36_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_36_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_36_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_36_conn = { &preamble_2_2_conn, &test_case_2_2_5_36_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_36_resp = { &preamble_2_2_resp, &test_case_2_2_5_36_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_36_list = { &preamble_2_2_list, &test_case_2_2_5_36_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_STATUS
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_37 test_group_2_2_5
#define numb_case_2_2_5_37 "2.2.5.37"
#define name_case_2_2_5_37 "Transfer connectionless data with options -- T_SCTP_STATUS"
#define sref_case_2_2_5_37 sref_case_2_2
#define desc_case_2_2_5_37 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_STATUS.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_37_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_37_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_37_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_37_conn = { &preamble_2_2_conn, &test_case_2_2_5_37_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_37_resp = { &preamble_2_2_resp, &test_case_2_2_5_37_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_37_list = { &preamble_2_2_list, &test_case_2_2_5_37_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- T_SCTP_DEBUG
 */
#define test_group_2_2_5 "Connectionless data transfer -- SCTP options"
#define tgrp_case_2_2_5_38 test_group_2_2_5
#define numb_case_2_2_5_38 "2.2.5.38"
#define name_case_2_2_5_38 "Transfer connectionless data with options -- T_SCTP_DEBUG"
#define sref_case_2_2_5_38 sref_case_2_2
#define desc_case_2_2_5_38 "\
Transfer connectionless data with options.  The specific option used by this\n\
case is T_SCTP_DEBUG.  The specification indicates that unknown options issued\n\
in a T_UNITDATA_REQ should be ignored by the transport provider.  T_COTS_ORD\n\
transport providers are always expected to fail when issued a T_UNITDATA_REQ\n\
primitive."

int
test_case_2_2_5_38_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_conn(child);
}

int
test_case_2_2_5_38_resp(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_resp(child);
}

int
test_case_2_2_5_38_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, 0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_2_2_list(child);
}

struct test_stream test_2_2_5_38_conn = { &preamble_2_2_conn, &test_case_2_2_5_38_conn, &postamble_2_2_conn };
struct test_stream test_2_2_5_38_resp = { &preamble_2_2_resp, &test_case_2_2_5_38_resp, &postamble_2_2_resp };
struct test_stream test_2_2_5_38_list = { &preamble_2_2_list, &test_case_2_2_5_38_list, &postamble_2_2_list };

/*
 *  Transfer connectionless data with options -- illegal option
 */
#define test_group_2_2_6 "Connectionless data transfer -- illegal option"
#define tgrp_case_2_2_6 test_group_2_2_6
#define numb_case_2_2_6 "2.2.6"
#define name_case_2_2_6 "Transfer connectionless data with options -- illegal option"
#define sref_case_2_2_6 sref_case_2_2
#define desc_case_2_2_6 "\
Transfer connectionless data with options.  This specific test case uses\n\
an illegal option.  The specification says that when t_sndudata(3) is\n\
given an illegal option, the transport provider must fail with TBADOPT or\n\
issue a T_UDERROR_IND primitive.  We rely on the XTI library to check for\n\
illegal options and return [TBADOPT].  If the transport provider is given\n\
an illegal option we treat it as a fatal error.  This is not well described\n\
in the TPI 2.2 specification.  T_COTS_ORD transport providers are always\n\
expected to fail when issued a T_UNITDATA_REQ primitive."

int
test_case_2_2_6(int child, struct sockaddr_in *addr, socklen_t len)
{
	const char msg[] = "Unit test data.";
	struct t_opthdr opt_hdr = { sizeof(struct t_opthdr) + 100, XTI_GENERIC, XTI_DEBUG, T_SUCCESS };

	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addr;
	test_alen = len;
	test_data = msg;
	test_opts = &opt_hdr;
	test_olen = sizeof(opt_hdr);
	if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
      wait_again:
	switch (wait_event(child, LONG_WAIT)) {
	case __EVENT_NO_MSG:
		goto wait_again;
	case __RESULT_FAILURE:
		state++;
		if (last_errno != EPROTO)
			goto failure;
		break;
	case __TEST_ERROR_ACK:
		state++;
		if (last_info.SERV_type != T_CLTS)
			goto failure;
		state++;
		if (last_t_errno != TBADOPT)
			goto failure;
		break;
	case __TEST_UDERROR_IND:
		state++;
		if (last_info.SERV_type != T_CLTS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_2_2_6_conn(int child)
{
	return test_case_2_2_6(child, addrs[1], sizeof(addrs[1]));
}

int
test_case_2_2_6_resp(int child)
{
	return test_case_2_2_6(child, addrs[2], sizeof(addrs[2]));
}

int
test_case_2_2_6_list(int child)
{
	return test_case_2_2_6(child, addrs[0], sizeof(addrs[0]));
}

#define preamble_2_2_6_conn	preamble_1
#define preamble_2_2_6_resp	preamble_1
#define preamble_2_2_6_list	preamble_1

#define postamble_2_2_6_conn	postamble_0
#define postamble_2_2_6_resp	postamble_0
#define postamble_2_2_6_list	postamble_0

struct test_stream test_2_2_6_conn = { &preamble_2_2_6_conn, &test_case_2_2_6_conn, &postamble_2_2_6_conn };
struct test_stream test_2_2_6_resp = { &preamble_2_2_6_resp, &test_case_2_2_6_resp, &postamble_2_2_6_resp };
struct test_stream test_2_2_6_list = { &preamble_2_2_6_list, &test_case_2_2_6_list, &postamble_2_2_6_list };

/*
 *  Attempt a connection with no listener.
 */
#define test_group_3 "Connection and disconnection -- unsuccessful"
#define tgrp_case_3_1 test_group_3
#define numb_case_3_1 "3.1"
#define name_case_3_1 "Attempt a connection with no listener."
#define sref_case_3_1 "(none)"
#define desc_case_3_1 "\
Attempts a connection with no listener.  The connection attempt\n\
should time out."

int
test_case_3_1_conn(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, INFINITE_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_1_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_1_list(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_3_1_conn	preamble_1s
#define preamble_3_1_resp	preamble_1s
#define preamble_3_1_list	preamble_0

#define postamble_3_1_conn	postamble_1
#define postamble_3_1_resp	postamble_1
#define postamble_3_1_list	postamble_0

struct test_stream test_3_1_conn = { &preamble_3_1_conn, &test_case_3_1_conn, &postamble_3_1_conn };
struct test_stream test_3_1_resp = { &preamble_3_1_resp, &test_case_3_1_resp, &postamble_3_1_resp };
struct test_stream test_3_1_list = { &preamble_3_1_list, &test_case_3_1_list, &postamble_3_1_list };

/*
 *  Attempt and withdraw a connection request.
 */
#define tgrp_case_3_2 test_group_3
#define numb_case_3_2 "3.2"
#define name_case_3_2 "Attempt and withdraw a connection request."
#define sref_case_3_2 "(none)"
#define desc_case_3_2 "\
Attempts and then withdraws a connection request.  The connection\n\
should disconnect at both ends."

int
test_case_3_2_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_2_resp(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_3_2_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, SHORT_WAIT, __TEST_CONN_IND) == __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, SHORT_WAIT, __TEST_DISCON_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_3_2_conn	preamble_1s
#define preamble_3_2_resp	preamble_1s
#define preamble_3_2_list	preamble_1s

#define postamble_3_2_conn	postamble_1
#define postamble_3_2_resp	postamble_1
#define postamble_3_2_list	postamble_1

struct test_stream test_3_2_conn = { &preamble_3_2_conn, &test_case_3_2_conn, &postamble_3_2_conn };
struct test_stream test_3_2_resp = { &preamble_3_2_resp, &test_case_3_2_resp, &postamble_3_2_resp };
struct test_stream test_3_2_list = { &preamble_3_2_list, &test_case_3_2_list, &postamble_3_2_list };

/*
 *  Attempt and refuse a connection request.
 */
#define tgrp_case_3_3 test_group_3
#define numb_case_3_3 "3.3"
#define name_case_3_3 "Attempt and refuse a connection request."
#define sref_case_3_3 "(none)"
#define desc_case_3_3 "\
Attempts a connection which is refused by the receiving end.\n\
The connection should disconnect at the attempting end."

int
test_case_3_3_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_OK_ACK:
			state++;
			switch (wait_event(child, LONG_WAIT)) {
			case __TEST_CONN_CON:
				state++;
				if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
					goto failure;
				break;
			case __TEST_DISCON_IND:
				/* the T_CONN_CON was flushed by the T_DISCON_IND */
				break;
			default:
				goto failure;
			}
			break;
		case __TEST_DISCON_IND:
			/* both the T_OK_ACK and T_CONN_CON were flushed by the T_DISCON_IND */
			break;
		default:
			goto failure;
		}
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_3_3_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, SHORT_WAIT, __TEST_CONN_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_data = NULL;
	last_sequence = last_sequence;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_3_3_conn	preamble_1s
#define preamble_3_3_resp	preamble_1s
#define preamble_3_3_list	preamble_1s

#define postamble_3_3_conn	postamble_1
#define postamble_3_3_resp	postamble_1
#define postamble_3_3_list	postamble_1

struct test_stream test_3_3_conn = { &preamble_3_3_conn, &test_case_3_3_conn, &postamble_3_3_conn };
struct test_stream test_3_3_resp = { &preamble_3_3_resp, &test_case_3_3_resp, &postamble_3_3_resp };
struct test_stream test_3_3_list = { &preamble_3_3_list, &test_case_3_3_list, &postamble_3_3_list };

/*
 *  Attempt and delayed refuse a connection request.
 */
#define tgrp_case_3_4 test_group_3
#define numb_case_3_4 "3.4"
#define name_case_3_4 "Attempt and delayed refuse a connection request."
#define sref_case_3_4 "(none)"
#define desc_case_3_4 "\
Attempts a delayed refusal of a connection requrest.  This delayed\n\
refusal should come after the connector has already timed out."

int
test_case_3_4_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		state++;
		test_sleep(child, 5);
		state++;
		if (expect(child, SHORT_WAIT, __TEST_DISCON_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		expect(child, NORMAL_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __TEST_CONN_CON:
			if (test_level == T_INET_TCP)
				break;
			goto failure;
		case __EVENT_NO_MSG:
			break;
		default:
			goto failure;
		}
		state++;
		test_sleep(child, 5);
		state++;
		if (expect(child, LONGER_WAIT << 1, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_4_resp(int child)
{
	test_sleep(child, 6);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_3_4_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, SHORT_WAIT, __TEST_CONN_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_sleep(child, 5);
	state++;
	test_data = NULL;
	last_sequence = last_sequence;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_3_4_conn	preamble_1s
#define preamble_3_4_resp	preamble_1s
#define preamble_3_4_list	preamble_1s

#define postamble_3_4_conn	postamble_1
#define postamble_3_4_resp	postamble_1
#define postamble_3_4_list	postamble_1

struct test_stream test_3_4_conn = { &preamble_3_4_conn, &test_case_3_4_conn, &postamble_3_4_conn };
struct test_stream test_3_4_resp = { &preamble_3_4_resp, &test_case_3_4_resp, &postamble_3_4_resp };
struct test_stream test_3_4_list = { &preamble_3_4_list, &test_case_3_4_list, &postamble_3_4_list };

#define tgrp_case_3_5 test_group_3
#define numb_case_3_5 "3.5"
#define name_case_3_5 "Double attempt a connection request."
#define sref_case_3_5 "(none)"
#define desc_case_3_5 "\
Attempts a connection request twice to the same address.  The second request is\n\
made either in the awaiting confirmation of connection request state.  This is\n\
to check that the second connection request is refused with a TOUTSTATE error."

int
test_case_3_5_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		state++;
		if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		state++;
		test_sleep(child, 5);
		state++;
		if (expect(child, SHORT_WAIT, __TEST_DISCON_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		test_msleep(child, SHORT_WAIT);
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
			goto failure;
		state++;
		expect(child, NORMAL_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __TEST_CONN_CON:
			if (test_level == T_INET_TCP)
				break;
			goto failure;
		case __EVENT_NO_MSG:
			break;
		default:
			goto failure;
		}
		state++;
		test_sleep(child, 5);
		state++;
		if (expect(child, LONGER_WAIT << 1, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_5_resp(int child)
{
	test_sleep(child, 6);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_3_5_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, SHORT_WAIT, __TEST_CONN_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_sleep(child, 5);
	state++;
	test_data = NULL;
	last_sequence = last_sequence;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_3_5_conn	preamble_1s
#define preamble_3_5_resp	preamble_1s
#define preamble_3_5_list	preamble_1s

#define postamble_3_5_conn	postamble_1
#define postamble_3_5_resp	postamble_1
#define postamble_3_5_list	postamble_1

struct test_stream test_3_5_conn = { &preamble_3_5_conn, &test_case_3_5_conn, &postamble_3_5_conn };
struct test_stream test_3_5_resp = { &preamble_3_5_resp, &test_case_3_5_resp, &postamble_3_5_resp };
struct test_stream test_3_5_list = { &preamble_3_5_list, &test_case_3_5_list, &postamble_3_5_list };

#define tgrp_case_3_6 test_group_3
#define numb_case_3_6 "3.6"
#define name_case_3_6 "Attempt a connection request from the unbound state."
#define sref_case_3_6 "(none)"
#define desc_case_3_6 "\
Attempts a connection request from the unbound state.  This is to check that\n\
the connection request is refused with a TOUTSTATE error.  The test then\n\
properly completes a connection to ensure that the state machine continues to\n\
work correctly."

int
test_case_3_6_conn(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		state++;
		test_sleep(child, 5);
		state++;
		if (expect(child, SHORT_WAIT, __TEST_DISCON_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		expect(child, NORMAL_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __TEST_CONN_CON:
			if (test_level == T_INET_TCP)
				break;
			goto failure;
		case __EVENT_NO_MSG:
			break;
		default:
			goto failure;
		}
		state++;
		test_sleep(child, 5);
		state++;
		if (expect(child, LONGER_WAIT << 1, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_3_6_resp(int child)
{
	test_sleep(child, 6);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_3_6_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, SHORT_WAIT, __TEST_CONN_IND) == __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_sleep(child, 5);
	state++;
	test_data = NULL;
	last_sequence = last_sequence;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_3_6_conn	preamble_0
#define preamble_3_6_resp	preamble_1s
#define preamble_3_6_list	preamble_1s

#define postamble_3_6_conn	postamble_1
#define postamble_3_6_resp	postamble_1
#define postamble_3_6_list	postamble_1

struct test_stream test_3_6_conn = { &preamble_3_6_conn, &test_case_3_6_conn, &postamble_3_6_conn };
struct test_stream test_3_6_resp = { &preamble_3_6_resp, &test_case_3_6_resp, &postamble_3_6_resp };
struct test_stream test_3_6_list = { &preamble_3_6_list, &test_case_3_6_list, &postamble_3_6_list };

#define test_group_4 "Connection and disconnection -- successful"
#define sref_case_4_1 "TPI Version 2 Draft 2 -- Appendix A -- Connection Acceptance"

/*
 *  Accept a connection.
 */
#define tgrp_case_4_1_1 test_group_4
#define numb_case_4_1_1 "4.1.1"
#define name_case_4_1_1 "Accept a connection."
#define sref_case_4_1_1 sref_case_4_1
#define desc_case_4_1_1 "\
Attempt and accept a connection.  This should be successful."

int
test_case_4_1_1_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_1_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_1_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_1_conn	preamble_1
#define preamble_4_1_1_resp	preamble_1
#define preamble_4_1_1_list	preamble_1

#define postamble_4_1_1_conn	postamble_2_conn
#define postamble_4_1_1_resp	postamble_2_resp
#define postamble_4_1_1_list	postamble_2_list

struct test_stream test_4_1_1_conn = { &preamble_4_1_1_conn, &test_case_4_1_1_conn, &postamble_4_1_1_conn };
struct test_stream test_4_1_1_resp = { &preamble_4_1_1_resp, &test_case_4_1_1_resp, &postamble_4_1_1_resp };
struct test_stream test_4_1_1_list = { &preamble_4_1_1_list, &test_case_4_1_1_list, &postamble_4_1_1_list };

/*
 *  Accept a connection on the listening stream.
 */
#define tgrp_case_4_1_2 test_group_4
#define numb_case_4_1_2 "4.1.2"
#define name_case_4_1_2 "Accept a connection on the same stream."
#define sref_case_4_1_2 sref_case_4_1
#define desc_case_4_1_2 "\
Attempt and accept a connection on the same (listening) stream.  This is done by\n\
providing a acceptor id that belongs to the listening stream.  This test case\n\
tests that situation."

int
test_case_4_1_2_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_2_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_2_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[2];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_2_conn	preamble_1
#define preamble_4_1_2_resp	preamble_1
#define preamble_4_1_2_list	preamble_1

#define postamble_4_1_2_conn	postamble_2_conn
#define postamble_4_1_2_resp	postamble_2_list
#define postamble_4_1_2_list	postamble_2_resp

struct test_stream test_4_1_2_conn = { &preamble_4_1_2_conn, &test_case_4_1_2_conn, &postamble_4_1_2_conn };
struct test_stream test_4_1_2_resp = { &preamble_4_1_2_resp, &test_case_4_1_2_resp, &postamble_4_1_2_resp };
struct test_stream test_4_1_2_list = { &preamble_4_1_2_list, &test_case_4_1_2_list, &postamble_4_1_2_list };

/*
 *  Accept only one connection on the listening stream.
 */
#define tgrp_case_4_1_3 test_group_4
#define numb_case_4_1_3 "4.1.3"
#define name_case_4_1_3 "Accept a single connection on the same stream."
#define sref_case_4_1_3 sref_case_4_1
#define desc_case_4_1_3 "\
Attempt and accept a connection on the same (listening) stream.  Generate\n\
another connection attempt to the listening stream to ensure that a second\n\
connection indication is not generated while the stream is connected.  Upon\n\
release, the connection indication may be delivered if it continues to exist."

int
test_case_4_1_3_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_3_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	expect(child, LONG_WAIT << 2, __TEST_DISCON_IND);
	switch (last_event) {
	case __TEST_CONN_CON:
	case __EVENT_NO_MSG:
		state++;
		test_msleep(child, NORMAL_WAIT);
		state++;
		if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	case __TEST_DISCON_IND:
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_3_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[2];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	expect(child, LONG_WAIT, __EVENT_NO_MSG);
	switch (last_event) {
	case __EVENT_NO_MSG:
		state++;
		if (expect(child, LONG_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	case __TEST_DISCON_IND:
		break;
	default:
		goto failure;
	}
	state++;
	expect(child, LONG_WAIT, __EVENT_NO_MSG);
	switch (last_event) {
	case __TEST_CONN_IND:
		state++;
		test_resfd = test_fd[2];
		test_data = NULL;
		test_opts = &opt_conn;
		test_olen = sizeof(opt_conn);
		if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, LONG_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	case __EVENT_NO_MSG:
	case __EVENT_TIMEOUT:
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_3_conn	preamble_1
#define preamble_4_1_3_resp	preamble_1
#define preamble_4_1_3_list	preamble_1

#define postamble_4_1_3_conn	postamble_1
#define postamble_4_1_3_resp	postamble_1
#define postamble_4_1_3_list	postamble_1

struct test_stream test_4_1_3_conn = { &preamble_4_1_3_conn, &test_case_4_1_3_conn, &postamble_4_1_3_conn };
struct test_stream test_4_1_3_resp = { &preamble_4_1_3_resp, &test_case_4_1_3_resp, &postamble_4_1_3_resp };
struct test_stream test_4_1_3_list = { &preamble_4_1_3_list, &test_case_4_1_3_list, &postamble_4_1_3_list };

/*
 *  Accept a connection on an unbound stream.
 */
#define tgrp_case_4_1_4 test_group_4
#define numb_case_4_1_4 "4.1.4"
#define name_case_4_1_4 "Accept a connection on an unbound stream."
#define sref_case_4_1_4 sref_case_4_1
#define desc_case_4_1_4 "\
Attempt and accept a connection on an unbound stream.  The specification says\n\
that if a connection indication is accepted on an unbound stream that the\n\
transport service provider will automatically bind that stream to the address of\n\
the listening stream.  This test case tests both behaviors."

int
test_case_4_1_4_conn(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Synchronization test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_4_resp(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;
	struct sockaddr_in *sin;

	/* leave unbound */
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	sin = (typeof(sin)) (cbuf + p->addr_ack.LOCADDR_offset);
	if (sin->sin_family != addrs[2][0].sin_family) {
		failure_string = "LOCADDR sin_family unexpected";
		goto failure;
	}
	state++;
	if (sin->sin_port != addrs[2][0].sin_port) {
		failure_string = "LOCADDR sin_port unexpected";
		goto failure;
	}
#if 0
	state++;
	if (sin->sin_addr.s_addr != addrs[2][0].sin_addr.s_addr) {
		failure_string = "LOCADDR sin_addr.s_addr unexpected";
		goto failure;
	}
#endif
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_4_list(int child)
{
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_4_conn	preamble_0
#define preamble_4_1_4_resp	preamble_0
#define preamble_4_1_4_list	preamble_0

#define postamble_4_1_4_conn	postamble_2_conn
#define postamble_4_1_4_resp	postamble_2_resp
#define postamble_4_1_4_list	postamble_2_list

struct test_stream test_4_1_4_conn = { &preamble_4_1_4_conn, &test_case_4_1_4_conn, &postamble_4_1_4_conn };
struct test_stream test_4_1_4_resp = { &preamble_4_1_4_resp, &test_case_4_1_4_resp, &postamble_4_1_4_resp };
struct test_stream test_4_1_4_list = { &preamble_4_1_4_list, &test_case_4_1_4_list, &postamble_4_1_4_list };

/*
 *  Attempt to connect in the data transfer state.
 */
#define tgrp_case_4_1_5 test_group_4
#define numb_case_4_1_5 "4.1.5"
#define name_case_4_1_5 "Attempt a connection in the data transfer state."
#define sref_case_4_1_5 sref_case_4_1
#define desc_case_4_1_5 "\
Attempt and accept a connection.  Next attempt another connection in the data\n\
transfer state.  This second attempt should fail with error TOUTSTATE.  The\n\
complete and disconnection of the connection to ensure that the state machine\n\
continues to function correctly."

int
test_case_4_1_5_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_5_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_5_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_5_conn	preamble_1
#define preamble_4_1_5_resp	preamble_1
#define preamble_4_1_5_list	preamble_1

#define postamble_4_1_5_conn	postamble_2_conn
#define postamble_4_1_5_resp	postamble_2_resp
#define postamble_4_1_5_list	postamble_2_list

struct test_stream test_4_1_5_conn = { &preamble_4_1_5_conn, &test_case_4_1_5_conn, &postamble_4_1_5_conn };
struct test_stream test_4_1_5_resp = { &preamble_4_1_5_resp, &test_case_4_1_5_resp, &postamble_4_1_5_resp };
struct test_stream test_4_1_5_list = { &preamble_4_1_5_list, &test_case_4_1_5_list, &postamble_4_1_5_list };

/*
 *  Connect and disconnect two connections in sequence.
 */
#define tgrp_case_4_1_6 test_group_4
#define numb_case_4_1_6 "4.1.6"
#define name_case_4_1_6 "Attempt a two consecutive connections, no unbind."
#define sref_case_4_1_6 sref_case_4_1
#define desc_case_4_1_6 "\
Attempt and accept a connection, disconnect, and then attempt and disconnect\n\
again without unbinding.  This checks that the state machine works correctly\n\
after completing a connection cycle."

int
test_case_4_1_6_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Synchronizing test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	/* ---- */
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Synchronizing test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_6_resp(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, LONG_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Synchronizing test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	/* ---- */
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, LONG_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Synchronizing test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_6_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	/* ---- */
	/* ---- */
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_6_conn	preamble_1
#define preamble_4_1_6_resp	preamble_1
#define preamble_4_1_6_list	preamble_1

#define postamble_4_1_6_conn	postamble_2_conn
#define postamble_4_1_6_resp	postamble_2_resp
#define postamble_4_1_6_list	postamble_2_list

struct test_stream test_4_1_6_conn = { &preamble_4_1_6_conn, &test_case_4_1_6_conn, &postamble_4_1_6_conn };
struct test_stream test_4_1_6_resp = { &preamble_4_1_6_resp, &test_case_4_1_6_resp, &postamble_4_1_6_resp };
struct test_stream test_4_1_6_list = { &preamble_4_1_6_list, &test_case_4_1_6_list, &postamble_4_1_6_list };

/*
 *  Connect and disconnect two connections in sequence.
 */
#define tgrp_case_4_1_7 test_group_4
#define numb_case_4_1_7 "4.1.7"
#define name_case_4_1_7 "Attempt a two consecutive connections, with unbind."
#define sref_case_4_1_7 sref_case_4_1
#define desc_case_4_1_7 "\
Attempt and accept a connection, disconnect, and then attempt and disconnect\n\
again with unbinding.  This checks that the state machine works correctly\n\
after completing a connection cycle."

int
preamble_4_1_7(int child)
{
	union T_primitives *p = (typeof(p)) cbuf;
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_YES};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_NEGOTIATE;
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (p->optmgmt_ack.MGMT_flags != T_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_7_conn	preamble_4_1_7
#define preamble_4_1_7_resp	preamble_4_1_7
#define preamble_4_1_7_list	preamble_4_1_7

int
midamble_4_1_7_conn(int child)
{
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
midamble_4_1_7_resp(int child)
{
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
midamble_4_1_7_list(int child)
{
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_7_conn_part(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = "Synchronization test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, INFINITE_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_7_resp_part(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, INFINITE_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	test_data = "Synchronization test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_7_list_part(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_7_conn(int child)
{
	if (test_case_4_1_7_conn_part(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (midamble_4_1_7_conn(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (preamble_4_1_7(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (test_case_4_1_7_conn_part(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (midamble_4_1_7_conn(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_7_resp(int child)
{
	if (test_case_4_1_7_resp_part(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (midamble_4_1_7_resp(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (preamble_4_1_7(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (test_case_4_1_7_resp_part(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (midamble_4_1_7_resp(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_7_list(int child)
{
	if (test_case_4_1_7_list_part(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (midamble_4_1_7_list(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (preamble_4_1_7(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (test_case_4_1_7_list_part(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* ---- */
	if (midamble_4_1_7_list(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define postamble_4_1_7_conn	postamble_0
#define postamble_4_1_7_resp	postamble_0
#define postamble_4_1_7_list	postamble_0

struct test_stream test_4_1_7_conn = { &preamble_4_1_7_conn, &test_case_4_1_7_conn, &postamble_4_1_7_conn };
struct test_stream test_4_1_7_resp = { &preamble_4_1_7_resp, &test_case_4_1_7_resp, &postamble_4_1_7_resp };
struct test_stream test_4_1_7_list = { &preamble_4_1_7_list, &test_case_4_1_7_list, &postamble_4_1_7_list };

/*
 *  Double connection response.
 */
#define tgrp_case_4_1_8 test_group_4
#define numb_case_4_1_8 "4.1.8"
#define name_case_4_1_8 "Connect with double connection response attempt, different stream."
#define sref_case_4_1_8 sref_case_4_1
#define desc_case_4_1_8 "\
Attempt a connection and accept on a separate stream twice.  The second\n\
connection respose is issued in the TS_IDLE state for the listening stream and\n\
should fail with error TOUTSTATE.  The connection transfers data and disconnects\n\
to ensure that the state machine remains correct."

int
test_case_4_1_8_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_8_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_8_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_8_conn	preamble_1
#define preamble_4_1_8_resp	preamble_1
#define preamble_4_1_8_list	preamble_1

#define postamble_4_1_8_conn	postamble_2_conn
#define postamble_4_1_8_resp	postamble_2_resp
#define postamble_4_1_8_list	postamble_2_list

struct test_stream test_4_1_8_conn = { &preamble_4_1_8_conn, &test_case_4_1_8_conn, &postamble_4_1_8_conn };
struct test_stream test_4_1_8_resp = { &preamble_4_1_8_resp, &test_case_4_1_8_resp, &postamble_4_1_8_resp };
struct test_stream test_4_1_8_list = { &preamble_4_1_8_list, &test_case_4_1_8_list, &postamble_4_1_8_list };

/*
 *  Double connection response.
 */
#define tgrp_case_4_1_9 test_group_4
#define numb_case_4_1_9 "4.1.9"
#define name_case_4_1_9 "Connect with double connection response attempt, same stream."
#define sref_case_4_1_9 sref_case_4_1
#define desc_case_4_1_9 "\
Attempt a connection and accept on the same stream twice.  The second connection\n\
respose is issued in the TS_DATA_XFER state for the listening stream and should\n\
fail with error TOUTSTATE.  The connection transfers data and disconnects to\n\
ensure that the state machine remains correct."

int
test_case_4_1_9_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_9_resp(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_1_9_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[2];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[2];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS || last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_1_9_conn	preamble_1
#define preamble_4_1_9_resp	preamble_1
#define preamble_4_1_9_list	preamble_1

#define postamble_4_1_9_conn	postamble_2_conn
#define postamble_4_1_9_resp	postamble_2_list
#define postamble_4_1_9_list	postamble_2_resp

struct test_stream test_4_1_9_conn = { &preamble_4_1_9_conn, &test_case_4_1_9_conn, &postamble_4_1_9_conn };
struct test_stream test_4_1_9_resp = { &preamble_4_1_9_resp, &test_case_4_1_9_resp, &postamble_4_1_9_resp };
struct test_stream test_4_1_9_list = { &preamble_4_1_9_list, &test_case_4_1_9_list, &postamble_4_1_9_list };

/*
 *  Connect with data.
 */
#define tgrp_case_4_2_1 test_group_4
#define numb_case_4_2_1 "4.2.1"
#define name_case_4_2_1 "Connect with data."
#define sref_case_4_2_1 "(none)"
#define desc_case_4_2_1 "\
Attempt and accept a connection where data is also passed in the\n\
connection request and the connection response.  This cannot be\n\
accomplished in TCP protocol, and should generate an error."

int
test_case_4_2_1_conn(int child)
{
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = "Connection Data!";
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (test_level) {
	case T_INET_TCP:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS
		    || last_t_errno != TBADDATA)
			goto failure;
		state++;
		break;
	case T_INET_UDP:
	case T_INET_IP:
		goto script_error;
	case T_INET_SCTP:
		if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS) {
			failure_string = "Did not get T_OK_ACK.";
			goto failure;
		}
		state++;
		test_sleep(child, 2);
		state++;
		if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS) {
			failure_string = "Did not get T_CONN_CON.";
			goto failure;
		}
		state++;
		if (expect(child, SHORT_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS) {
			failure_string = "Did not get T_EXDATA_IND.";
			goto failure;
		}
		state++;
		test_msleep(child, LONG_WAIT);
		state++;
		break;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      script_error:
	return (__RESULT_SCRIPT_ERROR);
}

int
test_case_4_2_1_resp(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	switch (test_level) {
	case T_INET_TCP:
		if (wait_event(child, SHORT_WAIT) != __EVENT_NO_MSG)
			goto failure;
		state++;
		break;
	case T_INET_SCTP:
		test_sleep(child, 2);
		state++;
		if (expect(child, LONGER_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS) {
			failure_string = "Did not get T_EXDATA_IND.";
			goto failure;
		}
		state++;
		test_msleep(child, LONG_WAIT);
		state++;
		break;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_2_1_list(int child)
{
	test_msleep(child, LONG_WAIT);
	expect(child, LONGER_WAIT, __TEST_CONN_IND);
	state++;
	switch (test_level) {
	case T_INET_TCP:
		if (last_event != __EVENT_NO_MSG)
			goto failure;
		state++;
		break;
	case T_INET_SCTP:
		if (last_event != __TEST_CONN_IND) {
			failure_string = "Did not get T_CONN_IND.";
			goto failure;
		}
		state++;
		test_sleep(child, 2);
		state++;
		test_resfd = test_fd[1];
		test_data = "Connection Response Data!\n";
		test_opts = &opt_conn;
		test_olen = sizeof(opt_conn);
		if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS) {
			failure_string = "Could not send T_CONN_RES.";
			goto failure;
		}
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS) {
			failure_string = "Did not get T_OK_ACK.";
			goto failure;
		}
		state++;
		test_msleep(child, LONG_WAIT);
		state++;
		break;
	}
	return (__RESULT_SUCCESS);
failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_2_1_conn	preamble_1s
#define preamble_4_2_1_resp	preamble_1s
#define preamble_4_2_1_list	preamble_1s

#if 0
#define postamble_4_2_1_conn	postamble_1
#define postamble_4_2_1_resp	postamble_1
#define postamble_4_2_1_list	postamble_1
#else
#define postamble_4_2_1_conn	postamble_2_conn
#define postamble_4_2_1_resp	postamble_2_resp
#define postamble_4_2_1_list	postamble_2_list
#endif

struct test_stream test_4_2_1_conn = { &preamble_4_2_1_conn, &test_case_4_2_1_conn, &postamble_4_2_1_conn };
struct test_stream test_4_2_1_resp = { &preamble_4_2_1_resp, &test_case_4_2_1_resp, &postamble_4_2_1_resp };
struct test_stream test_4_2_1_list = { &preamble_4_2_1_list, &test_case_4_2_1_list, &postamble_4_2_1_list };

/*
 *  Connect, transfer single data.
 */
#define tgrp_case_4_2_2 test_group_4
#define numb_case_4_2_2 "4.2.2"
#define name_case_4_2_2 "Connect with single data delayed accept"
#define sref_case_4_2_2 "(none)"
#define desc_case_4_2_2 "\
Attempt a connection where data is passed immediately following connection\n\
confirmation, and then later accept the connection at the listening stream.\n\
Ensure that the data is indicated on the responding stream.  This was at one\n\
time a bug report.  This test case is for regression on the bug fix."

int
test_case_4_2_2_conn(int child)
{
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_sleep(child, 5);
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Initial data request.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_2_2_resp(int child)
{
	test_sleep(child, 5);
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_2_2_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_sleep(child, 5);
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_2_2_conn	preamble_1s
#define preamble_4_2_2_resp	preamble_1s
#define preamble_4_2_2_list	preamble_1s

#define postamble_4_2_2_conn	postamble_2_conn
#define postamble_4_2_2_resp	postamble_2_resp
#define postamble_4_2_2_list	postamble_2_list

struct test_stream test_4_2_2_conn = { &preamble_4_2_2_conn, &test_case_4_2_2_conn, &postamble_4_2_2_conn };
struct test_stream test_4_2_2_resp = { &preamble_4_2_2_resp, &test_case_4_2_2_resp, &postamble_4_2_2_resp };
struct test_stream test_4_2_2_list = { &preamble_4_2_2_list, &test_case_4_2_2_list, &postamble_4_2_2_list };

/*
 *  Connect with options.
 */
#define tgrp_case_4_3 test_group_4
#define numb_case_4_3 "4.3"
#define name_case_4_3 "Connect with options"
#define sref_case_4_3 "XNS 5.2 -- Chapter 6 -- The Use of Options in XTI"
#define desc_case_4_3 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response."

int
test_case_4_3_conn(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (last_t_errno != TNOTSUPPORT)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
			goto failure;
		/* FIXME: check that the options in the connection confirmation are correct */
		break;
	default:
		goto failure;
	}
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_3_resp(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_3_list(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, LONGER_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
			goto failure;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (last_t_errno != TNOTSUPPORT)
			goto failure;
		state++;
		break;
	case T_COTS:
	case T_COTS_ORD:
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		goto failure;
	}
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_4_3_conn_readonly(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADOPT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}


int
test_case_4_3_resp_readonly(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_list_readonly(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_4_3_conn	preamble_1s
#define preamble_4_3_resp	preamble_1s
#define preamble_4_3_list	preamble_1s

int
postamble_4_3_conn(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_1(child);
	return postamble_2_conn(child);
}

int
postamble_4_3_resp(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_1(child);
	return postamble_2_resp(child);
}

int
postamble_4_3_list(int child)
{
	if (last_info.SERV_type == T_CLTS)
		return postamble_1(child);
	return postamble_2_list(child);
}

#if 0
#define postamble_4_3_conn_readonly postamble_4_3_conn
#define postamble_4_3_resp_readonly postamble_4_3_resp
#define postamble_4_3_list_readonly postamble_4_3_list
#else
#define postamble_4_3_conn_readonly postamble_1
#define postamble_4_3_resp_readonly postamble_1
#define postamble_4_3_list_readonly postamble_1
#endif

struct test_stream test_4_3_conn = { &preamble_4_3_conn, &test_case_4_3_conn, &postamble_4_3_conn };
struct test_stream test_4_3_resp = { &preamble_4_3_resp, &test_case_4_3_resp, &postamble_4_3_resp };
struct test_stream test_4_3_list = { &preamble_4_3_list, &test_case_4_3_list, &postamble_4_3_list };

/*
 *  Connect with options - XTI_DEBUG.
 */
#define tgrp_case_4_3_1_1 test_group_4
#define numb_case_4_3_1_1 "4.3.1.1"
#define name_case_4_3_1_1 "Connect with options - XTI_DEBUG"
#define sref_case_4_3_1_1 sref_case_4_3
#define desc_case_4_3_1_1 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the XTI_DEBUG option."

int
test_case_4_3_1_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_1_1_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_1_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_DEBUG, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_1_1_conn = { &preamble_4_3_conn, &test_case_4_3_1_1_conn, &postamble_4_3_conn };
struct test_stream test_4_3_1_1_resp = { &preamble_4_3_resp, &test_case_4_3_1_1_resp, &postamble_4_3_resp };
struct test_stream test_4_3_1_1_list = { &preamble_4_3_list, &test_case_4_3_1_1_list, &postamble_4_3_list };

/*
 *  Connect with options - XTI_LINGER.
 */
#define tgrp_case_4_3_1_2 test_group_4
#define numb_case_4_3_1_2 "4.3.1.2"
#define name_case_4_3_1_2 "Connect with options - XTI_LINGER"
#define sref_case_4_3_1_2 sref_case_4_3
#define desc_case_4_3_1_2 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the XTI_LINGER option."

int
test_case_4_3_1_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_1_2_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_1_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_linger opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_linger), XTI_GENERIC, XTI_LINGER, T_SUCCESS}, {
		T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_1_2_conn = { &preamble_4_3_conn, &test_case_4_3_1_2_conn, &postamble_4_3_conn };
struct test_stream test_4_3_1_2_resp = { &preamble_4_3_resp, &test_case_4_3_1_2_resp, &postamble_4_3_resp };
struct test_stream test_4_3_1_2_list = { &preamble_4_3_list, &test_case_4_3_1_2_list, &postamble_4_3_list };

/*
 *  Connect with options - XTI_RCVBUF.
 */
#define tgrp_case_4_3_1_3 test_group_4
#define numb_case_4_3_1_3 "4.3.1.3"
#define name_case_4_3_1_3 "Connect with options - XTI_RCVBUF"
#define sref_case_4_3_1_3 sref_case_4_3
#define desc_case_4_3_1_3 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the XTI_RCVBUF option."

int
test_case_4_3_1_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_1_3_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_1_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_1_3_conn = { &preamble_4_3_conn, &test_case_4_3_1_3_conn, &postamble_4_3_conn };
struct test_stream test_4_3_1_3_resp = { &preamble_4_3_resp, &test_case_4_3_1_3_resp, &postamble_4_3_resp };
struct test_stream test_4_3_1_3_list = { &preamble_4_3_list, &test_case_4_3_1_3_list, &postamble_4_3_list };

/*
 *  Connect with options - XTI_RCVLOWAT.
 */
#define tgrp_case_4_3_1_4 test_group_4
#define numb_case_4_3_1_4 "4.3.1.4"
#define name_case_4_3_1_4 "Connect with options - XTI_RCVLOWAT"
#define sref_case_4_3_1_4 sref_case_4_3
#define desc_case_4_3_1_4 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the XTI_RCVLOWAT option."

int
test_case_4_3_1_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_1_4_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_1_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_RCVLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_1_4_conn = { &preamble_4_3_conn, &test_case_4_3_1_4_conn, &postamble_4_3_conn };
struct test_stream test_4_3_1_4_resp = { &preamble_4_3_resp, &test_case_4_3_1_4_resp, &postamble_4_3_resp };
struct test_stream test_4_3_1_4_list = { &preamble_4_3_list, &test_case_4_3_1_4_list, &postamble_4_3_list };

/*
 *  Connect with options - XTI_SNDBUF.
 */
#define tgrp_case_4_3_1_5 test_group_4
#define numb_case_4_3_1_5 "4.3.1.5"
#define name_case_4_3_1_5 "Connect with options - XTI_SNDBUF"
#define sref_case_4_3_1_5 sref_case_4_3
#define desc_case_4_3_1_5 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the XTI_SNDBUF option."

int
test_case_4_3_1_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_1_5_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_1_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDBUF, T_SUCCESS}
	, 32767};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_1_5_conn = { &preamble_4_3_conn, &test_case_4_3_1_5_conn, &postamble_4_3_conn };
struct test_stream test_4_3_1_5_resp = { &preamble_4_3_resp, &test_case_4_3_1_5_resp, &postamble_4_3_resp };
struct test_stream test_4_3_1_5_list = { &preamble_4_3_list, &test_case_4_3_1_5_list, &postamble_4_3_list };

/*
 *  Connect with options - XTI_SNDLOWAT.
 */
#define tgrp_case_4_3_1_6 test_group_4
#define numb_case_4_3_1_6 "4.3.1.6"
#define name_case_4_3_1_6 "Connect with options - XTI_SNDLOWAT"
#define sref_case_4_3_1_6 sref_case_4_3
#define desc_case_4_3_1_6 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the XTI_SNDLOWAT option."

int
test_case_4_3_1_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_1_6_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_1_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_uscalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), XTI_GENERIC, XTI_SNDLOWAT, T_SUCCESS}
	, 1};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_1_6_conn = { &preamble_4_3_conn, &test_case_4_3_1_6_conn, &postamble_4_3_conn };
struct test_stream test_4_3_1_6_resp = { &preamble_4_3_resp, &test_case_4_3_1_6_resp, &postamble_4_3_resp };
struct test_stream test_4_3_1_6_list = { &preamble_4_3_list, &test_case_4_3_1_6_list, &postamble_4_3_list };

/*
 *  Connect with options - T_IP_TOS.
 */
#define tgrp_case_4_3_2_1 test_group_4
#define numb_case_4_3_2_1 "4.3.2.1"
#define name_case_4_3_2_1 "Connect with options - T_IP_TOS"
#define sref_case_4_3_2_1 sref_case_4_3
#define desc_case_4_3_2_1 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_IP_TOS option."

int
test_case_4_3_2_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		unsigned char opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_2_1_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_2_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		unsigned char opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TOS, T_SUCCESS}, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_2_1_conn = { &preamble_4_3_conn, &test_case_4_3_2_1_conn, &postamble_4_3_conn };
struct test_stream test_4_3_2_1_resp = { &preamble_4_3_resp, &test_case_4_3_2_1_resp, &postamble_4_3_resp };
struct test_stream test_4_3_2_1_list = { &preamble_4_3_list, &test_case_4_3_2_1_list, &postamble_4_3_list };

/*
 *  Connect with options - T_IP_TTL.
 */
#define tgrp_case_4_3_2_2 test_group_4
#define numb_case_4_3_2_2 "4.3.2.2"
#define name_case_4_3_2_2 "Connect with options - T_IP_TTL"
#define sref_case_4_3_2_2 sref_case_4_3
#define desc_case_4_3_2_2 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_IP_TTL option."

int
test_case_4_3_2_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		unsigned char opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, 64};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_2_2_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_2_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		unsigned char opt_val;
	} options = {
		{
	sizeof(struct t_opthdr) + sizeof(unsigned char), T_INET_IP, T_IP_TTL, T_SUCCESS}, 64};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_2_2_conn = { &preamble_4_3_conn, &test_case_4_3_2_2_conn, &postamble_4_3_conn };
struct test_stream test_4_3_2_2_resp = { &preamble_4_3_resp, &test_case_4_3_2_2_resp, &postamble_4_3_resp };
struct test_stream test_4_3_2_2_list = { &preamble_4_3_list, &test_case_4_3_2_2_list, &postamble_4_3_list };

/*
 *  Connect with options - T_IP_REUSEADDR.
 */
#define tgrp_case_4_3_2_3 test_group_4
#define numb_case_4_3_2_3 "4.3.2.3"
#define name_case_4_3_2_3 "Connect with options - T_IP_REUSEADDR"
#define sref_case_4_3_2_3 sref_case_4_3
#define desc_case_4_3_2_3 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_IP_REUSEADDR option."

int
test_case_4_3_2_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_2_3_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_2_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_REUSEADDR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_2_3_conn = { &preamble_4_3_conn, &test_case_4_3_2_3_conn, &postamble_4_3_conn };
struct test_stream test_4_3_2_3_resp = { &preamble_4_3_resp, &test_case_4_3_2_3_resp, &postamble_4_3_resp };
struct test_stream test_4_3_2_3_list = { &preamble_4_3_list, &test_case_4_3_2_3_list, &postamble_4_3_list };

/*
 *  Connect with options - T_IP_DONTROUTE.
 */
#define tgrp_case_4_3_2_4 test_group_4
#define numb_case_4_3_2_4 "4.3.2.4"
#define name_case_4_3_2_4 "Connect with options - T_IP_DONTROUTE"
#define sref_case_4_3_2_4 sref_case_4_3
#define desc_case_4_3_2_4 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_IP_DONTROUTE option."

int
test_case_4_3_2_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_2_4_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_2_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_DONTROUTE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_2_4_conn = { &preamble_4_3_conn, &test_case_4_3_2_4_conn, &postamble_4_3_conn };
struct test_stream test_4_3_2_4_resp = { &preamble_4_3_resp, &test_case_4_3_2_4_resp, &postamble_4_3_resp };
struct test_stream test_4_3_2_4_list = { &preamble_4_3_list, &test_case_4_3_2_4_list, &postamble_4_3_list };

/*
 *  Connect with options - T_IP_BROADCAST.
 */
#define tgrp_case_4_3_2_5 test_group_4
#define numb_case_4_3_2_5 "4.3.2.5"
#define name_case_4_3_2_5 "Connect with options - T_IP_BROADCAST"
#define sref_case_4_3_2_5 sref_case_4_3
#define desc_case_4_3_2_5 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_IP_BROADCAST option."

int
test_case_4_3_2_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_2_5_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_2_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_IP, T_IP_BROADCAST, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_2_5_conn = { &preamble_4_3_conn, &test_case_4_3_2_5_conn, &postamble_4_3_conn };
struct test_stream test_4_3_2_5_resp = { &preamble_4_3_resp, &test_case_4_3_2_5_resp, &postamble_4_3_resp };
struct test_stream test_4_3_2_5_list = { &preamble_4_3_list, &test_case_4_3_2_5_list, &postamble_4_3_list };

/*
 *  Connect with options - T_UDP_CHECKSUM.
 */
#define tgrp_case_4_3_3_1 test_group_4
#define numb_case_4_3_3_1 "4.3.3.1"
#define name_case_4_3_3_1 "Connect with options - T_UDP_CHECKSUM"
#define sref_case_4_3_3_1 "(open)"
#define desc_case_4_3_3_1 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_UDP_CHECKSUM option."

int
test_case_4_3_3_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_3_1_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_3_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_uscalar_t), T_INET_UDP, T_UDP_CHECKSUM, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_3_1_conn = { &preamble_4_3_conn, &test_case_4_3_3_1_conn, &postamble_4_3_conn };
struct test_stream test_4_3_3_1_resp = { &preamble_4_3_resp, &test_case_4_3_3_1_resp, &postamble_4_3_resp };
struct test_stream test_4_3_3_1_list = { &preamble_4_3_list, &test_case_4_3_3_1_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_NODELAY.
 */
#define tgrp_case_4_3_4_1 test_group_4
#define numb_case_4_3_4_1 "4.3.4.1"
#define name_case_4_3_4_1 "Connect with options - T_TCP_NODELAY"
#define sref_case_4_3_4_1 sref_case_4_3
#define desc_case_4_3_4_1 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_NODELAY option."

int
test_case_4_3_4_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_1_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_1_conn = { &preamble_4_3_conn, &test_case_4_3_4_1_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_1_resp = { &preamble_4_3_resp, &test_case_4_3_4_1_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_1_list = { &preamble_4_3_list, &test_case_4_3_4_1_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_MAXSEG.
 */
#define tgrp_case_4_3_4_2 test_group_4
#define numb_case_4_3_4_2 "4.3.4.2"
#define name_case_4_3_4_2 "Connect with options - T_TCP_MAXSEG"
#define sref_case_4_3_4_2 sref_case_4_3
#define desc_case_4_3_4_2 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_MAXSEG option."

int
test_case_4_3_4_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_2_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_MAXSEG, T_SUCCESS}
	, 576};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_2_conn = { &preamble_4_3_conn, &test_case_4_3_4_2_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_2_resp = { &preamble_4_3_resp, &test_case_4_3_4_2_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_2_list = { &preamble_4_3_list, &test_case_4_3_4_2_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_KEEPALIVE.
 */
#define tgrp_case_4_3_4_3 test_group_4
#define numb_case_4_3_4_3 "4.3.4.3"
#define name_case_4_3_4_3 "Connect with options - T_TCP_KEEPALIVE"
#define sref_case_4_3_4_3 sref_case_4_3
#define desc_case_4_3_4_3 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_KEEPALIVE option."

int
test_case_4_3_4_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_3_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_kpalive opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_kpalive), T_INET_TCP, T_TCP_KEEPALIVE, T_SUCCESS}, {
		T_NO, 0}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_3_conn = { &preamble_4_3_conn, &test_case_4_3_4_3_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_3_resp = { &preamble_4_3_resp, &test_case_4_3_4_3_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_3_list = { &preamble_4_3_list, &test_case_4_3_4_3_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_CORK.
 */
#define tgrp_case_4_3_4_4 test_group_4
#define numb_case_4_3_4_4 "4.3.4.4"
#define name_case_4_3_4_4 "Connect with options - T_TCP_CORK"
#define sref_case_4_3_4_4 sref_case_4_3
#define desc_case_4_3_4_4 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_CORK option."

int
test_case_4_3_4_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_4_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_4_conn = { &preamble_4_3_conn, &test_case_4_3_4_4_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_4_resp = { &preamble_4_3_resp, &test_case_4_3_4_4_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_4_list = { &preamble_4_3_list, &test_case_4_3_4_4_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_KEEPIDLE.
 */
#define tgrp_case_4_3_4_5 test_group_4
#define numb_case_4_3_4_5 "4.3.4.5"
#define name_case_4_3_4_5 "Connect with options - T_TCP_KEEPIDLE"
#define sref_case_4_3_4_5 sref_case_4_3
#define desc_case_4_3_4_5 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_KEEPIDLE option."

int
test_case_4_3_4_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_5_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_KEEPIDLE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_5_conn = { &preamble_4_3_conn, &test_case_4_3_4_5_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_5_resp = { &preamble_4_3_resp, &test_case_4_3_4_5_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_5_list = { &preamble_4_3_list, &test_case_4_3_4_5_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_KEEPINTVL.
 */
#define tgrp_case_4_3_4_6 test_group_4
#define numb_case_4_3_4_6 "4.3.4.6"
#define name_case_4_3_4_6 "Connect with options - T_TCP_KEEPINTVL"
#define sref_case_4_3_4_6 sref_case_4_3
#define desc_case_4_3_4_6 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_KEEPINTVL option."

int
test_case_4_3_4_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_6_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_KEEPINTVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_6_conn = { &preamble_4_3_conn, &test_case_4_3_4_6_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_6_resp = { &preamble_4_3_resp, &test_case_4_3_4_6_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_6_list = { &preamble_4_3_list, &test_case_4_3_4_6_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_KEEPCNT.
 */
#define tgrp_case_4_3_4_7 test_group_4
#define numb_case_4_3_4_7 "4.3.4.7"
#define name_case_4_3_4_7 "Connect with options - T_TCP_KEEPCNT"
#define sref_case_4_3_4_7 sref_case_4_3
#define desc_case_4_3_4_7 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_KEEPCNT option."

int
test_case_4_3_4_7_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_7_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_7_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_KEEPCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_7_conn = { &preamble_4_3_conn, &test_case_4_3_4_7_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_7_resp = { &preamble_4_3_resp, &test_case_4_3_4_7_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_7_list = { &preamble_4_3_list, &test_case_4_3_4_7_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_SYNCNT.
 */
#define tgrp_case_4_3_4_8 test_group_4
#define numb_case_4_3_4_8 "4.3.4.8"
#define name_case_4_3_4_8 "Connect with options - T_TCP_SYNCNT"
#define sref_case_4_3_4_8 sref_case_4_3
#define desc_case_4_3_4_8 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_SYNCNT option."

int
test_case_4_3_4_8_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_8_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_8_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_SYNCNT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_8_conn = { &preamble_4_3_conn, &test_case_4_3_4_8_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_8_resp = { &preamble_4_3_resp, &test_case_4_3_4_8_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_8_list = { &preamble_4_3_list, &test_case_4_3_4_8_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_LINGER2.
 */
#define tgrp_case_4_3_4_9 test_group_4
#define numb_case_4_3_4_9 "4.3.4.9"
#define name_case_4_3_4_9 "Connect with options - T_TCP_LINGER2"
#define sref_case_4_3_4_9 sref_case_4_3
#define desc_case_4_3_4_9 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_LINGER2 option."

int
test_case_4_3_4_9_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_9_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_9_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_LINGER2, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_9_conn = { &preamble_4_3_conn, &test_case_4_3_4_9_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_9_resp = { &preamble_4_3_resp, &test_case_4_3_4_9_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_9_list = { &preamble_4_3_list, &test_case_4_3_4_9_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_DEFER_ACCEPT.
 */
#define tgrp_case_4_3_4_10 test_group_4
#define numb_case_4_3_4_10 "4.3.4.10"
#define name_case_4_3_4_10 "Connect with options - T_TCP_DEFER_ACCEPT"
#define sref_case_4_3_4_10 sref_case_4_3
#define desc_case_4_3_4_10 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_DEFER_ACCEPT option."

int
test_case_4_3_4_10_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_10_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_10_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_DEFER_ACCEPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_10_conn = { &preamble_4_3_conn, &test_case_4_3_4_10_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_10_resp = { &preamble_4_3_resp, &test_case_4_3_4_10_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_10_list = { &preamble_4_3_list, &test_case_4_3_4_10_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_WINDOW_CLAMP.
 */
#define tgrp_case_4_3_4_11 test_group_4
#define numb_case_4_3_4_11 "4.3.4.11"
#define name_case_4_3_4_11 "Connect with options - T_TCP_WINDOW_CLAMP"
#define sref_case_4_3_4_11 sref_case_4_3
#define desc_case_4_3_4_11 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_WINDOW_CLAMP option."

int
test_case_4_3_4_11_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_11_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_11_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_WINDOW_CLAMP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_11_conn = { &preamble_4_3_conn, &test_case_4_3_4_11_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_11_resp = { &preamble_4_3_resp, &test_case_4_3_4_11_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_11_list = { &preamble_4_3_list, &test_case_4_3_4_11_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_INFO.
 */
#define tgrp_case_4_3_4_12 test_group_4
#define numb_case_4_3_4_12 "4.3.4.12"
#define name_case_4_3_4_12 "Connect with options - T_TCP_INFO"
#define sref_case_4_3_4_12 sref_case_4_3
#define desc_case_4_3_4_12 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_INFO option."

int
test_case_4_3_4_12_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_INFO, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_12_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_12_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_INFO, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_12_conn = { &preamble_4_3_conn, &test_case_4_3_4_12_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_12_resp = { &preamble_4_3_resp, &test_case_4_3_4_12_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_12_list = { &preamble_4_3_list, &test_case_4_3_4_12_list, &postamble_4_3_list };

/*
 *  Connect with options - T_TCP_QUICKACK.
 */
#define tgrp_case_4_3_4_13 test_group_4
#define numb_case_4_3_4_13 "4.3.4.13"
#define name_case_4_3_4_13 "Connect with options - T_TCP_QUICKACK"
#define sref_case_4_3_4_13 sref_case_4_3
#define desc_case_4_3_4_13 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_TCP_QUICKACK option."

int
test_case_4_3_4_13_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_4_13_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_4_13_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_TCP, T_TCP_QUICKACK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_4_13_conn = { &preamble_4_3_conn, &test_case_4_3_4_13_conn, &postamble_4_3_conn };
struct test_stream test_4_3_4_13_resp = { &preamble_4_3_resp, &test_case_4_3_4_13_resp, &postamble_4_3_resp };
struct test_stream test_4_3_4_13_list = { &preamble_4_3_list, &test_case_4_3_4_13_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_NODELAY
 */
#define tgrp_case_4_3_5_1 test_group_4
#define numb_case_4_3_5_1 "4.3.5.1"
#define name_case_4_3_5_1 "Connect with options - T_SCTP_NODELAY"
#define sref_case_4_3_5_1 sref_case_4_3
#define desc_case_4_3_5_1 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_NODELAY option."

int
test_case_4_3_5_1_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_1_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_1_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_NODELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_1_conn = { &preamble_4_3_conn, &test_case_4_3_5_1_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_1_resp = { &preamble_4_3_resp, &test_case_4_3_5_1_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_1_list = { &preamble_4_3_list, &test_case_4_3_5_1_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_CORK
 */
#define tgrp_case_4_3_5_2 test_group_4
#define numb_case_4_3_5_2 "4.3.5.2"
#define name_case_4_3_5_2 "Connect with options - T_SCTP_CORK"
#define sref_case_4_3_5_2 sref_case_4_3
#define desc_case_4_3_5_2 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_CORK option."

int
test_case_4_3_5_2_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_2_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_2_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CORK, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_2_conn = { &preamble_4_3_conn, &test_case_4_3_5_2_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_2_resp = { &preamble_4_3_resp, &test_case_4_3_5_2_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_2_list = { &preamble_4_3_list, &test_case_4_3_5_2_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_PPI
 */
#define tgrp_case_4_3_5_3 test_group_4
#define numb_case_4_3_5_3 "4.3.5.3"
#define name_case_4_3_5_3 "Connect with options - T_SCTP_PPI"
#define sref_case_4_3_5_3 sref_case_4_3
#define desc_case_4_3_5_3 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_PPI option."

int
test_case_4_3_5_3_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_3_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_3_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PPI, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_3_conn = { &preamble_4_3_conn, &test_case_4_3_5_3_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_3_resp = { &preamble_4_3_resp, &test_case_4_3_5_3_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_3_list = { &preamble_4_3_list, &test_case_4_3_5_3_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_SID
 */
#define tgrp_case_4_3_5_4 test_group_4
#define numb_case_4_3_5_4 "4.3.5.4"
#define name_case_4_3_5_4 "Connect with options - T_SCTP_SID"
#define sref_case_4_3_5_4 sref_case_4_3
#define desc_case_4_3_5_4 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_SID option."

int
test_case_4_3_5_4_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_4_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_4_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SID, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_4_conn = { &preamble_4_3_conn, &test_case_4_3_5_4_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_4_resp = { &preamble_4_3_resp, &test_case_4_3_5_4_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_4_list = { &preamble_4_3_list, &test_case_4_3_5_4_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_SSN
 */
#define tgrp_case_4_3_5_5 test_group_4
#define numb_case_4_3_5_5 "4.3.5.5"
#define name_case_4_3_5_5 "Connect with options - T_SCTP_SSN"
#define sref_case_4_3_5_5 sref_case_4_3
#define desc_case_4_3_5_5 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_SSN option."

int
test_case_4_3_5_5_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_conn(child);
	case T_INET_SCTP:
		return test_case_4_3_conn_readonly(child);
	}
}

int
test_case_4_3_5_5_resp(int child)
{
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_resp(child);
	case T_INET_SCTP:
		return test_case_4_3_resp_readonly(child);
	}
}

int
test_case_4_3_5_5_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SSN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_list(child);
	case T_INET_SCTP:
		return test_case_4_3_list_readonly(child);
	}
}

struct test_stream test_4_3_5_5_conn = { &preamble_4_3_conn, &test_case_4_3_5_5_conn, &postamble_4_3_conn_readonly };
struct test_stream test_4_3_5_5_resp = { &preamble_4_3_resp, &test_case_4_3_5_5_resp, &postamble_4_3_resp_readonly };
struct test_stream test_4_3_5_5_list = { &preamble_4_3_list, &test_case_4_3_5_5_list, &postamble_4_3_list_readonly };

/*
 *  Connect with options - T_SCTP_TSN
 */
#define tgrp_case_4_3_5_6 test_group_4
#define numb_case_4_3_5_6 "4.3.5.6"
#define name_case_4_3_5_6 "Connect with options - T_SCTP_TSN"
#define sref_case_4_3_5_6 sref_case_4_3
#define desc_case_4_3_5_6 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_TSN option."

int
test_case_4_3_5_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_conn(child);
	case T_INET_SCTP:
		return test_case_4_3_conn_readonly(child);
	}
}

int
test_case_4_3_5_6_resp(int child)
{
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_resp(child);
	case T_INET_SCTP:
		return test_case_4_3_resp_readonly(child);
	}
}

int
test_case_4_3_5_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_TSN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_list(child);
	case T_INET_SCTP:
		return test_case_4_3_list_readonly(child);
	}
}

struct test_stream test_4_3_5_6_conn = { &preamble_4_3_conn, &test_case_4_3_5_6_conn, &postamble_4_3_conn_readonly };
struct test_stream test_4_3_5_6_resp = { &preamble_4_3_resp, &test_case_4_3_5_6_resp, &postamble_4_3_resp_readonly };
struct test_stream test_4_3_5_6_list = { &preamble_4_3_list, &test_case_4_3_5_6_list, &postamble_4_3_list_readonly };

/*
 *  Connect with options - T_SCTP_RECVOPT
 */
#define tgrp_case_4_3_5_7 test_group_4
#define numb_case_4_3_5_7 "4.3.5.7"
#define name_case_4_3_5_7 "Connect with options - T_SCTP_RECVOPT"
#define sref_case_4_3_5_7 sref_case_4_3
#define desc_case_4_3_5_7 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_RECVOPT option."

int
test_case_4_3_5_7_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_7_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_7_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RECVOPT, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_7_conn = { &preamble_4_3_conn, &test_case_4_3_5_7_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_7_resp = { &preamble_4_3_resp, &test_case_4_3_5_7_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_7_list = { &preamble_4_3_list, &test_case_4_3_5_7_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_COOKIE_LIFE
 */
#define tgrp_case_4_3_5_8 test_group_4
#define numb_case_4_3_5_8 "4.3.5.8"
#define name_case_4_3_5_8 "Connect with options - T_SCTP_COOKIE_LIFE"
#define sref_case_4_3_5_8 sref_case_4_3
#define desc_case_4_3_5_8 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_COOKIE_LIFE option."

int
test_case_4_3_5_8_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_8_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_8_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_LIFE, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_8_conn = { &preamble_4_3_conn, &test_case_4_3_5_8_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_8_resp = { &preamble_4_3_resp, &test_case_4_3_5_8_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_8_list = { &preamble_4_3_list, &test_case_4_3_5_8_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_SACK_DELAY
 */
#define tgrp_case_4_3_5_9 test_group_4
#define numb_case_4_3_5_9 "4.3.5.9"
#define name_case_4_3_5_9 "Connect with options - T_SCTP_SACK_DELAY"
#define sref_case_4_3_5_9 sref_case_4_3
#define desc_case_4_3_5_9 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_SACK_DELAY option."

int
test_case_4_3_5_9_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_9_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_9_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SACK_DELAY, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_9_conn = { &preamble_4_3_conn, &test_case_4_3_5_9_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_9_resp = { &preamble_4_3_resp, &test_case_4_3_5_9_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_9_list = { &preamble_4_3_list, &test_case_4_3_5_9_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_PATH_MAX_RETRANS
 */
#define tgrp_case_4_3_5_10 test_group_4
#define numb_case_4_3_5_10 "4.3.5.10"
#define name_case_4_3_5_10 "Connect with options - T_SCTP_PATH_MAX_RETRANS"
#define sref_case_4_3_5_10 sref_case_4_3
#define desc_case_4_3_5_10 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_PATH_MAX_RETRANS option."

int
test_case_4_3_5_10_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_10_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_10_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PATH_MAX_RETRANS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_10_conn = { &preamble_4_3_conn, &test_case_4_3_5_10_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_10_resp = { &preamble_4_3_resp, &test_case_4_3_5_10_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_10_list = { &preamble_4_3_list, &test_case_4_3_5_10_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_ASSOC_MAX_RETRANS
 */
#define tgrp_case_4_3_5_11 test_group_4
#define numb_case_4_3_5_11 "4.3.5.11"
#define name_case_4_3_5_11 "Connect with options - T_SCTP_ASSOC_MAX_RETRANS"
#define sref_case_4_3_5_11 sref_case_4_3
#define desc_case_4_3_5_11 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_ASSOC_MAX_RETRANS option."

int
test_case_4_3_5_11_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_11_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_11_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ASSOC_MAX_RETRANS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_11_conn = { &preamble_4_3_conn, &test_case_4_3_5_11_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_11_resp = { &preamble_4_3_resp, &test_case_4_3_5_11_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_11_list = { &preamble_4_3_list, &test_case_4_3_5_11_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_MAX_INIT_RETRIES
 */
#define tgrp_case_4_3_5_12 test_group_4
#define numb_case_4_3_5_12 "4.3.5.12"
#define name_case_4_3_5_12 "Connect with options - T_SCTP_MAX_INIT_RETRIES"
#define sref_case_4_3_5_12 sref_case_4_3
#define desc_case_4_3_5_12 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_MAX_INIT_RETRIES option."

int
test_case_4_3_5_12_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_12_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_12_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAX_INIT_RETRIES, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_12_conn = { &preamble_4_3_conn, &test_case_4_3_5_12_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_12_resp = { &preamble_4_3_resp, &test_case_4_3_5_12_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_12_list = { &preamble_4_3_list, &test_case_4_3_5_12_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_HEARTBEAT_ITVL
 */
#define tgrp_case_4_3_5_13 test_group_4
#define numb_case_4_3_5_13 "4.3.5.13"
#define name_case_4_3_5_13 "Connect with options - T_SCTP_HEARTBEAT_ITVL"
#define sref_case_4_3_5_13 sref_case_4_3
#define desc_case_4_3_5_13 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_HEARTBEAT_ITVL option."

int
test_case_4_3_5_13_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_13_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_13_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_HEARTBEAT_ITVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_13_conn = { &preamble_4_3_conn, &test_case_4_3_5_13_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_13_resp = { &preamble_4_3_resp, &test_case_4_3_5_13_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_13_list = { &preamble_4_3_list, &test_case_4_3_5_13_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_RTO_INITIAL
 */
#define tgrp_case_4_3_5_14 test_group_4
#define numb_case_4_3_5_14 "4.3.5.14"
#define name_case_4_3_5_14 "Connect with options - T_SCTP_RTO_INITIAL"
#define sref_case_4_3_5_14 sref_case_4_3
#define desc_case_4_3_5_14 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_RTO_INITIAL option."

int
test_case_4_3_5_14_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_14_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_14_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_INITIAL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_14_conn = { &preamble_4_3_conn, &test_case_4_3_5_14_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_14_resp = { &preamble_4_3_resp, &test_case_4_3_5_14_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_14_list = { &preamble_4_3_list, &test_case_4_3_5_14_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_RTO_MIN
 */
#define tgrp_case_4_3_5_15 test_group_4
#define numb_case_4_3_5_15 "4.3.5.15"
#define name_case_4_3_5_15 "Connect with options - T_SCTP_RTO_MIN"
#define sref_case_4_3_5_15 sref_case_4_3
#define desc_case_4_3_5_15 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_RTO_MIN option."

int
test_case_4_3_5_15_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_15_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_15_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_MIN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_15_conn = { &preamble_4_3_conn, &test_case_4_3_5_15_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_15_resp = { &preamble_4_3_resp, &test_case_4_3_5_15_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_15_list = { &preamble_4_3_list, &test_case_4_3_5_15_list, &postamble_4_3_list };

/*
 *  Connect with options -  T_SCTP_RTO_MAX
 */
#define tgrp_case_4_3_5_16 test_group_4
#define numb_case_4_3_5_16 "4.3.5.16"
#define name_case_4_3_5_16 "Connect with options - T_SCTP_RTO_MAX"
#define sref_case_4_3_5_16 sref_case_4_3
#define desc_case_4_3_5_16 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the  T_SCTP_RTO_MAX option."

int
test_case_4_3_5_16_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_16_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_16_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_RTO_MAX, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_16_conn = { &preamble_4_3_conn, &test_case_4_3_5_16_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_16_resp = { &preamble_4_3_resp, &test_case_4_3_5_16_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_16_list = { &preamble_4_3_list, &test_case_4_3_5_16_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_OSTREAMS
 */
#define tgrp_case_4_3_5_17 test_group_4
#define numb_case_4_3_5_17 "4.3.5.17"
#define name_case_4_3_5_17 "Connect with options - T_SCTP_OSTREAMS"
#define sref_case_4_3_5_17 sref_case_4_3
#define desc_case_4_3_5_17 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_OSTREAMS option."

int
test_case_4_3_5_17_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 16};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_17_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_17_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_OSTREAMS, T_SUCCESS}
	, 16};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_17_conn = { &preamble_4_3_conn, &test_case_4_3_5_17_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_17_resp = { &preamble_4_3_resp, &test_case_4_3_5_17_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_17_list = { &preamble_4_3_list, &test_case_4_3_5_17_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_ISTREAMS
 */
#define tgrp_case_4_3_5_18 test_group_4
#define numb_case_4_3_5_18 "4.3.5.18"
#define name_case_4_3_5_18 "Connect with options - T_SCTP_ISTREAMS"
#define sref_case_4_3_5_18 sref_case_4_3
#define desc_case_4_3_5_18 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_ISTREAMS option."

int
test_case_4_3_5_18_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 256};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_18_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_18_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ISTREAMS, T_SUCCESS}
	, 256};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_18_conn = { &preamble_4_3_conn, &test_case_4_3_5_18_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_18_resp = { &preamble_4_3_resp, &test_case_4_3_5_18_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_18_list = { &preamble_4_3_list, &test_case_4_3_5_18_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_COOKIE_INC
 */
#define tgrp_case_4_3_5_19 test_group_4
#define numb_case_4_3_5_19 "4.3.5.19"
#define name_case_4_3_5_19 "Connect with options - T_SCTP_COOKIE_INC"
#define sref_case_4_3_5_19 sref_case_4_3
#define desc_case_4_3_5_19 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_COOKIE_INC option."

int
test_case_4_3_5_19_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_19_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_19_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_COOKIE_INC, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_19_conn = { &preamble_4_3_conn, &test_case_4_3_5_19_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_19_resp = { &preamble_4_3_resp, &test_case_4_3_5_19_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_19_list = { &preamble_4_3_list, &test_case_4_3_5_19_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_THROTTLE_ITVL
 */
#define tgrp_case_4_3_5_20 test_group_4
#define numb_case_4_3_5_20 "4.3.5.20"
#define name_case_4_3_5_20 "Connect with options - T_SCTP_THROTTLE_ITVL"
#define sref_case_4_3_5_20 sref_case_4_3
#define desc_case_4_3_5_20 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_THROTTLE_ITVL option."

int
test_case_4_3_5_20_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_20_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_20_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_THROTTLE_ITVL, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_20_conn = { &preamble_4_3_conn, &test_case_4_3_5_20_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_20_resp = { &preamble_4_3_resp, &test_case_4_3_5_20_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_20_list = { &preamble_4_3_list, &test_case_4_3_5_20_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_MAC_TYPE
 */
#define tgrp_case_4_3_5_21 test_group_4
#define numb_case_4_3_5_21 "4.3.5.21"
#define name_case_4_3_5_21 "Connect with options - T_SCTP_MAC_TYPE"
#define sref_case_4_3_5_21 sref_case_4_3
#define desc_case_4_3_5_21 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_MAC_TYPE option."

int
test_case_4_3_5_21_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_21_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_21_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAC_TYPE, T_SUCCESS}
	, T_SCTP_HMAC_NONE};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_21_conn = { &preamble_4_3_conn, &test_case_4_3_5_21_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_21_resp = { &preamble_4_3_resp, &test_case_4_3_5_21_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_21_list = { &preamble_4_3_list, &test_case_4_3_5_21_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_CKSUM_TYPE
 */
#define tgrp_case_4_3_5_22 test_group_4
#define numb_case_4_3_5_22 "4.3.5.22"
#define name_case_4_3_5_22 "Connect with options - T_SCTP_CKSUM_TYPE"
#define sref_case_4_3_5_22 sref_case_4_3
#define desc_case_4_3_5_22 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_CKSUM_TYPE option."

int
test_case_4_3_5_22_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_22_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_22_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_CKSUM_TYPE, T_SUCCESS}
	, T_SCTP_CSUM_CRC32C};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_22_conn = { &preamble_4_3_conn, &test_case_4_3_5_22_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_22_resp = { &preamble_4_3_resp, &test_case_4_3_5_22_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_22_list = { &preamble_4_3_list, &test_case_4_3_5_22_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_ECN
 */
#define tgrp_case_4_3_5_23 test_group_4
#define numb_case_4_3_5_23 "4.3.5.23"
#define name_case_4_3_5_23 "Connect with options - T_SCTP_ECN"
#define sref_case_4_3_5_23 sref_case_4_3
#define desc_case_4_3_5_23 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_ECN option."

int
test_case_4_3_5_23_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_23_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_23_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ECN, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_23_conn = { &preamble_4_3_conn, &test_case_4_3_5_23_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_23_resp = { &preamble_4_3_resp, &test_case_4_3_5_23_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_23_list = { &preamble_4_3_list, &test_case_4_3_5_23_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_ALI
 */
#define tgrp_case_4_3_5_24 test_group_4
#define numb_case_4_3_5_24 "4.3.5.24"
#define name_case_4_3_5_24 "Connect with options - T_SCTP_ALI"
#define sref_case_4_3_5_24 sref_case_4_3
#define desc_case_4_3_5_24 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_ALI option."

int
test_case_4_3_5_24_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_24_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_24_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ALI, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_24_conn = { &preamble_4_3_conn, &test_case_4_3_5_24_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_24_resp = { &preamble_4_3_resp, &test_case_4_3_5_24_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_24_list = { &preamble_4_3_list, &test_case_4_3_5_24_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_ADD
 */
#define tgrp_case_4_3_5_25 test_group_4
#define numb_case_4_3_5_25 "4.3.5.25"
#define name_case_4_3_5_25 "Connect with options - T_SCTP_ADD"
#define sref_case_4_3_5_25 sref_case_4_3
#define desc_case_4_3_5_25 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_ADD option."

int
test_case_4_3_5_25_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_25_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_25_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_25_conn = { &preamble_4_3_conn, &test_case_4_3_5_25_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_25_resp = { &preamble_4_3_resp, &test_case_4_3_5_25_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_25_list = { &preamble_4_3_list, &test_case_4_3_5_25_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_SET
 */
#define tgrp_case_4_3_5_26 test_group_4
#define numb_case_4_3_5_26 "4.3.5.26"
#define name_case_4_3_5_26 "Connect with options - T_SCTP_SET"
#define sref_case_4_3_5_26 sref_case_4_3
#define desc_case_4_3_5_26 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_SET option."

int
test_case_4_3_5_26_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_26_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_26_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_26_conn = { &preamble_4_3_conn, &test_case_4_3_5_26_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_26_resp = { &preamble_4_3_resp, &test_case_4_3_5_26_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_26_list = { &preamble_4_3_list, &test_case_4_3_5_26_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_ADD_IP
 */
#define tgrp_case_4_3_5_27 test_group_4
#define numb_case_4_3_5_27 "4.3.5.27"
#define name_case_4_3_5_27 "Connect with options - T_SCTP_ADD_IP"
#define sref_case_4_3_5_27 sref_case_4_3
#define desc_case_4_3_5_27 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_ADD_IP option."

int
test_case_4_3_5_27_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_27_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_27_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_ADD_IP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_27_conn = { &preamble_4_3_conn, &test_case_4_3_5_27_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_27_resp = { &preamble_4_3_resp, &test_case_4_3_5_27_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_27_list = { &preamble_4_3_list, &test_case_4_3_5_27_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_DEL_IP
 */
#define tgrp_case_4_3_5_28 test_group_4
#define numb_case_4_3_5_28 "4.3.5.28"
#define name_case_4_3_5_28 "Connect with options - T_SCTP_DEL_IP"
#define sref_case_4_3_5_28 sref_case_4_3
#define desc_case_4_3_5_28 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_DEL_IP option."

int
test_case_4_3_5_28_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_28_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_28_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DEL_IP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_28_conn = { &preamble_4_3_conn, &test_case_4_3_5_28_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_28_resp = { &preamble_4_3_resp, &test_case_4_3_5_28_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_28_list = { &preamble_4_3_list, &test_case_4_3_5_28_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_SET_IP
 */
#define tgrp_case_4_3_5_29 test_group_4
#define numb_case_4_3_5_29 "4.3.5.29"
#define name_case_4_3_5_29 "Connect with options - T_SCTP_SET_IP"
#define sref_case_4_3_5_29 sref_case_4_3
#define desc_case_4_3_5_29 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_SET_IP option."

int
test_case_4_3_5_29_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_29_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_29_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_SET_IP, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_29_conn = { &preamble_4_3_conn, &test_case_4_3_5_29_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_29_resp = { &preamble_4_3_resp, &test_case_4_3_5_29_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_29_list = { &preamble_4_3_list, &test_case_4_3_5_29_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_PR
 */
#define tgrp_case_4_3_5_30 test_group_4
#define numb_case_4_3_5_30 "4.3.5.30"
#define name_case_4_3_5_30 "Connect with options - T_SCTP_PR"
#define sref_case_4_3_5_30 sref_case_4_3
#define desc_case_4_3_5_30 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_PR option."

int
test_case_4_3_5_30_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_30_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_30_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_PR, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_30_conn = { &preamble_4_3_conn, &test_case_4_3_5_30_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_30_resp = { &preamble_4_3_resp, &test_case_4_3_5_30_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_30_list = { &preamble_4_3_list, &test_case_4_3_5_30_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_LIFETIME
 */
#define tgrp_case_4_3_5_31 test_group_4
#define numb_case_4_3_5_31 "4.3.5.31"
#define name_case_4_3_5_31 "Connect with options - T_SCTP_LIFETIME"
#define sref_case_4_3_5_31 sref_case_4_3
#define desc_case_4_3_5_31 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_LIFETIME option."

int
test_case_4_3_5_31_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_31_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_31_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_LIFETIME, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_31_conn = { &preamble_4_3_conn, &test_case_4_3_5_31_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_31_resp = { &preamble_4_3_resp, &test_case_4_3_5_31_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_31_list = { &preamble_4_3_list, &test_case_4_3_5_31_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_DISPOSITION
 */
#define tgrp_case_4_3_5_32 test_group_4
#define numb_case_4_3_5_32 "4.3.5.32"
#define name_case_4_3_5_32 "Connect with options - T_SCTP_DISPOSITION"
#define sref_case_4_3_5_32 sref_case_4_3
#define desc_case_4_3_5_32 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_DISPOSITION option."

int
test_case_4_3_5_32_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_32_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_32_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DISPOSITION, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_32_conn = { &preamble_4_3_conn, &test_case_4_3_5_32_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_32_resp = { &preamble_4_3_resp, &test_case_4_3_5_32_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_32_list = { &preamble_4_3_list, &test_case_4_3_5_32_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_MAX_BURST
 */
#define tgrp_case_4_3_5_33 test_group_4
#define numb_case_4_3_5_33 "4.3.5.33"
#define name_case_4_3_5_33 "Connect with options - T_SCTP_MAX_BURST"
#define sref_case_4_3_5_33 sref_case_4_3
#define desc_case_4_3_5_33 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_MAX_BURST option."

int
test_case_4_3_5_33_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_33_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_33_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAX_BURST, T_SUCCESS}
	, 3};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_33_conn = { &preamble_4_3_conn, &test_case_4_3_5_33_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_33_resp = { &preamble_4_3_resp, &test_case_4_3_5_33_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_33_list = { &preamble_4_3_list, &test_case_4_3_5_33_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_HB
 */
#define tgrp_case_4_3_5_34 test_group_4
#define numb_case_4_3_5_34 "4.3.5.34"
#define name_case_4_3_5_34 "Connect with options - T_SCTP_HB"
#define sref_case_4_3_5_34 sref_case_4_3
#define desc_case_4_3_5_34 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_HB option."

int
test_case_4_3_5_34_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_34_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_34_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_hb opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_hb), T_INET_SCTP, T_SCTP_HB, T_SUCCESS}, {
		0, T_NO, T_UNSPEC}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_34_conn = { &preamble_4_3_conn, &test_case_4_3_5_34_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_34_resp = { &preamble_4_3_resp, &test_case_4_3_5_34_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_34_list = { &preamble_4_3_list, &test_case_4_3_5_34_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_RTO
 */
#define tgrp_case_4_3_5_35 test_group_4
#define numb_case_4_3_5_35 "4.3.5.35"
#define name_case_4_3_5_35 "Connect with options - T_SCTP_RTO"
#define sref_case_4_3_5_35 sref_case_4_3
#define desc_case_4_3_5_35 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_RTO option."

int
test_case_4_3_5_35_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_35_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_35_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		struct t_sctp_rto opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(struct t_sctp_rto), T_INET_SCTP, T_SCTP_RTO, T_SUCCESS}, {
		0, 1000, 200, 5000, 5}
	};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_35_conn = { &preamble_4_3_conn, &test_case_4_3_5_35_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_35_resp = { &preamble_4_3_resp, &test_case_4_3_5_35_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_35_list = { &preamble_4_3_list, &test_case_4_3_5_35_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_MAXSEG
 */
#define tgrp_case_4_3_5_36 test_group_4
#define numb_case_4_3_5_36 "4.3.5.36"
#define name_case_4_3_5_36 "Connect with options - T_SCTP_MAXSEG"
#define sref_case_4_3_5_36 sref_case_4_3
#define desc_case_4_3_5_36 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_MAXSEG option."

int
test_case_4_3_5_36_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_36_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_36_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_MAXSEG, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_36_conn = { &preamble_4_3_conn, &test_case_4_3_5_36_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_36_resp = { &preamble_4_3_resp, &test_case_4_3_5_36_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_36_list = { &preamble_4_3_list, &test_case_4_3_5_36_list, &postamble_4_3_list };

/*
 *  Connect with options - T_SCTP_STATUS
 */
#define tgrp_case_4_3_5_37 test_group_4
#define numb_case_4_3_5_37 "4.3.5.37"
#define name_case_4_3_5_37 "Connect with options - T_SCTP_STATUS"
#define sref_case_4_3_5_37 sref_case_4_3
#define desc_case_4_3_5_37 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_STATUS option."

int
test_case_4_3_5_37_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_conn(child);
	case T_INET_SCTP:
		return test_case_4_3_conn_readonly(child);
	}
}

int
test_case_4_3_5_37_resp(int child)
{
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_resp(child);
	case T_INET_SCTP:
		return test_case_4_3_resp_readonly(child);
	}
}

int
test_case_4_3_5_37_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_STATUS, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	switch (test_level) {
	case T_INET_TCP:
	default:
		return test_case_4_3_list(child);
	case T_INET_SCTP:
		return test_case_4_3_list_readonly(child);
	}
}

struct test_stream test_4_3_5_37_conn = { &preamble_4_3_conn, &test_case_4_3_5_37_conn, &postamble_4_3_conn_readonly };
struct test_stream test_4_3_5_37_resp = { &preamble_4_3_resp, &test_case_4_3_5_37_resp, &postamble_4_3_resp_readonly };
struct test_stream test_4_3_5_37_list = { &preamble_4_3_list, &test_case_4_3_5_37_list, &postamble_4_3_list_readonly };

/*
 *  Connect with options - T_SCTP_DEBUG
 */
#define tgrp_case_4_3_5_38 test_group_4
#define numb_case_4_3_5_38 "4.3.5.38"
#define name_case_4_3_5_38 "Connect with options - T_SCTP_DEBUG"
#define sref_case_4_3_5_38 sref_case_4_3
#define desc_case_4_3_5_38 "\
Attempt and accept a connection with connection options in the connection\n\
request and expected in the connection response.  This specific test case\n\
tests the T_SCTP_DEBUG option."

int
test_case_4_3_5_38_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_conn(child);
}

int
test_case_4_3_5_38_resp(int child)
{
	return test_case_4_3_resp(child);
}

int
test_case_4_3_5_38_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t optval;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t), T_INET_SCTP, T_SCTP_DEBUG, T_SUCCESS}
	, T_NO};
	test_opts = &options;
	test_olen = sizeof(options);
	return test_case_4_3_list(child);
}

struct test_stream test_4_3_5_38_conn = { &preamble_4_3_conn, &test_case_4_3_5_38_conn, &postamble_4_3_conn };
struct test_stream test_4_3_5_38_resp = { &preamble_4_3_resp, &test_case_4_3_5_38_resp, &postamble_4_3_resp };
struct test_stream test_4_3_5_38_list = { &preamble_4_3_list, &test_case_4_3_5_38_list, &postamble_4_3_list };

/*
 *  Connect with transfer data and orderly release.
 */
#define test_group_5 "Data transfer"
#define tgrp_case_5_1 test_group_5
#define numb_case_5_1 "5.1"
#define name_case_5_1 "Connect with transfer data and orderly release."
#define sref_case_5_1 "(none)"
#define desc_case_5_1 "\
Connect, transfer data and perform orderly release."

int
test_case_5_1_conn(int child)
{
	static char dat[] = "Orderly release data connecting.";
	int data_seen = 0, data_sent;

	for (data_sent = 0; data_sent < 4; data_sent++) {
		test_data = dat;
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		switch (wait_event(child, SHORT_WAIT)) {
		case __EVENT_NO_MSG:
			break;
		case __TEST_DATA_IND:
			if (data_seen >= 4)
				goto failure;
			data_seen++;
			break;
		default:
			goto failure;
		}
		state++;
	}
	while (data_seen < 4) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __EVENT_NO_MSG:
			break;
		case __TEST_DATA_IND:
			if (data_seen >= 4)
				goto failure;
			data_seen++;
			break;
		default:
			goto failure;
		}
		state++;
	}
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_1_resp(int child)
{
	static char dat[] = "Orderly release data responding.";
	int data_seen = 0, data_sent, ordrel_seen = 0;

	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	data_seen++;
	state++;
	for (data_sent = 0; data_sent < 4; data_sent++) {
		test_data = dat;
		MORE_flag = 1;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		switch (wait_event(child, SHORT_WAIT)) {
		case __EVENT_NO_MSG:
			break;
		case __TEST_DATA_IND:
			if (data_seen >= 4)
				goto failure;
			data_seen++;
			break;
		case __TEST_ORDREL_IND:
			if (ordrel_seen >= 1)
				goto failure;
			ordrel_seen++;
			break;
		default:
			goto failure;
		}
		state++;
	}
	while (data_seen < 4 || ordrel_seen < 1) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __EVENT_NO_MSG:
			break;
		case __TEST_DATA_IND:
			if (data_seen >= 4)
				goto failure;
			data_seen++;
			break;
		case __TEST_ORDREL_IND:
			if (ordrel_seen >= 1)
				goto failure;
			ordrel_seen++;
			break;
		default:
			goto failure;
		}
		state++;
	}
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_5_1_conn	preamble_2_conn
#define preamble_5_1_resp	preamble_2_resp
#define preamble_5_1_list	preamble_2_list

#define postamble_5_1_conn	postamble_1
#define postamble_5_1_resp	postamble_1
#define postamble_5_1_list	postamble_1

struct test_stream test_5_1_conn = { &preamble_5_1_conn, &test_case_5_1_conn, &postamble_5_1_conn };
struct test_stream test_5_1_resp = { &preamble_5_1_resp, &test_case_5_1_resp, &postamble_5_1_resp };
struct test_stream test_5_1_list = { &preamble_5_1_list, &test_case_5_1_list, &postamble_5_1_list };

/*
 *  Connect with orderly release and late data transfer.
 */
#define tgrp_case_5_2 test_group_5
#define numb_case_5_2 "5.2"
#define name_case_5_2 "Connect with orderly release and late data transfer."
#define sref_case_5_2 "(none)"
#define desc_case_5_2 "\
Connect, transfer data and perform orderly release but transfer\n\
data after release has been initiated"

int
test_case_5_2_conn(int child)
{
	int data_seen = 0;

	test_data = "Orderly release data connecting.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	data_seen++;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
      more:
	switch (wait_event(child, LONG_WAIT)) {
	case __TEST_DATA_IND:
		if (data_seen >= 5)
			goto failure;
		data_seen++;
		state++;
		goto more;
	case __TEST_ORDREL_IND:
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_2_resp(int child)
{
	int data_seen = 0;

	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	data_seen++;
	state++;
	test_data = "Orderly release data responding.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Orderly release data responding.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Orderly release data responding.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Orderly release data responding.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Orderly release data responding.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_5_2_conn	preamble_2_conn
#define preamble_5_2_resp	preamble_2_resp
#define preamble_5_2_list	preamble_2_list

#define postamble_5_2_conn	postamble_1
#define postamble_5_2_resp	postamble_1
#define postamble_5_2_list	postamble_1

struct test_stream test_5_2_conn = { &preamble_5_2_conn, &test_case_5_2_conn, &postamble_5_2_conn };
struct test_stream test_5_2_resp = { &preamble_5_2_resp, &test_case_5_2_resp, &postamble_5_2_resp };
struct test_stream test_5_2_list = { &preamble_5_2_list, &test_case_5_2_list, &postamble_5_2_list };

/*
 *  Connect with attempted simultaneous orderly release.
 */
#define tgrp_case_5_3 test_group_5
#define numb_case_5_3 "5.3"
#define name_case_5_3 "Connect with attempted simultaneous orderly release."
#define sref_case_5_3 "(none)"
#define desc_case_5_3 "\
Connect, transfer data and perform orderly release but attempt\n\
to perform a simultaneous release from both sides.  (This might\n\
or might not result in a simultaneous release attempt.)"

int
test_case_5_3_conn(int child)
{
	int data_seen = 0;

	test_data = "Orderly release data connecting.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	data_seen++;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (;;) {
		switch (wait_event(child, LONGER_WAIT)) {
#if 0
		case __EVENT_NO_MSG:
			continue;
#endif
		case __TEST_ORDREL_IND:
			break;
		case __TEST_DATA_IND:
			if (data_seen >= 4)
				goto failure;
			data_seen++;
			state++;
			continue;
		default:
			goto failure;
		}
		break;
	}
	state++;
#if 0
	if (wait_event(child, LONGER_WAIT) != __EVENT_NO_MSG)
		goto failure;
	state++;
#endif
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_3_resp(int child)
{
	int data_seen = 0;

	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	data_seen++;
	state++;
	test_data = "Orderly release data responding.";
	MORE_flag = 1;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (;;) {
		switch (wait_event(child, LONGER_WAIT)) {
#if 0
		case __EVENT_NO_MSG:
			continue;
#endif
		case __TEST_ORDREL_IND:
			break;
		case __TEST_DATA_IND:
			if (data_seen >= 4)
				goto failure;
			data_seen++;
			state++;
			continue;
		default:
			goto failure;
		}
		break;
	}
	state++;
#if 0
	if (wait_event(child, LONGER_WAIT) != __EVENT_NO_MSG)
		goto failure;
	state++;
#endif
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_5_3_conn	preamble_2_conn
#define preamble_5_3_resp	preamble_2_resp
#define preamble_5_3_list	preamble_2_list

#define postamble_5_3_conn	postamble_1
#define postamble_5_3_resp	postamble_1
#define postamble_5_3_list	postamble_1

struct test_stream test_5_3_conn = { &preamble_5_3_conn, &test_case_5_3_conn, &postamble_5_3_conn };
struct test_stream test_5_3_resp = { &preamble_5_3_resp, &test_case_5_3_resp, &postamble_5_3_resp };
struct test_stream test_5_3_list = { &preamble_5_3_list, &test_case_5_3_list, &postamble_5_3_list };

/*
 *  Connect with data transfer and abortive release.
 */
#define tgrp_case_5_4 test_group_5
#define numb_case_5_4 "5.4"
#define name_case_5_4 "Connection with data transfer and abortive release."
#define sref_case_5_4 "(none)"
#define desc_case_5_4 "\
Connect, transfer data and perform abort."

int
test_case_5_4_conn(int child)
{
	static char dat[] = "Abortive release data connecting.";

	test_data = dat;
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = dat;
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	for (;;) {
		switch (wait_event(child, LONGER_WAIT)) {
		case __EVENT_NO_MSG:
		case __TEST_DISCON_IND:
			break;
		case __TEST_OK_ACK:
		case __TEST_ERROR_ACK:
			continue;
		default:
			goto failure;
		}
		break;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_4_resp(int child)
{
	static char dat[] = "Abortive release data responding.";

	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = dat;
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = dat;
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	for (;;) {
		switch (wait_event(child, LONGER_WAIT)) {
		case __EVENT_NO_MSG:
		case __TEST_DISCON_IND:
			break;
		case __TEST_OK_ACK:
		case __TEST_ERROR_ACK:
			continue;
		default:
			goto failure;
		}
		break;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_5_4_conn	preamble_2_conn
#define preamble_5_4_resp	preamble_2_resp
#define preamble_5_4_list	preamble_2_list

#define postamble_5_4_conn	postamble_1
#define postamble_5_4_resp	postamble_1
#define postamble_5_4_list	postamble_1

struct test_stream test_5_4_conn = { &preamble_5_4_conn, &test_case_5_4_conn, &postamble_5_4_conn };
struct test_stream test_5_4_resp = { &preamble_5_4_resp, &test_case_5_4_resp, &postamble_5_4_resp };
struct test_stream test_5_4_list = { &preamble_5_4_list, &test_case_5_4_list, &postamble_5_4_list };

#if 1
/*
 *  Accept a connection.
 */
#define test_group_5_5 "Connections with different HMAC algorithms"
#define tgrp_case_5_5_1 test_group_5_5
#define numb_case_5_5_1 "5.5.1"
#define name_case_5_5_1 "Accept a connection."
#define sref_case_5_5_1 "(none)"
#define desc_case_5_5_1 "\
Attempt and accept a connection.  This should be successful.  The\n\
accepting stream uses the T_SCTP_HMAC_NONE signature on its cookie."

int
test_case_5_5_1_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[1];
	test_alen = anums[1]*sizeof(addrs[1][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_5_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_5_1_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_5_5_1_conn	preamble_1
#define preamble_5_5_1_resp	preamble_1
#define preamble_5_5_1_list	preamble_1

#define postamble_5_5_1_conn	postamble_1
#define postamble_5_5_1_resp	postamble_1
#define postamble_5_5_1_list	postamble_1

struct test_stream test_5_5_1_conn = { &preamble_5_5_1_conn, &test_case_5_5_1_conn, &postamble_5_5_1_conn };
struct test_stream test_5_5_1_resp = { &preamble_5_5_1_resp, &test_case_5_5_1_resp, &postamble_5_5_1_resp };
struct test_stream test_5_5_1_list = { &preamble_5_5_1_list, &test_case_5_5_1_list, &postamble_5_5_1_list };

/*
 *  Accept a connection (MD5 hashed cookie)
 */
#define tgrp_case_5_5_2 test_group_5_5
#define numb_case_5_5_2 "5.5.2"
#define name_case_5_5_2 "Accept a connection (MD5 hashed cookie)."
#define sref_case_5_5_2 "(none)"
#define desc_case_5_5_2 "\
Attempt and accept a connection.  This should be successful.  The\n\
accepting stream uses the T_SCTP_HMAC_MD5 signature on its cookie."

int
test_case_5_5_2_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[1];
	test_alen = anums[1]*sizeof(addrs[1][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_5_2_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_5_2_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_5_5_2_conn	preamble_8_conn
#define preamble_5_5_2_resp	preamble_8_resp
#define preamble_5_5_2_list	preamble_8_list

#define postamble_5_5_2_conn	postamble_1
#define postamble_5_5_2_resp	postamble_1
#define postamble_5_5_2_list	postamble_1

struct test_stream test_5_5_2_conn = { &preamble_5_5_2_conn, &test_case_5_5_2_conn, &postamble_5_5_2_conn };
struct test_stream test_5_5_2_resp = { &preamble_5_5_2_resp, &test_case_5_5_2_resp, &postamble_5_5_2_resp };
struct test_stream test_5_5_2_list = { &preamble_5_5_2_list, &test_case_5_5_2_list, &postamble_5_5_2_list };

/*
 *  Accept a connection (SHA1 hashed cookie)
 */
#define tgrp_case_5_5_3 test_group_5_5
#define numb_case_5_5_3 "5.5.3"
#define name_case_5_5_3 "Accept a connection (SHA1 hashed cookie)"
#define sref_case_5_5_3 "(none)"
#define desc_case_5_5_3 "\
Attempt and accept a connection.  This should be successful.  The\n\
accepting stream uses the T_SCTP_HMAC_SHA1 signature on its cookie."

int
test_case_5_5_3_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[1];
	test_alen = anums[1]*sizeof(addrs[1][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_CONN_CON) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_5_3_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_5_5_3_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_5_5_3_conn	preamble_7_conn
#define preamble_5_5_3_resp	preamble_7_resp
#define preamble_5_5_3_list	preamble_7_list

#define postamble_5_5_3_conn	postamble_1
#define postamble_5_5_3_resp	postamble_1
#define postamble_5_5_3_list	postamble_1

struct test_stream test_5_5_3_conn = { &preamble_5_5_3_conn, &test_case_5_5_3_conn, &postamble_5_5_3_conn };
struct test_stream test_5_5_3_resp = { &preamble_5_5_3_resp, &test_case_5_5_3_resp, &postamble_5_5_3_resp };
struct test_stream test_5_5_3_list = { &preamble_5_5_3_list, &test_case_5_5_3_list, &postamble_5_5_3_list };
#endif

#if 1
/*
 *  Connect with data.
 */
#define test_group_6 "Connections with data"
#define tgrp_case_6_1 test_group_6
#define numb_case_6_1 "6.1"
#define name_case_6_1 "Connect with data."
#define sref_case_6_1 "(none)"
#define desc_case_6_1 "\
Attempt and accept a connection where data is also passed in the\n\
connection request and the connection response.  This should result\n\
in DATA chunks being bundled with the COOKIE-ECHO and COOKIE-ACK\n\
chunks in the SCTP messages."

int
test_case_6_1_conn(int child)
{
	int i;

	test_data = "Hello Again!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello Again!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello Again!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 21; i++)
		if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
			goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_6_1_resp(int child)
{
	int i;

	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 21; i++) {
		test_data = "Hello Too!";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_6_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_6_1_conn	preamble_2b_conn
#define preamble_6_1_resp	preamble_2b_resp
#define preamble_6_1_list	preamble_2b_list

#define postamble_6_1_conn	postamble_3_conn
#define postamble_6_1_resp	postamble_3_resp
#define postamble_6_1_list	postamble_3_list

struct test_stream test_6_1_conn = { &preamble_6_1_conn, &test_case_6_1_conn, &postamble_6_1_conn };
struct test_stream test_6_1_resp = { &preamble_6_1_resp, &test_case_6_1_resp, &postamble_6_1_resp };
struct test_stream test_6_1_list = { &preamble_6_1_list, &test_case_6_1_list, &postamble_6_1_list };

/*
 *  Connect and send partial data.
 */
#define tgrp_case_6_2 test_group_6
#define numb_case_6_2 "6.2"
#define name_case_6_2 "Connect and send partial data."
#define sref_case_6_2 "(none)"
#define desc_case_6_2 "\
Connect and send partial data (i.e., data with more flag set)."

int
test_case_6_2_conn(int child)
{
	test_data = "Hello There.";
	MORE_flag = T_MORE;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello There.";
	MORE_flag = T_MORE;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello There.";
	MORE_flag = T_MORE;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello There.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_6_2_resp(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_6_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_6_2_conn	preamble_2_conn
#define preamble_6_2_resp	preamble_2_resp
#define preamble_6_2_list	preamble_2_list

#define postamble_6_2_conn	postamble_3_conn
#define postamble_6_2_resp	postamble_3_resp
#define postamble_6_2_list	postamble_3_list

struct test_stream test_6_2_conn = { &preamble_6_2_conn, &test_case_6_2_conn, &postamble_6_2_conn };
struct test_stream test_6_2_resp = { &preamble_6_2_resp, &test_case_6_2_resp, &postamble_6_2_resp };
struct test_stream test_6_2_list = { &preamble_6_2_list, &test_case_6_2_list, &postamble_6_2_list };

/*
 *  Connect and send partial data.
 */
#define tgrp_case_6_3 test_group_6
#define numb_case_6_3 "6.3"
#define name_case_6_3 "Connect and send partial data."
#define sref_case_6_3 "(none)"
#define desc_case_6_3 "\
Connect and send partial data and expedited data on multiple streams.\n\
Expedited data should be delivered between ordered data fragments on\n\
the same stream and delivered to the user first."

int
test_case_6_3_conn(int child)
{
	opt_data.sid_val = 0;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 1;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 2;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 3;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 0;
	test_data = "Hello There.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 0;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 1;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 2;
	test_data = "Hello There.";
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 3;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 0;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 1;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 2;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 3;
	test_data = "Hello There.";
	DATA_flag = T_MORE;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 0;
	test_data = "Hello There.";
	DATA_flag = 0;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 1;
	test_data = "Hello There.";
	DATA_flag = 0;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 2;
	test_data = "Hello There.";
	DATA_flag = 0;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 3;
	test_data = "Hello There.";
	DATA_flag = 0;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_6_3_resp(int child)
{
	int i;

	if (expect(child, NORMAL_WAIT, __TEST_EXP_OPTDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 16; i++) {
		if (expect(child, NORMAL_WAIT, __TEST_NRM_OPTDATA_IND) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_6_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_6_3_conn	preamble_3b_conn
#define preamble_6_3_resp	preamble_3b_resp
#define preamble_6_3_list	preamble_3b_list

#define postamble_6_3_conn	postamble_3_conn
#define postamble_6_3_resp	postamble_3_resp
#define postamble_6_3_list	postamble_3_list

struct test_stream test_6_3_conn = { &preamble_6_3_conn, &test_case_6_3_conn, &postamble_6_3_conn };
struct test_stream test_6_3_resp = { &preamble_6_3_resp, &test_case_6_3_resp, &postamble_6_3_resp };
struct test_stream test_6_3_list = { &preamble_6_3_list, &test_case_6_3_list, &postamble_6_3_list };
#endif

#if 1
/*
 *  Test fragmentation by sending very large packets.
 */
#define test_group_7 "Segmentation and reassembly"
#define tgrp_case_7_1 test_group_7
#define numb_case_7_1 "7.1"
#define name_case_7_1 "Test fragmentation by sending very large packets."
#define sref_case_7_1 "(none)"
#define desc_case_7_1 "\
Connect and send very large packets to test fragmentation."

int
test_case_7_1_conn(int child)
{
	unsigned char lbuf[100000];
	const char nrm[] = "Hello.";
	const char urg[] = "Urgent.";
	int i;

	for (i = 0; i < 100000; i++)
		lbuf[i] = 'A';
	lbuf[99999] = '\0';
	bzero(lbuf, sizeof(lbuf));
	for (i = 0; i < 4; i++) {
		test_data = (char *) lbuf;
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS) {
			state++;
			test_msleep(child, LONG_WAIT);
			test_data = (char *) lbuf;
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				goto failure;
		}
		state++;
		test_data = urg;
		MORE_flag = 0;
		if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS) {
			state++;
			test_msleep(child, LONG_WAIT);
			test_data = urg;
			MORE_flag = 0;
			if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
		}
		state++;
		test_data = nrm;
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS) {
			state++;
			test_msleep(child, LONG_WAIT);
			test_data = nrm;
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_7_1_resp(int child)
{
	size_t len = 0;

	while (len < 4 * 100000 + 4 * 8 + 4 * 7) {
		switch (wait_event(child, LONGER_WAIT)) {
		case __TEST_EXDATA_IND:
		case __TEST_DATA_IND:
			len += data.len;
			break;
		default:
			goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "i = %d, j = %d, k = %d\n", 4, 4, 4);
	fprintf(stdout, "Received %lu bytes, expecting %u\n", (ulong) len, 4 * 100000 + 4 * 8 + 4 * 7);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_7_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_7_1_conn	preamble_2_conn
#define preamble_7_1_resp	preamble_2_resp
#define preamble_7_1_list	preamble_2_list

#define postamble_7_1_conn	postamble_3_conn
#define postamble_7_1_resp	postamble_3_resp
#define postamble_7_1_list	postamble_3_list

struct test_stream test_7_1_conn = { &preamble_7_1_conn, &test_case_7_1_conn, &postamble_7_1_conn };
struct test_stream test_7_1_resp = { &preamble_7_1_resp, &test_case_7_1_resp, &postamble_7_1_resp };
struct test_stream test_7_1_list = { &preamble_7_1_list, &test_case_7_1_list, &postamble_7_1_list };

/*
 *  Test coallescing packets by sending many small fragmented pieces.
 */
#define tgrp_case_7_2 test_group_7
#define numb_case_7_2 "7.2"
#define name_case_7_2 "Test coallescing by sending small fragmented pieces."
#define sref_case_7_2 "(none)"
#define desc_case_7_2 "\
Connect and send many small packets to test coallescing of packets."

int
test_case_7_2_conn(int child)
{
	int s = 0;
	size_t snd_bytes = 0;

	while (s < 100000) {
		test_data = "Hi Threre.";
		MORE_flag = T_MORE;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS) {
			state++;
			print_more();
			test_msleep(child, LONG_WAIT);
			test_data = "Hi Threre.";
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				goto failure;
		}
		snd_bytes += 10;
		s++;
		state++;
		if (s > 3)
			print_less(child);
	}
	state++;
	test_data = "Hi Threre.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	snd_bytes += 10;
	s++;
	state++;
	print_more();
	state++;
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "Sent %3d messages making %6lu bytes.\n", s, (ulong) snd_bytes);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	print_more();
	return (__RESULT_FAILURE);
}

int
test_case_7_2_resp(int child)
{
	int r = 0;
	size_t rcv_bytes = 0;
	int joined = 0;

	while (r < 4) {
		if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
			goto failure;
		if (data.len > 10)
			joined = 1;
		rcv_bytes += data.len;
		r++;
		state++;
	}
	print_less(child);
	while (rcv_bytes < 1000010) {
		if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
			goto failure;
		if (data.len > 10)
			joined = 1;
		rcv_bytes += data.len;
		r++;
		state++;
	}
	if (!joined)
		goto failure;
	state++;
	print_more();
	state++;
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "Rcvd %3d messages making %6lu bytes.\n", r, (ulong) rcv_bytes);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	print_more();
	return (__RESULT_FAILURE);
}

int
test_case_7_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_7_2_conn	preamble_2_conn
#define preamble_7_2_resp	preamble_2_resp
#define preamble_7_2_list	preamble_2_list

#define postamble_7_2_conn	postamble_3_conn
#define postamble_7_2_resp	postamble_3_resp
#define postamble_7_2_list	postamble_3_list

struct test_stream test_7_2_conn = { &preamble_7_2_conn, &test_case_7_2_conn, &postamble_7_2_conn };
struct test_stream test_7_2_resp = { &preamble_7_2_resp, &test_case_7_2_resp, &postamble_7_2_resp };
struct test_stream test_7_2_list = { &preamble_7_2_list, &test_case_7_2_list, &postamble_7_2_list };
#endif

#if 1
/*
 *  Connect with transfer data and orderly release.
 */
#define test_group_8 "Orderly release"
#define tgrp_case_8_1 test_group_8
#define numb_case_8_1 "8.1"
#define name_case_8_1 "Connect with transfer data and orderly release."
#define sref_case_8_1 "(none)"
#define desc_case_8_1 "\
Connect, transfer data and perform orderly release."

int
test_case_8_1_conn(int child)
{
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_1_resp(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_8_1_conn	preamble_2_conn
#define preamble_8_1_resp	preamble_2_resp
#define preamble_8_1_list	preamble_2_list

#define postamble_8_1_conn	postamble_1
#define postamble_8_1_resp	postamble_1
#define postamble_8_1_list	postamble_1

struct test_stream test_8_1_conn = { &preamble_8_1_conn, &test_case_8_1_conn, &postamble_8_1_conn };
struct test_stream test_8_1_resp = { &preamble_8_1_resp, &test_case_8_1_resp, &postamble_8_1_resp };
struct test_stream test_8_1_list = { &preamble_8_1_list, &test_case_8_1_list, &postamble_8_1_list };

/*
 *  Connect with orderly release and late data transfer.
 */
#define tgrp_case_8_2 test_group_8
#define numb_case_8_2 "8.2"
#define name_case_8_2 "Connect with orderly release and late data transfer."
#define sref_case_8_2 "(none)"
#define desc_case_8_2 "\
Connect, transfer data and perform orderly release but transfer\n\
data after release has been initiated"

int
test_case_8_2_conn(int child)
{
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_2_resp(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_8_2_conn	preamble_2_conn
#define preamble_8_2_resp	preamble_2_resp
#define preamble_8_2_list	preamble_2_list

#define postamble_8_2_conn	postamble_1
#define postamble_8_2_resp	postamble_1
#define postamble_8_2_list	postamble_1

struct test_stream test_8_2_conn = { &preamble_8_2_conn, &test_case_8_2_conn, &postamble_8_2_conn };
struct test_stream test_8_2_resp = { &preamble_8_2_resp, &test_case_8_2_resp, &postamble_8_2_resp };
struct test_stream test_8_2_list = { &preamble_8_2_list, &test_case_8_2_list, &postamble_8_2_list };

/*
 *  Connect with attempted simultaneous orderly release.
 */
#define tgrp_case_8_3 test_group_8
#define numb_case_8_3 "8.3"
#define name_case_8_3 "Connect with attempted simultaneous orderly release."
#define sref_case_8_3 "(none)"
#define desc_case_8_3 "\
Connect, transfer data and perform orderly release but attempt\n\
to perform a simultaneous release from both sides.  (This might\n\
or might not result in a simultaneous release attempt.)"

int
test_case_8_3_conn(int child)
{
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_3_resp(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_8_3_conn	preamble_2_conn
#define preamble_8_3_resp	preamble_2_resp
#define preamble_8_3_list	preamble_2_list

#define postamble_8_3_conn	postamble_1
#define postamble_8_3_resp	postamble_1
#define postamble_8_3_list	postamble_1

struct test_stream test_8_3_conn = { &preamble_8_3_conn, &test_case_8_3_conn, &postamble_8_3_conn };
struct test_stream test_8_3_resp = { &preamble_8_3_resp, &test_case_8_3_resp, &postamble_8_3_resp };
struct test_stream test_8_3_list = { &preamble_8_3_list, &test_case_8_3_list, &postamble_8_3_list };

/*
 *  Connect with orderly release under noise.
 */
#define tgrp_case_8_4 test_group_8
#define numb_case_8_4 "8.4"
#define name_case_8_4 "Connect with orderly release under noise."
#define sref_case_8_4 "(none)"
#define desc_case_8_4 "\
Connect, transfer data and perform orderly release under noise."

int
test_case_8_4_conn(int child)
{
	int i;

	test_data = "Hello World!";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 20; i++) {
		test_data = "Hello World!";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 20; i++) {
		if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_4_resp(int child)
{
	int i;

	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 20; i++) {
		test_data = "Hello World!";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 20; i++) {
		if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
			goto failure;
		state++;
	}
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_8_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_8_4_conn	preamble_4b_conn
#define preamble_8_4_resp	preamble_4b_resp
#define preamble_8_4_list	preamble_4b_list

#define postamble_8_4_conn	postamble_1
#define postamble_8_4_resp	postamble_1
#define postamble_8_4_list	postamble_1

struct test_stream test_8_4_conn = { &preamble_8_4_conn, &test_case_8_4_conn, &postamble_8_4_conn };
struct test_stream test_8_4_resp = { &preamble_8_4_resp, &test_case_8_4_resp, &postamble_8_4_resp };
struct test_stream test_8_4_list = { &preamble_8_4_list, &test_case_8_4_list, &postamble_8_4_list };
#endif

#if 1
/*
 *  Delivering ordered data under noise.
 */
#define test_group_9 "Data transfer under noise"
#define tgrp_case_9_1 test_group_9
#define numb_case_9_1 "9.1"
#define name_case_9_1 "Delivering ordered data under noise."
#define sref_case_9_1 "(none)"
#define desc_case_9_1 "\
Delivery of ordered data under noise with acknowledgement."
#define TEST_PACKETS 300
int
test_case_9_1_conn(int child)
{
	int i = 0, j = 0;

	test_data = "Pattern-1";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	while (i < TEST_PACKETS) {
		test_data = "Pattern-1";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		i++;
		state++;
	}
	while (j < TEST_PACKETS) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_DATA_IND:
			j++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "%d sent %d inds %d\n", child, i, j);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_1_resp(int child)
{
	int i = 0, j = 0;

	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	while (i < TEST_PACKETS) {
		test_data = "Pattern-3";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		i++;
		state++;
	}
	while (j < TEST_PACKETS) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_DATA_IND:
			j++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "%d sent %d inds %d\n", child, i, j);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_9_1_conn	preamble_4_conn
#define preamble_9_1_resp	preamble_4_resp
#define preamble_9_1_list	preamble_4_list

#define postamble_9_1_conn	postamble_3_conn
#define postamble_9_1_resp	postamble_3_resp
#define postamble_9_1_list	postamble_3_list

struct test_stream test_9_1_conn = { &preamble_9_1_conn, &test_case_9_1_conn, &postamble_9_1_conn };
struct test_stream test_9_1_resp = { &preamble_9_1_resp, &test_case_9_1_resp, &postamble_9_1_resp };
struct test_stream test_9_1_list = { &preamble_9_1_list, &test_case_9_1_list, &postamble_9_1_list };

/*
 *  Delivering out-of-order data under noise.
 */
#define tgrp_case_9_2 test_group_9
#define numb_case_9_2 "9.2"
#define name_case_9_2 "Delivering out-of-order data under noise."
#define sref_case_9_2 "(none)"
#define desc_case_9_2 "\
Delivery of un-ordered data under noise."
int
test_case_9_2_conn(int child)
{
	int i = 0, j = 0;

	test_data = "Pattern-1";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	while (i < TEST_PACKETS) {
		test_data = "Pattern-1";
		MORE_flag = 0;
		if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		i++;
		state++;
	}
	while (j < TEST_PACKETS) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_EXDATA_IND:
			j++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "%d sent %d inds %d\n", child, i, j);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_2_resp(int child)
{
	int i = 0, j = 0;

	if (expect(child, LONG_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Pattern-3";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	while (i < TEST_PACKETS) {
		test_data = "Pattern-3";
		MORE_flag = 0;
		if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		i++;
		state++;
	}
	while (j < TEST_PACKETS) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_EXDATA_IND:
			j++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "%d sent %d inds %d\n", child, i, j);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_9_2_conn	preamble_4_conn
#define preamble_9_2_resp	preamble_4_resp
#define preamble_9_2_list	preamble_4_list

#define postamble_9_2_conn	postamble_3_conn
#define postamble_9_2_resp	postamble_3_resp
#define postamble_9_2_list	postamble_3_list

struct test_stream test_9_2_conn = { &preamble_9_2_conn, &test_case_9_2_conn, &postamble_9_2_conn };
struct test_stream test_9_2_resp = { &preamble_9_2_resp, &test_case_9_2_resp, &postamble_9_2_resp };
struct test_stream test_9_2_list = { &preamble_9_2_list, &test_case_9_2_list, &postamble_9_2_list };

#undef TEST_PACKETS

#define TEST_PACKETS  5
#define TEST_STREAMS 32
#define TEST_TOTAL (TEST_PACKETS*TEST_STREAMS)
/*
 *  Delivering ordered data in multiple streams under noise.
 */
#define tgrp_case_9_3 test_group_9
#define numb_case_9_3 "9.3"
#define name_case_9_3 "Delivering ordered data in multiple streams under noise."
#define sref_case_9_3 "(none)"
#define desc_case_9_3 "\
Delivery of ordered data in multiple streams under noise."
int
test_case_9_3_conn(int child)
{
	int s;
	int i[TEST_STREAMS] = { 0, };
	int j[TEST_STREAMS] = { 0, };
	int I = 0, J = 0;

	test_data = "Pattern-1";
	DATA_flag = 0;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_NRM_OPTDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (s = 0; s < TEST_STREAMS; s++) {
		while (I < TEST_TOTAL && i[s] < TEST_PACKETS) {
			opt_data.sid_val = s;
			test_data = "Pattern-1";
			DATA_flag = 0;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			i[s]++;
			I++;
			state++;
		}
	}
	while (J < TEST_TOTAL) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_NRM_OPTDATA_IND:
			j[sid[child]]++;
			J++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	for (s = 0; s < TEST_STREAMS; s++) {
		if (j[s] != TEST_PACKETS)
			goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	for (s = 0; s < TEST_STREAMS; s++)
		fprintf(stdout, "%d send %d inds %d\n", child, i[s], j[s]);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_3_resp(int child)
{
	int s;
	int i[TEST_STREAMS] = { 0, };
	int j[TEST_STREAMS] = { 0, };
	int I = 0, J = 0;

	if (expect(child, LONG_WAIT, __TEST_NRM_OPTDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Pattern-3";
	DATA_flag = 0;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (s = 0; s < TEST_STREAMS; s++) {
		while (I < TEST_TOTAL && i[s] < TEST_PACKETS) {
			opt_data.sid_val = s;
			test_data = "Pattern-3";
			DATA_flag = 0;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			i[s]++;
			I++;
			state++;
		}
	}
	while (J < TEST_TOTAL) {
		switch (wait_event(child, NORMAL_WAIT)) {
		case __TEST_NRM_OPTDATA_IND:
			j[sid[child]]++;
			J++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	for (s = 0; s < TEST_STREAMS; s++) {
		if (j[s] != TEST_PACKETS)
			goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	for (s = 0; s < TEST_STREAMS; s++)
		fprintf(stdout, "%d send %d inds %d\n", child, i[s], j[s]);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_9_3_conn	preamble_6_conn
#define preamble_9_3_resp	preamble_6_resp
#define preamble_9_3_list	preamble_6_list

#define postamble_9_3_conn	postamble_3_conn
#define postamble_9_3_resp	postamble_3_resp
#define postamble_9_3_list	postamble_3_list

struct test_stream test_9_3_conn = { &preamble_9_3_conn, &test_case_9_3_conn, &postamble_9_3_conn };
struct test_stream test_9_3_resp = { &preamble_9_3_resp, &test_case_9_3_resp, &postamble_9_3_resp };
struct test_stream test_9_3_list = { &preamble_9_3_list, &test_case_9_3_list, &postamble_9_3_list };

/*
 *  Delivering ordered and unordered data in multiple streams under noise.
 */
#define tgrp_case_9_4 test_group_9
#define numb_case_9_4 "9.4"
#define name_case_9_4 "Delivering data in multiple streams under noise."
#define sref_case_9_4 "(none)"
#define desc_case_9_4 "\
Delivery of ordered and un-ordered data in multiple streams under noise."
int
test_case_9_4_conn(int child)
{
	int s;
	int i[TEST_STREAMS] = { 0, };
	int j[TEST_STREAMS] = { 0, };
	int o[TEST_STREAMS] = { 0, };
	int p[TEST_STREAMS] = { 0, };
	int I = 0, J = 0, O = 0, P = 0;

	opt_data.sid_val = 1;
	test_data = "Pattern-1";
	DATA_flag = T_ODF_EX;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_NRM_OPTDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (s = 0; s < TEST_STREAMS; s++) {
		while (I < TEST_TOTAL && i[s] < TEST_PACKETS) {
			opt_data.sid_val = s;
			test_data = "Pattern-1";
			DATA_flag = 0;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				continue;
			i[s]++;
			I++;
			state++;
		}
		while (O < TEST_TOTAL && o[s] < TEST_PACKETS) {
			opt_data.sid_val = s;
			test_data = "Pattern-1";
			DATA_flag = T_ODF_EX;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				continue;
			o[s]++;
			O++;
			state++;
		}
	}
	while (J < TEST_TOTAL || P < TEST_TOTAL) {
		switch (wait_event(child, LONGER_WAIT)) {
		case __TEST_NRM_OPTDATA_IND:
			if (!exc[child]) {
				j[sid[child]]++;
				J++;
			} else {
				p[sid[child]]++;
				P++;
			}
			break;
		case __TEST_DATA_IND:
			j[sid[child]]++;
			J++;
			break;
		case __TEST_EXDATA_IND:
			p[sid[child]]++;
			P++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	for (s = 0; s < TEST_STREAMS; s++)
		fprintf(stdout, "%d send %d inds %d\n", child, i[s], j[s]);
	for (s = 0; s < TEST_STREAMS; s++)
		fprintf(stdout, "%d send %d inds %d\n", child, o[s], p[s]);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_4_resp(int child)
{
	int s;
	int i[TEST_STREAMS] = { 0, };
	int j[TEST_STREAMS] = { 0, };
	int o[TEST_STREAMS] = { 0, };
	int p[TEST_STREAMS] = { 0, };
	int I = 0, J = 0, O = 0, P = 0;

	if (expect(child, LONG_WAIT, __TEST_NRM_OPTDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	opt_data.sid_val = 3;
	test_data = "Pattern-3";
	DATA_flag = T_ODF_EX;
	test_opts = &opt_data;
	test_olen = sizeof(opt_data);
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (s = 0; s < TEST_STREAMS; s++) {
		while (I < TEST_TOTAL && i[s] < TEST_PACKETS) {
			opt_data.sid_val = s;
			test_data = "Pattern-3";
			DATA_flag = 0;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				continue;
			i[s]++;
			I++;
			state++;
		}
		while (O < TEST_TOTAL && o[s] < TEST_PACKETS) {
			opt_data.sid_val = s;
			test_data = "Pattern-3";
			DATA_flag = T_ODF_EX;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				continue;
			o[s]++;
			O++;
			state++;
		}
	}
	while (J < TEST_TOTAL || P < TEST_TOTAL) {
		switch (wait_event(child, LONGER_WAIT)) {
		case __TEST_NRM_OPTDATA_IND:
			if (!exc[child]) {
				j[sid[child]]++;
				J++;
			} else {
				p[sid[child]]++;
				P++;
			}
			break;
		case __TEST_DATA_IND:
			j[sid[child]]++;
			J++;
			break;
		case __TEST_EXDATA_IND:
			p[sid[child]]++;
			P++;
			break;
		case __EVENT_NO_MSG:
			continue;
		default:
			goto failure;
		}
		state++;
	}
	for (s = 0; s < TEST_STREAMS; s++) {
		if (j[s] != TEST_PACKETS || p[s] != TEST_PACKETS)
			goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	for (s = 0; s < TEST_STREAMS; s++)
		fprintf(stdout, "%d send %d inds %d\n", child, i[s], j[s]);
	for (s = 0; s < TEST_STREAMS; s++)
		fprintf(stdout, "%d send %d inds %d\n", child, o[s], p[s]);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	return (__RESULT_FAILURE);
}

int
test_case_9_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_9_4_conn	preamble_6_conn
#define preamble_9_4_resp	preamble_6_resp
#define preamble_9_4_list	preamble_6_list

#define postamble_9_4_conn	postamble_3_conn
#define postamble_9_4_resp	postamble_3_resp
#define postamble_9_4_list	postamble_3_list

struct test_stream test_9_4_conn = { &preamble_9_4_conn, &test_case_9_4_conn, &postamble_9_4_conn };
struct test_stream test_9_4_resp = { &preamble_9_4_resp, &test_case_9_4_resp, &postamble_9_4_resp };
struct test_stream test_9_4_list = { &preamble_9_4_list, &test_case_9_4_list, &postamble_9_4_list };
#endif

#if 1
/*
 *  Data for destination failure testing.
 */
#define test_group_10 "Data transfer undder destination failure"
#define tgrp_case_10_1 test_group_10
#define numb_case_10_1 "10.1"
#define name_case_10_1 "Data for destination failure testing."
#define sref_case_10_1 "(none)"
#define desc_case_10_1 "\
Delivery of ordered data with destination failure."
int
test_case_10_1_conn(int child)
{
	int i, j;

	test_data = "Test Pattern-1";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (j = 0; j < 20; j++) {
		for (i = 0; i < 20;) {
			test_data = "Test Pattern-1";
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				continue;
			i++;
			state++;
		}
		for (i = 0; i < 20;) {
			switch (wait_event(child, LONGER_WAIT)) {
			case __TEST_DATA_IND:
				i++;
				break;
			case __EVENT_NO_MSG:
				continue;
			default:
				goto failure;
			}
			state++;
		}
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_10_1_resp(int child)
{
	int i, j;

	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Test Pattern-3";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (j = 0; j < 20; j++) {
		for (i = 0; i < 20;) {
			test_data = "Test Pattern-3";
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				continue;
			i++;
			state++;
		}
		for (i = 0; i < 20;) {
			switch (wait_event(child, LONGER_WAIT)) {
			case __TEST_DATA_IND:
				i++;
				break;
			case __EVENT_NO_MSG:
				continue;
			default:
				goto failure;
			}
			state++;
		}
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_10_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_10_1_conn	preamble_5_conn
#define preamble_10_1_resp	preamble_5_resp
#define preamble_10_1_list	preamble_5_list

#define postamble_10_1_conn	postamble_3_conn
#define postamble_10_1_resp	postamble_3_resp
#define postamble_10_1_list	postamble_3_list

struct test_stream test_10_1_conn = { &preamble_10_1_conn, &test_case_10_1_conn, &postamble_10_1_conn };
struct test_stream test_10_1_resp = { &preamble_10_1_resp, &test_case_10_1_resp, &postamble_10_1_resp };
struct test_stream test_10_1_list = { &preamble_10_1_list, &test_case_10_1_list, &postamble_10_1_list };

/*
 *  Data for destination failure testing.
 */
long
time_sub(struct timeval *t1, struct timeval *t2)
{
	return ((t1->tv_sec - t2->tv_sec) * 1000000 + (t1->tv_usec - t2->tv_usec));
}

#define tgrp_case_10_2 test_group_10
#define numb_case_10_2 "10.2"
#define name_case_10_2 "Data for destination failure testing."
#define sref_case_10_2 "(none)"
#define desc_case_10_2 "\
Delivery of ordered data with destination failure."
int
test_case_10_2_conn(int child)
{
	int i, j, n = 0;
	struct result {
		uint req_idx;
		struct timeval req;
	};

#define SETS 1000
#define REPS 1
	struct result times[SETS * REPS];

	bzero(times, sizeof(times));
	show = 0;
	for (j = 0; j < SETS;) {
		for (i = 0; i < REPS; i++, state++) {
			test_data = "Test Pattern-1";
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				continue;
			times[j * REPS + i].req = when;
			times[j * REPS + i].req_idx = n++;
			j++;
			state++;
		}
	}
	show = 1;
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	for (j = 0, n = 0; n < 3 * SETS * REPS; n++) {
		for (i = 0; i < SETS * REPS; i++) {
			if (times[i].req_idx == n) {
				fprintf(stdout, "T_DATA_REQ    ----->| - - - - - - ->\\               |  |                    \n");
				fprintf(stdout, "                    |               \\ - - - - - - - +->|---> T_DATA_IND     \n");
				break;
			}
		}
	}
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
	show = 1;
	return (__RESULT_SUCCESS);
	goto failure;
      failure:
	show = 1;
	return (__RESULT_FAILURE);
}

int
test_case_10_2_resp(int child)
{
	int i, j;

	show = 0;
	for (j = 0; j < SETS; j++)
		for (i = 0; i < REPS;) {
			switch (wait_event(child, LONG_WAIT)) {
			case __TEST_DATA_IND:
				i++;
				break;
			case __EVENT_NO_MSG:
				continue;
			default:
				goto failure;
			}
			state++;
		}
	show = 1;
	return (__RESULT_SUCCESS);
      failure:
	show = 1;
	return (__RESULT_FAILURE);
}

int
test_case_10_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_10_2_conn	preamble_5_conn
#define preamble_10_2_resp	preamble_5_resp
#define preamble_10_2_list	preamble_5_list

#define postamble_10_2_conn	postamble_3_conn
#define postamble_10_2_resp	postamble_3_resp
#define postamble_10_2_list	postamble_3_list

struct test_stream test_10_2_conn = { &preamble_10_2_conn, &test_case_10_2_conn, &postamble_10_2_conn };
struct test_stream test_10_2_resp = { &preamble_10_2_resp, &test_case_10_2_resp, &postamble_10_2_resp };
struct test_stream test_10_2_list = { &preamble_10_2_list, &test_case_10_2_list, &postamble_10_2_list };
#endif

#define test_group_11_1 "Primitives in error -- too short"

int
test_case_11_1(int child, int prim)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	last_prim = prim;
	switch (prim) {
	case T_ADDR_REQ:
	case T_INFO_REQ:
	case T_ORDREL_REQ:
	case T_UNBIND_REQ:
		if (do_signal(child, __TEST_PRIM_WAY_TOO_SHORT) != __RESULT_SUCCESS)
			goto failure;
		break;
	default:
		if (do_signal(child, __TEST_PRIM_TOO_SHORT) != __RESULT_SUCCESS)
			goto failure;
		break;
	}
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		switch (prim) {
		case T_ADDR_REQ:
			goto expect_error;
		case T_BIND_REQ:
			goto expect_ack;
		case T_CAPABILITY_REQ:
			goto expect_ack;
		case T_CONN_REQ:
			goto expect_nosupport_ack;
		case T_CONN_RES:
			goto expect_nosupport_ack;
		case T_DATA_REQ:
			goto expect_error;
		case T_DISCON_REQ:
			goto expect_nosupport_ack;
		case T_EXDATA_REQ:
			goto expect_error;
		case T_INFO_REQ:
			goto expect_error;
		case T_OPTDATA_REQ:
			goto expect_error;
		case T_ORDREL_REQ:
			goto expect_error;
		case T_UNBIND_REQ:
			goto expect_error;
		case T_UNITDATA_REQ:
			goto expect_error;
		case -1:
			goto expect_nosupport_ack;
		default:
			goto expect_error;
		}
	case T_COTS:
		switch (prim) {
		case T_ADDR_REQ:
			goto expect_error;
		case T_BIND_REQ:
			goto expect_ack;
		case T_CAPABILITY_REQ:
			goto expect_ack;
		case T_CONN_REQ:
			goto expect_ack;
		case T_CONN_RES:
			goto expect_ack;
		case T_DATA_REQ:
			goto expect_error;
		case T_DISCON_REQ:
			goto expect_ack;
		case T_EXDATA_REQ:
			goto expect_error;
		case T_INFO_REQ:
			goto expect_error;
		case T_OPTDATA_REQ:
			goto expect_error;
		case T_ORDREL_REQ:
			goto expect_error;
		case T_UNBIND_REQ:
			goto expect_error;
		case T_UNITDATA_REQ:
			goto expect_error;
		case -1:
			goto expect_nosupport_ack;
		default:
			goto expect_error;
		}
	case T_COTS_ORD:
		switch (prim) {
		case T_ADDR_REQ:
			goto expect_error;
		case T_BIND_REQ:
			goto expect_ack;
		case T_CAPABILITY_REQ:
			goto expect_ack;
		case T_CONN_REQ:
			goto expect_ack;
		case T_CONN_RES:
			goto expect_ack;
		case T_DATA_REQ:
			goto expect_error;
		case T_DISCON_REQ:
			goto expect_ack;
		case T_EXDATA_REQ:
			goto expect_error;
		case T_INFO_REQ:
			goto expect_error;
		case T_OPTDATA_REQ:
			goto expect_error;
		case T_ORDREL_REQ:
			goto expect_error;
		case T_UNBIND_REQ:
			goto expect_error;
		case T_UNITDATA_REQ:
			goto expect_error;
		case -1:
			goto expect_nosupport_ack;
		default:
			goto expect_error;
		}
	default:
		goto failure;
	}
      expect_ack:
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TSYSERR)
		goto failure;
	state++;
	if (last_errno != EINVAL)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      expect_nosupport_ack:
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TNOTSUPPORT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      expect_error:
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define tgrp_case_11_1_1 test_group_11_1
#define numb_case_11_1_1 "11.1.1"
#define sref_case_11_1_1 "(none)"
#define name_case_11_1_1 "Primitives in error -- too short -- T_ADDR_REQ"
#define desc_case_11_1_1 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_ADDR_REQ primitive that is too short."

int
test_case_11_1_1(int child)
{
	return test_case_11_1(child, T_ADDR_REQ);
}

#define preamble_11_1_1_conn	preamble_0
#define preamble_11_1_1_resp	preamble_0
#define preamble_11_1_1_list	preamble_0

#define postamble_11_1_1_conn	postamble_0
#define postamble_11_1_1_resp	postamble_0
#define postamble_11_1_1_list	postamble_0

struct test_stream test_11_1_1_conn = { &preamble_11_1_1_conn, &test_case_11_1_1, &postamble_11_1_1_conn };
struct test_stream test_11_1_1_resp = { &preamble_11_1_1_resp, &test_case_11_1_1, &postamble_11_1_1_resp };
struct test_stream test_11_1_1_list = { &preamble_11_1_1_list, &test_case_11_1_1, &postamble_11_1_1_list };

#define tgrp_case_11_1_2 test_group_11_1
#define numb_case_11_1_2 "11.1.2"
#define sref_case_11_1_2 "(none)"
#define name_case_11_1_2 "Primitives in error -- too short -- T_BIND_REQ"
#define desc_case_11_1_2 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_BIND_REQ primitive that is too short."

int
test_case_11_1_2(int child)
{
	return test_case_11_1(child, T_BIND_REQ);
}

#define preamble_11_1_2_conn	preamble_0
#define preamble_11_1_2_resp	preamble_0
#define preamble_11_1_2_list	preamble_0

#define postamble_11_1_2_conn	postamble_0
#define postamble_11_1_2_resp	postamble_0
#define postamble_11_1_2_list	postamble_0

struct test_stream test_11_1_2_conn = { &preamble_11_1_2_conn, &test_case_11_1_2, &postamble_11_1_2_conn };
struct test_stream test_11_1_2_resp = { &preamble_11_1_2_resp, &test_case_11_1_2, &postamble_11_1_2_resp };
struct test_stream test_11_1_2_list = { &preamble_11_1_2_list, &test_case_11_1_2, &postamble_11_1_2_list };

#define tgrp_case_11_1_3 test_group_11_1
#define numb_case_11_1_3 "11.1.3"
#define sref_case_11_1_3 "(none)"
#define name_case_11_1_3 "Primitives in error -- too short -- T_CAPABILITY_REQ"
#define desc_case_11_1_3 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_CAPABILITY_REQ primitive that is too short."

int
test_case_11_1_3(int child)
{
	return test_case_11_1(child, T_CAPABILITY_REQ);
}

#define preamble_11_1_3_conn	preamble_0
#define preamble_11_1_3_resp	preamble_0
#define preamble_11_1_3_list	preamble_0

#define postamble_11_1_3_conn	postamble_0
#define postamble_11_1_3_resp	postamble_0
#define postamble_11_1_3_list	postamble_0

struct test_stream test_11_1_3_conn = { &preamble_11_1_3_conn, &test_case_11_1_3, &postamble_11_1_3_conn };
struct test_stream test_11_1_3_resp = { &preamble_11_1_3_resp, &test_case_11_1_3, &postamble_11_1_3_resp };
struct test_stream test_11_1_3_list = { &preamble_11_1_3_list, &test_case_11_1_3, &postamble_11_1_3_list };

#define tgrp_case_11_1_4 test_group_11_1
#define numb_case_11_1_4 "11.1.4"
#define sref_case_11_1_4 "(none)"
#define name_case_11_1_4 "Primitives in error -- too short -- T_CONN_REQ"
#define desc_case_11_1_4 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_CONN_REQ primitive that is too short."

int
test_case_11_1_4(int child)
{
	return test_case_11_1(child, T_CONN_REQ);
}

#define preamble_11_1_4_conn	preamble_0
#define preamble_11_1_4_resp	preamble_0
#define preamble_11_1_4_list	preamble_0

#define postamble_11_1_4_conn	postamble_0
#define postamble_11_1_4_resp	postamble_0
#define postamble_11_1_4_list	postamble_0

struct test_stream test_11_1_4_conn = { &preamble_11_1_4_conn, &test_case_11_1_4, &postamble_11_1_4_conn };
struct test_stream test_11_1_4_resp = { &preamble_11_1_4_resp, &test_case_11_1_4, &postamble_11_1_4_resp };
struct test_stream test_11_1_4_list = { &preamble_11_1_4_list, &test_case_11_1_4, &postamble_11_1_4_list };

#define tgrp_case_11_1_5 test_group_11_1
#define numb_case_11_1_5 "11.1.5"
#define sref_case_11_1_5 "(none)"
#define name_case_11_1_5 "Primitives in error -- too short -- T_CONN_RES"
#define desc_case_11_1_5 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_CONN_RES primitive that is too short."

int
test_case_11_1_5(int child)
{
	return test_case_11_1(child, T_CONN_RES);
}

#define preamble_11_1_5_conn	preamble_0
#define preamble_11_1_5_resp	preamble_0
#define preamble_11_1_5_list	preamble_0

#define postamble_11_1_5_conn	postamble_0
#define postamble_11_1_5_resp	postamble_0
#define postamble_11_1_5_list	postamble_0

struct test_stream test_11_1_5_conn = { &preamble_11_1_5_conn, &test_case_11_1_5, &postamble_11_1_5_conn };
struct test_stream test_11_1_5_resp = { &preamble_11_1_5_resp, &test_case_11_1_5, &postamble_11_1_5_resp };
struct test_stream test_11_1_5_list = { &preamble_11_1_5_list, &test_case_11_1_5, &postamble_11_1_5_list };

#define tgrp_case_11_1_6 test_group_11_1
#define numb_case_11_1_6 "11.1.6"
#define sref_case_11_1_6 "(none)"
#define name_case_11_1_6 "Primitives in error -- too short -- T_DATA_REQ"
#define desc_case_11_1_6 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_DATA_REQ primitive that is too short."

int
test_case_11_1_6(int child)
{
	return test_case_11_1(child, T_DATA_REQ);
}

#define preamble_11_1_6_conn	preamble_0
#define preamble_11_1_6_resp	preamble_0
#define preamble_11_1_6_list	preamble_0

#define postamble_11_1_6_conn	postamble_0
#define postamble_11_1_6_resp	postamble_0
#define postamble_11_1_6_list	postamble_0

struct test_stream test_11_1_6_conn = { &preamble_11_1_6_conn, &test_case_11_1_6, &postamble_11_1_6_conn };
struct test_stream test_11_1_6_resp = { &preamble_11_1_6_resp, &test_case_11_1_6, &postamble_11_1_6_resp };
struct test_stream test_11_1_6_list = { &preamble_11_1_6_list, &test_case_11_1_6, &postamble_11_1_6_list };

#define tgrp_case_11_1_7 test_group_11_1
#define numb_case_11_1_7 "11.1.7"
#define sref_case_11_1_7 "(none)"
#define name_case_11_1_7 "Primitives in error -- too short -- T_DISCON_REQ"
#define desc_case_11_1_7 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_DISCON_REQ primitive that is too short."

int
test_case_11_1_7(int child)
{
	return test_case_11_1(child, T_DISCON_REQ);
}

#define preamble_11_1_7_conn	preamble_0
#define preamble_11_1_7_resp	preamble_0
#define preamble_11_1_7_list	preamble_0

#define postamble_11_1_7_conn	postamble_0
#define postamble_11_1_7_resp	postamble_0
#define postamble_11_1_7_list	postamble_0

struct test_stream test_11_1_7_conn = { &preamble_11_1_7_conn, &test_case_11_1_7, &postamble_11_1_7_conn };
struct test_stream test_11_1_7_resp = { &preamble_11_1_7_resp, &test_case_11_1_7, &postamble_11_1_7_resp };
struct test_stream test_11_1_7_list = { &preamble_11_1_7_list, &test_case_11_1_7, &postamble_11_1_7_list };

#define tgrp_case_11_1_8 test_group_11_1
#define numb_case_11_1_8 "11.1.8"
#define sref_case_11_1_8 "(none)"
#define name_case_11_1_8 "Primitives in error -- too short -- T_EXDATA_REQ"
#define desc_case_11_1_8 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_EXDATA_REQ primitive that is too short."

int
test_case_11_1_8(int child)
{
	return test_case_11_1(child, T_EXDATA_REQ);
}

#define preamble_11_1_8_conn	preamble_0
#define preamble_11_1_8_resp	preamble_0
#define preamble_11_1_8_list	preamble_0

#define postamble_11_1_8_conn	postamble_0
#define postamble_11_1_8_resp	postamble_0
#define postamble_11_1_8_list	postamble_0

struct test_stream test_11_1_8_conn = { &preamble_11_1_8_conn, &test_case_11_1_8, &postamble_11_1_8_conn };
struct test_stream test_11_1_8_resp = { &preamble_11_1_8_resp, &test_case_11_1_8, &postamble_11_1_8_resp };
struct test_stream test_11_1_8_list = { &preamble_11_1_8_list, &test_case_11_1_8, &postamble_11_1_8_list };

#define tgrp_case_11_1_9 test_group_11_1
#define numb_case_11_1_9 "11.1.9"
#define sref_case_11_1_9 "(none)"
#define name_case_11_1_9 "Primitives in error -- too short -- T_INFO_REQ"
#define desc_case_11_1_9 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_INFO_REQ primitive that is too short."

int
test_case_11_1_9(int child)
{
	return test_case_11_1(child, T_INFO_REQ);
}

#define preamble_11_1_9_conn	preamble_0
#define preamble_11_1_9_resp	preamble_0
#define preamble_11_1_9_list	preamble_0

#define postamble_11_1_9_conn	postamble_0
#define postamble_11_1_9_resp	postamble_0
#define postamble_11_1_9_list	postamble_0

struct test_stream test_11_1_9_conn = { &preamble_11_1_9_conn, &test_case_11_1_9, &postamble_11_1_9_conn };
struct test_stream test_11_1_9_resp = { &preamble_11_1_9_resp, &test_case_11_1_9, &postamble_11_1_9_resp };
struct test_stream test_11_1_9_list = { &preamble_11_1_9_list, &test_case_11_1_9, &postamble_11_1_9_list };

#define tgrp_case_11_1_10 test_group_11_1
#define numb_case_11_1_10 "11.1.10"
#define sref_case_11_1_10 "(none)"
#define name_case_11_1_10 "Primitives in error -- too short -- T_OPTDATA_REQ"
#define desc_case_11_1_10 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_OPTDATA_REQ primitive that is too short."

int
test_case_11_1_10(int child)
{
	return test_case_11_1(child, T_OPTDATA_REQ);
}

#define preamble_11_1_10_conn	preamble_0
#define preamble_11_1_10_resp	preamble_0
#define preamble_11_1_10_list	preamble_0

#define postamble_11_1_10_conn	postamble_0
#define postamble_11_1_10_resp	postamble_0
#define postamble_11_1_10_list	postamble_0

struct test_stream test_11_1_10_conn = { &preamble_11_1_10_conn, &test_case_11_1_10, &postamble_11_1_10_conn };
struct test_stream test_11_1_10_resp = { &preamble_11_1_10_resp, &test_case_11_1_10, &postamble_11_1_10_resp };
struct test_stream test_11_1_10_list = { &preamble_11_1_10_list, &test_case_11_1_10, &postamble_11_1_10_list };

#define tgrp_case_11_1_11 test_group_11_1
#define numb_case_11_1_11 "11.1.11"
#define sref_case_11_1_11 "(none)"
#define name_case_11_1_11 "Primitives in error -- too short -- T_ORDREL_REQ"
#define desc_case_11_1_11 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_ORDREL_REQ primitive that is too short."

int
test_case_11_1_11(int child)
{
	return test_case_11_1(child, T_ORDREL_REQ);
}

#define preamble_11_1_11_conn	preamble_0
#define preamble_11_1_11_resp	preamble_0
#define preamble_11_1_11_list	preamble_0

#define postamble_11_1_11_conn	postamble_0
#define postamble_11_1_11_resp	postamble_0
#define postamble_11_1_11_list	postamble_0

struct test_stream test_11_1_11_conn = { &preamble_11_1_11_conn, &test_case_11_1_11, &postamble_11_1_11_conn };
struct test_stream test_11_1_11_resp = { &preamble_11_1_11_resp, &test_case_11_1_11, &postamble_11_1_11_resp };
struct test_stream test_11_1_11_list = { &preamble_11_1_11_list, &test_case_11_1_11, &postamble_11_1_11_list };

#define tgrp_case_11_1_12 test_group_11_1
#define numb_case_11_1_12 "11.1.12"
#define sref_case_11_1_12 "(none)"
#define name_case_11_1_12 "Primitives in error -- too short -- T_UNBIND_REQ"
#define desc_case_11_1_12 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_UNBIND_REQ primitive that is too short."

int
test_case_11_1_12(int child)
{
	return test_case_11_1(child, T_UNBIND_REQ);
}

#define preamble_11_1_12_conn	preamble_0
#define preamble_11_1_12_resp	preamble_0
#define preamble_11_1_12_list	preamble_0

#define postamble_11_1_12_conn	postamble_0
#define postamble_11_1_12_resp	postamble_0
#define postamble_11_1_12_list	postamble_0

struct test_stream test_11_1_12_conn = { &preamble_11_1_12_conn, &test_case_11_1_12, &postamble_11_1_12_conn };
struct test_stream test_11_1_12_resp = { &preamble_11_1_12_resp, &test_case_11_1_12, &postamble_11_1_12_resp };
struct test_stream test_11_1_12_list = { &preamble_11_1_12_list, &test_case_11_1_12, &postamble_11_1_12_list };

#define tgrp_case_11_1_13 test_group_11_1
#define numb_case_11_1_13 "11.1.13"
#define sref_case_11_1_13 "(none)"
#define name_case_11_1_13 "Primitives in error -- too short -- T_UNITDATA_REQ"
#define desc_case_11_1_13 "\
Checks that a primitive that is too short results in an error.  Neither the TPI\n\
nor the XTI specification indicates what action is taken when a primitive is\n\
received that is too short.  For primitives that require an acknowledgeement we\n\
return a T_ERROR_ACK with a UNIX error number of EINVAL.  For primitives that do\n\
not require an acknowledgement we issue an M_ERROR with an error number of\n\
EPROTO.  This test case is for a T_UNITDATA_REQ primitive that is too short."

int
test_case_11_1_13(int child)
{
	return test_case_11_1(child, T_UNITDATA_REQ);
}

#define preamble_11_1_13_conn	preamble_0
#define preamble_11_1_13_resp	preamble_0
#define preamble_11_1_13_list	preamble_0

#define postamble_11_1_13_conn	postamble_0
#define postamble_11_1_13_resp	postamble_0
#define postamble_11_1_13_list	postamble_0

struct test_stream test_11_1_13_conn = { &preamble_11_1_13_conn, &test_case_11_1_13, &postamble_11_1_13_conn };
struct test_stream test_11_1_13_resp = { &preamble_11_1_13_resp, &test_case_11_1_13, &postamble_11_1_13_resp };
struct test_stream test_11_1_13_list = { &preamble_11_1_13_list, &test_case_11_1_13, &postamble_11_1_13_list };

#define test_group_11_2 "Primitives in error -- wrong primitive type"

#define tgrp_case_11_2_1 test_group_11_2
#define numb_case_11_2_1 "11.2.1"
#define sref_case_11_2_1 "(none)"
#define name_case_11_2_1 "Primitivie in error -- wrong primitive type -- T_ADDR_ACK"
#define desc_case_11_2_1 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_ADDR_ACK primitive sent in the wrong direction."

int
test_case_11_2_1(int child)
{
	return test_case_11_1(child, T_ADDR_ACK);
}

#define preamble_11_2_1_conn	preamble_0
#define preamble_11_2_1_resp	preamble_0
#define preamble_11_2_1_list	preamble_0

#define postamble_11_2_1_conn	postamble_0
#define postamble_11_2_1_resp	postamble_0
#define postamble_11_2_1_list	postamble_0

struct test_stream test_11_2_1_conn = { &preamble_11_2_1_conn, &test_case_11_2_1, &postamble_11_2_1_conn };
struct test_stream test_11_2_1_resp = { &preamble_11_2_1_resp, &test_case_11_2_1, &postamble_11_2_1_resp };
struct test_stream test_11_2_1_list = { &preamble_11_2_1_list, &test_case_11_2_1, &postamble_11_2_1_list };

#define tgrp_case_11_2_2 test_group_11_2
#define numb_case_11_2_2 "11.2.2"
#define sref_case_11_2_2 "(none)"
#define name_case_11_2_2 "Primitivie in error -- wrong primitive type -- T_BIND_ACK"
#define desc_case_11_2_2 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_BIND_ACK primitive sent in the wrong direction."

int
test_case_11_2_2(int child)
{
	return test_case_11_1(child, T_BIND_ACK);
}

#define preamble_11_2_2_conn	preamble_0
#define preamble_11_2_2_resp	preamble_0
#define preamble_11_2_2_list	preamble_0

#define postamble_11_2_2_conn	postamble_0
#define postamble_11_2_2_resp	postamble_0
#define postamble_11_2_2_list	postamble_0

struct test_stream test_11_2_2_conn = { &preamble_11_2_2_conn, &test_case_11_2_2, &postamble_11_2_2_conn };
struct test_stream test_11_2_2_resp = { &preamble_11_2_2_resp, &test_case_11_2_2, &postamble_11_2_2_resp };
struct test_stream test_11_2_2_list = { &preamble_11_2_2_list, &test_case_11_2_2, &postamble_11_2_2_list };

#define tgrp_case_11_2_3 test_group_11_2
#define numb_case_11_2_3 "11.2.3"
#define sref_case_11_2_3 "(none)"
#define name_case_11_2_3 "Primitivie in error -- wrong primitive type -- T_CAPABILITY_ACK"
#define desc_case_11_2_3 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_CAPABILITY_ACK primitive sent in the wrong direction."

int
test_case_11_2_3(int child)
{
	return test_case_11_1(child, T_CAPABILITY_ACK);
}

#define preamble_11_2_3_conn	preamble_0
#define preamble_11_2_3_resp	preamble_0
#define preamble_11_2_3_list	preamble_0

#define postamble_11_2_3_conn	postamble_0
#define postamble_11_2_3_resp	postamble_0
#define postamble_11_2_3_list	postamble_0

struct test_stream test_11_2_3_conn = { &preamble_11_2_3_conn, &test_case_11_2_3, &postamble_11_2_3_conn };
struct test_stream test_11_2_3_resp = { &preamble_11_2_3_resp, &test_case_11_2_3, &postamble_11_2_3_resp };
struct test_stream test_11_2_3_list = { &preamble_11_2_3_list, &test_case_11_2_3, &postamble_11_2_3_list };

#define tgrp_case_11_2_4 test_group_11_2
#define numb_case_11_2_4 "11.2.4"
#define sref_case_11_2_4 "(none)"
#define name_case_11_2_4 "Primitivie in error -- wrong primitive type -- T_CONN_CON"
#define desc_case_11_2_4 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_CONN_CON primitive sent in the wrong direction."

int
test_case_11_2_4(int child)
{
	return test_case_11_1(child, T_CONN_CON);
}

#define preamble_11_2_4_conn	preamble_0
#define preamble_11_2_4_resp	preamble_0
#define preamble_11_2_4_list	preamble_0

#define postamble_11_2_4_conn	postamble_0
#define postamble_11_2_4_resp	postamble_0
#define postamble_11_2_4_list	postamble_0

struct test_stream test_11_2_4_conn = { &preamble_11_2_4_conn, &test_case_11_2_4, &postamble_11_2_4_conn };
struct test_stream test_11_2_4_resp = { &preamble_11_2_4_resp, &test_case_11_2_4, &postamble_11_2_4_resp };
struct test_stream test_11_2_4_list = { &preamble_11_2_4_list, &test_case_11_2_4, &postamble_11_2_4_list };

#define tgrp_case_11_2_5 test_group_11_2
#define numb_case_11_2_5 "11.2.5"
#define sref_case_11_2_5 "(none)"
#define name_case_11_2_5 "Primitivie in error -- wrong primitive type -- T_CONN_IND"
#define desc_case_11_2_5 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_CONN_IND primitive sent in the wrong direction."

int
test_case_11_2_5(int child)
{
	return test_case_11_1(child, T_CONN_IND);
}

#define preamble_11_2_5_conn	preamble_0
#define preamble_11_2_5_resp	preamble_0
#define preamble_11_2_5_list	preamble_0

#define postamble_11_2_5_conn	postamble_0
#define postamble_11_2_5_resp	postamble_0
#define postamble_11_2_5_list	postamble_0

struct test_stream test_11_2_5_conn = { &preamble_11_2_5_conn, &test_case_11_2_5, &postamble_11_2_5_conn };
struct test_stream test_11_2_5_resp = { &preamble_11_2_5_resp, &test_case_11_2_5, &postamble_11_2_5_resp };
struct test_stream test_11_2_5_list = { &preamble_11_2_5_list, &test_case_11_2_5, &postamble_11_2_5_list };

#define tgrp_case_11_2_6 test_group_11_2
#define numb_case_11_2_6 "11.2.6"
#define sref_case_11_2_6 "(none)"
#define name_case_11_2_6 "Primitivie in error -- wrong primitive type -- T_DATA_IND"
#define desc_case_11_2_6 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_DATA_IND primitive sent in the wrong direction."

int
test_case_11_2_6(int child)
{
	return test_case_11_1(child, T_DATA_IND);
}

#define preamble_11_2_6_conn	preamble_0
#define preamble_11_2_6_resp	preamble_0
#define preamble_11_2_6_list	preamble_0

#define postamble_11_2_6_conn	postamble_0
#define postamble_11_2_6_resp	postamble_0
#define postamble_11_2_6_list	postamble_0

struct test_stream test_11_2_6_conn = { &preamble_11_2_6_conn, &test_case_11_2_6, &postamble_11_2_6_conn };
struct test_stream test_11_2_6_resp = { &preamble_11_2_6_resp, &test_case_11_2_6, &postamble_11_2_6_resp };
struct test_stream test_11_2_6_list = { &preamble_11_2_6_list, &test_case_11_2_6, &postamble_11_2_6_list };

#define tgrp_case_11_2_7 test_group_11_2
#define numb_case_11_2_7 "11.2.7"
#define sref_case_11_2_7 "(none)"
#define name_case_11_2_7 "Primitivie in error -- wrong primitive type -- T_DISCON_IND"
#define desc_case_11_2_7 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_DISCON_IND primitive sent in the wrong direction."

int
test_case_11_2_7(int child)
{
	return test_case_11_1(child, T_DISCON_IND);
}

#define preamble_11_2_7_conn	preamble_0
#define preamble_11_2_7_resp	preamble_0
#define preamble_11_2_7_list	preamble_0

#define postamble_11_2_7_conn	postamble_0
#define postamble_11_2_7_resp	postamble_0
#define postamble_11_2_7_list	postamble_0

struct test_stream test_11_2_7_conn = { &preamble_11_2_7_conn, &test_case_11_2_7, &postamble_11_2_7_conn };
struct test_stream test_11_2_7_resp = { &preamble_11_2_7_resp, &test_case_11_2_7, &postamble_11_2_7_resp };
struct test_stream test_11_2_7_list = { &preamble_11_2_7_list, &test_case_11_2_7, &postamble_11_2_7_list };

#define tgrp_case_11_2_8 test_group_11_2
#define numb_case_11_2_8 "11.2.8"
#define sref_case_11_2_8 "(none)"
#define name_case_11_2_8 "Primitivie in error -- wrong primitive type -- T_ERROR_ACK"
#define desc_case_11_2_8 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_ERROR_ACK primitive sent in the wrong direction."

int
test_case_11_2_8(int child)
{
	return test_case_11_1(child, T_ERROR_ACK);
}

#define preamble_11_2_8_conn	preamble_0
#define preamble_11_2_8_resp	preamble_0
#define preamble_11_2_8_list	preamble_0

#define postamble_11_2_8_conn	postamble_0
#define postamble_11_2_8_resp	postamble_0
#define postamble_11_2_8_list	postamble_0

struct test_stream test_11_2_8_conn = { &preamble_11_2_8_conn, &test_case_11_2_8, &postamble_11_2_8_conn };
struct test_stream test_11_2_8_resp = { &preamble_11_2_8_resp, &test_case_11_2_8, &postamble_11_2_8_resp };
struct test_stream test_11_2_8_list = { &preamble_11_2_8_list, &test_case_11_2_8, &postamble_11_2_8_list };

#define tgrp_case_11_2_9 test_group_11_2
#define numb_case_11_2_9 "11.2.9"
#define sref_case_11_2_9 "(none)"
#define name_case_11_2_9 "Primitivie in error -- wrong primitive type -- T_EXDATA_IND"
#define desc_case_11_2_9 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_EXDATA_IND primitive sent in the wrong direction."

int
test_case_11_2_9(int child)
{
	return test_case_11_1(child, T_EXDATA_IND);
}

#define preamble_11_2_9_conn	preamble_0
#define preamble_11_2_9_resp	preamble_0
#define preamble_11_2_9_list	preamble_0

#define postamble_11_2_9_conn	postamble_0
#define postamble_11_2_9_resp	postamble_0
#define postamble_11_2_9_list	postamble_0

struct test_stream test_11_2_9_conn = { &preamble_11_2_9_conn, &test_case_11_2_9, &postamble_11_2_9_conn };
struct test_stream test_11_2_9_resp = { &preamble_11_2_9_resp, &test_case_11_2_9, &postamble_11_2_9_resp };
struct test_stream test_11_2_9_list = { &preamble_11_2_9_list, &test_case_11_2_9, &postamble_11_2_9_list };

#define tgrp_case_11_2_10 test_group_11_2
#define numb_case_11_2_10 "11.2.10"
#define sref_case_11_2_10 "(none)"
#define name_case_11_2_10 "Primitivie in error -- wrong primitive type -- T_INFO_ACK"
#define desc_case_11_2_10 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_INFO_ACK primitive sent in the wrong direction."

int
test_case_11_2_10(int child)
{
	return test_case_11_1(child, T_INFO_ACK);
}

#define preamble_11_2_10_conn	preamble_0
#define preamble_11_2_10_resp	preamble_0
#define preamble_11_2_10_list	preamble_0

#define postamble_11_2_10_conn	postamble_0
#define postamble_11_2_10_resp	postamble_0
#define postamble_11_2_10_list	postamble_0

struct test_stream test_11_2_10_conn = { &preamble_11_2_10_conn, &test_case_11_2_10, &postamble_11_2_10_conn };
struct test_stream test_11_2_10_resp = { &preamble_11_2_10_resp, &test_case_11_2_10, &postamble_11_2_10_resp };
struct test_stream test_11_2_10_list = { &preamble_11_2_10_list, &test_case_11_2_10, &postamble_11_2_10_list };

#define tgrp_case_11_2_11 test_group_11_2
#define numb_case_11_2_11 "11.2.11"
#define sref_case_11_2_11 "(none)"
#define name_case_11_2_11 "Primitivie in error -- wrong primitive type -- T_OK_ACK"
#define desc_case_11_2_11 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_OK_ACK primitive sent in the wrong direction."

int
test_case_11_2_11(int child)
{
	return test_case_11_1(child, T_OK_ACK);
}

#define preamble_11_2_11_conn	preamble_0
#define preamble_11_2_11_resp	preamble_0
#define preamble_11_2_11_list	preamble_0

#define postamble_11_2_11_conn	postamble_0
#define postamble_11_2_11_resp	postamble_0
#define postamble_11_2_11_list	postamble_0

struct test_stream test_11_2_11_conn = { &preamble_11_2_11_conn, &test_case_11_2_11, &postamble_11_2_11_conn };
struct test_stream test_11_2_11_resp = { &preamble_11_2_11_resp, &test_case_11_2_11, &postamble_11_2_11_resp };
struct test_stream test_11_2_11_list = { &preamble_11_2_11_list, &test_case_11_2_11, &postamble_11_2_11_list };

#define tgrp_case_11_2_12 test_group_11_2
#define numb_case_11_2_12 "11.2.12"
#define sref_case_11_2_12 "(none)"
#define name_case_11_2_12 "Primitivie in error -- wrong primitive type -- T_OPTDATA_IND"
#define desc_case_11_2_12 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_OPTDATA_IND primitive sent in the wrong direction."

int
test_case_11_2_12(int child)
{
	return test_case_11_1(child, T_OPTDATA_IND);
}

#define preamble_11_2_12_conn	preamble_0
#define preamble_11_2_12_resp	preamble_0
#define preamble_11_2_12_list	preamble_0

#define postamble_11_2_12_conn	postamble_0
#define postamble_11_2_12_resp	postamble_0
#define postamble_11_2_12_list	postamble_0

struct test_stream test_11_2_12_conn = { &preamble_11_2_12_conn, &test_case_11_2_12, &postamble_11_2_12_conn };
struct test_stream test_11_2_12_resp = { &preamble_11_2_12_resp, &test_case_11_2_12, &postamble_11_2_12_resp };
struct test_stream test_11_2_12_list = { &preamble_11_2_12_list, &test_case_11_2_12, &postamble_11_2_12_list };

#define tgrp_case_11_2_13 test_group_11_2
#define numb_case_11_2_13 "11.2.13"
#define sref_case_11_2_13 "(none)"
#define name_case_11_2_13 "Primitivie in error -- wrong primitive type -- T_OPTMGMT_ACK"
#define desc_case_11_2_13 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_OPTMGMT_ACK primitive sent in the wrong direction."

int
test_case_11_2_13(int child)
{
	return test_case_11_1(child, T_OPTMGMT_ACK);
}

#define preamble_11_2_13_conn	preamble_0
#define preamble_11_2_13_resp	preamble_0
#define preamble_11_2_13_list	preamble_0

#define postamble_11_2_13_conn	postamble_0
#define postamble_11_2_13_resp	postamble_0
#define postamble_11_2_13_list	postamble_0

struct test_stream test_11_2_13_conn = { &preamble_11_2_13_conn, &test_case_11_2_13, &postamble_11_2_13_conn };
struct test_stream test_11_2_13_resp = { &preamble_11_2_13_resp, &test_case_11_2_13, &postamble_11_2_13_resp };
struct test_stream test_11_2_13_list = { &preamble_11_2_13_list, &test_case_11_2_13, &postamble_11_2_13_list };

#define tgrp_case_11_2_14 test_group_11_2
#define numb_case_11_2_14 "11.2.14"
#define sref_case_11_2_14 "(none)"
#define name_case_11_2_14 "Primitivie in error -- wrong primitive type -- T_ORDREL_IND"
#define desc_case_11_2_14 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_ORDREL_IND primitive sent in the wrong direction."

int
test_case_11_2_14(int child)
{
	return test_case_11_1(child, T_ORDREL_IND);
}

#define preamble_11_2_14_conn	preamble_0
#define preamble_11_2_14_resp	preamble_0
#define preamble_11_2_14_list	preamble_0

#define postamble_11_2_14_conn	postamble_0
#define postamble_11_2_14_resp	postamble_0
#define postamble_11_2_14_list	postamble_0

struct test_stream test_11_2_14_conn = { &preamble_11_2_14_conn, &test_case_11_2_14, &postamble_11_2_14_conn };
struct test_stream test_11_2_14_resp = { &preamble_11_2_14_resp, &test_case_11_2_14, &postamble_11_2_14_resp };
struct test_stream test_11_2_14_list = { &preamble_11_2_14_list, &test_case_11_2_14, &postamble_11_2_14_list };

#define tgrp_case_11_2_15 test_group_11_2
#define numb_case_11_2_15 "11.2.15"
#define sref_case_11_2_15 "(none)"
#define name_case_11_2_15 "Primitivie in error -- wrong primitive type -- T_UDERROR_IND"
#define desc_case_11_2_15 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_UDERROR_IND primitive sent in the wrong direction."

int
test_case_11_2_15(int child)
{
	return test_case_11_1(child, T_UDERROR_IND);
}

#define preamble_11_2_15_conn	preamble_0
#define preamble_11_2_15_resp	preamble_0
#define preamble_11_2_15_list	preamble_0

#define postamble_11_2_15_conn	postamble_0
#define postamble_11_2_15_resp	postamble_0
#define postamble_11_2_15_list	postamble_0

struct test_stream test_11_2_15_conn = { &preamble_11_2_15_conn, &test_case_11_2_15, &postamble_11_2_15_conn };
struct test_stream test_11_2_15_resp = { &preamble_11_2_15_resp, &test_case_11_2_15, &postamble_11_2_15_resp };
struct test_stream test_11_2_15_list = { &preamble_11_2_15_list, &test_case_11_2_15, &postamble_11_2_15_list };

#define tgrp_case_11_2_16 test_group_11_2
#define numb_case_11_2_16 "11.2.16"
#define sref_case_11_2_16 "(none)"
#define name_case_11_2_16 "Primitivie in error -- wrong primitive type -- T_UNITDATA_IND"
#define desc_case_11_2_16 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a T_UNITDATA_IND primitive sent in the wrong direction."

int
test_case_11_2_16(int child)
{
	return test_case_11_1(child, T_UNITDATA_IND);
}

#define preamble_11_2_16_conn	preamble_0
#define preamble_11_2_16_resp	preamble_0
#define preamble_11_2_16_list	preamble_0

#define postamble_11_2_16_conn	postamble_0
#define postamble_11_2_16_resp	postamble_0
#define postamble_11_2_16_list	postamble_0

struct test_stream test_11_2_16_conn = { &preamble_11_2_16_conn, &test_case_11_2_16, &postamble_11_2_16_conn };
struct test_stream test_11_2_16_resp = { &preamble_11_2_16_resp, &test_case_11_2_16, &postamble_11_2_16_resp };
struct test_stream test_11_2_16_list = { &preamble_11_2_16_list, &test_case_11_2_16, &postamble_11_2_16_list };

#define tgrp_case_11_2_17 test_group_11_2
#define numb_case_11_2_17 "11.2.17"
#define sref_case_11_2_17 "(none)"
#define name_case_11_2_17 "Primitivie in error -- wrong primitive type -- UNKNOWN"
#define desc_case_11_2_17 "\
Checks that a primitive of a known but incorrect primitive type results in an\n\
error.  Neither the TPI nor the XTI specification indicates what action is taken\n\
when a primitive of the a known wrong type is received.  For known primitives we\n\
issue an M_ERROR with an error number of EPROTO.  For unknown primitives, we\n\
return a T_ERROR_ACK with a UNIX error number of TNOTSUPPORT.  This test case is\n\
for a UNKNOWN primitive sent in the wrong direction."

int
test_case_11_2_17(int child)
{
	return test_case_11_1(child, -1);
}

#define preamble_11_2_17_conn	preamble_0
#define preamble_11_2_17_resp	preamble_0
#define preamble_11_2_17_list	preamble_0

#define postamble_11_2_17_conn	postamble_0
#define postamble_11_2_17_resp	postamble_0
#define postamble_11_2_17_list	postamble_0

struct test_stream test_11_2_17_conn = { &preamble_11_2_17_conn, &test_case_11_2_17, &postamble_11_2_17_conn };
struct test_stream test_11_2_17_resp = { &preamble_11_2_17_resp, &test_case_11_2_17, &postamble_11_2_17_resp };
struct test_stream test_11_2_17_list = { &preamble_11_2_17_list, &test_case_11_2_17, &postamble_11_2_17_list };

#define test_group_11_3 "Primitives in error -- unsupported primitive type"

int
test_case_11_3(int child, long prim)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (last_info.SERV_type) {
	case T_CLTS:
		switch (prim) {
		case T_ADDR_REQ:
			break;
		case T_BIND_REQ:
			break;
		case T_CAPABILITY_REQ:
			break;
		case T_CONN_REQ:
			test_addr = addrs[2];
			test_alen = anums[2]*sizeof(addrs[2][0]);
			test_data = "Hello World";
			test_opts = &opt_conn;
			test_olen = sizeof(opt_conn);
			if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_nosupport_ack;
		case T_CONN_RES:
			test_resfd = test_fd[1];
			test_data = "Hello There!";
			test_opts = &opt_conn;
			test_olen = sizeof(opt_conn);
			if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_nosupport_ack;
		case T_DATA_REQ:
			test_data = "Normal test message.";
			MORE_flag = 0;
			if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case T_DISCON_REQ:
			test_data = NULL;
			last_sequence = 0;
			if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_nosupport_ack;
		case T_EXDATA_REQ:
			test_data = "Expedited test message.";
			MORE_flag = 0;
			if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case T_INFO_REQ:
			break;
		case T_OPTDATA_REQ:
			test_data = "Option data.";
			DATA_flag = 0;
			test_opts = &opt_data;
			test_olen = sizeof(opt_data);
			if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case T_ORDREL_REQ:
			test_data = NULL;
			if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case T_UNBIND_REQ:
			break;
		case T_UNITDATA_REQ:
			break;
		case -1:
		default:
			last_prim = prim;
			if (do_signal(child, __TEST_PRIM_TOO_SHORT) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_nosupport_ack;
		}
		break;
	case T_COTS:
		switch (prim) {
		case T_ADDR_REQ:
			break;
		case T_BIND_REQ:
			break;
		case T_CAPABILITY_REQ:
			break;
		case T_CONN_REQ:
			break;
		case T_CONN_RES:
			break;
		case T_DATA_REQ:
			break;
		case T_DISCON_REQ:
			break;
		case T_EXDATA_REQ:
			break;
		case T_INFO_REQ:
			break;
		case T_OPTDATA_REQ:
			break;
		case T_ORDREL_REQ:
			test_data = NULL;
			if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case T_UNBIND_REQ:
			break;
		case T_UNITDATA_REQ:
			test_addr = addrs[(child + 1) % 3];
			test_alen = anums[(child + 1) % 3]*sizeof(addrs[(child + 1) % 3][0]);
			test_data = "Unit test data.";
			if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case -1:
		default:
			last_prim = prim;
			if (do_signal(child, __TEST_PRIM_TOO_SHORT) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_nosupport_ack;
		}
		break;
	case T_COTS_ORD:
		switch (prim) {
		case T_ADDR_REQ:
			break;
		case T_BIND_REQ:
			break;
		case T_CAPABILITY_REQ:
			break;
		case T_CONN_REQ:
			break;
		case T_CONN_RES:
			break;
		case T_DATA_REQ:
			break;
		case T_DISCON_REQ:
			break;
		case T_EXDATA_REQ:
			break;
		case T_INFO_REQ:
			break;
		case T_OPTDATA_REQ:
			break;
		case T_ORDREL_REQ:
			break;
		case T_UNBIND_REQ:
			break;
		case T_UNITDATA_REQ:
			test_addr = addrs[(child + 1) % 3];
			test_alen = anums[(child + 1) % 3]*sizeof(addrs[(child + 1) % 3][0]);
			test_data = "Unit test data.";
			if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_error;
		case -1:
		default:
			last_prim = prim;
			if (do_signal(child, __TEST_PRIM_TOO_SHORT) != __RESULT_SUCCESS)
				goto failure;
			state++;
			goto expect_nosupport_ack;
		}
		break;
	default:
		goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      expect_nosupport_ack:
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TNOTSUPPORT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      expect_error:
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define tgrp_case_11_3_1 test_group_11_3
#define numb_case_11_3_1 "11.3.1"
#define sref_case_11_3_1 "(none)"
#define name_case_11_3_1 "Primitive in error -- unsupported primitive type -- T_ADDR_REQ"
#define desc_case_11_3_1 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_ADDR_REQ primitive."

int
test_case_11_3_1(int child)
{
	return test_case_11_3(child, T_ADDR_REQ);
}

struct test_stream test_11_3_1_conn = { &preamble_0, &test_case_11_3_1, &postamble_0 };
struct test_stream test_11_3_1_resp = { &preamble_0, &test_case_11_3_1, &postamble_0 };
struct test_stream test_11_3_1_list = { &preamble_0, &test_case_11_3_1, &postamble_0 };

#define tgrp_case_11_3_2 test_group_11_3
#define numb_case_11_3_2 "11.3.2"
#define sref_case_11_3_2 "(none)"
#define name_case_11_3_2 "Primitive in error -- unsupported primitive type -- T_BIND_REQ"
#define desc_case_11_3_2 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_BIND_REQ primitive."

int
test_case_11_3_2(int child)
{
	return test_case_11_3(child, T_BIND_REQ);
}

struct test_stream test_11_3_2_conn = { &preamble_0, &test_case_11_3_2, &postamble_0 };
struct test_stream test_11_3_2_resp = { &preamble_0, &test_case_11_3_2, &postamble_0 };
struct test_stream test_11_3_2_list = { &preamble_0, &test_case_11_3_2, &postamble_0 };

#define tgrp_case_11_3_3 test_group_11_3
#define numb_case_11_3_3 "11.3.3"
#define sref_case_11_3_3 "(none)"
#define name_case_11_3_3 "Primitive in error -- unsupported primitive type -- T_CAPABILITY_REQ"
#define desc_case_11_3_3 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_CAPABILITY_REQ primitive."

int
test_case_11_3_3(int child)
{
	return test_case_11_3(child, T_CAPABILITY_REQ);
}

struct test_stream test_11_3_3_conn = { &preamble_0, &test_case_11_3_3, &postamble_0 };
struct test_stream test_11_3_3_resp = { &preamble_0, &test_case_11_3_3, &postamble_0 };
struct test_stream test_11_3_3_list = { &preamble_0, &test_case_11_3_3, &postamble_0 };

#define tgrp_case_11_3_4 test_group_11_3
#define numb_case_11_3_4 "11.3.4"
#define sref_case_11_3_4 "(none)"
#define name_case_11_3_4 "Primitive in error -- unsupported primitive type -- T_CONN_REQ"
#define desc_case_11_3_4 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_CONN_REQ primitive."

int
test_case_11_3_4(int child)
{
	return test_case_11_3(child, T_CONN_REQ);
}

struct test_stream test_11_3_4_conn = { &preamble_0, &test_case_11_3_4, &postamble_0 };
struct test_stream test_11_3_4_resp = { &preamble_0, &test_case_11_3_4, &postamble_0 };
struct test_stream test_11_3_4_list = { &preamble_0, &test_case_11_3_4, &postamble_0 };

#define tgrp_case_11_3_5 test_group_11_3
#define numb_case_11_3_5 "11.3.5"
#define sref_case_11_3_5 "(none)"
#define name_case_11_3_5 "Primitive in error -- unsupported primitive type -- T_CONN_RES"
#define desc_case_11_3_5 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_CONN_RES primitive."

int
test_case_11_3_5(int child)
{
	return test_case_11_3(child, T_CONN_RES);
}

struct test_stream test_11_3_5_conn = { &preamble_0, &test_case_11_3_5, &postamble_0 };
struct test_stream test_11_3_5_resp = { &preamble_0, &test_case_11_3_5, &postamble_0 };
struct test_stream test_11_3_5_list = { &preamble_0, &test_case_11_3_5, &postamble_0 };

#define tgrp_case_11_3_6 test_group_11_3
#define numb_case_11_3_6 "11.3.6"
#define sref_case_11_3_6 "(none)"
#define name_case_11_3_6 "Primitive in error -- unsupported primitive type -- T_DATA_REQ"
#define desc_case_11_3_6 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_DATA_REQ primitive."

int
test_case_11_3_6(int child)
{
	return test_case_11_3(child, T_DATA_REQ);
}

struct test_stream test_11_3_6_conn = { &preamble_0, &test_case_11_3_6, &postamble_0 };
struct test_stream test_11_3_6_resp = { &preamble_0, &test_case_11_3_6, &postamble_0 };
struct test_stream test_11_3_6_list = { &preamble_0, &test_case_11_3_6, &postamble_0 };

#define tgrp_case_11_3_7 test_group_11_3
#define numb_case_11_3_7 "11.3.7"
#define sref_case_11_3_7 "(none)"
#define name_case_11_3_7 "Primitive in error -- unsupported primitive type -- T_DISCON_REQ"
#define desc_case_11_3_7 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_DISCON_REQ primitive."

int
test_case_11_3_7(int child)
{
	return test_case_11_3(child, T_DISCON_REQ);
}

struct test_stream test_11_3_7_conn = { &preamble_0, &test_case_11_3_7, &postamble_0 };
struct test_stream test_11_3_7_resp = { &preamble_0, &test_case_11_3_7, &postamble_0 };
struct test_stream test_11_3_7_list = { &preamble_0, &test_case_11_3_7, &postamble_0 };

#define tgrp_case_11_3_8 test_group_11_3
#define numb_case_11_3_8 "11.3.8"
#define sref_case_11_3_8 "(none)"
#define name_case_11_3_8 "Primitive in error -- unsupported primitive type -- T_EXDATA_REQ"
#define desc_case_11_3_8 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_EXDATA_REQ primitive."

int
test_case_11_3_8(int child)
{
	return test_case_11_3(child, T_EXDATA_REQ);
}

struct test_stream test_11_3_8_conn = { &preamble_0, &test_case_11_3_8, &postamble_0 };
struct test_stream test_11_3_8_resp = { &preamble_0, &test_case_11_3_8, &postamble_0 };
struct test_stream test_11_3_8_list = { &preamble_0, &test_case_11_3_8, &postamble_0 };

#define tgrp_case_11_3_9 test_group_11_3
#define numb_case_11_3_9 "11.3.9"
#define sref_case_11_3_9 "(none)"
#define name_case_11_3_9 "Primitive in error -- unsupported primitive type -- T_INFO_REQ"
#define desc_case_11_3_9 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_INFO_REQ primitive."

int
test_case_11_3_9(int child)
{
	return test_case_11_3(child, T_INFO_REQ);
}

struct test_stream test_11_3_9_conn = { &preamble_0, &test_case_11_3_9, &postamble_0 };
struct test_stream test_11_3_9_resp = { &preamble_0, &test_case_11_3_9, &postamble_0 };
struct test_stream test_11_3_9_list = { &preamble_0, &test_case_11_3_9, &postamble_0 };

#define tgrp_case_11_3_10 test_group_11_3
#define numb_case_11_3_10 "11.3.10"
#define sref_case_11_3_10 "(none)"
#define name_case_11_3_10 "Primitive in error -- unsupported primitive type -- T_OPTDATA_REQ"
#define desc_case_11_3_10 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_OPTDATA_REQ primitive."

int
test_case_11_3_10(int child)
{
	return test_case_11_3(child, T_OPTDATA_REQ);
}

struct test_stream test_11_3_10_conn = { &preamble_0, &test_case_11_3_10, &postamble_0 };
struct test_stream test_11_3_10_resp = { &preamble_0, &test_case_11_3_10, &postamble_0 };
struct test_stream test_11_3_10_list = { &preamble_0, &test_case_11_3_10, &postamble_0 };

#define tgrp_case_11_3_11 test_group_11_3
#define numb_case_11_3_11 "11.3.11"
#define sref_case_11_3_11 "(none)"
#define name_case_11_3_11 "Primitive in error -- unsupported primitive type -- T_ORDREL_REQ"
#define desc_case_11_3_11 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_ORDREL_REQ primitive."

int
test_case_11_3_11(int child)
{
	return test_case_11_3(child, T_ORDREL_REQ);
}

struct test_stream test_11_3_11_conn = { &preamble_0, &test_case_11_3_11, &postamble_0 };
struct test_stream test_11_3_11_resp = { &preamble_0, &test_case_11_3_11, &postamble_0 };
struct test_stream test_11_3_11_list = { &preamble_0, &test_case_11_3_11, &postamble_0 };

#define tgrp_case_11_3_12 test_group_11_3
#define numb_case_11_3_12 "11.3.12"
#define sref_case_11_3_12 "(none)"
#define name_case_11_3_12 "Primitive in error -- unsupported primitive type -- T_UNBIND_REQ"
#define desc_case_11_3_12 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_UNBIND_REQ primitive."

int
test_case_11_3_12(int child)
{
	return test_case_11_3(child, T_UNBIND_REQ);
}

struct test_stream test_11_3_12_conn = { &preamble_0, &test_case_11_3_12, &postamble_0 };
struct test_stream test_11_3_12_resp = { &preamble_0, &test_case_11_3_12, &postamble_0 };
struct test_stream test_11_3_12_list = { &preamble_0, &test_case_11_3_12, &postamble_0 };

#define tgrp_case_11_3_13 test_group_11_3
#define numb_case_11_3_13 "11.3.13"
#define sref_case_11_3_13 "(none)"
#define name_case_11_3_13 "Primitive in error -- unsupported primitive type -- T_UNITDATA_REQ"
#define desc_case_11_3_13 "\
Checks than an unsupported primitive returns an error.  Neither the TPI nor the\n\
XTI specification indicates what action to take when an unsupported primitive\n\
type is received.  For known primitives belonging to the wrong service class that\n\
expect an acknowledgement, and unknown primitives, we issue a T_ERROR_ACK with\n\
the errror TNOTSUPPORT.  For known primitives belonging to the wrong service\n\
class that do not expect an acknowledgement, we issue an M_ERROR with a UNIX\n\
error number of EPROTO.  This test case is for a T_UNITDATA_REQ primitive."

int
test_case_11_3_13(int child)
{
	return test_case_11_3(child, T_UNITDATA_REQ);
}

struct test_stream test_11_3_13_conn = { &preamble_0, &test_case_11_3_13, &postamble_0 };
struct test_stream test_11_3_13_resp = { &preamble_0, &test_case_11_3_13, &postamble_0 };
struct test_stream test_11_3_13_list = { &preamble_0, &test_case_11_3_13, &postamble_0 };

#define tgrp_case_11_3_14 test_group_11_3
#define numb_case_11_3_14 "11.3.14"
#define sref_case_11_3_14 "TPI Version 2 Draft 2 -- Chapter 1 -- Receipt of Unknown Primitives"
#define name_case_11_3_14 "Primitive in error -- unsupported primitive type -- UNKNOWN"
#define desc_case_11_3_14 "\
Checks than an unsupported primitive returns an error.  The TPI specification\n\
indicates that when an unknown primitive is received by the transport provider,\n\
it should issue a T_ERROR_ACK with the error TNOSUPPORT.  This test case\n\
verifies that behavior."

int
test_case_11_3_14(int child)
{
	return test_case_11_3(child, -1);
}

struct test_stream test_11_3_14_conn = { &preamble_0, &test_case_11_3_14, &postamble_0 };
struct test_stream test_11_3_14_resp = { &preamble_0, &test_case_11_3_14, &postamble_0 };
struct test_stream test_11_3_14_list = { &preamble_0, &test_case_11_3_14, &postamble_0 };

#define test_group_12 "Flushing"
#define sref_case_12 "TPI Version 2 Draft 2 -- Chapter 1 -- Rules for Flushing Queues"

#define tgrp_case_12_1 test_group_12
#define numb_case_12_1 "12.1"
#define name_case_12_1 "Flushing queues -- T_UNBIND_REQ primitive"
#define sref_case_12_1 sref_case_12
#define desc_case_12_1 "\
Checks flushing of queues in response to a T_UNBIND_REQ primitive.  The\n\
specification states that the transport provider must send up a M_FLUSH message\n\
to flush both the read and write queues after receiving a successful\n\
T_UNBIND_REQ message and before issuing the T_OK_ACK primitive."

int
preamble_12_1(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type != T_CLTS)
		goto notapplicable;
	state++;
	return preamble_1s(child);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_12_1_conn	preamble_12_1
#define preamble_12_1_resp	preamble_12_1
#define preamble_12_1_list	preamble_12_1

int
test_case_12_1_conn(int child)
{
	int i;

	for (i = 0; i < 10; i++, state++) {
		test_data = "Some unit data test message.";
		test_opts = NULL;
		test_olen = 0;
		test_addr = addrs[2];
		test_alen = anums[2]*sizeof(addrs[2][0]);
		if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_1_resp(int child)
{
	return test_case_12_1_conn(child);
}

int
test_case_12_1_list(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_UNITDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	expect(child, NORMAL_WAIT, __EVENT_NO_MSG);
	switch (last_event) {
	case __EVENT_NO_MSG:
		break;
	default:
		goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define postamble_12_1_conn	postamble_1
#define postamble_12_1_resp	postamble_1
#define postamble_12_1_list	postamble_0

struct test_stream test_12_1_conn = { &preamble_12_1_conn, &test_case_12_1_conn, &postamble_12_1_conn };
struct test_stream test_12_1_resp = { &preamble_12_1_resp, &test_case_12_1_resp, &postamble_12_1_resp };
struct test_stream test_12_1_list = { &preamble_12_1_list, &test_case_12_1_list, &postamble_12_1_list };

int
preamble_12_2(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		goto notapplicable;
	switch (child) {
	case 0:
		return preamble_2_conn(child);
	case 1:
		return preamble_2_resp(child);
	case 2:
		return preamble_2_list(child);
	}
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define tgrp_case_12_2_1 test_group_12
#define numb_case_12_2_1 "12.2.1"
#define name_case_12_2_1 "Flushing queues -- T_DISCON_IND primitive -- TS_DATA_XFER"
#define sref_case_12_2_1 sref_case_12
#define desc_case_12_2_1 "\
Checks flushing of queues in response to a T_DISCON_IND primitive in the\n\
TS_DATA_XFER state.  The specification states that, if the interface is in the\n\
TS_DATA_XFER, TS_WIND_ORDREL or TS_WACK_ORDREL (sic) state, the transport\n\
provider must send up a M_FLUSH message to flush both the read and write queues\n\
before sending up a T_DISCON_IND."

int
test_case_12_2_1_conn(int child)
{
	int i;

	test_data = "Here is some normal test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 10; i++, state++) {
		test_data = "Here is some normal test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_2_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Here is some normal reply data for synchronization.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_2_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_12_2_1_conn	preamble_12_2
#define preamble_12_2_1_resp	preamble_12_2
#define preamble_12_2_1_list	preamble_12_2

#define postamble_12_2_1_conn	postamble_1
#define postamble_12_2_1_resp	postamble_1
#define postamble_12_2_1_list	postamble_1

struct test_stream test_12_2_1_conn = { &preamble_12_2_1_conn, &test_case_12_2_1_conn, &postamble_12_2_1_conn };
struct test_stream test_12_2_1_resp = { &preamble_12_2_1_resp, &test_case_12_2_1_resp, &postamble_12_2_1_resp };
struct test_stream test_12_2_1_list = { &preamble_12_2_1_list, &test_case_12_2_1_list, &postamble_12_2_1_list };

#define tgrp_case_12_2_2 test_group_12
#define numb_case_12_2_2 "12.2.2"
#define name_case_12_2_2 "Flushing queues -- T_DISCON_IND primitive -- TS_WIND_ORDREL"
#define sref_case_12_2_2 sref_case_12
#define desc_case_12_2_2 "\
Checks flushing of queues in response to a T_DISCON_IND primitive in the\n\
TS_WIND_ORDREL state.  The specification states that, if the interface is in the\n\
TS_DATA_XFER, TS_WIND_ORDREL or TS_WACK_ORDREL (sic) state, the transport\n\
provider must send up a M_FLUSH message to flush both the read and write queues\n\
before sending up a T_DISCON_IND."

int
test_case_12_2_2_conn(int child)
{
	int i;

	test_data = "Here is some normal test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 10; i++, state++) {
		test_data = "Here is some normal test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_2_2_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Here is some normal reply data for synchronization.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_2_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_12_2_2_conn	preamble_12_2
#define preamble_12_2_2_resp	preamble_12_2
#define preamble_12_2_2_list	preamble_12_2

#define postamble_12_2_2_conn	postamble_1
#define postamble_12_2_2_resp	postamble_1
#define postamble_12_2_2_list	postamble_1

struct test_stream test_12_2_2_conn = { &preamble_12_2_2_conn, &test_case_12_2_2_conn, &postamble_12_2_2_conn };
struct test_stream test_12_2_2_resp = { &preamble_12_2_2_resp, &test_case_12_2_2_resp, &postamble_12_2_2_resp };
struct test_stream test_12_2_2_list = { &preamble_12_2_2_list, &test_case_12_2_2_list, &postamble_12_2_2_list };

#define tgrp_case_12_2_3 test_group_12
#define numb_case_12_2_3 "12.2.3"
#define name_case_12_2_3 "Flushing queues -- T_DISCON_IND primitive -- TS_WREQ_ORDREL"
#define sref_case_12_2_3 sref_case_12
#define desc_case_12_2_3 "\
Checks flushing of queues in response to a T_DISCON_IND primitive in the\n\
TS_WREQ_ORDREL state.  The specification states that, if the interface is in the\n\
TS_DATA_XFER, TS_WIND_ORDREL or TS_WACK_ORDREL (sic) state, the transport\n\
provider must send up a M_FLUSH message to flush both the read and write queues\n\
before sending up a T_DISCON_IND."

int
test_case_12_2_3_conn(int child)
{
	int i;

	test_data = "Here is some normal test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 10; i++, state++) {
		test_data = "Here is some normal test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
		test_msleep(child, 0);
	}
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_2_3_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Here is some normal reply data for synchronization.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_2_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_12_2_3_conn	preamble_12_2
#define preamble_12_2_3_resp	preamble_12_2
#define preamble_12_2_3_list	preamble_12_2

#define postamble_12_2_3_conn	postamble_1
#define postamble_12_2_3_resp	postamble_1
#define postamble_12_2_3_list	postamble_1

struct test_stream test_12_2_3_conn = { &preamble_12_2_3_conn, &test_case_12_2_3_conn, &postamble_12_2_3_conn };
struct test_stream test_12_2_3_resp = { &preamble_12_2_3_resp, &test_case_12_2_3_resp, &postamble_12_2_3_resp };
struct test_stream test_12_2_3_list = { &preamble_12_2_3_list, &test_case_12_2_3_list, &postamble_12_2_3_list };

#define tgrp_case_12_3_1 test_group_12
#define numb_case_12_3_1 "12.3.1"
#define name_case_12_3_1 "Flushing queues -- T_DISCON_REQ primitive -- TS_DATA_XFER"
#define sref_case_12_3_1 sref_case_12
#define desc_case_12_3_1 "\
Checks flushing of queues in response to a T_DISCON_REQ primitive in the\n\
TS_DATA_XFER state.  The specification states that, if the interface is in the\n\
TS_DATA_XFER, TS_WIND_ORDREL or TS_WACK_ORDREL (sic) state, the transport\n\
provider must send up a M_FLUSH message to flush both the read and write queues\n\
after receiving a successful T_DISCON_REQ message and before issuing the\n\
T_OK_ACK primitive."

int
test_case_12_3_1_conn(int child)
{
	int i;

	test_data = "Here is some normal test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 10; i++, state++) {
		test_data = "Here is some normal test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_3_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Here is some normal reply data for synchronization.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_3_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_12_3_1_conn	preamble_12_2
#define preamble_12_3_1_resp	preamble_12_2
#define preamble_12_3_1_list	preamble_12_2

#define postamble_12_3_1_conn	postamble_1
#define postamble_12_3_1_resp	postamble_1
#define postamble_12_3_1_list	postamble_1

struct test_stream test_12_3_1_conn = { &preamble_12_3_1_conn, &test_case_12_3_1_conn, &postamble_12_3_1_conn };
struct test_stream test_12_3_1_resp = { &preamble_12_3_1_resp, &test_case_12_3_1_resp, &postamble_12_3_1_resp };
struct test_stream test_12_3_1_list = { &preamble_12_3_1_list, &test_case_12_3_1_list, &postamble_12_3_1_list };

#define tgrp_case_12_3_2 test_group_12
#define numb_case_12_3_2 "12.3.2"
#define name_case_12_3_2 "Flushing queues -- T_DISCON_REQ primitive -- TS_WIND_ORDREL"
#define sref_case_12_3_2 sref_case_12
#define desc_case_12_3_2 "\
Checks flushing of queues in response to a T_DISCON_REQ primitive in the\n\
TS_WIND_ORDREL state.  The specification states that, if the interface is in the\n\
TS_DATA_XFER, TS_WIND_ORDREL or TS_WACK_ORDREL (sic) state, the transport\n\
provider must send up a M_FLUSH message to flush both the read and write queues\n\
after receiving a successful T_DISCON_REQ message and before issuing the\n\
T_OK_ACK primitive."

int
test_case_12_3_2_conn(int child)
{
	int i;

	test_data = "Here is some normal test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 10; i++, state++) {
		test_data = "Here is some normal test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	if (expect(child, LONG_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_3_2_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Here is some normal reply data for synchronization.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_3_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_12_3_2_conn	preamble_12_2
#define preamble_12_3_2_resp	preamble_12_2
#define preamble_12_3_2_list	preamble_12_2

#define postamble_12_3_2_conn	postamble_1
#define postamble_12_3_2_resp	postamble_1
#define postamble_12_3_2_list	postamble_1

struct test_stream test_12_3_2_conn = { &preamble_12_3_2_conn, &test_case_12_3_2_conn, &postamble_12_3_2_conn };
struct test_stream test_12_3_2_resp = { &preamble_12_3_2_resp, &test_case_12_3_2_resp, &postamble_12_3_2_resp };
struct test_stream test_12_3_2_list = { &preamble_12_3_2_list, &test_case_12_3_2_list, &postamble_12_3_2_list };

#define tgrp_case_12_3_3 test_group_12
#define numb_case_12_3_3 "12.3.3"
#define name_case_12_3_3 "Flushing queues -- T_DISCON_REQ primitive -- TS_WREQ_ORDREL"
#define sref_case_12_3_3 sref_case_12
#define desc_case_12_3_3 "\
Checks flushing of queues in response to a T_DISCON_REQ primitive in the\n\
TS_WREQ_ORDREL state.  The specification states that, if the interface is in the\n\
TS_DATA_XFER, TS_WIND_ORDREL or TS_WACK_ORDREL (sic) state, the transport\n\
provider must send up a M_FLUSH message to flush both the read and write queues\n\
after receiving a successful T_DISCON_REQ message and before issuing the\n\
T_OK_ACK primitive."

int
test_case_12_3_3_conn(int child)
{
	int i;

	test_data = "Here is some normal test data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	for (i = 0; i < 10; i++, state++) {
		test_data = "Here is some normal test data.";
		MORE_flag = 0;
		if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_3_3_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Here is some normal reply data for synchronization.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, SHORT_WAIT);
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_12_3_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_12_3_3_conn	preamble_12_2
#define preamble_12_3_3_resp	preamble_12_2
#define preamble_12_3_3_list	preamble_12_2

#define postamble_12_3_3_conn	postamble_1
#define postamble_12_3_3_resp	postamble_1
#define postamble_12_3_3_list	postamble_1

struct test_stream test_12_3_3_conn = { &preamble_12_3_3_conn, &test_case_12_3_3_conn, &postamble_12_3_3_conn };
struct test_stream test_12_3_3_resp = { &preamble_12_3_3_resp, &test_case_12_3_3_resp, &postamble_12_3_3_resp };
struct test_stream test_12_3_3_list = { &preamble_12_3_3_list, &test_case_12_3_3_list, &postamble_12_3_3_list };

#define test_group_13 "Fatal and non-fatal errors."
#define sref_case_13 "TPI Version 2 Draft 2 -- Chapter 2"

int
preamble_ts_unbnd_cots(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		goto notapplicable;
	state++;
	return preamble_0(child);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_ts_unbnd_cots_conn	preamble_ts_unbnd_cots
#define preamble_ts_unbnd_cots_resp	preamble_ts_unbnd_cots
#define preamble_ts_unbnd_cots_list	preamble_ts_unbnd_cots

#define postamble_ts_unbnd_cots_conn	postamble_0
#define postamble_ts_unbnd_cots_resp	postamble_0
#define postamble_ts_unbnd_cots_list	postamble_0

int
preamble_ts_unbnd_clts(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type != T_CLTS)
		goto notapplicable;
	state++;
	return preamble_0(child);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_ts_unbnd_clts_conn	preamble_ts_unbnd_clts
#define preamble_ts_unbnd_clts_resp	preamble_ts_unbnd_clts
#define preamble_ts_unbnd_clts_list	preamble_ts_unbnd_clts

#define postamble_ts_unbnd_clts_conn	postamble_0
#define postamble_ts_unbnd_clts_resp	postamble_0
#define postamble_ts_unbnd_clts_list	postamble_0

#define preamble_ts_unbnd_conn	preamble_0
#define preamble_ts_unbnd_resp	preamble_0
#define preamble_ts_unbnd_list	preamble_0

#define postamble_ts_unbnd_conn	postamble_0
#define postamble_ts_unbnd_resp	postamble_0
#define postamble_ts_unbnd_list	postamble_0

int
preamble_ts_idle_cots(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		goto notapplicable;
	state++;
	return preamble_1s(child);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_ts_idle_cots_conn	preamble_ts_idle_cots
#define preamble_ts_idle_cots_resp	preamble_ts_idle_cots
#define preamble_ts_idle_cots_list	preamble_ts_idle_cots

#define postamble_ts_idle_cots_conn	postamble_1
#define postamble_ts_idle_cots_resp	postamble_1
#define postamble_ts_idle_cots_list	postamble_1

int
preamble_ts_idle_clts(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type != T_CLTS)
		goto notapplicable;
	state++;
	return preamble_1s(child);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_ts_idle_clts_conn	preamble_ts_idle_clts
#define preamble_ts_idle_clts_resp	preamble_ts_idle_clts
#define preamble_ts_idle_clts_list	preamble_ts_idle_clts

#define postamble_ts_idle_clts_conn	postamble_1
#define postamble_ts_idle_clts_resp	postamble_1
#define postamble_ts_idle_clts_list	postamble_1

#define preamble_ts_idle_conn	preamble_1s
#define preamble_ts_idle_resp	preamble_1s
#define preamble_ts_idle_list	preamble_1s

#define postamble_ts_idle_conn	postamble_1
#define postamble_ts_idle_resp	postamble_1
#define postamble_ts_idle_list	postamble_1

int
preamble_13_connection(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		goto notapplicable;
	state++;
	switch (child) {
	case 0:
		return preamble_2_conn(child);
	case 1:
		return preamble_2_resp(child);
	case 2:
		return preamble_2_list(child);
	}
	return (__RESULT_SCRIPT_ERROR);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

int
preamble_ts_wcon_creq_conn(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_ts_idle_cots(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	test_data = NULL;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	return (result);
}

 /* we do not actually listen on the address in the hope that the connection request will have to
    time out before we leave the TS_WCON_CREQ state. */
#define preamble_ts_wcon_creq_resp	preamble_0
#define preamble_ts_wcon_creq_list	preamble_0

int
postamble_ts_wcon_creq_conn(int child)
{
	int failed = -1;

	while (1) {
		expect(child, SHORT_WAIT, __EVENT_NO_MSG);
		switch (last_event) {
		case __EVENT_NO_MSG:
		case __EVENT_TIMEOUT:
			break;
		case __TEST_DISCON_IND:
			goto disconnected;
		case __RESULT_FAILURE:
			failed = (failed == -1) ? state : failed;
			break;
		default:
			failed = (failed == -1) ? state : failed;
			state++;
			continue;
		}
		break;
	}
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
      disconnected:
	state++;
	if (postamble_1(child) != __RESULT_SUCCESS)
		failed = (failed == -1) ? state : failed;
	state++;
	if (stop_tt() != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (failed != -1)
		goto failure;
	return (__RESULT_SUCCESS);
      failure:
	state = failed;
	return (__RESULT_FAILURE);
}

#define postamble_ts_wcon_creq_resp	postamble_0
#define postamble_ts_wcon_creq_list	postamble_0

int
preamble_ts_wres_cind_conn(int child)
{
	switch(test_level) {
	case T_INET_TCP:
	default:
		return preamble_13_connection(child);
	case T_INET_SCTP:
		break;
	}
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type == T_CLTS)
		goto notapplicable;
	state++;
	if (preamble_1(child) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, SHORT_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONG_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_ts_wres_cind_resp	preamble_0

int
preamble_ts_wres_cind_list(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_ts_idle_cots(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_CONN_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* this might not work for SCTP which might need an actual connection response before the
	   connectin confirmation is seen by the other side */
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	return (result);
}

#define postamble_ts_wres_cind_conn	postamble_2_conn
#define postamble_ts_wres_cind_resp	postamble_0
#define postamble_ts_wres_cind_list	postamble_2_resp

int
preamble_ts_data_xfer_conn(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_13_connection(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	test_data = "Synchornizing data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	return (result);
}

int
preamble_ts_data_xfer_resp(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_13_connection(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Synchornizing data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	return (result);
}

int
preamble_ts_data_xfer_list(int child)
{
	return preamble_13_connection(child);
}

#define postamble_ts_data_xfer_conn	postamble_2_conn
#define postamble_ts_data_xfer_resp	postamble_2_resp
#define postamble_ts_data_xfer_list	postamble_2_list

int
preamble_ts_wind_ordrel_conn(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_13_connection(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	return (result);
}

int
preamble_ts_wind_ordrel_resp(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_13_connection(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	return (result);
}

int
preamble_ts_wind_ordrel_list(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = preamble_13_connection(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	return (__RESULT_SUCCESS);
      abort:
	return (result);
}

int
postamble_ts_wind_ordrel_conn(int child)
{
	int failed = -1;
	int result = __RESULT_SCRIPT_ERROR;

	if (expect(child, LONGER_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		failed = state;
	state++;
	if ((result = postamble_1(child)) != __RESULT_SUCCESS)
		goto abort;
	if (failed != -1) {
		state = failed;
		goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	if (failed != -1)
		state = failed;
	return (result);
}

int
postamble_ts_wind_ordrel_resp(int child)
{
	int failed = -1;
	int result = __RESULT_SCRIPT_ERROR;

	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS) {
		state++;
		test_data = NULL;
		if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
			failed = state;
	}
	state++;
	if ((result = postamble_1(child)) != __RESULT_SUCCESS)
		goto abort;
	if (failed != -1) {
		state = failed;
		goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      abort:
	if (failed != -1)
		state = failed;
	return (result);
}

int
postamble_ts_wind_ordrel_list(int child)
{
	int result = __RESULT_SCRIPT_ERROR;

	if ((result = postamble_2_list(child)) != __RESULT_SUCCESS)
		goto abort;
	state++;
	return (__RESULT_SUCCESS);
      abort:
	return (result);
}

#define preamble_ts_wreq_ordrel_conn		preamble_ts_wind_ordrel_conn
#define preamble_ts_wreq_ordrel_resp		preamble_ts_wind_ordrel_resp
#define preamble_ts_wreq_ordrel_list		preamble_ts_wind_ordrel_list

#define postamble_ts_wreq_ordrel_conn	postamble_ts_wind_ordrel_conn
#define postamble_ts_wreq_ordrel_resp	postamble_ts_wind_ordrel_resp
#define postamble_ts_wreq_ordrel_list	postamble_ts_wind_ordrel_list

#define tgrp_case_13_1_1 test_group_13
#define numb_case_13_1_1 "13.1.1"
#define name_case_13_1_1 "Fatal and non-fatal errors -- T_ADDR_REQ - EPROTO"
#define sref_case_13_1_1 sref_case_13
#define desc_case_13_1_1 "\
Checks that the EPROTO error is returned in response to a T_ADDR_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_ADDR_REQ primitive."

int
test_case_13_1_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_1_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_1_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_1_1_conn	preamble_0
#define preamble_13_1_1_resp	preamble_0
#define preamble_13_1_1_list	preamble_0

#define postamble_13_1_1_conn	postamble_0
#define postamble_13_1_1_resp	postamble_0
#define postamble_13_1_1_list	postamble_0

struct test_stream test_13_1_1_conn = { &preamble_13_1_1_conn, &test_case_13_1_1_conn, &postamble_13_1_1_conn };
struct test_stream test_13_1_1_resp = { &preamble_13_1_1_resp, &test_case_13_1_1_resp, &postamble_13_1_1_resp };
struct test_stream test_13_1_1_list = { &preamble_13_1_1_list, &test_case_13_1_1_list, &postamble_13_1_1_list };

#define tgrp_case_13_1_2 test_group_13
#define numb_case_13_1_2 "13.1.2"
#define name_case_13_1_2 "Fatal and non-fatal errors -- T_ADDR_REQ - TSYSERR"
#define sref_case_13_1_2 sref_case_13
#define desc_case_13_1_2 "\
Checks that the TSYSERR error is returned in response to a T_ADDR_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_ADDR_REQ primitive."

int
test_case_13_1_2_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_1_2_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_1_2_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_1_2_conn	preamble_0
#define preamble_13_1_2_resp	preamble_0
#define preamble_13_1_2_list	preamble_0

#define postamble_13_1_2_conn	postamble_0
#define postamble_13_1_2_resp	postamble_0
#define postamble_13_1_2_list	postamble_0

struct test_stream test_13_1_2_conn = { &preamble_13_1_2_conn, &test_case_13_1_2_conn, &postamble_13_1_2_conn };
struct test_stream test_13_1_2_resp = { &preamble_13_1_2_resp, &test_case_13_1_2_resp, &postamble_13_1_2_resp };
struct test_stream test_13_1_2_list = { &preamble_13_1_2_list, &test_case_13_1_2_list, &postamble_13_1_2_list };

#define tgrp_case_13_2_1 test_group_13
#define numb_case_13_2_1 "13.2.1"
#define name_case_13_2_1 "Fatal and non-fatal errors -- T_BIND_REQ - EPROTO"
#define sref_case_13_2_1 sref_case_13
#define desc_case_13_2_1 "\
Checks that the EPROTO error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_BIND_REQ primitive.  T_BIND_REQ does not have any fatal errors so this\n\
test is not applicable."

int
test_case_13_2_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_2_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_2_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_2_1_conn	preamble_0
#define preamble_13_2_1_resp	preamble_0
#define preamble_13_2_1_list	preamble_0

#define postamble_13_2_1_conn	postamble_0
#define postamble_13_2_1_resp	postamble_0
#define postamble_13_2_1_list	postamble_0

struct test_stream test_13_2_1_conn = { &preamble_13_2_1_conn, &test_case_13_2_1_conn, &postamble_13_2_1_conn };
struct test_stream test_13_2_1_resp = { &preamble_13_2_1_resp, &test_case_13_2_1_resp, &postamble_13_2_1_resp };
struct test_stream test_13_2_1_list = { &preamble_13_2_1_list, &test_case_13_2_1_list, &postamble_13_2_1_list };

#define tgrp_case_13_2_2 test_group_13
#define numb_case_13_2_2 "13.2.2"
#define name_case_13_2_2 "Fatal and non-fatal errors -- T_BIND_REQ - TACCES"
#define sref_case_13_2_2 sref_case_13
#define desc_case_13_2_2 "\
Checks that the TACCES error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TACCES error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_2(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	/* broadcast addresses require privilege - this might not work for TCP or SCTP */
	test_addr = addrs[child];
	test_alen = sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	addrs[child][0].sin_addr.s_addr = htonl(0x7fffffff);	/* 127.255.255.255 is a broadcast address */
	addrs[child][0].sin_port = htons(3);			/* reserved port */
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TACCES)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

#define test_case_13_2_2_conn	test_case_13_2_2
#define test_case_13_2_2_resp	test_case_13_2_2
#define test_case_13_2_2_list	test_case_13_2_2

#define preamble_13_2_2_conn	preamble_0
#define preamble_13_2_2_resp	preamble_0
#define preamble_13_2_2_list	preamble_0

#define postamble_13_2_2_conn	postamble_0
#define postamble_13_2_2_resp	postamble_0
#define postamble_13_2_2_list	postamble_0

struct test_stream test_13_2_2_conn = { &preamble_13_2_2_conn, &test_case_13_2_2_conn, &postamble_13_2_2_conn };
struct test_stream test_13_2_2_resp = { &preamble_13_2_2_resp, &test_case_13_2_2_resp, &postamble_13_2_2_resp };
struct test_stream test_13_2_2_list = { &preamble_13_2_2_list, &test_case_13_2_2_list, &postamble_13_2_2_list };

#define tgrp_case_13_2_3 test_group_13
#define numb_case_13_2_3 "13.2.3"
#define name_case_13_2_3 "Fatal and non-fatal errors -- T_BIND_REQ - TADDRBUSY"
#define sref_case_13_2_3 sref_case_13
#define desc_case_13_2_3 "\
Checks that the TADDRBUSY error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TADDRBUSY error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_3(int child)
{
	/* can never occur for rawip */
	if (test_level == T_INET_IP)
		goto notapplicable;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	last_qlen = 5;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TADDRBUSY)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define test_case_13_2_3_conn	test_case_13_2_3
#define test_case_13_2_3_resp	test_case_13_2_3

int
test_case_13_2_3_list(int child)
{
	/* can never occur for rawip */
	if (test_level == T_INET_IP)
		goto notapplicable;
	state++;
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	switch (test_level) {
	case T_INET_TCP:
	case T_INET_SCTP:
		if (last_qlen != ((child == 2) ? 5 : 0))
			goto failure;
		state++;
		break;
	}
	test_msleep(child, LONGER_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define preamble_13_2_3_conn	preamble_0
#define preamble_13_2_3_resp	preamble_0
#define preamble_13_2_3_list	preamble_0

#define postamble_13_2_3_conn	postamble_0
#define postamble_13_2_3_resp	postamble_0
#define postamble_13_2_3_list	postamble_0

struct test_stream test_13_2_3_conn = { &preamble_13_2_3_conn, &test_case_13_2_3_conn, &postamble_13_2_3_conn };
struct test_stream test_13_2_3_resp = { &preamble_13_2_3_resp, &test_case_13_2_3_resp, &postamble_13_2_3_resp };
struct test_stream test_13_2_3_list = { &preamble_13_2_3_list, &test_case_13_2_3_list, &postamble_13_2_3_list };

#define tgrp_case_13_2_4 test_group_13
#define numb_case_13_2_4 "13.2.4"
#define name_case_13_2_4 "Fatal and non-fatal errors -- T_BIND_REQ - TBADADDR"
#define sref_case_13_2_4 sref_case_13
#define desc_case_13_2_4 "\
Checks that the TBADADDR error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADADDR error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_4(int child)
{
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]) - 1;
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADADDR)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_13_2_4_conn	test_case_13_2_4
#define test_case_13_2_4_resp	test_case_13_2_4
#define test_case_13_2_4_list	test_case_13_2_4

#define preamble_13_2_4_conn	preamble_0
#define preamble_13_2_4_resp	preamble_0
#define preamble_13_2_4_list	preamble_0

#define postamble_13_2_4_conn	postamble_0
#define postamble_13_2_4_resp	postamble_0
#define postamble_13_2_4_list	postamble_0

struct test_stream test_13_2_4_conn = { &preamble_13_2_4_conn, &test_case_13_2_4_conn, &postamble_13_2_4_conn };
struct test_stream test_13_2_4_resp = { &preamble_13_2_4_resp, &test_case_13_2_4_resp, &postamble_13_2_4_resp };
struct test_stream test_13_2_4_list = { &preamble_13_2_4_list, &test_case_13_2_4_list, &postamble_13_2_4_list };

#define tgrp_case_13_2_5 test_group_13
#define numb_case_13_2_5 "13.2.5"
#define name_case_13_2_5 "Fatal and non-fatal errors -- T_BIND_REQ - TNOADDR"
#define sref_case_13_2_5 sref_case_13
#define desc_case_13_2_5 "\
Checks that the TNOADDR error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TNOADDR error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_5(int child)
{
	switch (test_level) {
	case T_INET_IP:
		/* if we are not super user, we cannot test rawip */
		if (getuid() != 0 && geteuid() != 0)
			goto skipped;
		break;
	case T_INET_UDP:
	case T_INET_TCP:
	case T_INET_SCTP:
		break;
	default:
		goto scripterror;
	}
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	addrs[child][0].sin_addr.s_addr = 0x3f00003f;	/* pick some non-local address */
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TNOADDR)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
      scripterror:
	return (__RESULT_SCRIPT_ERROR);
}

#define test_case_13_2_5_conn	test_case_13_2_5
#define test_case_13_2_5_resp	test_case_13_2_5
#define test_case_13_2_5_list	test_case_13_2_5

#define preamble_13_2_5_conn	preamble_0
#define preamble_13_2_5_resp	preamble_0
#define preamble_13_2_5_list	preamble_0

#define postamble_13_2_5_conn	postamble_0
#define postamble_13_2_5_resp	postamble_0
#define postamble_13_2_5_list	postamble_0

struct test_stream test_13_2_5_conn = { &preamble_13_2_5_conn, &test_case_13_2_5_conn, &postamble_13_2_5_conn };
struct test_stream test_13_2_5_resp = { &preamble_13_2_5_resp, &test_case_13_2_5_resp, &postamble_13_2_5_resp };
struct test_stream test_13_2_5_list = { &preamble_13_2_5_list, &test_case_13_2_5_list, &postamble_13_2_5_list };

#define tgrp_case_13_2_6_1 test_group_13
#define numb_case_13_2_6_1 "13.2.6.1"
#define name_case_13_2_6_1 "Fatal and non-fatal errors -- T_BIND_REQ - TOUTSTATE - TS_IDLE"
#define sref_case_13_2_6_1 sref_case_13
#define desc_case_13_2_6_1 "\
Checks that the TOUTSTATE error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_6(int child)
{
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_2_6_1(int child)
{
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return test_case_13_2_6(child);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_13_2_6_1_conn	test_case_13_2_6_1
#define test_case_13_2_6_1_resp	test_case_13_2_6_1
#define test_case_13_2_6_1_list	test_case_13_2_6_1

#define preamble_13_2_6_1_conn	preamble_ts_idle_conn
#define preamble_13_2_6_1_resp	preamble_ts_idle_resp
#define preamble_13_2_6_1_list	preamble_ts_idle_list

#define postamble_13_2_6_1_conn	postamble_ts_idle_conn
#define postamble_13_2_6_1_resp	postamble_ts_idle_resp
#define postamble_13_2_6_1_list	postamble_ts_idle_list

struct test_stream test_13_2_6_1_conn = { &preamble_13_2_6_1_conn, &test_case_13_2_6_1_conn, &postamble_13_2_6_1_conn };
struct test_stream test_13_2_6_1_resp = { &preamble_13_2_6_1_resp, &test_case_13_2_6_1_resp, &postamble_13_2_6_1_resp };
struct test_stream test_13_2_6_1_list = { &preamble_13_2_6_1_list, &test_case_13_2_6_1_list, &postamble_13_2_6_1_list };

#define tgrp_case_13_2_6_2 test_group_13
#define numb_case_13_2_6_2 "13.2.6.2"
#define name_case_13_2_6_2 "Fatal and non-fatal errors -- T_BIND_REQ - TOUTSTATE - TS_WCON_CREQ"
#define sref_case_13_2_6_2 sref_case_13
#define desc_case_13_2_6_2 "\
Checks that the TOUTSTATE error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_6_2_conn(int child)
{
	return test_case_13_2_6(child);
}

int
test_case_13_2_6_2_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_2_6_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_2_6_2_conn	preamble_ts_wcon_creq_conn
#define preamble_13_2_6_2_resp	preamble_ts_wcon_creq_resp
#define preamble_13_2_6_2_list	preamble_ts_wcon_creq_list

#define postamble_13_2_6_2_conn	postamble_ts_wcon_creq_conn
#define postamble_13_2_6_2_resp	postamble_ts_wcon_creq_resp
#define postamble_13_2_6_2_list	postamble_ts_wcon_creq_list

struct test_stream test_13_2_6_2_conn = { &preamble_13_2_6_2_conn, &test_case_13_2_6_2_conn, &postamble_13_2_6_2_conn };
struct test_stream test_13_2_6_2_resp = { &preamble_13_2_6_2_resp, &test_case_13_2_6_2_resp, &postamble_13_2_6_2_resp };
struct test_stream test_13_2_6_2_list = { &preamble_13_2_6_2_list, &test_case_13_2_6_2_list, &postamble_13_2_6_2_list };

#define tgrp_case_13_2_6_3 test_group_13
#define numb_case_13_2_6_3 "13.2.6.3"
#define name_case_13_2_6_3 "Fatal and non-fatal errors -- T_BIND_REQ - TOUTSTATE - TS_WRES_CIND"
#define sref_case_13_2_6_3 sref_case_13
#define desc_case_13_2_6_3 "\
Checks that the TOUTSTATE error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_6_3_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_2_6_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_2_6_3_list(int child)
{
	return test_case_13_2_6(child);
}

#define preamble_13_2_6_3_conn	preamble_ts_wres_cind_conn
#define preamble_13_2_6_3_resp	preamble_ts_wres_cind_resp
#define preamble_13_2_6_3_list	preamble_ts_wres_cind_list

#define postamble_13_2_6_3_conn	postamble_ts_wres_cind_conn
#define postamble_13_2_6_3_resp	postamble_ts_wres_cind_resp
#define postamble_13_2_6_3_list	postamble_ts_wres_cind_list

struct test_stream test_13_2_6_3_conn = { &preamble_13_2_6_3_conn, &test_case_13_2_6_3_conn, &postamble_13_2_6_3_conn };
struct test_stream test_13_2_6_3_resp = { &preamble_13_2_6_3_resp, &test_case_13_2_6_3_resp, &postamble_13_2_6_3_resp };
struct test_stream test_13_2_6_3_list = { &preamble_13_2_6_3_list, &test_case_13_2_6_3_list, &postamble_13_2_6_3_list };

#define tgrp_case_13_2_6_4 test_group_13
#define numb_case_13_2_6_4 "13.2.6.4"
#define name_case_13_2_6_4 "Fatal and non-fatal errors -- T_BIND_REQ - TOUTSTATE - TS_DATA_XFER"
#define sref_case_13_2_6_4 sref_case_13
#define desc_case_13_2_6_4 "\
Checks that the TOUTSTATE error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_6_4_conn(int child)
{
	return test_case_13_2_6(child);
}

int
test_case_13_2_6_4_resp(int child)
{
	return test_case_13_2_6(child);
}

int
test_case_13_2_6_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_2_6_4_conn	preamble_ts_data_xfer_conn
#define preamble_13_2_6_4_resp	preamble_ts_data_xfer_resp
#define preamble_13_2_6_4_list	preamble_ts_data_xfer_list

#define postamble_13_2_6_4_conn	postamble_ts_data_xfer_conn
#define postamble_13_2_6_4_resp	postamble_ts_data_xfer_resp
#define postamble_13_2_6_4_list	postamble_ts_data_xfer_list

struct test_stream test_13_2_6_4_conn = { &preamble_13_2_6_4_conn, &test_case_13_2_6_4_conn, &postamble_13_2_6_4_conn };
struct test_stream test_13_2_6_4_resp = { &preamble_13_2_6_4_resp, &test_case_13_2_6_4_resp, &postamble_13_2_6_4_resp };
struct test_stream test_13_2_6_4_list = { &preamble_13_2_6_4_list, &test_case_13_2_6_4_list, &postamble_13_2_6_4_list };

#define tgrp_case_13_2_6_5 test_group_13
#define numb_case_13_2_6_5 "13.2.6.5"
#define name_case_13_2_6_5 "Fatal and non-fatal errors -- T_BIND_REQ - TOUTSTATE - TS_WIND_ORDREL"
#define sref_case_13_2_6_5 sref_case_13
#define desc_case_13_2_6_5 "\
Checks that the TOUTSTATE error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_6_5_conn(int child)
{
	return test_case_13_2_6(child);
}

int
test_case_13_2_6_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_2_6_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_2_6_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_2_6_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_2_6_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_2_6_5_conn	postamble_ts_wind_ordrel_conn
#define postamble_13_2_6_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_2_6_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_2_6_5_conn = { &preamble_13_2_6_5_conn, &test_case_13_2_6_5_conn, &postamble_13_2_6_5_conn };
struct test_stream test_13_2_6_5_resp = { &preamble_13_2_6_5_resp, &test_case_13_2_6_5_resp, &postamble_13_2_6_5_resp };
struct test_stream test_13_2_6_5_list = { &preamble_13_2_6_5_list, &test_case_13_2_6_5_list, &postamble_13_2_6_5_list };

#define tgrp_case_13_2_6_6 test_group_13
#define numb_case_13_2_6_6 "13.2.6.6"
#define name_case_13_2_6_6 "Fatal and non-fatal errors -- T_BIND_REQ - TOUTSTATE - TS_WREQ_ORDREL"
#define sref_case_13_2_6_6 sref_case_13
#define desc_case_13_2_6_6 "\
Checks that the TOUTSTATE error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_6_6_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_2_6_6_resp(int child)
{
	return test_case_13_2_6(child);
}

int
test_case_13_2_6_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_2_6_6_conn	preamble_ts_wreq_ordrel_conn
#define preamble_13_2_6_6_resp	preamble_ts_wreq_ordrel_resp
#define preamble_13_2_6_6_list	preamble_ts_wreq_ordrel_list

#define postamble_13_2_6_6_conn	postamble_ts_wreq_ordrel_conn
#define postamble_13_2_6_6_resp	postamble_ts_wreq_ordrel_resp
#define postamble_13_2_6_6_list	postamble_ts_wreq_ordrel_list

struct test_stream test_13_2_6_6_conn = { &preamble_13_2_6_6_conn, &test_case_13_2_6_6_conn, &postamble_13_2_6_6_conn };
struct test_stream test_13_2_6_6_resp = { &preamble_13_2_6_6_resp, &test_case_13_2_6_6_resp, &postamble_13_2_6_6_resp };
struct test_stream test_13_2_6_6_list = { &preamble_13_2_6_6_list, &test_case_13_2_6_6_list, &postamble_13_2_6_6_list };

#define tgrp_case_13_2_7 test_group_13
#define numb_case_13_2_7 "13.2.7"
#define name_case_13_2_7 "Fatal and non-fatal errors -- T_BIND_REQ - TSYSERR"
#define sref_case_13_2_7 sref_case_13
#define desc_case_13_2_7 "\
Checks that the TSYSERR error is returned in response to a T_BIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_BIND_REQ primitive."

int
test_case_13_2_7_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_2_7_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_2_7_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_2_7_conn	preamble_0
#define preamble_13_2_7_resp	preamble_0
#define preamble_13_2_7_list	preamble_0

#define postamble_13_2_7_conn	postamble_0
#define postamble_13_2_7_resp	postamble_0
#define postamble_13_2_7_list	postamble_0

struct test_stream test_13_2_7_conn = { &preamble_13_2_7_conn, &test_case_13_2_7_conn, &postamble_13_2_7_conn };
struct test_stream test_13_2_7_resp = { &preamble_13_2_7_resp, &test_case_13_2_7_resp, &postamble_13_2_7_resp };
struct test_stream test_13_2_7_list = { &preamble_13_2_7_list, &test_case_13_2_7_list, &postamble_13_2_7_list };

#define tgrp_case_13_3_1 test_group_13
#define numb_case_13_3_1 "13.3.1"
#define name_case_13_3_1 "Fatal and non-fatal errors -- T_CAPABILITY_REQ - EPROTO"
#define sref_case_13_3_1 sref_case_13
#define desc_case_13_3_1 "\
Checks that the EPROTO error is returned in response to a T_CAPABILITY_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_CAPABILITY_REQ primitive."

int
test_case_13_3_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_3_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_3_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_3_1_conn	preamble_1
#define preamble_13_3_1_resp	preamble_1
#define preamble_13_3_1_list	preamble_1

#define postamble_13_3_1_conn	postamble_1
#define postamble_13_3_1_resp	postamble_1
#define postamble_13_3_1_list	postamble_1

struct test_stream test_13_3_1_conn = { &preamble_13_3_1_conn, &test_case_13_3_1_conn, &postamble_13_3_1_conn };
struct test_stream test_13_3_1_resp = { &preamble_13_3_1_resp, &test_case_13_3_1_resp, &postamble_13_3_1_resp };
struct test_stream test_13_3_1_list = { &preamble_13_3_1_list, &test_case_13_3_1_list, &postamble_13_3_1_list };

#define tgrp_case_13_3_2 test_group_13
#define numb_case_13_3_2 "13.3.2"
#define name_case_13_3_2 "Fatal and non-fatal errors -- T_CAPABILITY_REQ - TSYSERR"
#define sref_case_13_3_2 sref_case_13
#define desc_case_13_3_2 "\
Checks that the TSYSERR error is returned in response to a T_CAPABILITY_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_CAPABILITY_REQ primitive."

int
test_case_13_3_2_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_3_2_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_3_2_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_3_2_conn	preamble_1
#define preamble_13_3_2_resp	preamble_1
#define preamble_13_3_2_list	preamble_1

#define postamble_13_3_2_conn	postamble_1
#define postamble_13_3_2_resp	postamble_1
#define postamble_13_3_2_list	postamble_1

struct test_stream test_13_3_2_conn = { &preamble_13_3_2_conn, &test_case_13_3_2_conn, &postamble_13_3_2_conn };
struct test_stream test_13_3_2_resp = { &preamble_13_3_2_resp, &test_case_13_3_2_resp, &postamble_13_3_2_resp };
struct test_stream test_13_3_2_list = { &preamble_13_3_2_list, &test_case_13_3_2_list, &postamble_13_3_2_list };

#define tgrp_case_13_4_1 test_group_13
#define numb_case_13_4_1 "13.4.1"
#define name_case_13_4_1 "Fatal and non-fatal errors -- T_CONN_REQ - EPROTO"
#define sref_case_13_4_1 sref_case_13
#define desc_case_13_4_1 "\
Checks that the EPROTO error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_4_1_conn	preamble_1
#define preamble_13_4_1_resp	preamble_1
#define preamble_13_4_1_list	preamble_1

#define postamble_13_4_1_conn	postamble_1
#define postamble_13_4_1_resp	postamble_1
#define postamble_13_4_1_list	postamble_1

struct test_stream test_13_4_1_conn = { &preamble_13_4_1_conn, &test_case_13_4_1_conn, &postamble_13_4_1_conn };
struct test_stream test_13_4_1_resp = { &preamble_13_4_1_resp, &test_case_13_4_1_resp, &postamble_13_4_1_resp };
struct test_stream test_13_4_1_list = { &preamble_13_4_1_list, &test_case_13_4_1_list, &postamble_13_4_1_list };

#define tgrp_case_13_4_2 test_group_13
#define numb_case_13_4_2 "13.4.2"
#define name_case_13_4_2 "Fatal and non-fatal errors -- T_CONN_REQ - TACCES"
#define sref_case_13_4_2 sref_case_13
#define desc_case_13_4_2 "\
Checks that the TACCES error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TACCES error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_2_conn(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

int
test_case_13_4_2_resp(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

int
test_case_13_4_2_list(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

#define preamble_13_4_2_conn	preamble_1
#define preamble_13_4_2_resp	preamble_1
#define preamble_13_4_2_list	preamble_1

#define postamble_13_4_2_conn	postamble_1
#define postamble_13_4_2_resp	postamble_1
#define postamble_13_4_2_list	postamble_1

struct test_stream test_13_4_2_conn = { &preamble_13_4_2_conn, &test_case_13_4_2_conn, &postamble_13_4_2_conn };
struct test_stream test_13_4_2_resp = { &preamble_13_4_2_resp, &test_case_13_4_2_resp, &postamble_13_4_2_resp };
struct test_stream test_13_4_2_list = { &preamble_13_4_2_list, &test_case_13_4_2_list, &postamble_13_4_2_list };

#define tgrp_case_13_4_3 test_group_13
#define numb_case_13_4_3 "13.4.3"
#define name_case_13_4_3 "Fatal and non-fatal errors -- T_CONN_REQ - TADDRBUSY"
#define sref_case_13_4_3 sref_case_13
#define desc_case_13_4_3 "\
Checks that the TADDRBUSY error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TADDRBUSY error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_3_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_3_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_3_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_4_3_conn	preamble_1
#define preamble_13_4_3_resp	preamble_1
#define preamble_13_4_3_list	preamble_1

#define postamble_13_4_3_conn	postamble_1
#define postamble_13_4_3_resp	postamble_1
#define postamble_13_4_3_list	postamble_1

struct test_stream test_13_4_3_conn = { &preamble_13_4_3_conn, &test_case_13_4_3_conn, &postamble_13_4_3_conn };
struct test_stream test_13_4_3_resp = { &preamble_13_4_3_resp, &test_case_13_4_3_resp, &postamble_13_4_3_resp };
struct test_stream test_13_4_3_list = { &preamble_13_4_3_list, &test_case_13_4_3_list, &postamble_13_4_3_list };

#define tgrp_case_13_4_4 test_group_13
#define numb_case_13_4_4 "13.4.4"
#define name_case_13_4_4 "Fatal and non-fatal errors -- T_CONN_REQ - TBADADDR"
#define sref_case_13_4_4 sref_case_13
#define desc_case_13_4_4 "\
Checks that the TBADADDR error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADADDR error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_4_conn(int child)
{
	test_data = NULL;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]) - 1;
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADADDR)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_4_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_4_conn	preamble_ts_idle_cots_conn
#define preamble_13_4_4_resp	preamble_ts_idle_cots_resp
#define preamble_13_4_4_list	preamble_ts_idle_cots_list

#define postamble_13_4_4_conn	postamble_ts_idle_cots_conn
#define postamble_13_4_4_resp	postamble_ts_idle_cots_resp
#define postamble_13_4_4_list	postamble_ts_idle_cots_list

struct test_stream test_13_4_4_conn = { &preamble_13_4_4_conn, &test_case_13_4_4_conn, &postamble_13_4_4_conn };
struct test_stream test_13_4_4_resp = { &preamble_13_4_4_resp, &test_case_13_4_4_resp, &postamble_13_4_4_resp };
struct test_stream test_13_4_4_list = { &preamble_13_4_4_list, &test_case_13_4_4_list, &postamble_13_4_4_list };

#define tgrp_case_13_4_5 test_group_13
#define numb_case_13_4_5 "13.4.5"
#define name_case_13_4_5 "Fatal and non-fatal errors -- T_CONN_REQ - TBADDATA"
#define sref_case_13_4_5 sref_case_13
#define desc_case_13_4_5 "\
Checks that the TBADDATA error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADDATA error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_5_conn(int child)
{
	test_data = "";
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADDATA)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_4_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_5_conn	preamble_ts_idle_cots_conn
#define preamble_13_4_5_resp	preamble_ts_idle_cots_resp
#define preamble_13_4_5_list	preamble_ts_idle_cots_list

#define postamble_13_4_5_conn	postamble_ts_idle_cots_conn
#define postamble_13_4_5_resp	postamble_ts_idle_cots_resp
#define postamble_13_4_5_list	postamble_ts_idle_cots_list

struct test_stream test_13_4_5_conn = { &preamble_13_4_5_conn, &test_case_13_4_5_conn, &postamble_13_4_5_conn };
struct test_stream test_13_4_5_resp = { &preamble_13_4_5_resp, &test_case_13_4_5_resp, &postamble_13_4_5_resp };
struct test_stream test_13_4_5_list = { &preamble_13_4_5_list, &test_case_13_4_5_list, &postamble_13_4_5_list };

#define tgrp_case_13_4_6 test_group_13
#define numb_case_13_4_6 "13.4.6"
#define name_case_13_4_6 "Fatal and non-fatal errors -- T_CONN_REQ - TBADOPT"
#define sref_case_13_4_6 sref_case_13
#define desc_case_13_4_6 "\
Checks that the TBADOPT error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADOPT error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_6_conn(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t) + 1, T_INET_IP, T_IP_TOS, T_SUCCESS}
	, 0x0};
	test_data = NULL;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_opts = &options;
	test_olen = sizeof(options);
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADOPT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_4_6_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_6_conn	preamble_ts_idle_cots_conn
#define preamble_13_4_6_resp	preamble_ts_idle_cots_resp
#define preamble_13_4_6_list	preamble_ts_idle_cots_list

#define postamble_13_4_6_conn	postamble_ts_idle_cots_conn
#define postamble_13_4_6_resp	postamble_ts_idle_cots_resp
#define postamble_13_4_6_list	postamble_ts_idle_cots_list

struct test_stream test_13_4_6_conn = { &preamble_13_4_6_conn, &test_case_13_4_6_conn, &postamble_13_4_6_conn };
struct test_stream test_13_4_6_resp = { &preamble_13_4_6_resp, &test_case_13_4_6_resp, &postamble_13_4_6_resp };
struct test_stream test_13_4_6_list = { &preamble_13_4_6_list, &test_case_13_4_6_list, &postamble_13_4_6_list };

#define tgrp_case_13_4_7 test_group_13
#define numb_case_13_4_7 "13.4.7"
#define name_case_13_4_7 "Fatal and non-fatal errors -- T_CONN_REQ - TNOTSUPPORT"
#define sref_case_13_4_7 sref_case_13
#define desc_case_13_4_7 "\
Checks that the TNOTSUPPORT error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TNOTSUPPORT error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_7_conn(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type != T_CLTS)
		goto notapplicable;
	state++;
	test_data = NULL;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TNOTSUPPORT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_7_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_7_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_7_conn	preamble_1
#define preamble_13_4_7_resp	preamble_1
#define preamble_13_4_7_list	preamble_1

#define postamble_13_4_7_conn	postamble_1
#define postamble_13_4_7_resp	postamble_1
#define postamble_13_4_7_list	postamble_1

struct test_stream test_13_4_7_conn = { &preamble_13_4_7_conn, &test_case_13_4_7_conn, &postamble_13_4_7_conn };
struct test_stream test_13_4_7_resp = { &preamble_13_4_7_resp, &test_case_13_4_7_resp, &postamble_13_4_7_resp };
struct test_stream test_13_4_7_list = { &preamble_13_4_7_list, &test_case_13_4_7_list, &postamble_13_4_7_list };

#define tgrp_case_13_4_8_1 test_group_13
#define numb_case_13_4_8_1 "13.4.8.1"
#define name_case_13_4_8_1 "Fatal and non-fatal errors -- T_CONN_REQ - TOUTSTATE - TS_UNBND"
#define sref_case_13_4_8_1 sref_case_13
#define desc_case_13_4_8_1 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_8(int child)
{
	test_data = NULL;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_4_8_1_conn(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_1_resp(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_1_list(int child)
{
	return test_case_13_4_8(child);
}

#define preamble_13_4_8_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_4_8_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_4_8_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_4_8_1_conn	postamble_ts_unbnd_cots_conn
#define postamble_13_4_8_1_resp	postamble_ts_unbnd_cots_resp
#define postamble_13_4_8_1_list	postamble_ts_unbnd_cots_list

struct test_stream test_13_4_8_1_conn = { &preamble_13_4_8_1_conn, &test_case_13_4_8_1_conn, &postamble_13_4_8_1_conn };
struct test_stream test_13_4_8_1_resp = { &preamble_13_4_8_1_resp, &test_case_13_4_8_1_resp, &postamble_13_4_8_1_resp };
struct test_stream test_13_4_8_1_list = { &preamble_13_4_8_1_list, &test_case_13_4_8_1_list, &postamble_13_4_8_1_list };

#define tgrp_case_13_4_8_2 test_group_13
#define numb_case_13_4_8_2 "13.4.8.2"
#define name_case_13_4_8_2 "Fatal and non-fatal errors -- T_CONN_REQ - TOUTSTATE - TS_WCON_CREQ"
#define sref_case_13_4_8_2 sref_case_13
#define desc_case_13_4_8_2 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_8_2_conn(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_2_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_8_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_8_2_conn	preamble_ts_wcon_creq_conn
#define preamble_13_4_8_2_resp	preamble_ts_wcon_creq_resp
#define preamble_13_4_8_2_list	preamble_ts_wcon_creq_list

#define postamble_13_4_8_2_conn	postamble_ts_wcon_creq_conn
#define postamble_13_4_8_2_resp	postamble_ts_wcon_creq_resp
#define postamble_13_4_8_2_list	postamble_ts_wcon_creq_list

struct test_stream test_13_4_8_2_conn = { &preamble_13_4_8_2_conn, &test_case_13_4_8_2_conn, &postamble_13_4_8_2_conn };
struct test_stream test_13_4_8_2_resp = { &preamble_13_4_8_2_resp, &test_case_13_4_8_2_resp, &postamble_13_4_8_2_resp };
struct test_stream test_13_4_8_2_list = { &preamble_13_4_8_2_list, &test_case_13_4_8_2_list, &postamble_13_4_8_2_list };

#define tgrp_case_13_4_8_3 test_group_13
#define numb_case_13_4_8_3 "13.4.8.3"
#define name_case_13_4_8_3 "Fatal and non-fatal errors -- T_CONN_REQ - TOUTSTATE - TS_WRES_CIND"
#define sref_case_13_4_8_3 sref_case_13
#define desc_case_13_4_8_3 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_8_3_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_8_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_8_3_list(int child)
{
	return test_case_13_4_8(child);
}

#define preamble_13_4_8_3_conn	preamble_ts_wres_cind_conn
#define preamble_13_4_8_3_resp	preamble_ts_wres_cind_resp
#define preamble_13_4_8_3_list	preamble_ts_wres_cind_list

#define postamble_13_4_8_3_conn	postamble_ts_wres_cind_conn
#define postamble_13_4_8_3_resp	postamble_ts_wres_cind_resp
#define postamble_13_4_8_3_list	postamble_ts_wres_cind_list

struct test_stream test_13_4_8_3_conn = { &preamble_13_4_8_3_conn, &test_case_13_4_8_3_conn, &postamble_13_4_8_3_conn };
struct test_stream test_13_4_8_3_resp = { &preamble_13_4_8_3_resp, &test_case_13_4_8_3_resp, &postamble_13_4_8_3_resp };
struct test_stream test_13_4_8_3_list = { &preamble_13_4_8_3_list, &test_case_13_4_8_3_list, &postamble_13_4_8_3_list };

#define tgrp_case_13_4_8_4 test_group_13
#define numb_case_13_4_8_4 "13.4.8.4"
#define name_case_13_4_8_4 "Fatal and non-fatal errors -- T_CONN_REQ - TOUTSTATE - TS_DATA_XFER"
#define sref_case_13_4_8_4 sref_case_13
#define desc_case_13_4_8_4 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_8_4_conn(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_4_resp(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_8_4_conn	preamble_ts_data_xfer_conn
#define preamble_13_4_8_4_resp	preamble_ts_data_xfer_resp
#define preamble_13_4_8_4_list	preamble_ts_data_xfer_list

#define postamble_13_4_8_4_conn	postamble_ts_data_xfer_conn
#define postamble_13_4_8_4_resp	postamble_ts_data_xfer_resp
#define postamble_13_4_8_4_list	postamble_ts_data_xfer_list

struct test_stream test_13_4_8_4_conn = { &preamble_13_4_8_4_conn, &test_case_13_4_8_4_conn, &postamble_13_4_8_4_conn };
struct test_stream test_13_4_8_4_resp = { &preamble_13_4_8_4_resp, &test_case_13_4_8_4_resp, &postamble_13_4_8_4_resp };
struct test_stream test_13_4_8_4_list = { &preamble_13_4_8_4_list, &test_case_13_4_8_4_list, &postamble_13_4_8_4_list };

#define tgrp_case_13_4_8_5 test_group_13
#define numb_case_13_4_8_5 "13.4.8.5"
#define name_case_13_4_8_5 "Fatal and non-fatal errors -- T_CONN_REQ - TOUTSTATE - TS_WIND_ORDREL"
#define sref_case_13_4_8_5 sref_case_13
#define desc_case_13_4_8_5 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_8_5_conn(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_8_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_8_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_4_8_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_4_8_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_4_8_5_conn	postamble_ts_wind_ordrel_conn
#define postamble_13_4_8_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_4_8_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_4_8_5_conn = { &preamble_13_4_8_5_conn, &test_case_13_4_8_5_conn, &postamble_13_4_8_5_conn };
struct test_stream test_13_4_8_5_resp = { &preamble_13_4_8_5_resp, &test_case_13_4_8_5_resp, &postamble_13_4_8_5_resp };
struct test_stream test_13_4_8_5_list = { &preamble_13_4_8_5_list, &test_case_13_4_8_5_list, &postamble_13_4_8_5_list };

#define tgrp_case_13_4_8_6 test_group_13
#define numb_case_13_4_8_6 "13.4.8.6"
#define name_case_13_4_8_6 "Fatal and non-fatal errors -- T_CONN_REQ - TOUTSTATE - TS_WREQ_ORDREL"
#define sref_case_13_4_8_6 sref_case_13
#define desc_case_13_4_8_6 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_8_6_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_4_8_6_resp(int child)
{
	return test_case_13_4_8(child);
}

int
test_case_13_4_8_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_4_8_6_conn	preamble_ts_wreq_ordrel_conn
#define preamble_13_4_8_6_resp	preamble_ts_wreq_ordrel_resp
#define preamble_13_4_8_6_list	preamble_ts_wreq_ordrel_list

#define postamble_13_4_8_6_conn	postamble_ts_wreq_ordrel_conn
#define postamble_13_4_8_6_resp	postamble_ts_wreq_ordrel_resp
#define postamble_13_4_8_6_list	postamble_ts_wreq_ordrel_list

struct test_stream test_13_4_8_6_conn = { &preamble_13_4_8_6_conn, &test_case_13_4_8_6_conn, &postamble_13_4_8_6_conn };
struct test_stream test_13_4_8_6_resp = { &preamble_13_4_8_6_resp, &test_case_13_4_8_6_resp, &postamble_13_4_8_6_resp };
struct test_stream test_13_4_8_6_list = { &preamble_13_4_8_6_list, &test_case_13_4_8_6_list, &postamble_13_4_8_6_list };

#define tgrp_case_13_4_9 test_group_13
#define numb_case_13_4_9 "13.4.9"
#define name_case_13_4_9 "Fatal and non-fatal errors -- T_CONN_REQ - TSYSERR"
#define sref_case_13_4_9 sref_case_13
#define desc_case_13_4_9 "\
Checks that the TSYSERR error is returned in response to a T_CONN_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_CONN_REQ primitive."

int
test_case_13_4_9_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_9_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_4_9_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_4_9_conn	preamble_1
#define preamble_13_4_9_resp	preamble_1
#define preamble_13_4_9_list	preamble_1

#define postamble_13_4_9_conn	postamble_1
#define postamble_13_4_9_resp	postamble_1
#define postamble_13_4_9_list	postamble_1

struct test_stream test_13_4_9_conn = { &preamble_13_4_9_conn, &test_case_13_4_9_conn, &postamble_13_4_9_conn };
struct test_stream test_13_4_9_resp = { &preamble_13_4_9_resp, &test_case_13_4_9_resp, &postamble_13_4_9_resp };
struct test_stream test_13_4_9_list = { &preamble_13_4_9_list, &test_case_13_4_9_list, &postamble_13_4_9_list };

#define tgrp_case_13_5_1 test_group_13
#define numb_case_13_5_1 "13.5.1"
#define name_case_13_5_1 "Fatal and non-fatal errors -- T_CONN_RES - EPROTO"
#define sref_case_13_5_1 sref_case_13
#define desc_case_13_5_1 "\
Checks that the EPROTO error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_5_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_5_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_5_1_conn	preamble_1
#define preamble_13_5_1_resp	preamble_1
#define preamble_13_5_1_list	preamble_1

#define postamble_13_5_1_conn	postamble_1
#define postamble_13_5_1_resp	postamble_1
#define postamble_13_5_1_list	postamble_1

struct test_stream test_13_5_1_conn = { &preamble_13_5_1_conn, &test_case_13_5_1_conn, &postamble_13_5_1_conn };
struct test_stream test_13_5_1_resp = { &preamble_13_5_1_resp, &test_case_13_5_1_resp, &postamble_13_5_1_resp };
struct test_stream test_13_5_1_list = { &preamble_13_5_1_list, &test_case_13_5_1_list, &postamble_13_5_1_list };

#define tgrp_case_13_5_2 test_group_13
#define numb_case_13_5_2 "13.5.2"
#define name_case_13_5_2 "Fatal and non-fatal errors -- T_CONN_RES - TACCES"
#define sref_case_13_5_2 sref_case_13
#define desc_case_13_5_2 "\
Checks that the TACCES error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TACCES error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_2_conn(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_2_resp(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_2_list(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

#define preamble_13_5_2_conn	preamble_1
#define preamble_13_5_2_resp	preamble_1
#define preamble_13_5_2_list	preamble_1

#define postamble_13_5_2_conn	postamble_1
#define postamble_13_5_2_resp	postamble_1
#define postamble_13_5_2_list	postamble_1

struct test_stream test_13_5_2_conn = { &preamble_13_5_2_conn, &test_case_13_5_2_conn, &postamble_13_5_2_conn };
struct test_stream test_13_5_2_resp = { &preamble_13_5_2_resp, &test_case_13_5_2_resp, &postamble_13_5_2_resp };
struct test_stream test_13_5_2_list = { &preamble_13_5_2_list, &test_case_13_5_2_list, &postamble_13_5_2_list };

#define tgrp_case_13_5_3 test_group_13
#define numb_case_13_5_3 "13.5.3"
#define name_case_13_5_3 "Fatal and non-fatal errors -- T_CONN_RES - TBADADDR"
#define sref_case_13_5_3 sref_case_13
#define desc_case_13_5_3 "\
Checks that the TBADADDR error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADADDR error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_3_conn(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_3_resp(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_3_list(int child)
{
	return (__RESULT_SKIPPED);
}

#define preamble_13_5_3_conn	preamble_0
#define preamble_13_5_3_resp	preamble_0
#define preamble_13_5_3_list	preamble_0

#define postamble_13_5_3_conn	postamble_0
#define postamble_13_5_3_resp	postamble_0
#define postamble_13_5_3_list	postamble_0

struct test_stream test_13_5_3_conn = { &preamble_13_5_3_conn, &test_case_13_5_3_conn, &postamble_13_5_3_conn };
struct test_stream test_13_5_3_resp = { &preamble_13_5_3_resp, &test_case_13_5_3_resp, &postamble_13_5_3_resp };
struct test_stream test_13_5_3_list = { &preamble_13_5_3_list, &test_case_13_5_3_list, &postamble_13_5_3_list };

#define tgrp_case_13_5_4 test_group_13
#define numb_case_13_5_4 "13.5.4"
#define name_case_13_5_4 "Fatal and non-fatal errors -- T_CONN_RES - TBADDATA"
#define sref_case_13_5_4 sref_case_13
#define desc_case_13_5_4 "\
Checks that the TBADDATA error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADDATA error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_4_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_4_list(int child)
{
	switch (test_level) {
	case T_INET_TCP:
		/* LiS has a bug where it passes a zero length data message. */
		test_data = "data";
		test_opts = NULL;
		test_olen = 0;
		test_resfd = test_fd[1];
		if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (last_t_errno != TBADDATA)
			goto failure;
		state++;
		break;
	case T_INET_SCTP:
		return (__RESULT_SKIPPED);
	default:
		return (__RESULT_SCRIPT_ERROR);
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_13_5_4_conn	preamble_ts_wres_cind_conn
#define preamble_13_5_4_resp	preamble_ts_wres_cind_resp
#define preamble_13_5_4_list	preamble_ts_wres_cind_list

#define postamble_13_5_4_conn	postamble_ts_wres_cind_conn
#define postamble_13_5_4_resp	postamble_ts_wres_cind_resp
#define postamble_13_5_4_list	postamble_ts_wres_cind_list

struct test_stream test_13_5_4_conn = { &preamble_13_5_4_conn, &test_case_13_5_4_conn, &postamble_13_5_4_conn };
struct test_stream test_13_5_4_resp = { &preamble_13_5_4_resp, &test_case_13_5_4_resp, &postamble_13_5_4_resp };
struct test_stream test_13_5_4_list = { &preamble_13_5_4_list, &test_case_13_5_4_list, &postamble_13_5_4_list };

#define tgrp_case_13_5_5 test_group_13
#define numb_case_13_5_5 "13.5.5"
#define name_case_13_5_5 "Fatal and non-fatal errors -- T_CONN_RES - TBADF"
#define sref_case_13_5_5 sref_case_13
#define desc_case_13_5_5 "\
Checks that the TBADF error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADF error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_5_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_5_list(int child)
{
	test_data = NULL;
	test_opts = NULL;
	test_olen = 0;
	test_resfd = -1;
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADF)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_13_5_5_conn	preamble_ts_wres_cind_conn
#define preamble_13_5_5_resp	preamble_ts_wres_cind_resp
#define preamble_13_5_5_list	preamble_ts_wres_cind_list

#define postamble_13_5_5_conn	postamble_ts_wres_cind_conn
#define postamble_13_5_5_resp	postamble_ts_wres_cind_resp
#define postamble_13_5_5_list	postamble_ts_wres_cind_list

struct test_stream test_13_5_5_conn = { &preamble_13_5_5_conn, &test_case_13_5_5_conn, &postamble_13_5_5_conn };
struct test_stream test_13_5_5_resp = { &preamble_13_5_5_resp, &test_case_13_5_5_resp, &postamble_13_5_5_resp };
struct test_stream test_13_5_5_list = { &preamble_13_5_5_list, &test_case_13_5_5_list, &postamble_13_5_5_list };

#define tgrp_case_13_5_6 test_group_13
#define numb_case_13_5_6 "13.5.6"
#define name_case_13_5_6 "Fatal and non-fatal errors -- T_CONN_RES - TBADOPT"
#define sref_case_13_5_6 sref_case_13
#define desc_case_13_5_6 "\
Checks that the TBADOPT error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADOPT error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_6_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_6_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_6_list(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t) + 1, T_INET_IP, T_IP_TOS, T_SUCCESS}
	, 0x0};
	test_data = NULL;
	test_opts = &options;
	test_olen = sizeof(options);
	test_resfd = test_fd[1];
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADOPT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_13_5_6_conn	preamble_ts_wres_cind_conn
#define preamble_13_5_6_resp	preamble_ts_wres_cind_resp
#define preamble_13_5_6_list	preamble_ts_wres_cind_list

#define postamble_13_5_6_conn	postamble_ts_wres_cind_conn
#define postamble_13_5_6_resp	postamble_ts_wres_cind_resp
#define postamble_13_5_6_list	postamble_ts_wres_cind_list

struct test_stream test_13_5_6_conn = { &preamble_13_5_6_conn, &test_case_13_5_6_conn, &postamble_13_5_6_conn };
struct test_stream test_13_5_6_resp = { &preamble_13_5_6_resp, &test_case_13_5_6_resp, &postamble_13_5_6_resp };
struct test_stream test_13_5_6_list = { &preamble_13_5_6_list, &test_case_13_5_6_list, &postamble_13_5_6_list };

#define tgrp_case_13_5_7 test_group_13
#define numb_case_13_5_7 "13.5.7"
#define name_case_13_5_7 "Fatal and non-fatal errors -- T_CONN_RES - TBADSEQ"
#define sref_case_13_5_7 sref_case_13
#define desc_case_13_5_7 "\
Checks that the TBADSEQ error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADSEQ error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_7_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_7_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_7_list(int child)
{
	test_data = NULL;
	test_opts = NULL;
	test_olen = 0;
	test_resfd = test_fd[1];
	last_sequence = 45;
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADSEQ)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_13_5_7_conn	preamble_ts_wres_cind_conn
#define preamble_13_5_7_resp	preamble_ts_wres_cind_resp
#define preamble_13_5_7_list	preamble_ts_wres_cind_list

#define postamble_13_5_7_conn	postamble_ts_wres_cind_conn
#define postamble_13_5_7_resp	postamble_ts_wres_cind_resp
#define postamble_13_5_7_list	postamble_ts_wres_cind_list

struct test_stream test_13_5_7_conn = { &preamble_13_5_7_conn, &test_case_13_5_7_conn, &postamble_13_5_7_conn };
struct test_stream test_13_5_7_resp = { &preamble_13_5_7_resp, &test_case_13_5_7_resp, &postamble_13_5_7_resp };
struct test_stream test_13_5_7_list = { &preamble_13_5_7_list, &test_case_13_5_7_list, &postamble_13_5_7_list };

#define tgrp_case_13_5_8 test_group_13
#define numb_case_13_5_8 "13.5.8"
#define name_case_13_5_8 "Fatal and non-fatal errors -- T_CONN_RES - TNOTSUPPORT"
#define sref_case_13_5_8 sref_case_13
#define desc_case_13_5_8 "\
Checks that the TNOTSUPPORT error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TNOTSUPPORT error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_8_conn(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type != T_CLTS)
		goto notapplicable;
	state++;
	test_data = NULL;
	test_opts = NULL;
	test_olen = 0;
	last_sequence = 0;
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TNOTSUPPORT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

int
test_case_13_5_8_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_5_8_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_5_8_conn	preamble_1
#define preamble_13_5_8_resp	preamble_1
#define preamble_13_5_8_list	preamble_1

#define postamble_13_5_8_conn	postamble_1
#define postamble_13_5_8_resp	postamble_1
#define postamble_13_5_8_list	postamble_1

struct test_stream test_13_5_8_conn = { &preamble_13_5_8_conn, &test_case_13_5_8_conn, &postamble_13_5_8_conn };
struct test_stream test_13_5_8_resp = { &preamble_13_5_8_resp, &test_case_13_5_8_resp, &postamble_13_5_8_resp };
struct test_stream test_13_5_8_list = { &preamble_13_5_8_list, &test_case_13_5_8_list, &postamble_13_5_8_list };

#define tgrp_case_13_5_9_1 test_group_13
#define numb_case_13_5_9_1 "13.5.9.1"
#define name_case_13_5_9_1 "Fatal and non-fatal errors -- T_CONN_RES - TOUTSTATE - TS_UNBND"
#define sref_case_13_5_9_1 sref_case_13
#define desc_case_13_5_9_1 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_9(int child)
{
	test_data = NULL;
	test_opts = NULL;
	test_olen = 0;
	test_resfd = test_fd[child];
	last_sequence = 0;
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_5_9_1_conn(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_1_resp(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_1_list(int child)
{
	return test_case_13_5_9(child);
}

#define preamble_13_5_9_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_5_9_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_5_9_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_5_9_1_conn	postamble_ts_unbnd_cots_conn
#define postamble_13_5_9_1_resp	postamble_ts_unbnd_cots_resp
#define postamble_13_5_9_1_list	postamble_ts_unbnd_cots_list

struct test_stream test_13_5_9_1_conn = { &preamble_13_5_9_1_conn, &test_case_13_5_9_1_conn, &postamble_13_5_9_1_conn };
struct test_stream test_13_5_9_1_resp = { &preamble_13_5_9_1_resp, &test_case_13_5_9_1_resp, &postamble_13_5_9_1_resp };
struct test_stream test_13_5_9_1_list = { &preamble_13_5_9_1_list, &test_case_13_5_9_1_list, &postamble_13_5_9_1_list };

#define tgrp_case_13_5_9_2 test_group_13
#define numb_case_13_5_9_2 "13.5.9.2"
#define name_case_13_5_9_2 "Fatal and non-fatal errors -- T_CONN_RES - TOUTSTATE - TS_IDLE"
#define sref_case_13_5_9_2 sref_case_13
#define desc_case_13_5_9_2 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_9_2_conn(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_2_resp(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_2_list(int child)
{
	return test_case_13_5_9(child);
}

#define preamble_13_5_9_2_conn	preamble_ts_idle_cots_conn
#define preamble_13_5_9_2_resp	preamble_ts_idle_cots_resp
#define preamble_13_5_9_2_list	preamble_ts_idle_cots_list

#define postamble_13_5_9_2_conn	postamble_ts_idle_cots_conn
#define postamble_13_5_9_2_resp	postamble_ts_idle_cots_resp
#define postamble_13_5_9_2_list	postamble_ts_idle_cots_list

struct test_stream test_13_5_9_2_conn = { &preamble_13_5_9_2_conn, &test_case_13_5_9_2_conn, &postamble_13_5_9_2_conn };
struct test_stream test_13_5_9_2_resp = { &preamble_13_5_9_2_resp, &test_case_13_5_9_2_resp, &postamble_13_5_9_2_resp };
struct test_stream test_13_5_9_2_list = { &preamble_13_5_9_2_list, &test_case_13_5_9_2_list, &postamble_13_5_9_2_list };

#define tgrp_case_13_5_9_3 test_group_13
#define numb_case_13_5_9_3 "13.5.9.3"
#define name_case_13_5_9_3 "Fatal and non-fatal errors -- T_CONN_RES - TOUTSTATE - TS_WCON_CREQ"
#define sref_case_13_5_9_3 sref_case_13
#define desc_case_13_5_9_3 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_9_3_conn(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_9_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_5_9_3_conn	preamble_ts_wcon_creq_conn
#define preamble_13_5_9_3_resp	preamble_ts_wcon_creq_resp
#define preamble_13_5_9_3_list	preamble_ts_wcon_creq_list

#define postamble_13_5_9_3_conn	postamble_ts_wcon_creq_conn
#define postamble_13_5_9_3_resp	postamble_ts_wcon_creq_resp
#define postamble_13_5_9_3_list	postamble_ts_wcon_creq_list

struct test_stream test_13_5_9_3_conn = { &preamble_13_5_9_3_conn, &test_case_13_5_9_3_conn, &postamble_13_5_9_3_conn };
struct test_stream test_13_5_9_3_resp = { &preamble_13_5_9_3_resp, &test_case_13_5_9_3_resp, &postamble_13_5_9_3_resp };
struct test_stream test_13_5_9_3_list = { &preamble_13_5_9_3_list, &test_case_13_5_9_3_list, &postamble_13_5_9_3_list };

#define tgrp_case_13_5_9_4 test_group_13
#define numb_case_13_5_9_4 "13.5.9.4"
#define name_case_13_5_9_4 "Fatal and non-fatal errors -- T_CONN_RES - TOUTSTATE - TS_DATA_XFER"
#define sref_case_13_5_9_4 sref_case_13
#define desc_case_13_5_9_4 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_9_4_conn(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_4_resp(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_5_9_4_conn	preamble_ts_data_xfer_conn
#define preamble_13_5_9_4_resp	preamble_ts_data_xfer_resp
#define preamble_13_5_9_4_list	preamble_ts_data_xfer_list

#define postamble_13_5_9_4_conn	postamble_ts_data_xfer_conn
#define postamble_13_5_9_4_resp	postamble_ts_data_xfer_resp
#define postamble_13_5_9_4_list	postamble_ts_data_xfer_list

struct test_stream test_13_5_9_4_conn = { &preamble_13_5_9_4_conn, &test_case_13_5_9_4_conn, &postamble_13_5_9_4_conn };
struct test_stream test_13_5_9_4_resp = { &preamble_13_5_9_4_resp, &test_case_13_5_9_4_resp, &postamble_13_5_9_4_resp };
struct test_stream test_13_5_9_4_list = { &preamble_13_5_9_4_list, &test_case_13_5_9_4_list, &postamble_13_5_9_4_list };

#define tgrp_case_13_5_9_5 test_group_13
#define numb_case_13_5_9_5 "13.5.9.5"
#define name_case_13_5_9_5 "Fatal and non-fatal errors -- T_CONN_RES - TOUTSTATE - TS_WIND_ORDREL"
#define sref_case_13_5_9_5 sref_case_13
#define desc_case_13_5_9_5 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_9_5_conn(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_9_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_5_9_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_5_9_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_5_9_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_5_9_5_conn	postamble_ts_wind_ordrel_conn
#define postamble_13_5_9_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_5_9_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_5_9_5_conn = { &preamble_13_5_9_5_conn, &test_case_13_5_9_5_conn, &postamble_13_5_9_5_conn };
struct test_stream test_13_5_9_5_resp = { &preamble_13_5_9_5_resp, &test_case_13_5_9_5_resp, &postamble_13_5_9_5_resp };
struct test_stream test_13_5_9_5_list = { &preamble_13_5_9_5_list, &test_case_13_5_9_5_list, &postamble_13_5_9_5_list };

#define tgrp_case_13_5_9_6 test_group_13
#define numb_case_13_5_9_6 "13.5.9.6"
#define name_case_13_5_9_6 "Fatal and non-fatal errors -- T_CONN_RES - TOUTSTATE - TS_WREQ_ORDREL"
#define sref_case_13_5_9_6 sref_case_13
#define desc_case_13_5_9_6 "\
Checks that the TOUTSTATE error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_9_6_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_5_9_6_resp(int child)
{
	return test_case_13_5_9(child);
}

int
test_case_13_5_9_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_5_9_6_conn	preamble_ts_wreq_ordrel_conn
#define preamble_13_5_9_6_resp	preamble_ts_wreq_ordrel_resp
#define preamble_13_5_9_6_list	preamble_ts_wreq_ordrel_list

#define postamble_13_5_9_6_conn	postamble_ts_wreq_ordrel_conn
#define postamble_13_5_9_6_resp	postamble_ts_wreq_ordrel_resp
#define postamble_13_5_9_6_list	postamble_ts_wreq_ordrel_list

struct test_stream test_13_5_9_6_conn = { &preamble_13_5_9_6_conn, &test_case_13_5_9_6_conn, &postamble_13_5_9_6_conn };
struct test_stream test_13_5_9_6_resp = { &preamble_13_5_9_6_resp, &test_case_13_5_9_6_resp, &postamble_13_5_9_6_resp };
struct test_stream test_13_5_9_6_list = { &preamble_13_5_9_6_list, &test_case_13_5_9_6_list, &postamble_13_5_9_6_list };

#define tgrp_case_13_5_10 test_group_13
#define numb_case_13_5_10 "13.5.10"
#define name_case_13_5_10 "Fatal and non-fatal errors -- T_CONN_RES - TPROVMISMATCH"
#define sref_case_13_5_10 sref_case_13
#define desc_case_13_5_10 "\
Checks that the TPROVMISMATCH error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TPROVMISMATCH error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_10_conn(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_10_resp(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_10_list(int child)
{
	return (__RESULT_SKIPPED);
}

#define preamble_13_5_10_conn	preamble_0
#define preamble_13_5_10_resp	preamble_0
#define preamble_13_5_10_list	preamble_0

#define postamble_13_5_10_conn	postamble_0
#define postamble_13_5_10_resp	postamble_0
#define postamble_13_5_10_list	postamble_0

struct test_stream test_13_5_10_conn = { &preamble_13_5_10_conn, &test_case_13_5_10_conn, &postamble_13_5_10_conn };
struct test_stream test_13_5_10_resp = { &preamble_13_5_10_resp, &test_case_13_5_10_resp, &postamble_13_5_10_resp };
struct test_stream test_13_5_10_list = { &preamble_13_5_10_list, &test_case_13_5_10_list, &postamble_13_5_10_list };

#define tgrp_case_13_5_11 test_group_13
#define numb_case_13_5_11 "13.5.11"
#define name_case_13_5_11 "Fatal and non-fatal errors -- T_CONN_RES - TRESADDR"
#define sref_case_13_5_11 sref_case_13
#define desc_case_13_5_11 "\
Checks that the TRESADDR error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TRESADDR error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_11_conn(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_11_resp(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_11_list(int child)
{
	return (__RESULT_SKIPPED);
}

#define preamble_13_5_11_conn	preamble_0
#define preamble_13_5_11_resp	preamble_0
#define preamble_13_5_11_list	preamble_0

#define postamble_13_5_11_conn	postamble_0
#define postamble_13_5_11_resp	postamble_0
#define postamble_13_5_11_list	postamble_0

struct test_stream test_13_5_11_conn = { &preamble_13_5_11_conn, &test_case_13_5_11_conn, &postamble_13_5_11_conn };
struct test_stream test_13_5_11_resp = { &preamble_13_5_11_resp, &test_case_13_5_11_resp, &postamble_13_5_11_resp };
struct test_stream test_13_5_11_list = { &preamble_13_5_11_list, &test_case_13_5_11_list, &postamble_13_5_11_list };

#define tgrp_case_13_5_12 test_group_13
#define numb_case_13_5_12 "13.5.12"
#define name_case_13_5_12 "Fatal and non-fatal errors -- T_CONN_RES - TRESQLEN"
#define sref_case_13_5_12 sref_case_13
#define desc_case_13_5_12 "\
Checks that the TRESQLEN error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TRESQLEN error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_12_conn(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_12_resp(int child)
{
	return (__RESULT_SKIPPED);
}

int
test_case_13_5_12_list(int child)
{
	return (__RESULT_SKIPPED);
}

#define preamble_13_5_12_conn	preamble_0
#define preamble_13_5_12_resp	preamble_0
#define preamble_13_5_12_list	preamble_0

#define postamble_13_5_12_conn	postamble_0
#define postamble_13_5_12_resp	postamble_0
#define postamble_13_5_12_list	postamble_0

struct test_stream test_13_5_12_conn = { &preamble_13_5_12_conn, &test_case_13_5_12_conn, &postamble_13_5_12_conn };
struct test_stream test_13_5_12_resp = { &preamble_13_5_12_resp, &test_case_13_5_12_resp, &postamble_13_5_12_resp };
struct test_stream test_13_5_12_list = { &preamble_13_5_12_list, &test_case_13_5_12_list, &postamble_13_5_12_list };

#define tgrp_case_13_5_13 test_group_13
#define numb_case_13_5_13 "13.5.13"
#define name_case_13_5_13 "Fatal and non-fatal errors -- T_CONN_RES - TSYSERR"
#define sref_case_13_5_13 sref_case_13
#define desc_case_13_5_13 "\
Checks that the TSYSERR error is returned in response to a T_CONN_RES primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_CONN_RES primitive."

int
test_case_13_5_13_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_5_13_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_5_13_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_5_13_conn	preamble_0
#define preamble_13_5_13_resp	preamble_0
#define preamble_13_5_13_list	preamble_0

#define postamble_13_5_13_conn	postamble_0
#define postamble_13_5_13_resp	postamble_0
#define postamble_13_5_13_list	postamble_0

struct test_stream test_13_5_13_conn = { &preamble_13_5_13_conn, &test_case_13_5_13_conn, &postamble_13_5_13_conn };
struct test_stream test_13_5_13_resp = { &preamble_13_5_13_resp, &test_case_13_5_13_resp, &postamble_13_5_13_resp };
struct test_stream test_13_5_13_list = { &preamble_13_5_13_list, &test_case_13_5_13_list, &postamble_13_5_13_list };

#define tgrp_case_13_6_1_1 test_group_13
#define numb_case_13_6_1_1 "13.6.1.1"
#define name_case_13_6_1_1 "Fatal and non-fatal errors -- T_DATA_REQ - EPROTO - TS_UNBND"
#define sref_case_13_6_1_1 sref_case_13
#define desc_case_13_6_1_1 "\
Checks that the EPROTO error is returned in response to a T_DATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DATA_REQ primitive."

int
test_case_13_6_1(int child)
{
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_6_1_nofail(int child)
{
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_6_1_1_conn(int child)
{
	return test_case_13_6_1(child);
}

int
test_case_13_6_1_1_resp(int child)
{
	return test_case_13_6_1(child);
}

int
test_case_13_6_1_1_list(int child)
{
	return test_case_13_6_1(child);
}

#define preamble_13_6_1_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_6_1_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_6_1_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_6_1_1_conn	postamble_0
#define postamble_13_6_1_1_resp	postamble_0
#define postamble_13_6_1_1_list	postamble_0

struct test_stream test_13_6_1_1_conn = { &preamble_13_6_1_1_conn, &test_case_13_6_1_1_conn, &postamble_13_6_1_1_conn };
struct test_stream test_13_6_1_1_resp = { &preamble_13_6_1_1_resp, &test_case_13_6_1_1_resp, &postamble_13_6_1_1_resp };
struct test_stream test_13_6_1_1_list = { &preamble_13_6_1_1_list, &test_case_13_6_1_1_list, &postamble_13_6_1_1_list };

#define tgrp_case_13_6_1_2 test_group_13
#define numb_case_13_6_1_2 "13.6.1.2"
#define name_case_13_6_1_2 "Fatal and non-fatal errors -- T_DATA_REQ - EPROTO - TS_IDLE"
#define sref_case_13_6_1_2 sref_case_13
#define desc_case_13_6_1_2 "\
Checks that the EPROTO error is returned in response to a T_DATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DATA_REQ primitive."

int
test_case_13_6_1_2_conn(int child)
{
	return test_case_13_6_1_nofail(child);
}

int
test_case_13_6_1_2_resp(int child)
{
	return test_case_13_6_1_nofail(child);
}

int
test_case_13_6_1_2_list(int child)
{
	return test_case_13_6_1_nofail(child);
}

#define preamble_13_6_1_2_conn	preamble_ts_idle_cots_conn
#define preamble_13_6_1_2_resp	preamble_ts_idle_cots_resp
#define preamble_13_6_1_2_list	preamble_ts_idle_cots_list

#define postamble_13_6_1_2_conn	postamble_ts_idle_cots_conn
#define postamble_13_6_1_2_resp	postamble_ts_idle_cots_resp
#define postamble_13_6_1_2_list	postamble_ts_idle_cots_list

struct test_stream test_13_6_1_2_conn = { &preamble_13_6_1_2_conn, &test_case_13_6_1_2_conn, &postamble_13_6_1_2_conn };
struct test_stream test_13_6_1_2_resp = { &preamble_13_6_1_2_resp, &test_case_13_6_1_2_resp, &postamble_13_6_1_2_resp };
struct test_stream test_13_6_1_2_list = { &preamble_13_6_1_2_list, &test_case_13_6_1_2_list, &postamble_13_6_1_2_list };

#define tgrp_case_13_6_1_3 test_group_13
#define numb_case_13_6_1_3 "13.6.1.3"
#define name_case_13_6_1_3 "Fatal and non-fatal errors -- T_DATA_REQ - EPROTO - TS_WCON_CREQ"
#define sref_case_13_6_1_3 sref_case_13
#define desc_case_13_6_1_3 "\
Checks that the EPROTO error is returned in response to a T_DATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DATA_REQ primitive."

int
test_case_13_6_1_3_conn(int child)
{
	return test_case_13_6_1(child);
}

int
test_case_13_6_1_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_6_1_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_6_1_3_conn	preamble_ts_wcon_creq_conn
#define preamble_13_6_1_3_resp	preamble_ts_wcon_creq_resp
#define preamble_13_6_1_3_list	preamble_ts_wcon_creq_list

#define postamble_13_6_1_3_conn	postamble_0
#define postamble_13_6_1_3_resp	postamble_ts_wcon_creq_resp
#define postamble_13_6_1_3_list	postamble_ts_wcon_creq_list

struct test_stream test_13_6_1_3_conn = { &preamble_13_6_1_3_conn, &test_case_13_6_1_3_conn, &postamble_13_6_1_3_conn };
struct test_stream test_13_6_1_3_resp = { &preamble_13_6_1_3_resp, &test_case_13_6_1_3_resp, &postamble_13_6_1_3_resp };
struct test_stream test_13_6_1_3_list = { &preamble_13_6_1_3_list, &test_case_13_6_1_3_list, &postamble_13_6_1_3_list };

#define tgrp_case_13_6_1_4 test_group_13
#define numb_case_13_6_1_4 "13.6.1.4"
#define name_case_13_6_1_4 "Fatal and non-fatal errors -- T_DATA_REQ - EPROTO - TS_WRES_CIND"
#define sref_case_13_6_1_4 sref_case_13
#define desc_case_13_6_1_4 "\
Checks that the EPROTO error is returned in response to a T_DATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DATA_REQ primitive."

int
test_case_13_6_1_4_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS) {
		state++;
		test_data = NULL;
		last_sequence = 0;
		if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_6_1_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_6_1_4_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_13_6_1(child);
}

#define preamble_13_6_1_4_conn	preamble_ts_wres_cind_conn
#define preamble_13_6_1_4_resp	preamble_ts_wres_cind_resp
#define preamble_13_6_1_4_list	preamble_ts_wres_cind_list

#define postamble_13_6_1_4_conn	postamble_ts_idle_conn
#define postamble_13_6_1_4_resp	postamble_ts_wres_cind_resp
#define postamble_13_6_1_4_list	postamble_0

struct test_stream test_13_6_1_4_conn = { &preamble_13_6_1_4_conn, &test_case_13_6_1_4_conn, &postamble_13_6_1_4_conn };
struct test_stream test_13_6_1_4_resp = { &preamble_13_6_1_4_resp, &test_case_13_6_1_4_resp, &postamble_13_6_1_4_resp };
struct test_stream test_13_6_1_4_list = { &preamble_13_6_1_4_list, &test_case_13_6_1_4_list, &postamble_13_6_1_4_list };

#define tgrp_case_13_6_1_5 test_group_13
#define numb_case_13_6_1_5 "13.6.1.5"
#define name_case_13_6_1_5 "Fatal and non-fatal errors -- T_DATA_REQ - EPROTO - TS_WIND_ORDREL"
#define sref_case_13_6_1_5 sref_case_13
#define desc_case_13_6_1_5 "\
Checks that the EPROTO error is returned in response to a T_DATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DATA_REQ primitive."

int
test_case_13_6_1_5_conn(int child)
{
	return test_case_13_6_1(child);
}

int
test_case_13_6_1_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_6_1_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_6_1_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_6_1_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_6_1_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_6_1_5_conn	postamble_0
#define postamble_13_6_1_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_6_1_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_6_1_5_conn = { &preamble_13_6_1_5_conn, &test_case_13_6_1_5_conn, &postamble_13_6_1_5_conn };
struct test_stream test_13_6_1_5_resp = { &preamble_13_6_1_5_resp, &test_case_13_6_1_5_resp, &postamble_13_6_1_5_resp };
struct test_stream test_13_6_1_5_list = { &preamble_13_6_1_5_list, &test_case_13_6_1_5_list, &postamble_13_6_1_5_list };

#define tgrp_case_13_6_2 test_group_13
#define numb_case_13_6_2 "13.6.2"
#define name_case_13_6_2 "Fatal and non-fatal errors -- T_DATA_REQ - EPROTO"
#define sref_case_13_6_2 sref_case_13
#define desc_case_13_6_2 "\
Checks that the EPROTO error is returned in response to a T_DATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DATA_REQ primitive."

int
test_case_13_6_2_conn(int child)
{
	test_data = "";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
      again:
	state++;
	expect(child, NORMAL_WAIT, __RESULT_FAILURE);
	switch (last_event) {
	case __RESULT_FAILURE:
		break;
	case __TEST_DISCON_IND:
		goto success;
	case __TEST_ORDREL_IND:
		goto again;
	default:
		goto failure;
	}
	state++;
	if (last_errno != EPROTO)
		goto failure;
      success:
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_6_2_resp(int child)
{
	test_data = "";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
      again:
	state++;
	expect(child, NORMAL_WAIT, __RESULT_FAILURE);
	switch (last_event) {
	case __RESULT_FAILURE:
		break;
	case __TEST_DISCON_IND:
		goto success;
	case __TEST_ORDREL_IND:
		goto again;
	default:
		goto failure;
	}
	state++;
	if (last_errno != EPROTO)
		goto failure;
      success:
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_6_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_6_2_conn	preamble_ts_data_xfer_conn
#define preamble_13_6_2_resp	preamble_ts_data_xfer_resp
#define preamble_13_6_2_list	preamble_ts_data_xfer_list

#define postamble_13_6_2_conn	postamble_0
#define postamble_13_6_2_resp	postamble_0
#define postamble_13_6_2_list	postamble_ts_data_xfer_list

struct test_stream test_13_6_2_conn = { &preamble_13_6_2_conn, &test_case_13_6_2_conn, &postamble_13_6_2_conn };
struct test_stream test_13_6_2_resp = { &preamble_13_6_2_resp, &test_case_13_6_2_resp, &postamble_13_6_2_resp };
struct test_stream test_13_6_2_list = { &preamble_13_6_2_list, &test_case_13_6_2_list, &postamble_13_6_2_list };

#define tgrp_case_13_7_1 test_group_13
#define numb_case_13_7_1 "13.7.1"
#define name_case_13_7_1 "Fatal and non-fatal errors -- T_DISCON_REQ - EPROTO"
#define sref_case_13_7_1 sref_case_13
#define desc_case_13_7_1 "\
Checks that the EPROTO error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_7_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_7_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_7_1_conn	preamble_1
#define preamble_13_7_1_resp	preamble_1
#define preamble_13_7_1_list	preamble_1

#define postamble_13_7_1_conn	postamble_1
#define postamble_13_7_1_resp	postamble_1
#define postamble_13_7_1_list	postamble_1

struct test_stream test_13_7_1_conn = { &preamble_13_7_1_conn, &test_case_13_7_1_conn, &postamble_13_7_1_conn };
struct test_stream test_13_7_1_resp = { &preamble_13_7_1_resp, &test_case_13_7_1_resp, &postamble_13_7_1_resp };
struct test_stream test_13_7_1_list = { &preamble_13_7_1_list, &test_case_13_7_1_list, &postamble_13_7_1_list };

#define tgrp_case_13_7_2 test_group_13
#define numb_case_13_7_2 "13.7.2"
#define name_case_13_7_2 "Fatal and non-fatal errors -- T_DISCON_REQ - TBADDATA"
#define sref_case_13_7_2 sref_case_13
#define desc_case_13_7_2 "\
Checks that the TBADDATA error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADDATA error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_2_conn(int child)
{
	test_data = "";
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADDATA)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_7_2_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_7_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_7_2_conn	preamble_ts_data_xfer_conn
#define preamble_13_7_2_resp	preamble_ts_data_xfer_resp
#define preamble_13_7_2_list	preamble_ts_data_xfer_list

#define postamble_13_7_2_conn	postamble_ts_data_xfer_conn
#define postamble_13_7_2_resp	postamble_ts_data_xfer_resp
#define postamble_13_7_2_list	postamble_ts_data_xfer_list

struct test_stream test_13_7_2_conn = { &preamble_13_7_2_conn, &test_case_13_7_2_conn, &postamble_13_7_2_conn };
struct test_stream test_13_7_2_resp = { &preamble_13_7_2_resp, &test_case_13_7_2_resp, &postamble_13_7_2_resp };
struct test_stream test_13_7_2_list = { &preamble_13_7_2_list, &test_case_13_7_2_list, &postamble_13_7_2_list };

#define tgrp_case_13_7_3 test_group_13
#define numb_case_13_7_3 "13.7.3"
#define name_case_13_7_3 "Fatal and non-fatal errors -- T_DISCON_REQ - TBADSEQ"
#define sref_case_13_7_3 sref_case_13
#define desc_case_13_7_3 "\
Checks that the TBADSEQ error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADSEQ error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_3_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_7_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_7_3_list(int child)
{
	test_data = NULL;
	last_sequence = 45;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADSEQ)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_13_7_3_conn	preamble_ts_wres_cind_conn
#define preamble_13_7_3_resp	preamble_ts_wres_cind_resp
#define preamble_13_7_3_list	preamble_ts_wres_cind_list

#define postamble_13_7_3_conn	postamble_ts_wres_cind_conn
#define postamble_13_7_3_resp	postamble_ts_wres_cind_resp
#define postamble_13_7_3_list	postamble_ts_wres_cind_list

struct test_stream test_13_7_3_conn = { &preamble_13_7_3_conn, &test_case_13_7_3_conn, &postamble_13_7_3_conn };
struct test_stream test_13_7_3_resp = { &preamble_13_7_3_resp, &test_case_13_7_3_resp, &postamble_13_7_3_resp };
struct test_stream test_13_7_3_list = { &preamble_13_7_3_list, &test_case_13_7_3_list, &postamble_13_7_3_list };

#define tgrp_case_13_7_4 test_group_13
#define numb_case_13_7_4 "13.7.4"
#define name_case_13_7_4 "Fatal and non-fatal errors -- T_DISCON_REQ - TNOTSUPPORT"
#define sref_case_13_7_4 sref_case_13
#define desc_case_13_7_4 "\
Checks that the TNOTSUPPORT error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TNOTSUPPORT error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_4(int child)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.SERV_type != T_CLTS)
		goto notapplicable;
	state++;
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TNOTSUPPORT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      notapplicable:
	return (__RESULT_NOTAPPL);
}

#define test_case_13_7_4_conn	test_case_13_7_4
#define test_case_13_7_4_resp	test_case_13_7_4
#define test_case_13_7_4_list	test_case_13_7_4

#define preamble_13_7_4_conn	preamble_ts_unbnd_conn
#define preamble_13_7_4_resp	preamble_ts_unbnd_resp
#define preamble_13_7_4_list	preamble_ts_unbnd_list

#define postamble_13_7_4_conn	postamble_ts_unbnd_conn
#define postamble_13_7_4_resp	postamble_ts_unbnd_resp
#define postamble_13_7_4_list	postamble_ts_unbnd_list

struct test_stream test_13_7_4_conn = { &preamble_13_7_4_conn, &test_case_13_7_4_conn, &postamble_13_7_4_conn };
struct test_stream test_13_7_4_resp = { &preamble_13_7_4_resp, &test_case_13_7_4_resp, &postamble_13_7_4_resp };
struct test_stream test_13_7_4_list = { &preamble_13_7_4_list, &test_case_13_7_4_list, &postamble_13_7_4_list };

#define tgrp_case_13_7_5_1 test_group_13
#define numb_case_13_7_5_1 "13.7.5.1"
#define name_case_13_7_5_1 "Fatal and non-fatal errors -- T_DISCON_REQ - TOUTSTATE - TS_UNBND"
#define sref_case_13_7_5_1 sref_case_13
#define desc_case_13_7_5_1 "\
Checks that the TOUTSTATE error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_5(int child)
{
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_7_5_1_conn(int child)
{
	return test_case_13_7_5(child);
}

int
test_case_13_7_5_1_resp(int child)
{
	return test_case_13_7_5(child);
}

int
test_case_13_7_5_1_list(int child)
{
	return test_case_13_7_5(child);
}

#define preamble_13_7_5_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_7_5_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_7_5_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_7_5_1_conn	postamble_ts_unbnd_cots_conn
#define postamble_13_7_5_1_resp	postamble_ts_unbnd_cots_resp
#define postamble_13_7_5_1_list	postamble_ts_unbnd_cots_list

struct test_stream test_13_7_5_1_conn = { &preamble_13_7_5_1_conn, &test_case_13_7_5_1_conn, &postamble_13_7_5_1_conn };
struct test_stream test_13_7_5_1_resp = { &preamble_13_7_5_1_resp, &test_case_13_7_5_1_resp, &postamble_13_7_5_1_resp };
struct test_stream test_13_7_5_1_list = { &preamble_13_7_5_1_list, &test_case_13_7_5_1_list, &postamble_13_7_5_1_list };

#define tgrp_case_13_7_5_2 test_group_13
#define numb_case_13_7_5_2 "13.7.5.2"
#define name_case_13_7_5_2 "Fatal and non-fatal errors -- T_DISCON_REQ - TOUTSTATE - TS_IDLE"
#define sref_case_13_7_5_2 sref_case_13
#define desc_case_13_7_5_2 "\
Checks that the TOUTSTATE error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_5_2_conn(int child)
{
	return test_case_13_7_5(child);
}

int
test_case_13_7_5_2_resp(int child)
{
	return test_case_13_7_5(child);
}

int
test_case_13_7_5_2_list(int child)
{
	return test_case_13_7_5(child);
}

#define preamble_13_7_5_2_conn	preamble_ts_idle_cots_conn
#define preamble_13_7_5_2_resp	preamble_ts_idle_cots_resp
#define preamble_13_7_5_2_list	preamble_ts_idle_cots_list

#define postamble_13_7_5_2_conn	postamble_ts_idle_cots_conn
#define postamble_13_7_5_2_resp	postamble_ts_idle_cots_resp
#define postamble_13_7_5_2_list	postamble_ts_idle_cots_list

struct test_stream test_13_7_5_2_conn = { &preamble_13_7_5_2_conn, &test_case_13_7_5_2_conn, &postamble_13_7_5_2_conn };
struct test_stream test_13_7_5_2_resp = { &preamble_13_7_5_2_resp, &test_case_13_7_5_2_resp, &postamble_13_7_5_2_resp };
struct test_stream test_13_7_5_2_list = { &preamble_13_7_5_2_list, &test_case_13_7_5_2_list, &postamble_13_7_5_2_list };

#define tgrp_case_13_7_6 test_group_13
#define numb_case_13_7_6 "13.7.6"
#define name_case_13_7_6 "Fatal and non-fatal errors -- T_DISCON_REQ - TSYSERR"
#define sref_case_13_7_6 sref_case_13
#define desc_case_13_7_6 "\
Checks that the TSYSERR error is returned in response to a T_DISCON_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_DISCON_REQ primitive."

int
test_case_13_7_6_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_7_6_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_7_6_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_7_6_conn	preamble_1
#define preamble_13_7_6_resp	preamble_1
#define preamble_13_7_6_list	preamble_1

#define postamble_13_7_6_conn	postamble_1
#define postamble_13_7_6_resp	postamble_1
#define postamble_13_7_6_list	postamble_1

struct test_stream test_13_7_6_conn = { &preamble_13_7_6_conn, &test_case_13_7_6_conn, &postamble_13_7_6_conn };
struct test_stream test_13_7_6_resp = { &preamble_13_7_6_resp, &test_case_13_7_6_resp, &postamble_13_7_6_resp };
struct test_stream test_13_7_6_list = { &preamble_13_7_6_list, &test_case_13_7_6_list, &postamble_13_7_6_list };

#define tgrp_case_13_8_1_1 test_group_13
#define numb_case_13_8_1_1 "13.8.1.1"
#define name_case_13_8_1_1 "Fatal and non-fatal errors -- T_EXDATA_REQ - EPROTO - TS_UNBND"
#define sref_case_13_8_1_1 sref_case_13
#define desc_case_13_8_1_1 "\
Checks that the EPROTO error is returned in response to a T_EXDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_EXDATA_REQ primitive."

int
test_case_13_8_1(int child)
{
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_8_1_nofail(int child)
{
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_8_1_1_conn(int child)
{
	return test_case_13_8_1(child);
}

int
test_case_13_8_1_1_resp(int child)
{
	return test_case_13_8_1(child);
}

int
test_case_13_8_1_1_list(int child)
{
	return test_case_13_8_1(child);
}

#define preamble_13_8_1_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_8_1_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_8_1_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_8_1_1_conn	postamble_0
#define postamble_13_8_1_1_resp	postamble_0
#define postamble_13_8_1_1_list	postamble_0

struct test_stream test_13_8_1_1_conn = { &preamble_13_8_1_1_conn, &test_case_13_8_1_1_conn, &postamble_13_8_1_1_conn };
struct test_stream test_13_8_1_1_resp = { &preamble_13_8_1_1_resp, &test_case_13_8_1_1_resp, &postamble_13_8_1_1_resp };
struct test_stream test_13_8_1_1_list = { &preamble_13_8_1_1_list, &test_case_13_8_1_1_list, &postamble_13_8_1_1_list };

#define tgrp_case_13_8_1_2 test_group_13
#define numb_case_13_8_1_2 "13.8.1.2"
#define name_case_13_8_1_2 "Fatal and non-fatal errors -- T_EXDATA_REQ - EPROTO - TS_IDLE"
#define sref_case_13_8_1_2 sref_case_13
#define desc_case_13_8_1_2 "\
Checks that the EPROTO error is returned in response to a T_EXDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_EXDATA_REQ primitive."

int
test_case_13_8_1_2_conn(int child)
{
	return test_case_13_8_1_nofail(child);
}

int
test_case_13_8_1_2_resp(int child)
{
	return test_case_13_8_1_nofail(child);
}

int
test_case_13_8_1_2_list(int child)
{
	return test_case_13_8_1_nofail(child);
}

#define preamble_13_8_1_2_conn	preamble_ts_idle_cots_conn
#define preamble_13_8_1_2_resp	preamble_ts_idle_cots_resp
#define preamble_13_8_1_2_list	preamble_ts_idle_cots_list

#define postamble_13_8_1_2_conn	postamble_ts_idle_cots_conn
#define postamble_13_8_1_2_resp	postamble_ts_idle_cots_resp
#define postamble_13_8_1_2_list	postamble_ts_idle_cots_list

struct test_stream test_13_8_1_2_conn = { &preamble_13_8_1_2_conn, &test_case_13_8_1_2_conn, &postamble_13_8_1_2_conn };
struct test_stream test_13_8_1_2_resp = { &preamble_13_8_1_2_resp, &test_case_13_8_1_2_resp, &postamble_13_8_1_2_resp };
struct test_stream test_13_8_1_2_list = { &preamble_13_8_1_2_list, &test_case_13_8_1_2_list, &postamble_13_8_1_2_list };

#define tgrp_case_13_8_1_3 test_group_13
#define numb_case_13_8_1_3 "13.8.1.3"
#define name_case_13_8_1_3 "Fatal and non-fatal errors -- T_EXDATA_REQ - EPROTO - TS_WCON_CREQ"
#define sref_case_13_8_1_3 sref_case_13
#define desc_case_13_8_1_3 "\
Checks that the EPROTO error is returned in response to a T_EXDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_EXDATA_REQ primitive."

int
test_case_13_8_1_3_conn(int child)
{
	return test_case_13_8_1(child);
}

int
test_case_13_8_1_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_8_1_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_8_1_3_conn	preamble_ts_wcon_creq_conn
#define preamble_13_8_1_3_resp	preamble_ts_wcon_creq_resp
#define preamble_13_8_1_3_list	preamble_ts_wcon_creq_list

#define postamble_13_8_1_3_conn	postamble_0
#define postamble_13_8_1_3_resp	postamble_ts_wcon_creq_resp
#define postamble_13_8_1_3_list	postamble_ts_wcon_creq_list

struct test_stream test_13_8_1_3_conn = { &preamble_13_8_1_3_conn, &test_case_13_8_1_3_conn, &postamble_13_8_1_3_conn };
struct test_stream test_13_8_1_3_resp = { &preamble_13_8_1_3_resp, &test_case_13_8_1_3_resp, &postamble_13_8_1_3_resp };
struct test_stream test_13_8_1_3_list = { &preamble_13_8_1_3_list, &test_case_13_8_1_3_list, &postamble_13_8_1_3_list };

#define tgrp_case_13_8_1_4 test_group_13
#define numb_case_13_8_1_4 "13.8.1.4"
#define name_case_13_8_1_4 "Fatal and non-fatal errors -- T_EXDATA_REQ - EPROTO - TS_WRES_CIND"
#define sref_case_13_8_1_4 sref_case_13
#define desc_case_13_8_1_4 "\
Checks that the EPROTO error is returned in response to a T_EXDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_EXDATA_REQ primitive."

int
test_case_13_8_1_4_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS) {
		state++;
		test_data = NULL;
		last_sequence = 0;
		if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_8_1_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_8_1_4_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_13_8_1(child);
}

#define preamble_13_8_1_4_conn	preamble_ts_wres_cind_conn
#define preamble_13_8_1_4_resp	preamble_ts_wres_cind_resp
#define preamble_13_8_1_4_list	preamble_ts_wres_cind_list

#define postamble_13_8_1_4_conn	postamble_ts_idle_conn
#define postamble_13_8_1_4_resp	postamble_ts_wres_cind_resp
#define postamble_13_8_1_4_list	postamble_0

struct test_stream test_13_8_1_4_conn = { &preamble_13_8_1_4_conn, &test_case_13_8_1_4_conn, &postamble_13_8_1_4_conn };
struct test_stream test_13_8_1_4_resp = { &preamble_13_8_1_4_resp, &test_case_13_8_1_4_resp, &postamble_13_8_1_4_resp };
struct test_stream test_13_8_1_4_list = { &preamble_13_8_1_4_list, &test_case_13_8_1_4_list, &postamble_13_8_1_4_list };

#define tgrp_case_13_8_1_5 test_group_13
#define numb_case_13_8_1_5 "13.8.1.5"
#define name_case_13_8_1_5 "Fatal and non-fatal errors -- T_EXDATA_REQ - EPROTO - TS_WIND_ORDREL"
#define sref_case_13_8_1_5 sref_case_13
#define desc_case_13_8_1_5 "\
Checks that the EPROTO error is returned in response to a T_EXDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_EXDATA_REQ primitive."

int
test_case_13_8_1_5_conn(int child)
{
	return test_case_13_8_1(child);
}

int
test_case_13_8_1_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_8_1_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_8_1_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_8_1_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_8_1_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_8_1_5_conn	postamble_0
#define postamble_13_8_1_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_8_1_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_8_1_5_conn = { &preamble_13_8_1_5_conn, &test_case_13_8_1_5_conn, &postamble_13_8_1_5_conn };
struct test_stream test_13_8_1_5_resp = { &preamble_13_8_1_5_resp, &test_case_13_8_1_5_resp, &postamble_13_8_1_5_resp };
struct test_stream test_13_8_1_5_list = { &preamble_13_8_1_5_list, &test_case_13_8_1_5_list, &postamble_13_8_1_5_list };

#define tgrp_case_13_8_2 test_group_13
#define numb_case_13_8_2 "13.8.2"
#define name_case_13_8_2 "Fatal and non-fatal errors -- T_EXDATA_REQ - EPROTO"
#define sref_case_13_8_2 sref_case_13
#define desc_case_13_8_2 "\
Checks that the EPROTO error is returned in response to a T_EXDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_EXDATA_REQ primitive."

int
test_case_13_8_2_conn(int child)
{
	test_data = "";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
      again:
	state++;
	expect(child, NORMAL_WAIT, __RESULT_FAILURE);
	switch (last_event) {
	case __RESULT_FAILURE:
		break;
	case __TEST_DISCON_IND:
		goto success;
	case __TEST_ORDREL_IND:
		goto again;
	default:
		goto failure;
	}
	state++;
	if (last_errno != EPROTO)
		goto failure;
      success:
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_8_2_resp(int child)
{
	test_data = "";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
      again:
	state++;
	expect(child, NORMAL_WAIT, __RESULT_FAILURE);
	switch (last_event) {
	case __RESULT_FAILURE:
		break;
	case __TEST_DISCON_IND:
		goto success;
	case __TEST_ORDREL_IND:
		goto again;
	default:
		goto failure;
	}
	state++;
	if (last_errno != EPROTO)
		goto failure;
      success:
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_8_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_8_2_conn	preamble_ts_data_xfer_conn
#define preamble_13_8_2_resp	preamble_ts_data_xfer_resp
#define preamble_13_8_2_list	preamble_ts_data_xfer_list

#define postamble_13_8_2_conn	postamble_0
#define postamble_13_8_2_resp	postamble_0
#define postamble_13_8_2_list	postamble_ts_data_xfer_list

struct test_stream test_13_8_2_conn = { &preamble_13_8_2_conn, &test_case_13_8_2_conn, &postamble_13_8_2_conn };
struct test_stream test_13_8_2_resp = { &preamble_13_8_2_resp, &test_case_13_8_2_resp, &postamble_13_8_2_resp };
struct test_stream test_13_8_2_list = { &preamble_13_8_2_list, &test_case_13_8_2_list, &postamble_13_8_2_list };

#define tgrp_case_13_9_1 test_group_13
#define numb_case_13_9_1 "13.9.1"
#define name_case_13_9_1 "Fatal and non-fatal errors -- T_INFO_REQ - EPROTO"
#define sref_case_13_9_1 sref_case_13
#define desc_case_13_9_1 "\
Checks that the EPROTO error is returned in response to a T_INFO_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_INFO_REQ primitive."

int
test_case_13_9_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_9_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_9_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_9_1_conn	preamble_1
#define preamble_13_9_1_resp	preamble_1
#define preamble_13_9_1_list	preamble_1

#define postamble_13_9_1_conn	postamble_1
#define postamble_13_9_1_resp	postamble_1
#define postamble_13_9_1_list	postamble_1

struct test_stream test_13_9_1_conn = { &preamble_13_9_1_conn, &test_case_13_9_1_conn, &postamble_13_9_1_conn };
struct test_stream test_13_9_1_resp = { &preamble_13_9_1_resp, &test_case_13_9_1_resp, &postamble_13_9_1_resp };
struct test_stream test_13_9_1_list = { &preamble_13_9_1_list, &test_case_13_9_1_list, &postamble_13_9_1_list };

#define tgrp_case_13_9_2 test_group_13
#define numb_case_13_9_2 "13.9.2"
#define name_case_13_9_2 "Fatal and non-fatal errors -- T_INFO_REQ - TSYSERR"
#define sref_case_13_9_2 sref_case_13
#define desc_case_13_9_2 "\
Checks that the TSYSERR error is returned in response to a T_INFO_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_INFO_REQ primitive."

int
test_case_13_9_2_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_9_2_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_9_2_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_9_2_conn	preamble_1
#define preamble_13_9_2_resp	preamble_1
#define preamble_13_9_2_list	preamble_1

#define postamble_13_9_2_conn	postamble_1
#define postamble_13_9_2_resp	postamble_1
#define postamble_13_9_2_list	postamble_1

struct test_stream test_13_9_2_conn = { &preamble_13_9_2_conn, &test_case_13_9_2_conn, &postamble_13_9_2_conn };
struct test_stream test_13_9_2_resp = { &preamble_13_9_2_resp, &test_case_13_9_2_resp, &postamble_13_9_2_resp };
struct test_stream test_13_9_2_list = { &preamble_13_9_2_list, &test_case_13_9_2_list, &postamble_13_9_2_list };

#define tgrp_case_13_10_1_1 test_group_13
#define numb_case_13_10_1_1 "13.10.1.1"
#define name_case_13_10_1_1 "Fatal and non-fatal errors -- T_OPTDATA_REQ - EPROTO - TS_UNBND"
#define sref_case_13_10_1_1 sref_case_13
#define desc_case_13_10_1_1 "\
Checks that the EPROTO error is returned in response to a T_OPTDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTDATA_REQ primitive."

int
test_case_13_10_1(int child)
{
	test_data = "Some data.";
	DATA_flag = 0;
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_10_1_nofail(int child)
{
	test_data = "Some data.";
	DATA_flag = 0;
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_10_1_1_conn(int child)
{
	return test_case_13_10_1(child);
}

int
test_case_13_10_1_1_resp(int child)
{
	return test_case_13_10_1(child);
}

int
test_case_13_10_1_1_list(int child)
{
	return test_case_13_10_1(child);
}

#define preamble_13_10_1_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_10_1_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_10_1_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_10_1_1_conn	postamble_0
#define postamble_13_10_1_1_resp	postamble_0
#define postamble_13_10_1_1_list	postamble_0

struct test_stream test_13_10_1_1_conn = { &preamble_13_10_1_1_conn, &test_case_13_10_1_1_conn, &postamble_13_10_1_1_conn };
struct test_stream test_13_10_1_1_resp = { &preamble_13_10_1_1_resp, &test_case_13_10_1_1_resp, &postamble_13_10_1_1_resp };
struct test_stream test_13_10_1_1_list = { &preamble_13_10_1_1_list, &test_case_13_10_1_1_list, &postamble_13_10_1_1_list };

#define tgrp_case_13_10_1_2 test_group_13
#define numb_case_13_10_1_2 "13.10.1.2"
#define name_case_13_10_1_2 "Fatal and non-fatal errors -- T_OPTDATA_REQ - EPROTO - TS_IDLE"
#define sref_case_13_10_1_2 sref_case_13
#define desc_case_13_10_1_2 "\
Checks that the EPROTO error is returned in response to a T_OPTDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTDATA_REQ primitive."

int
test_case_13_10_1_2_conn(int child)
{
	return test_case_13_10_1_nofail(child);
}

int
test_case_13_10_1_2_resp(int child)
{
	return test_case_13_10_1_nofail(child);
}

int
test_case_13_10_1_2_list(int child)
{
	return test_case_13_10_1_nofail(child);
}

#define preamble_13_10_1_2_conn	preamble_ts_idle_cots_conn
#define preamble_13_10_1_2_resp	preamble_ts_idle_cots_resp
#define preamble_13_10_1_2_list	preamble_ts_idle_cots_list

#define postamble_13_10_1_2_conn	postamble_ts_idle_cots_conn
#define postamble_13_10_1_2_resp	postamble_ts_idle_cots_resp
#define postamble_13_10_1_2_list	postamble_ts_idle_cots_list

struct test_stream test_13_10_1_2_conn = { &preamble_13_10_1_2_conn, &test_case_13_10_1_2_conn, &postamble_13_10_1_2_conn };
struct test_stream test_13_10_1_2_resp = { &preamble_13_10_1_2_resp, &test_case_13_10_1_2_resp, &postamble_13_10_1_2_resp };
struct test_stream test_13_10_1_2_list = { &preamble_13_10_1_2_list, &test_case_13_10_1_2_list, &postamble_13_10_1_2_list };

#define tgrp_case_13_10_1_3 test_group_13
#define numb_case_13_10_1_3 "13.10.1.3"
#define name_case_13_10_1_3 "Fatal and non-fatal errors -- T_OPTDATA_REQ - EPROTO - TS_WCON_CREQ"
#define sref_case_13_10_1_3 sref_case_13
#define desc_case_13_10_1_3 "\
Checks that the EPROTO error is returned in response to a T_OPTDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTDATA_REQ primitive."

int
test_case_13_10_1_3_conn(int child)
{
	return test_case_13_10_1(child);
}

int
test_case_13_10_1_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_10_1_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_10_1_3_conn	preamble_ts_wcon_creq_conn
#define preamble_13_10_1_3_resp	preamble_ts_wcon_creq_resp
#define preamble_13_10_1_3_list	preamble_ts_wcon_creq_list

#define postamble_13_10_1_3_conn	postamble_0
#define postamble_13_10_1_3_resp	postamble_ts_wcon_creq_resp
#define postamble_13_10_1_3_list	postamble_ts_wcon_creq_list

struct test_stream test_13_10_1_3_conn = { &preamble_13_10_1_3_conn, &test_case_13_10_1_3_conn, &postamble_13_10_1_3_conn };
struct test_stream test_13_10_1_3_resp = { &preamble_13_10_1_3_resp, &test_case_13_10_1_3_resp, &postamble_13_10_1_3_resp };
struct test_stream test_13_10_1_3_list = { &preamble_13_10_1_3_list, &test_case_13_10_1_3_list, &postamble_13_10_1_3_list };

#define tgrp_case_13_10_1_4 test_group_13
#define numb_case_13_10_1_4 "13.10.1.4"
#define name_case_13_10_1_4 "Fatal and non-fatal errors -- T_OPTDATA_REQ - EPROTO - TS_WRES_CIND"
#define sref_case_13_10_1_4 sref_case_13
#define desc_case_13_10_1_4 "\
Checks that the EPROTO error is returned in response to a T_OPTDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTDATA_REQ primitive."

int
test_case_13_10_1_4_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS) {
		state++;
		test_data = NULL;
		last_sequence = 0;
		if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_10_1_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_10_1_4_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_13_10_1(child);
}

#define preamble_13_10_1_4_conn	preamble_ts_wres_cind_conn
#define preamble_13_10_1_4_resp	preamble_ts_wres_cind_resp
#define preamble_13_10_1_4_list	preamble_ts_wres_cind_list

#define postamble_13_10_1_4_conn	postamble_ts_idle_conn
#define postamble_13_10_1_4_resp	postamble_ts_wres_cind_resp
#define postamble_13_10_1_4_list	postamble_0

struct test_stream test_13_10_1_4_conn = { &preamble_13_10_1_4_conn, &test_case_13_10_1_4_conn, &postamble_13_10_1_4_conn };
struct test_stream test_13_10_1_4_resp = { &preamble_13_10_1_4_resp, &test_case_13_10_1_4_resp, &postamble_13_10_1_4_resp };
struct test_stream test_13_10_1_4_list = { &preamble_13_10_1_4_list, &test_case_13_10_1_4_list, &postamble_13_10_1_4_list };

#define tgrp_case_13_10_1_5 test_group_13
#define numb_case_13_10_1_5 "13.10.1.5"
#define name_case_13_10_1_5 "Fatal and non-fatal errors -- T_OPTDATA_REQ - EPROTO - TS_WIND_ORDREL"
#define sref_case_13_10_1_5 sref_case_13
#define desc_case_13_10_1_5 "\
Checks that the EPROTO error is returned in response to a T_OPTDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTDATA_REQ primitive."

int
test_case_13_10_1_5_conn(int child)
{
	return test_case_13_10_1(child);
}

int
test_case_13_10_1_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_10_1_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_10_1_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_10_1_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_10_1_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_10_1_5_conn	postamble_0
#define postamble_13_10_1_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_10_1_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_10_1_5_conn = { &preamble_13_10_1_5_conn, &test_case_13_10_1_5_conn, &postamble_13_10_1_5_conn };
struct test_stream test_13_10_1_5_resp = { &preamble_13_10_1_5_resp, &test_case_13_10_1_5_resp, &postamble_13_10_1_5_resp };
struct test_stream test_13_10_1_5_list = { &preamble_13_10_1_5_list, &test_case_13_10_1_5_list, &postamble_13_10_1_5_list };

#define tgrp_case_13_10_2 test_group_13
#define numb_case_13_10_2 "13.10.2"
#define name_case_13_10_2 "Fatal and non-fatal errors -- T_OPTDATA_REQ - EPROTO"
#define sref_case_13_10_2 sref_case_13
#define desc_case_13_10_2 "\
Checks that the EPROTO error is returned in response to a T_OPTDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTDATA_REQ primitive."

int
test_case_13_10_2_conn(int child)
{
	test_data = "";
	DATA_flag = 0;
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_10_2_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_10_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_10_2_conn	preamble_ts_data_xfer_conn
#define preamble_13_10_2_resp	preamble_ts_data_xfer_resp
#define preamble_13_10_2_list	preamble_ts_data_xfer_list

#define postamble_13_10_2_conn	postamble_0
#define postamble_13_10_2_resp	postamble_ts_data_xfer_resp
#define postamble_13_10_2_list	postamble_ts_data_xfer_list

struct test_stream test_13_10_2_conn = { &preamble_13_10_2_conn, &test_case_13_10_2_conn, &postamble_13_10_2_conn };
struct test_stream test_13_10_2_resp = { &preamble_13_10_2_resp, &test_case_13_10_2_resp, &postamble_13_10_2_resp };
struct test_stream test_13_10_2_list = { &preamble_13_10_2_list, &test_case_13_10_2_list, &postamble_13_10_2_list };

#define tgrp_case_13_11_1 test_group_13
#define numb_case_13_11_1 "13.11.1"
#define name_case_13_11_1 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - EPROTO"
#define sref_case_13_11_1 sref_case_13
#define desc_case_13_11_1 "\
Checks that the EPROTO error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_11_1_conn	preamble_1
#define preamble_13_11_1_resp	preamble_1
#define preamble_13_11_1_list	preamble_1

#define postamble_13_11_1_conn	postamble_1
#define postamble_13_11_1_resp	postamble_1
#define postamble_13_11_1_list	postamble_1

struct test_stream test_13_11_1_conn = { &preamble_13_11_1_conn, &test_case_13_11_1_conn, &postamble_13_11_1_conn };
struct test_stream test_13_11_1_resp = { &preamble_13_11_1_resp, &test_case_13_11_1_resp, &postamble_13_11_1_resp };
struct test_stream test_13_11_1_list = { &preamble_13_11_1_list, &test_case_13_11_1_list, &postamble_13_11_1_list };

#define tgrp_case_13_11_2 test_group_13
#define numb_case_13_11_2 "13.11.2"
#define name_case_13_11_2 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - TACCES"
#define sref_case_13_11_2 sref_case_13
#define desc_case_13_11_2 "\
Checks that the TACCES error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TACCES error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_2(int child)
{
	/* if we are super user, we cannot test for access errors */
	if (getuid() == 0 || geteuid() == 0)
		goto skipped;
	state++;
	if (expect(child, NORMAL_WAIT, __EVENT_NO_MSG) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
      skipped:
	return (__RESULT_SKIPPED);
}

#define test_case_13_11_2_conn	test_case_13_11_2
#define test_case_13_11_2_resp	test_case_13_11_2
#define test_case_13_11_2_list	test_case_13_11_2

#define preamble_13_11_2_conn	preamble_0
#define preamble_13_11_2_resp	preamble_0
#define preamble_13_11_2_list	preamble_0

#define postamble_13_11_2_conn	postamble_0
#define postamble_13_11_2_resp	postamble_0
#define postamble_13_11_2_list	postamble_0

struct test_stream test_13_11_2_conn = { &preamble_13_11_2_conn, &test_case_13_11_2_conn, &postamble_13_11_2_conn };
struct test_stream test_13_11_2_resp = { &preamble_13_11_2_resp, &test_case_13_11_2_resp, &postamble_13_11_2_resp };
struct test_stream test_13_11_2_list = { &preamble_13_11_2_list, &test_case_13_11_2_list, &postamble_13_11_2_list };

#define tgrp_case_13_11_3 test_group_13
#define numb_case_13_11_3 "13.11.3"
#define name_case_13_11_3 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - TBADFLAG"
#define sref_case_13_11_3 sref_case_13
#define desc_case_13_11_3 "\
Checks that the TBADFLAG error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADFLAG error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_3(int child)
{
	test_mgmtflags = -1;
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADFLAG)
		goto failure;
	state++;
	return (__RESULT_NOTAPPL);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_13_11_3_conn	test_case_13_11_3
#define test_case_13_11_3_resp	test_case_13_11_3
#define test_case_13_11_3_list	test_case_13_11_3

#define preamble_13_11_3_conn	preamble_ts_idle_conn
#define preamble_13_11_3_resp	preamble_ts_idle_resp
#define preamble_13_11_3_list	preamble_ts_idle_list

#define postamble_13_11_3_conn	postamble_ts_idle_conn
#define postamble_13_11_3_resp	postamble_ts_idle_resp
#define postamble_13_11_3_list	postamble_ts_idle_list

struct test_stream test_13_11_3_conn = { &preamble_13_11_3_conn, &test_case_13_11_3_conn, &postamble_13_11_3_conn };
struct test_stream test_13_11_3_resp = { &preamble_13_11_3_resp, &test_case_13_11_3_resp, &postamble_13_11_3_resp };
struct test_stream test_13_11_3_list = { &preamble_13_11_3_list, &test_case_13_11_3_list, &postamble_13_11_3_list };

#define tgrp_case_13_11_4 test_group_13
#define numb_case_13_11_4 "13.11.4"
#define name_case_13_11_4 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - TBADOPT"
#define sref_case_13_11_4 sref_case_13
#define desc_case_13_11_4 "\
Checks that the TBADOPT error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TBADOPT error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_4(int child)
{
	struct {
		struct t_opthdr opt_hdr;
		t_scalar_t opt_val;
	} options = {
		{
		sizeof(struct t_opthdr) + sizeof(t_scalar_t) + 1, T_INET_IP, T_IP_TOS, T_SUCCESS}
	, 0x0};
	test_opts = &options;
	test_olen = sizeof(options);
	test_mgmtflags = T_DEFAULT;
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TBADOPT)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_13_11_4_conn	test_case_13_11_4
#define test_case_13_11_4_resp	test_case_13_11_4
#define test_case_13_11_4_list	test_case_13_11_4

#define preamble_13_11_4_conn	preamble_ts_idle_conn
#define preamble_13_11_4_resp	preamble_ts_idle_resp
#define preamble_13_11_4_list	preamble_ts_idle_list

#define postamble_13_11_4_conn	postamble_ts_idle_conn
#define postamble_13_11_4_resp	postamble_ts_idle_resp
#define postamble_13_11_4_list	postamble_ts_idle_list

struct test_stream test_13_11_4_conn = { &preamble_13_11_4_conn, &test_case_13_11_4_conn, &postamble_13_11_4_conn };
struct test_stream test_13_11_4_resp = { &preamble_13_11_4_resp, &test_case_13_11_4_resp, &postamble_13_11_4_resp };
struct test_stream test_13_11_4_list = { &preamble_13_11_4_list, &test_case_13_11_4_list, &postamble_13_11_4_list };

#define tgrp_case_13_11_5 test_group_13
#define numb_case_13_11_5 "13.11.5"
#define name_case_13_11_5 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - TOUTSTATE"
#define sref_case_13_11_5 sref_case_13
#define desc_case_13_11_5 "\
Checks that the TOUTSTATE error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_5_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_5_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_5_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_11_5_conn	preamble_1
#define preamble_13_11_5_resp	preamble_1
#define preamble_13_11_5_list	preamble_1

#define postamble_13_11_5_conn	postamble_1
#define postamble_13_11_5_resp	postamble_1
#define postamble_13_11_5_list	postamble_1

struct test_stream test_13_11_5_conn = { &preamble_13_11_5_conn, &test_case_13_11_5_conn, &postamble_13_11_5_conn };
struct test_stream test_13_11_5_resp = { &preamble_13_11_5_resp, &test_case_13_11_5_resp, &postamble_13_11_5_resp };
struct test_stream test_13_11_5_list = { &preamble_13_11_5_list, &test_case_13_11_5_list, &postamble_13_11_5_list };

#define tgrp_case_13_11_6 test_group_13
#define numb_case_13_11_6 "13.11.6"
#define name_case_13_11_6 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - TNOTSUPPORT"
#define sref_case_13_11_6 sref_case_13
#define desc_case_13_11_6 "\
Checks that the TNOTSUPPORT error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TNOTSUPPORT error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_6_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_6_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_6_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_11_6_conn	preamble_1
#define preamble_13_11_6_resp	preamble_1
#define preamble_13_11_6_list	preamble_1

#define postamble_13_11_6_conn	postamble_1
#define postamble_13_11_6_resp	postamble_1
#define postamble_13_11_6_list	postamble_1

struct test_stream test_13_11_6_conn = { &preamble_13_11_6_conn, &test_case_13_11_6_conn, &postamble_13_11_6_conn };
struct test_stream test_13_11_6_resp = { &preamble_13_11_6_resp, &test_case_13_11_6_resp, &postamble_13_11_6_resp };
struct test_stream test_13_11_6_list = { &preamble_13_11_6_list, &test_case_13_11_6_list, &postamble_13_11_6_list };

#define tgrp_case_13_11_7 test_group_13
#define numb_case_13_11_7 "13.11.7"
#define name_case_13_11_7 "Fatal and non-fatal errors -- T_OPTMGMT_REQ - TSYSERR"
#define sref_case_13_11_7 sref_case_13
#define desc_case_13_11_7 "\
Checks that the TSYSERR error is returned in response to a T_OPTMGMT_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_OPTMGMT_REQ primitive."

int
test_case_13_11_7_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_7_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_11_7_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_11_7_conn	preamble_1
#define preamble_13_11_7_resp	preamble_1
#define preamble_13_11_7_list	preamble_1

#define postamble_13_11_7_conn	postamble_1
#define postamble_13_11_7_resp	postamble_1
#define postamble_13_11_7_list	postamble_1

struct test_stream test_13_11_7_conn = { &preamble_13_11_7_conn, &test_case_13_11_7_conn, &postamble_13_11_7_conn };
struct test_stream test_13_11_7_resp = { &preamble_13_11_7_resp, &test_case_13_11_7_resp, &postamble_13_11_7_resp };
struct test_stream test_13_11_7_list = { &preamble_13_11_7_list, &test_case_13_11_7_list, &postamble_13_11_7_list };

#define tgrp_case_13_12_1_1 test_group_13
#define numb_case_13_12_1_1 "13.12.1.1"
#define name_case_13_12_1_1 "Fatal and non-fatal errors -- T_ORDREL_REQ - EPROTO - TS_UNBND"
#define sref_case_13_12_1_1 sref_case_13
#define desc_case_13_12_1_1 "\
Checks that the EPROTO error is returned in response to a T_ORDREL_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_ORDREL_REQ primitive."

int
test_case_13_12_1(int child)
{
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_12_1_1_conn(int child)
{
	return test_case_13_12_1(child);
}

int
test_case_13_12_1_1_resp(int child)
{
	return test_case_13_12_1(child);
}

int
test_case_13_12_1_1_list(int child)
{
	return test_case_13_12_1(child);
}

#define preamble_13_12_1_1_conn	preamble_ts_unbnd_cots_conn
#define preamble_13_12_1_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_13_12_1_1_list	preamble_ts_unbnd_cots_list

#define postamble_13_12_1_1_conn	postamble_0
#define postamble_13_12_1_1_resp	postamble_0
#define postamble_13_12_1_1_list	postamble_0

struct test_stream test_13_12_1_1_conn = { &preamble_13_12_1_1_conn, &test_case_13_12_1_1_conn, &postamble_13_12_1_1_conn };
struct test_stream test_13_12_1_1_resp = { &preamble_13_12_1_1_resp, &test_case_13_12_1_1_resp, &postamble_13_12_1_1_resp };
struct test_stream test_13_12_1_1_list = { &preamble_13_12_1_1_list, &test_case_13_12_1_1_list, &postamble_13_12_1_1_list };

#define tgrp_case_13_12_1_2 test_group_13
#define numb_case_13_12_1_2 "13.12.1.2"
#define name_case_13_12_1_2 "Fatal and non-fatal errors -- T_ORDREL_REQ - EPROTO - TS_IDLE"
#define sref_case_13_12_1_2 sref_case_13
#define desc_case_13_12_1_2 "\
Checks that the EPROTO error is returned in response to a T_ORDREL_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_ORDREL_REQ primitive."

int
test_case_13_12_1_2_conn(int child)
{
	return test_case_13_12_1(child);
}

int
test_case_13_12_1_2_resp(int child)
{
	return test_case_13_12_1(child);
}

int
test_case_13_12_1_2_list(int child)
{
	return test_case_13_12_1(child);
}

#define preamble_13_12_1_2_conn	preamble_ts_idle_cots_conn
#define preamble_13_12_1_2_resp	preamble_ts_idle_cots_resp
#define preamble_13_12_1_2_list	preamble_ts_idle_cots_list

#define postamble_13_12_1_2_conn	postamble_0
#define postamble_13_12_1_2_resp	postamble_0
#define postamble_13_12_1_2_list	postamble_0

struct test_stream test_13_12_1_2_conn = { &preamble_13_12_1_2_conn, &test_case_13_12_1_2_conn, &postamble_13_12_1_2_conn };
struct test_stream test_13_12_1_2_resp = { &preamble_13_12_1_2_resp, &test_case_13_12_1_2_resp, &postamble_13_12_1_2_resp };
struct test_stream test_13_12_1_2_list = { &preamble_13_12_1_2_list, &test_case_13_12_1_2_list, &postamble_13_12_1_2_list };

#define tgrp_case_13_12_1_3 test_group_13
#define numb_case_13_12_1_3 "13.12.1.3"
#define name_case_13_12_1_3 "Fatal and non-fatal errors -- T_ORDREL_REQ - EPROTO - TS_WCON_CREQ"
#define sref_case_13_12_1_3 sref_case_13
#define desc_case_13_12_1_3 "\
Checks that the EPROTO error is returned in response to a T_ORDREL_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_ORDREL_REQ primitive."

int
test_case_13_12_1_3_conn(int child)
{
	return test_case_13_12_1(child);
}

int
test_case_13_12_1_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_12_1_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_12_1_3_conn	preamble_ts_wcon_creq_conn
#define preamble_13_12_1_3_resp	preamble_ts_wcon_creq_resp
#define preamble_13_12_1_3_list	preamble_ts_wcon_creq_list

#define postamble_13_12_1_3_conn	postamble_0
#define postamble_13_12_1_3_resp	postamble_ts_wcon_creq_resp
#define postamble_13_12_1_3_list	postamble_ts_wcon_creq_list

struct test_stream test_13_12_1_3_conn = { &preamble_13_12_1_3_conn, &test_case_13_12_1_3_conn, &postamble_13_12_1_3_conn };
struct test_stream test_13_12_1_3_resp = { &preamble_13_12_1_3_resp, &test_case_13_12_1_3_resp, &postamble_13_12_1_3_resp };
struct test_stream test_13_12_1_3_list = { &preamble_13_12_1_3_list, &test_case_13_12_1_3_list, &postamble_13_12_1_3_list };

#define tgrp_case_13_12_1_4 test_group_13
#define numb_case_13_12_1_4 "13.12.1.4"
#define name_case_13_12_1_4 "Fatal and non-fatal errors -- T_ORDREL_REQ - EPROTO - TS_WRES_CIND"
#define sref_case_13_12_1_4 sref_case_13
#define desc_case_13_12_1_4 "\
Checks that the EPROTO error is returned in response to a T_ORDREL_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_ORDREL_REQ primitive."

int
test_case_13_12_1_4_conn(int child)
{
	if (expect(child, NORMAL_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS) {
		state++;
		test_data = NULL;
		last_sequence = 0;
		if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
			goto failure;
		state++;
		if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
			goto failure;
	}
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_12_1_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_12_1_4_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_13_12_1(child);
}

#define preamble_13_12_1_4_conn	preamble_ts_wres_cind_conn
#define preamble_13_12_1_4_resp	preamble_ts_wres_cind_resp
#define preamble_13_12_1_4_list	preamble_ts_wres_cind_list

#define postamble_13_12_1_4_conn	postamble_ts_idle_conn
#define postamble_13_12_1_4_resp	postamble_ts_wres_cind_resp
#define postamble_13_12_1_4_list	postamble_0

struct test_stream test_13_12_1_4_conn = { &preamble_13_12_1_4_conn, &test_case_13_12_1_4_conn, &postamble_13_12_1_4_conn };
struct test_stream test_13_12_1_4_resp = { &preamble_13_12_1_4_resp, &test_case_13_12_1_4_resp, &postamble_13_12_1_4_resp };
struct test_stream test_13_12_1_4_list = { &preamble_13_12_1_4_list, &test_case_13_12_1_4_list, &postamble_13_12_1_4_list };

#define tgrp_case_13_12_1_5 test_group_13
#define numb_case_13_12_1_5 "13.12.1.5"
#define name_case_13_12_1_5 "Fatal and non-fatal errors -- T_ORDREL_REQ - EPROTO - TS_WIND_ORDREL"
#define sref_case_13_12_1_5 sref_case_13
#define desc_case_13_12_1_5 "\
Checks that the EPROTO error is returned in response to a T_ORDREL_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_ORDREL_REQ primitive."

int
test_case_13_12_1_5_conn(int child)
{
	return test_case_13_12_1(child);
}

int
test_case_13_12_1_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_12_1_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_12_1_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_12_1_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_12_1_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_12_1_5_conn	postamble_0
#define postamble_13_12_1_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_12_1_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_12_1_5_conn = { &preamble_13_12_1_5_conn, &test_case_13_12_1_5_conn, &postamble_13_12_1_5_conn };
struct test_stream test_13_12_1_5_resp = { &preamble_13_12_1_5_resp, &test_case_13_12_1_5_resp, &postamble_13_12_1_5_resp };
struct test_stream test_13_12_1_5_list = { &preamble_13_12_1_5_list, &test_case_13_12_1_5_list, &postamble_13_12_1_5_list };

#define tgrp_case_13_13_1 test_group_13
#define numb_case_13_13_1 "13.13.1"
#define name_case_13_13_1 "Fatal and non-fatal errors -- T_UNBIND_REQ - EPROTO"
#define sref_case_13_13_1 sref_case_13
#define desc_case_13_13_1 "\
Checks that the EPROTO error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_1_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_13_1_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_13_1_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_13_1_conn	preamble_1
#define preamble_13_13_1_resp	preamble_1
#define preamble_13_13_1_list	preamble_1

#define postamble_13_13_1_conn	postamble_1
#define postamble_13_13_1_resp	postamble_1
#define postamble_13_13_1_list	postamble_1

struct test_stream test_13_13_1_conn = { &preamble_13_13_1_conn, &test_case_13_13_1_conn, &postamble_13_13_1_conn };
struct test_stream test_13_13_1_resp = { &preamble_13_13_1_resp, &test_case_13_13_1_resp, &postamble_13_13_1_resp };
struct test_stream test_13_13_1_list = { &preamble_13_13_1_list, &test_case_13_13_1_list, &postamble_13_13_1_list };

#define tgrp_case_13_13_2_1 test_group_13
#define numb_case_13_13_2_1 "13.13.2.1"
#define name_case_13_13_2_1 "Fatal and non-fatal errors -- T_UNBIND_REQ - TOUTSTATE - TS_UNBND"
#define sref_case_13_13_2_1 sref_case_13
#define desc_case_13_13_2_1 "\
Checks that the TOUTSTATE error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_2(int child)
{
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ERROR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_t_errno != TOUTSTATE)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_13_2_1_conn(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_1_resp(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_1_list(int child)
{
	return test_case_13_13_2(child);
}

#define preamble_13_13_2_1_conn	preamble_ts_unbnd_conn
#define preamble_13_13_2_1_resp	preamble_ts_unbnd_resp
#define preamble_13_13_2_1_list	preamble_ts_unbnd_list

#define postamble_13_13_2_1_conn	postamble_ts_unbnd_conn
#define postamble_13_13_2_1_resp	postamble_ts_unbnd_resp
#define postamble_13_13_2_1_list	postamble_ts_unbnd_list

struct test_stream test_13_13_2_1_conn = { &preamble_13_13_2_1_conn, &test_case_13_13_2_1_conn, &postamble_13_13_2_1_conn };
struct test_stream test_13_13_2_1_resp = { &preamble_13_13_2_1_resp, &test_case_13_13_2_1_resp, &postamble_13_13_2_1_resp };
struct test_stream test_13_13_2_1_list = { &preamble_13_13_2_1_list, &test_case_13_13_2_1_list, &postamble_13_13_2_1_list };

#define tgrp_case_13_13_2_2 test_group_13
#define numb_case_13_13_2_2 "13.13.2.2"
#define name_case_13_13_2_2 "Fatal and non-fatal errors -- T_UNBIND_REQ - TOUTSTATE - TS_WCON_CREQ"
#define sref_case_13_13_2_2 sref_case_13
#define desc_case_13_13_2_2 "\
Checks that the TOUTSTATE error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_2_2_conn(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_2_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_13_2_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_13_2_2_conn	preamble_ts_wcon_creq_conn
#define preamble_13_13_2_2_resp	preamble_ts_wcon_creq_resp
#define preamble_13_13_2_2_list	preamble_ts_wcon_creq_list

#define postamble_13_13_2_2_conn	postamble_ts_wcon_creq_conn
#define postamble_13_13_2_2_resp	postamble_ts_wcon_creq_resp
#define postamble_13_13_2_2_list	postamble_ts_wcon_creq_list

struct test_stream test_13_13_2_2_conn = { &preamble_13_13_2_2_conn, &test_case_13_13_2_2_conn, &postamble_13_13_2_2_conn };
struct test_stream test_13_13_2_2_resp = { &preamble_13_13_2_2_resp, &test_case_13_13_2_2_resp, &postamble_13_13_2_2_resp };
struct test_stream test_13_13_2_2_list = { &preamble_13_13_2_2_list, &test_case_13_13_2_2_list, &postamble_13_13_2_2_list };

#define tgrp_case_13_13_2_3 test_group_13
#define numb_case_13_13_2_3 "13.13.2.3"
#define name_case_13_13_2_3 "Fatal and non-fatal errors -- T_UNBIND_REQ - TOUTSTATE - TS_WRES_CIND"
#define sref_case_13_13_2_3 sref_case_13
#define desc_case_13_13_2_3 "\
Checks that the TOUTSTATE error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_2_3_conn(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_13_13_2_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_13_2_3_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_13_13_2(child);
}

#define preamble_13_13_2_3_conn	preamble_ts_wres_cind_conn
#define preamble_13_13_2_3_resp	preamble_ts_wres_cind_resp
#define preamble_13_13_2_3_list	preamble_ts_wres_cind_list

#define postamble_13_13_2_3_conn	postamble_ts_wres_cind_conn
#define postamble_13_13_2_3_resp	postamble_ts_wres_cind_resp
#define postamble_13_13_2_3_list	postamble_ts_wres_cind_list

struct test_stream test_13_13_2_3_conn = { &preamble_13_13_2_3_conn, &test_case_13_13_2_3_conn, &postamble_13_13_2_3_conn };
struct test_stream test_13_13_2_3_resp = { &preamble_13_13_2_3_resp, &test_case_13_13_2_3_resp, &postamble_13_13_2_3_resp };
struct test_stream test_13_13_2_3_list = { &preamble_13_13_2_3_list, &test_case_13_13_2_3_list, &postamble_13_13_2_3_list };

#define tgrp_case_13_13_2_4 test_group_13
#define numb_case_13_13_2_4 "13.13.2.4"
#define name_case_13_13_2_4 "Fatal and non-fatal errors -- T_UNBIND_REQ - TOUTSTATE - TS_DATA_XFER"
#define sref_case_13_13_2_4 sref_case_13
#define desc_case_13_13_2_4 "\
Checks that the TOUTSTATE error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_2_4_conn(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_4_resp(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_13_2_4_conn	preamble_ts_data_xfer_conn
#define preamble_13_13_2_4_resp	preamble_ts_data_xfer_resp
#define preamble_13_13_2_4_list	preamble_ts_data_xfer_list

#define postamble_13_13_2_4_conn	postamble_ts_data_xfer_conn
#define postamble_13_13_2_4_resp	postamble_ts_data_xfer_resp
#define postamble_13_13_2_4_list	postamble_ts_data_xfer_list

struct test_stream test_13_13_2_4_conn = { &preamble_13_13_2_4_conn, &test_case_13_13_2_4_conn, &postamble_13_13_2_4_conn };
struct test_stream test_13_13_2_4_resp = { &preamble_13_13_2_4_resp, &test_case_13_13_2_4_resp, &postamble_13_13_2_4_resp };
struct test_stream test_13_13_2_4_list = { &preamble_13_13_2_4_list, &test_case_13_13_2_4_list, &postamble_13_13_2_4_list };

#define tgrp_case_13_13_2_5 test_group_13
#define numb_case_13_13_2_5 "13.13.2.5"
#define name_case_13_13_2_5 "Fatal and non-fatal errors -- T_UNBIND_REQ - TOUTSTATE - TS_WIND_ORDREL"
#define sref_case_13_13_2_5 sref_case_13
#define desc_case_13_13_2_5 "\
Checks that the TOUTSTATE error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_2_5_conn(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_5_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_13_2_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_13_2_5_conn	preamble_ts_wind_ordrel_conn
#define preamble_13_13_2_5_resp	preamble_ts_wind_ordrel_resp
#define preamble_13_13_2_5_list	preamble_ts_wind_ordrel_list

#define postamble_13_13_2_5_conn	postamble_ts_wind_ordrel_conn
#define postamble_13_13_2_5_resp	postamble_ts_wind_ordrel_resp
#define postamble_13_13_2_5_list	postamble_ts_wind_ordrel_list

struct test_stream test_13_13_2_5_conn = { &preamble_13_13_2_5_conn, &test_case_13_13_2_5_conn, &postamble_13_13_2_5_conn };
struct test_stream test_13_13_2_5_resp = { &preamble_13_13_2_5_resp, &test_case_13_13_2_5_resp, &postamble_13_13_2_5_resp };
struct test_stream test_13_13_2_5_list = { &preamble_13_13_2_5_list, &test_case_13_13_2_5_list, &postamble_13_13_2_5_list };

#define tgrp_case_13_13_2_6 test_group_13
#define numb_case_13_13_2_6 "13.13.2.6"
#define name_case_13_13_2_6 "Fatal and non-fatal errors -- T_UNBIND_REQ - TOUTSTATE - TS_WREQ_ORDREL"
#define sref_case_13_13_2_6 sref_case_13
#define desc_case_13_13_2_6 "\
Checks that the TOUTSTATE error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TOUTSTATE error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_2_6_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_13_13_2_6_resp(int child)
{
	return test_case_13_13_2(child);
}

int
test_case_13_13_2_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_13_13_2_6_conn	preamble_ts_wreq_ordrel_conn
#define preamble_13_13_2_6_resp	preamble_ts_wreq_ordrel_resp
#define preamble_13_13_2_6_list	preamble_ts_wreq_ordrel_list

#define postamble_13_13_2_6_conn	postamble_ts_wreq_ordrel_conn
#define postamble_13_13_2_6_resp	postamble_ts_wreq_ordrel_resp
#define postamble_13_13_2_6_list	postamble_ts_wreq_ordrel_list

struct test_stream test_13_13_2_6_conn = { &preamble_13_13_2_6_conn, &test_case_13_13_2_6_conn, &postamble_13_13_2_6_conn };
struct test_stream test_13_13_2_6_resp = { &preamble_13_13_2_6_resp, &test_case_13_13_2_6_resp, &postamble_13_13_2_6_resp };
struct test_stream test_13_13_2_6_list = { &preamble_13_13_2_6_list, &test_case_13_13_2_6_list, &postamble_13_13_2_6_list };

#define tgrp_case_13_13_3 test_group_13
#define numb_case_13_13_3 "13.13.3"
#define name_case_13_13_3 "Fatal and non-fatal errors -- T_UNBIND_REQ - TSYSERR"
#define sref_case_13_13_3 sref_case_13
#define desc_case_13_13_3 "\
Checks that the TSYSERR error is returned in response to a T_UNBIND_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the TSYSERR error\n\
for the T_UNBIND_REQ primitive."

int
test_case_13_13_3_conn(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_13_3_resp(int child)
{
	return (__RESULT_NOTAPPL);
}

int
test_case_13_13_3_list(int child)
{
	return (__RESULT_NOTAPPL);
}

#define preamble_13_13_3_conn	preamble_1
#define preamble_13_13_3_resp	preamble_1
#define preamble_13_13_3_list	preamble_1

#define postamble_13_13_3_conn	postamble_1
#define postamble_13_13_3_resp	postamble_1
#define postamble_13_13_3_list	postamble_1

struct test_stream test_13_13_3_conn = { &preamble_13_13_3_conn, &test_case_13_13_3_conn, &postamble_13_13_3_conn };
struct test_stream test_13_13_3_resp = { &preamble_13_13_3_resp, &test_case_13_13_3_resp, &postamble_13_13_3_resp };
struct test_stream test_13_13_3_list = { &preamble_13_13_3_list, &test_case_13_13_3_list, &postamble_13_13_3_list };

#define tgrp_case_13_14_1_1 test_group_13
#define numb_case_13_14_1_1 "13.14.1.1"
#define name_case_13_14_1_1 "Fatal and non-fatal errors -- T_UNITDATA_REQ - EPROTO - TS_UNBND"
#define sref_case_13_14_1_1 sref_case_13
#define desc_case_13_14_1_1 "\
Checks that the EPROTO error is returned in response to a T_UNITDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_UNITDATA_REQ primitive."

int
test_case_13_14_1(int child)
{
	test_data = "Some data.";
	test_addr = addrs[(child + 1) % 3];
	test_alen = anums[(child + 1) % 3]*sizeof(addrs[(child + 1) % 3][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_13_14_1_1_conn(int child)
{
	return test_case_13_14_1(child);
}

int
test_case_13_14_1_1_resp(int child)
{
	return test_case_13_14_1(child);
}

int
test_case_13_14_1_1_list(int child)
{
	return test_case_13_14_1(child);
}

#define preamble_13_14_1_1_conn	preamble_ts_unbnd_clts_conn
#define preamble_13_14_1_1_resp	preamble_ts_unbnd_clts_resp
#define preamble_13_14_1_1_list	preamble_ts_unbnd_clts_list

#define postamble_13_14_1_1_conn	postamble_0
#define postamble_13_14_1_1_resp	postamble_0
#define postamble_13_14_1_1_list	postamble_0

struct test_stream test_13_14_1_1_conn = { &preamble_13_14_1_1_conn, &test_case_13_14_1_1_conn, &postamble_13_14_1_1_conn };
struct test_stream test_13_14_1_1_resp = { &preamble_13_14_1_1_resp, &test_case_13_14_1_1_resp, &postamble_13_14_1_1_resp };
struct test_stream test_13_14_1_1_list = { &preamble_13_14_1_1_list, &test_case_13_14_1_1_list, &postamble_13_14_1_1_list };

#define tgrp_case_13_14_2 test_group_13
#define numb_case_13_14_2 "13.14.2"
#define name_case_13_14_2 "Fatal and non-fatal errors -- T_UNITDATA_REQ - EPROTO"
#define sref_case_13_14_2 sref_case_13
#define desc_case_13_14_2 "\
Checks that the EPROTO error is returned in response to a T_UNITDATA_REQ primitive under\n\
proper circumstances.  The TPI specification lists under each primitive which\n\
fatal and non-fatal errors are permitted.  This test case tests the EPROTO error\n\
for the T_UNITDATA_REQ primitive."

int
test_case_13_14_2(int child)
{
	test_data = "";
	test_addr = addrs[(child + 1) % 3];
	test_alen = anums[(child + 1) % 3]*sizeof(addrs[(child + 1) % 3][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __RESULT_FAILURE) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_errno != EPROTO)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_13_14_2_conn	test_case_13_14_2
#define test_case_13_14_2_resp	test_case_13_14_2
#define test_case_13_14_2_list	test_case_13_14_2

#define preamble_13_14_2_conn	preamble_ts_idle_clts_conn
#define preamble_13_14_2_resp	preamble_ts_idle_clts_resp
#define preamble_13_14_2_list	preamble_ts_idle_clts_list

#define postamble_13_14_2_conn	postamble_0
#define postamble_13_14_2_resp	postamble_0
#define postamble_13_14_2_list	postamble_0

struct test_stream test_13_14_2_conn = { &preamble_13_14_2_conn, &test_case_13_14_2_conn, &postamble_13_14_2_conn };
struct test_stream test_13_14_2_resp = { &preamble_13_14_2_resp, &test_case_13_14_2_resp, &postamble_13_14_2_resp };
struct test_stream test_13_14_2_list = { &preamble_13_14_2_list, &test_case_13_14_2_list, &postamble_13_14_2_list };

#define test_group_14 "Allowable states."
#define sref_case_14 "TPI Version 2 Draft 2 -- Chapter 2"

#define tgrp_case_14_1_1 test_group_14
#define numb_case_14_1_1 "14.1.1"
#define name_case_14_1_1 "Allowable states -- T_ADDR_REQ -- TS_UNBND"
#define sref_case_14_1_1 sref_case_14
#define desc_case_14_1_1 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_UNBND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_UNBND state."

int
test_case_14_1(int child)
{
	if (do_signal(child, __TEST_ADDR_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_ADDR_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_14_1_1_conn	test_case_14_1
#define test_case_14_1_1_resp	test_case_14_1
#define test_case_14_1_1_list	test_case_14_1

#define preamble_14_1_1_conn	preamble_ts_unbnd_conn
#define preamble_14_1_1_resp	preamble_ts_unbnd_resp
#define preamble_14_1_1_list	preamble_ts_unbnd_list

#define postamble_14_1_1_conn	postamble_ts_unbnd_conn
#define postamble_14_1_1_resp	postamble_ts_unbnd_resp
#define postamble_14_1_1_list	postamble_ts_unbnd_list

struct test_stream test_14_1_1_conn = { &preamble_14_1_1_conn, &test_case_14_1_1_conn, &postamble_14_1_1_conn };
struct test_stream test_14_1_1_resp = { &preamble_14_1_1_resp, &test_case_14_1_1_resp, &postamble_14_1_1_resp };
struct test_stream test_14_1_1_list = { &preamble_14_1_1_list, &test_case_14_1_1_list, &postamble_14_1_1_list };

#define tgrp_case_14_1_2 test_group_14
#define numb_case_14_1_2 "14.1.2"
#define name_case_14_1_2 "Allowable states -- T_ADDR_REQ -- TS_IDLE"
#define sref_case_14_1_2 sref_case_14
#define desc_case_14_1_2 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_IDLE state."

#define test_case_14_1_2_conn	test_case_14_1
#define test_case_14_1_2_resp	test_case_14_1
#define test_case_14_1_2_list	test_case_14_1

#define preamble_14_1_2_conn	preamble_ts_idle_conn
#define preamble_14_1_2_resp	preamble_ts_idle_resp
#define preamble_14_1_2_list	preamble_ts_idle_list

#define postamble_14_1_2_conn	postamble_ts_idle_conn
#define postamble_14_1_2_resp	postamble_ts_idle_resp
#define postamble_14_1_2_list	postamble_ts_idle_list

struct test_stream test_14_1_2_conn = { &preamble_14_1_2_conn, &test_case_14_1_2_conn, &postamble_14_1_2_conn };
struct test_stream test_14_1_2_resp = { &preamble_14_1_2_resp, &test_case_14_1_2_resp, &postamble_14_1_2_resp };
struct test_stream test_14_1_2_list = { &preamble_14_1_2_list, &test_case_14_1_2_list, &postamble_14_1_2_list };

#define tgrp_case_14_1_3 test_group_14
#define numb_case_14_1_3 "14.1.3"
#define name_case_14_1_3 "Allowable states -- T_ADDR_REQ -- TS_WCON_CREQ"
#define sref_case_14_1_3 sref_case_14
#define desc_case_14_1_3 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_WCON_CREQ.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_WCON_CREQ state."

int
test_case_14_1_3_conn(int child)
{
	return test_case_14_1(child);
}

int
test_case_14_1_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_1_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_1_3_conn	preamble_ts_wcon_creq_conn
#define preamble_14_1_3_resp	preamble_ts_wcon_creq_resp
#define preamble_14_1_3_list	preamble_ts_wcon_creq_list

#define postamble_14_1_3_conn	postamble_ts_wcon_creq_conn
#define postamble_14_1_3_resp	postamble_ts_wcon_creq_resp
#define postamble_14_1_3_list	postamble_ts_wcon_creq_list

struct test_stream test_14_1_3_conn = { &preamble_14_1_3_conn, &test_case_14_1_3_conn, &postamble_14_1_3_conn };
struct test_stream test_14_1_3_resp = { &preamble_14_1_3_resp, &test_case_14_1_3_resp, &postamble_14_1_3_resp };
struct test_stream test_14_1_3_list = { &preamble_14_1_3_list, &test_case_14_1_3_list, &postamble_14_1_3_list };

#define tgrp_case_14_1_4 test_group_14
#define numb_case_14_1_4 "14.1.4"
#define name_case_14_1_4 "Allowable states -- T_ADDR_REQ -- TS_WRES_CIND"
#define sref_case_14_1_4 sref_case_14
#define desc_case_14_1_4 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_WRES_CIND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_WRES_CIND state."

int
test_case_14_1_4_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_1_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_1_4_list(int child)
{
	return test_case_14_1(child);
}

#define preamble_14_1_4_conn	preamble_ts_wres_cind_conn
#define preamble_14_1_4_resp	preamble_ts_wres_cind_resp
#define preamble_14_1_4_list	preamble_ts_wres_cind_list

#define postamble_14_1_4_conn	postamble_ts_wres_cind_conn
#define postamble_14_1_4_resp	postamble_ts_wres_cind_resp
#define postamble_14_1_4_list	postamble_ts_wres_cind_list

struct test_stream test_14_1_4_conn = { &preamble_14_1_4_conn, &test_case_14_1_4_conn, &postamble_14_1_4_conn };
struct test_stream test_14_1_4_resp = { &preamble_14_1_4_resp, &test_case_14_1_4_resp, &postamble_14_1_4_resp };
struct test_stream test_14_1_4_list = { &preamble_14_1_4_list, &test_case_14_1_4_list, &postamble_14_1_4_list };

#define tgrp_case_14_1_5 test_group_14
#define numb_case_14_1_5 "14.1.5"
#define name_case_14_1_5 "Allowable states -- T_ADDR_REQ -- TS_DATA_XFER"
#define sref_case_14_1_5 sref_case_14
#define desc_case_14_1_5 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_1_5_conn(int child)
{
	return test_case_14_1(child);
}

int
test_case_14_1_5_resp(int child)
{
	return test_case_14_1(child);
}

int
test_case_14_1_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_1_5_conn	preamble_ts_data_xfer_conn
#define preamble_14_1_5_resp	preamble_ts_data_xfer_resp
#define preamble_14_1_5_list	preamble_ts_data_xfer_list

#define postamble_14_1_5_conn	postamble_ts_data_xfer_conn
#define postamble_14_1_5_resp	postamble_ts_data_xfer_resp
#define postamble_14_1_5_list	postamble_ts_data_xfer_list

struct test_stream test_14_1_5_conn = { &preamble_14_1_5_conn, &test_case_14_1_5_conn, &postamble_14_1_5_conn };
struct test_stream test_14_1_5_resp = { &preamble_14_1_5_resp, &test_case_14_1_5_resp, &postamble_14_1_5_resp };
struct test_stream test_14_1_5_list = { &preamble_14_1_5_list, &test_case_14_1_5_list, &postamble_14_1_5_list };

#define tgrp_case_14_1_6 test_group_14
#define numb_case_14_1_6 "14.1.6"
#define name_case_14_1_6 "Allowable states -- T_ADDR_REQ -- TS_WIND_ORDREL"
#define sref_case_14_1_6 sref_case_14
#define desc_case_14_1_6 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_WIND_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_WIND_ORDREL state."

int
test_case_14_1_6_conn(int child)
{
	return test_case_14_1(child);
}

int
test_case_14_1_6_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_1_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_1_6_conn	preamble_ts_wind_ordrel_conn
#define preamble_14_1_6_resp	preamble_ts_wind_ordrel_resp
#define preamble_14_1_6_list	preamble_ts_wind_ordrel_list

#define postamble_14_1_6_conn	postamble_ts_wind_ordrel_conn
#define postamble_14_1_6_resp	postamble_ts_wind_ordrel_resp
#define postamble_14_1_6_list	postamble_ts_wind_ordrel_list

struct test_stream test_14_1_6_conn = { &preamble_14_1_6_conn, &test_case_14_1_6_conn, &postamble_14_1_6_conn };
struct test_stream test_14_1_6_resp = { &preamble_14_1_6_resp, &test_case_14_1_6_resp, &postamble_14_1_6_resp };
struct test_stream test_14_1_6_list = { &preamble_14_1_6_list, &test_case_14_1_6_list, &postamble_14_1_6_list };

#define tgrp_case_14_1_7 test_group_14
#define numb_case_14_1_7 "14.1.7"
#define name_case_14_1_7 "Allowable states -- T_ADDR_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_1_7 sref_case_14
#define desc_case_14_1_7 "\
Checks that the T_ADDR_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ADDR_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_1_7_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_1_7_resp(int child)
{
	return test_case_14_1(child);
}

int
test_case_14_1_7_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_1_7_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_1_7_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_1_7_list	preamble_ts_wreq_ordrel_list

#define postamble_14_1_7_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_1_7_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_1_7_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_1_7_conn = { &preamble_14_1_7_conn, &test_case_14_1_7_conn, &postamble_14_1_7_conn };
struct test_stream test_14_1_7_resp = { &preamble_14_1_7_resp, &test_case_14_1_7_resp, &postamble_14_1_7_resp };
struct test_stream test_14_1_7_list = { &preamble_14_1_7_list, &test_case_14_1_7_list, &postamble_14_1_7_list };

#define tgrp_case_14_2_1 test_group_14
#define numb_case_14_2_1 "14.2.1"
#define name_case_14_2_1 "Allowable states -- T_BIND_REQ -- TS_UNBND"
#define sref_case_14_2_1 sref_case_14
#define desc_case_14_2_1 "\
Checks that the T_BIND_REQ primitive can be successfully issued in the allowed state\n\
TS_UNBND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_BIND_REQ primitive in the TS_UNBND state."

int
test_case_14_2(int child)
{
	test_addr = addrs[child];
	test_alen = anums[child]*sizeof(addrs[child][0]);
	last_qlen = (child == 2) ? 5 : 0;
	if (do_signal(child, __TEST_BIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_BIND_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_14_2_1_conn	test_case_14_2
#define test_case_14_2_1_resp	test_case_14_2
#define test_case_14_2_1_list	test_case_14_2

#define preamble_14_2_1_conn	preamble_ts_unbnd_conn
#define preamble_14_2_1_resp	preamble_ts_unbnd_resp
#define preamble_14_2_1_list	preamble_ts_unbnd_list

#define postamble_14_2_1_conn	postamble_ts_idle_conn
#define postamble_14_2_1_resp	postamble_ts_idle_resp
#define postamble_14_2_1_list	postamble_ts_idle_list

struct test_stream test_14_2_1_conn = { &preamble_14_2_1_conn, &test_case_14_2_1_conn, &postamble_14_2_1_conn };
struct test_stream test_14_2_1_resp = { &preamble_14_2_1_resp, &test_case_14_2_1_resp, &postamble_14_2_1_resp };
struct test_stream test_14_2_1_list = { &preamble_14_2_1_list, &test_case_14_2_1_list, &postamble_14_2_1_list };

#define tgrp_case_14_3_1 test_group_14
#define numb_case_14_3_1 "14.3.1"
#define name_case_14_3_1 "Allowable states -- T_CAPABILITY_REQ -- TS_UNBND"
#define sref_case_14_3_1 sref_case_14
#define desc_case_14_3_1 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_UNBND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_UNBND state."

int
test_case_14_3(int child)
{
	test_prio = 1;
	if (do_signal(child, __TEST_CAPABILITY_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_CAPABILITY_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define test_case_14_3_1_conn	test_case_14_3
#define test_case_14_3_1_resp	test_case_14_3
#define test_case_14_3_1_list	test_case_14_3

#define preamble_14_3_1_conn	preamble_ts_unbnd_conn
#define preamble_14_3_1_resp	preamble_ts_unbnd_resp
#define preamble_14_3_1_list	preamble_ts_unbnd_list

#define postamble_14_3_1_conn	postamble_ts_unbnd_conn
#define postamble_14_3_1_resp	postamble_ts_unbnd_resp
#define postamble_14_3_1_list	postamble_ts_unbnd_list

struct test_stream test_14_3_1_conn = { &preamble_14_3_1_conn, &test_case_14_3_1_conn, &postamble_14_3_1_conn };
struct test_stream test_14_3_1_resp = { &preamble_14_3_1_resp, &test_case_14_3_1_resp, &postamble_14_3_1_resp };
struct test_stream test_14_3_1_list = { &preamble_14_3_1_list, &test_case_14_3_1_list, &postamble_14_3_1_list };

#define tgrp_case_14_3_2 test_group_14
#define numb_case_14_3_2 "14.3.2"
#define name_case_14_3_2 "Allowable states -- T_CAPABILITY_REQ -- TS_IDLE"
#define sref_case_14_3_2 sref_case_14
#define desc_case_14_3_2 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_IDLE state."

#define test_case_14_3_2_conn	test_case_14_3
#define test_case_14_3_2_resp	test_case_14_3
#define test_case_14_3_2_list	test_case_14_3

#define preamble_14_3_2_conn	preamble_ts_idle_conn
#define preamble_14_3_2_resp	preamble_ts_idle_resp
#define preamble_14_3_2_list	preamble_ts_idle_list

#define postamble_14_3_2_conn	postamble_ts_idle_conn
#define postamble_14_3_2_resp	postamble_ts_idle_resp
#define postamble_14_3_2_list	postamble_ts_idle_list

struct test_stream test_14_3_2_conn = { &preamble_14_3_2_conn, &test_case_14_3_2_conn, &postamble_14_3_2_conn };
struct test_stream test_14_3_2_resp = { &preamble_14_3_2_resp, &test_case_14_3_2_resp, &postamble_14_3_2_resp };
struct test_stream test_14_3_2_list = { &preamble_14_3_2_list, &test_case_14_3_2_list, &postamble_14_3_2_list };

#define tgrp_case_14_3_3 test_group_14
#define numb_case_14_3_3 "14.3.3"
#define name_case_14_3_3 "Allowable states -- T_CAPABILITY_REQ -- TS_WCON_CREQ"
#define sref_case_14_3_3 sref_case_14
#define desc_case_14_3_3 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_WCON_CREQ.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_WCON_CREQ state."

int
test_case_14_3_3_conn(int child)
{
	return test_case_14_3(child);
}

int
test_case_14_3_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_3_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_3_3_conn	preamble_ts_wcon_creq_conn
#define preamble_14_3_3_resp	preamble_ts_wcon_creq_resp
#define preamble_14_3_3_list	preamble_ts_wcon_creq_list

#define postamble_14_3_3_conn	postamble_ts_wcon_creq_conn
#define postamble_14_3_3_resp	postamble_ts_wcon_creq_resp
#define postamble_14_3_3_list	postamble_ts_wcon_creq_list

struct test_stream test_14_3_3_conn = { &preamble_14_3_3_conn, &test_case_14_3_3_conn, &postamble_14_3_3_conn };
struct test_stream test_14_3_3_resp = { &preamble_14_3_3_resp, &test_case_14_3_3_resp, &postamble_14_3_3_resp };
struct test_stream test_14_3_3_list = { &preamble_14_3_3_list, &test_case_14_3_3_list, &postamble_14_3_3_list };

#define tgrp_case_14_3_4 test_group_14
#define numb_case_14_3_4 "14.3.4"
#define name_case_14_3_4 "Allowable states -- T_CAPABILITY_REQ -- TS_WRES_CIND"
#define sref_case_14_3_4 sref_case_14
#define desc_case_14_3_4 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_WRES_CIND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_WRES_CIND state."

int
test_case_14_3_4_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_3_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_3_4_list(int child)
{
	return test_case_14_3(child);
}

#define preamble_14_3_4_conn	preamble_ts_wres_cind_conn
#define preamble_14_3_4_resp	preamble_ts_wres_cind_resp
#define preamble_14_3_4_list	preamble_ts_wres_cind_list

#define postamble_14_3_4_conn	postamble_ts_wres_cind_conn
#define postamble_14_3_4_resp	postamble_ts_wres_cind_resp
#define postamble_14_3_4_list	postamble_ts_wres_cind_list

struct test_stream test_14_3_4_conn = { &preamble_14_3_4_conn, &test_case_14_3_4_conn, &postamble_14_3_4_conn };
struct test_stream test_14_3_4_resp = { &preamble_14_3_4_resp, &test_case_14_3_4_resp, &postamble_14_3_4_resp };
struct test_stream test_14_3_4_list = { &preamble_14_3_4_list, &test_case_14_3_4_list, &postamble_14_3_4_list };

#define tgrp_case_14_3_5 test_group_14
#define numb_case_14_3_5 "14.3.5"
#define name_case_14_3_5 "Allowable states -- T_CAPABILITY_REQ -- TS_DATA_XFER"
#define sref_case_14_3_5 sref_case_14
#define desc_case_14_3_5 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_3_5_conn(int child)
{
	return test_case_14_3(child);
}

int
test_case_14_3_5_resp(int child)
{
	return test_case_14_3(child);
}

int
test_case_14_3_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_3_5_conn	preamble_ts_data_xfer_conn
#define preamble_14_3_5_resp	preamble_ts_data_xfer_resp
#define preamble_14_3_5_list	preamble_ts_data_xfer_list

#define postamble_14_3_5_conn	postamble_ts_data_xfer_conn
#define postamble_14_3_5_resp	postamble_ts_data_xfer_resp
#define postamble_14_3_5_list	postamble_ts_data_xfer_list

struct test_stream test_14_3_5_conn = { &preamble_14_3_5_conn, &test_case_14_3_5_conn, &postamble_14_3_5_conn };
struct test_stream test_14_3_5_resp = { &preamble_14_3_5_resp, &test_case_14_3_5_resp, &postamble_14_3_5_resp };
struct test_stream test_14_3_5_list = { &preamble_14_3_5_list, &test_case_14_3_5_list, &postamble_14_3_5_list };

#define tgrp_case_14_3_6 test_group_14
#define numb_case_14_3_6 "14.3.6"
#define name_case_14_3_6 "Allowable states -- T_CAPABILITY_REQ -- TS_WIND_ORDREL"
#define sref_case_14_3_6 sref_case_14
#define desc_case_14_3_6 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_WIND_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_WIND_ORDREL state."

int
test_case_14_3_6_conn(int child)
{
	return test_case_14_3(child);
}

int
test_case_14_3_6_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_3_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_3_6_conn	preamble_ts_wind_ordrel_conn
#define preamble_14_3_6_resp	preamble_ts_wind_ordrel_resp
#define preamble_14_3_6_list	preamble_ts_wind_ordrel_list

#define postamble_14_3_6_conn	postamble_ts_wind_ordrel_conn
#define postamble_14_3_6_resp	postamble_ts_wind_ordrel_resp
#define postamble_14_3_6_list	postamble_ts_wind_ordrel_list

struct test_stream test_14_3_6_conn = { &preamble_14_3_6_conn, &test_case_14_3_6_conn, &postamble_14_3_6_conn };
struct test_stream test_14_3_6_resp = { &preamble_14_3_6_resp, &test_case_14_3_6_resp, &postamble_14_3_6_resp };
struct test_stream test_14_3_6_list = { &preamble_14_3_6_list, &test_case_14_3_6_list, &postamble_14_3_6_list };

#define tgrp_case_14_3_7 test_group_14
#define numb_case_14_3_7 "14.3.7"
#define name_case_14_3_7 "Allowable states -- T_CAPABILITY_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_3_7 sref_case_14
#define desc_case_14_3_7 "\
Checks that the T_CAPABILITY_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CAPABILITY_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_3_7_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_3_7_resp(int child)
{
	return test_case_14_3(child);
}

int
test_case_14_3_7_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_3_7_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_3_7_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_3_7_list	preamble_ts_wreq_ordrel_list

#define postamble_14_3_7_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_3_7_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_3_7_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_3_7_conn = { &preamble_14_3_7_conn, &test_case_14_3_7_conn, &postamble_14_3_7_conn };
struct test_stream test_14_3_7_resp = { &preamble_14_3_7_resp, &test_case_14_3_7_resp, &postamble_14_3_7_resp };
struct test_stream test_14_3_7_list = { &preamble_14_3_7_list, &test_case_14_3_7_list, &postamble_14_3_7_list };

#define tgrp_case_14_4_1 test_group_14
#define numb_case_14_4_1 "14.4.1"
#define name_case_14_4_1 "Allowable states -- T_CONN_REQ -- TS_IDLE"
#define sref_case_14_4_1 sref_case_14
#define desc_case_14_4_1 "\
Checks that the T_CONN_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CONN_REQ primitive in the TS_IDLE state."

int
test_case_14_4_1_conn(int child)
{
	test_data = NULL;
	test_addr = addrs[2];
	test_alen = anums[2]*sizeof(addrs[2][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_CONN_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_4_1_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_4_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_4_1_conn	preamble_ts_idle_cots_conn
#define preamble_14_4_1_resp	preamble_ts_unbnd_cots_resp
#define preamble_14_4_1_list	preamble_ts_unbnd_cots_list

#define postamble_14_4_1_conn	postamble_ts_wcon_creq_conn
#define postamble_14_4_1_resp	postamble_ts_wcon_creq_resp
#define postamble_14_4_1_list	postamble_ts_wcon_creq_list

struct test_stream test_14_4_1_conn = { &preamble_14_4_1_conn, &test_case_14_4_1_conn, &postamble_14_4_1_conn };
struct test_stream test_14_4_1_resp = { &preamble_14_4_1_resp, &test_case_14_4_1_resp, &postamble_14_4_1_resp };
struct test_stream test_14_4_1_list = { &preamble_14_4_1_list, &test_case_14_4_1_list, &postamble_14_4_1_list };

#define tgrp_case_14_5_1 test_group_14
#define numb_case_14_5_1 "14.5.1"
#define name_case_14_5_1 "Allowable states -- T_CONN_RES -- TS_WRES_CIND"
#define sref_case_14_5_1 sref_case_14
#define desc_case_14_5_1 "\
Checks that the T_CONN_RES primitive can be successfully issued in the allowed state\n\
TS_WRES_CIND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_CONN_RES primitive in the TS_WRES_CIND state."

int
test_case_14_5_1_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_5_1_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_5_1_list(int child)
{
	test_resfd = test_fd[1];
	test_data = NULL;
	test_opts = &opt_conn;
	test_olen = sizeof(opt_conn);
	if (do_signal(child, __TEST_CONN_RES) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_14_5_1_conn	preamble_ts_data_xfer_conn
#define preamble_14_5_1_resp	preamble_ts_data_xfer_resp
#define preamble_14_5_1_list	preamble_ts_wres_cind_list

#define postamble_14_5_1_conn	postamble_ts_data_xfer_conn
#define postamble_14_5_1_resp	postamble_ts_data_xfer_resp
#define postamble_14_5_1_list	postamble_ts_data_xfer_list

struct test_stream test_14_5_1_conn = { &preamble_14_5_1_conn, &test_case_14_5_1_conn, &postamble_14_5_1_conn };
struct test_stream test_14_5_1_resp = { &preamble_14_5_1_resp, &test_case_14_5_1_resp, &postamble_14_5_1_resp };
struct test_stream test_14_5_1_list = { &preamble_14_5_1_list, &test_case_14_5_1_list, &postamble_14_5_1_list };

#define tgrp_case_14_6_1 test_group_14
#define numb_case_14_6_1 "14.6.1"
#define name_case_14_6_1 "Allowable states -- T_DATA_REQ -- TS_DATA_XFER"
#define sref_case_14_6_1 sref_case_14
#define desc_case_14_6_1 "\
Checks that the T_DATA_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DATA_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_6_1_conn(int child)
{
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_6_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_6_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_6_1_conn	preamble_ts_data_xfer_conn
#define preamble_14_6_1_resp	preamble_ts_data_xfer_resp
#define preamble_14_6_1_list	preamble_ts_data_xfer_list

#define postamble_14_6_1_conn	postamble_ts_data_xfer_conn
#define postamble_14_6_1_resp	postamble_ts_data_xfer_resp
#define postamble_14_6_1_list	postamble_ts_data_xfer_list

struct test_stream test_14_6_1_conn = { &preamble_14_6_1_conn, &test_case_14_6_1_conn, &postamble_14_6_1_conn };
struct test_stream test_14_6_1_resp = { &preamble_14_6_1_resp, &test_case_14_6_1_resp, &postamble_14_6_1_resp };
struct test_stream test_14_6_1_list = { &preamble_14_6_1_list, &test_case_14_6_1_list, &postamble_14_6_1_list };

#define tgrp_case_14_6_2 test_group_14
#define numb_case_14_6_2 "14.6.2"
#define name_case_14_6_2 "Allowable states -- T_DATA_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_6_2 sref_case_14
#define desc_case_14_6_2 "\
Checks that the T_DATA_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DATA_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_6_2_conn(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_6_2_resp(int child)
{
	test_data = "Some data.";
	MORE_flag = 0;
	if (do_signal(child, __TEST_DATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_6_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_6_2_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_6_2_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_6_2_list	preamble_ts_wreq_ordrel_list

#define postamble_14_6_2_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_6_2_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_6_2_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_6_2_conn = { &preamble_14_6_2_conn, &test_case_14_6_2_conn, &postamble_14_6_2_conn };
struct test_stream test_14_6_2_resp = { &preamble_14_6_2_resp, &test_case_14_6_2_resp, &postamble_14_6_2_resp };
struct test_stream test_14_6_2_list = { &preamble_14_6_2_list, &test_case_14_6_2_list, &postamble_14_6_2_list };

#define tgrp_case_14_7_1 test_group_14
#define numb_case_14_7_1 "14.7.1"
#define name_case_14_7_1 "Allowable states -- T_DISCON_REQ -- TS_WCON_CREQ"
#define sref_case_14_7_1 sref_case_14
#define desc_case_14_7_1 "\
Checks that the T_DISCON_REQ primitive can be successfully issued in the allowed state\n\
TS_WCON_CREQ.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DISCON_REQ primitive in the TS_WCON_CREQ state."

int
test_case_14_7_1_conn(int child)
{
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_1_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_7_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_7_1_conn	preamble_ts_wcon_creq_conn
#define preamble_14_7_1_resp	preamble_ts_wcon_creq_resp
#define preamble_14_7_1_list	preamble_ts_wcon_creq_list

#define postamble_14_7_1_conn	postamble_ts_idle_conn
#define postamble_14_7_1_resp	postamble_ts_wcon_creq_resp
#define postamble_14_7_1_list	postamble_ts_wcon_creq_list

struct test_stream test_14_7_1_conn = { &preamble_14_7_1_conn, &test_case_14_7_1_conn, &postamble_14_7_1_conn };
struct test_stream test_14_7_1_resp = { &preamble_14_7_1_resp, &test_case_14_7_1_resp, &postamble_14_7_1_resp };
struct test_stream test_14_7_1_list = { &preamble_14_7_1_list, &test_case_14_7_1_list, &postamble_14_7_1_list };

#define tgrp_case_14_7_2 test_group_14
#define numb_case_14_7_2 "14.7.2"
#define name_case_14_7_2 "Allowable states -- T_DISCON_REQ -- TS_WRES_CIND"
#define sref_case_14_7_2 sref_case_14
#define desc_case_14_7_2 "\
Checks that the T_DISCON_REQ primitive can be successfully issued in the allowed state\n\
TS_WRES_CIND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DISCON_REQ primitive in the TS_WRES_CIND state."

int
test_case_14_7_2_conn(int child)
{
	expect(child, LONG_WAIT, __TEST_DISCON_IND);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_14_7_2_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_7_2_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = NULL;
	last_sequence = last_sequence;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

#define preamble_14_7_2_conn	preamble_ts_wres_cind_conn
#define preamble_14_7_2_resp	preamble_ts_wres_cind_resp
#define preamble_14_7_2_list	preamble_ts_wres_cind_list

#define postamble_14_7_2_conn	postamble_ts_idle_conn
#define postamble_14_7_2_resp	postamble_ts_unbnd_resp
#define postamble_14_7_2_list	postamble_ts_idle_list

struct test_stream test_14_7_2_conn = { &preamble_14_7_2_conn, &test_case_14_7_2_conn, &postamble_14_7_2_conn };
struct test_stream test_14_7_2_resp = { &preamble_14_7_2_resp, &test_case_14_7_2_resp, &postamble_14_7_2_resp };
struct test_stream test_14_7_2_list = { &preamble_14_7_2_list, &test_case_14_7_2_list, &postamble_14_7_2_list };

#define tgrp_case_14_7_3 test_group_14
#define numb_case_14_7_3 "14.7.3"
#define name_case_14_7_3 "Allowable states -- T_DISCON_REQ -- TS_DATA_XFER"
#define sref_case_14_7_3 sref_case_14
#define desc_case_14_7_3 "\
Checks that the T_DISCON_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DISCON_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_7_3_conn(int child)
{
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_3_resp(int child)
{
	if (expect(child, LONG_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_7_3_conn	preamble_ts_data_xfer_conn
#define preamble_14_7_3_resp	preamble_ts_data_xfer_resp
#define preamble_14_7_3_list	preamble_ts_data_xfer_list

#define postamble_14_7_3_conn	postamble_ts_idle_conn
#define postamble_14_7_3_resp	postamble_ts_idle_resp
#define postamble_14_7_3_list	postamble_ts_idle_list

struct test_stream test_14_7_3_conn = { &preamble_14_7_3_conn, &test_case_14_7_3_conn, &postamble_14_7_3_conn };
struct test_stream test_14_7_3_resp = { &preamble_14_7_3_resp, &test_case_14_7_3_resp, &postamble_14_7_3_resp };
struct test_stream test_14_7_3_list = { &preamble_14_7_3_list, &test_case_14_7_3_list, &postamble_14_7_3_list };

#define tgrp_case_14_7_4 test_group_14
#define numb_case_14_7_4 "14.7.4"
#define name_case_14_7_4 "Allowable states -- T_DISCON_REQ -- TS_WIND_ORDREL"
#define sref_case_14_7_4 sref_case_14
#define desc_case_14_7_4 "\
Checks that the T_DISCON_REQ primitive can be successfully issued in the allowed state\n\
TS_WIND_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DISCON_REQ primitive in the TS_WIND_ORDREL state."

int
test_case_14_7_4_conn(int child)
{
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_4_resp(int child)
{
	if (expect(child, LONG_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_4_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_7_4_conn	preamble_ts_wind_ordrel_conn
#define preamble_14_7_4_resp	preamble_ts_wind_ordrel_resp
#define preamble_14_7_4_list	preamble_ts_wind_ordrel_list

#define postamble_14_7_4_conn	postamble_ts_idle_conn
#define postamble_14_7_4_resp	postamble_ts_idle_resp
#define postamble_14_7_4_list	postamble_ts_idle_list

struct test_stream test_14_7_4_conn = { &preamble_14_7_4_conn, &test_case_14_7_4_conn, &postamble_14_7_4_conn };
struct test_stream test_14_7_4_resp = { &preamble_14_7_4_resp, &test_case_14_7_4_resp, &postamble_14_7_4_resp };
struct test_stream test_14_7_4_list = { &preamble_14_7_4_list, &test_case_14_7_4_list, &postamble_14_7_4_list };

#define tgrp_case_14_7_5 test_group_14
#define numb_case_14_7_5 "14.7.5"
#define name_case_14_7_5 "Allowable states -- T_DISCON_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_7_5 sref_case_14
#define desc_case_14_7_5 "\
Checks that the T_DISCON_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_DISCON_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_7_5_conn(int child)
{
	if (expect(child, LONG_WAIT, __TEST_DISCON_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_5_resp(int child)
{
	test_data = NULL;
	last_sequence = 0;
	if (do_signal(child, __TEST_DISCON_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_7_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_7_5_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_7_5_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_7_5_list	preamble_ts_wreq_ordrel_list

#define postamble_14_7_5_conn	postamble_ts_idle_conn
#define postamble_14_7_5_resp	postamble_ts_idle_resp
#define postamble_14_7_5_list	postamble_ts_idle_list

struct test_stream test_14_7_5_conn = { &preamble_14_7_5_conn, &test_case_14_7_5_conn, &postamble_14_7_5_conn };
struct test_stream test_14_7_5_resp = { &preamble_14_7_5_resp, &test_case_14_7_5_resp, &postamble_14_7_5_resp };
struct test_stream test_14_7_5_list = { &preamble_14_7_5_list, &test_case_14_7_5_list, &postamble_14_7_5_list };

#define tgrp_case_14_8_1 test_group_14
#define numb_case_14_8_1 "14.8.1"
#define name_case_14_8_1 "Allowable states -- T_EXDATA_REQ -- TS_DATA_XFER"
#define sref_case_14_8_1 sref_case_14
#define desc_case_14_8_1 "\
Checks that the T_EXDATA_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_EXDATA_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_8_1_conn(int child)
{
	test_data = "A";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_8_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "A";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_8_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_8_1_conn	preamble_ts_data_xfer_conn
#define preamble_14_8_1_resp	preamble_ts_data_xfer_resp
#define preamble_14_8_1_list	preamble_ts_data_xfer_list

#define postamble_14_8_1_conn	postamble_ts_data_xfer_conn
#define postamble_14_8_1_resp	postamble_ts_data_xfer_resp
#define postamble_14_8_1_list	postamble_ts_data_xfer_list

struct test_stream test_14_8_1_conn = { &preamble_14_8_1_conn, &test_case_14_8_1_conn, &postamble_14_8_1_conn };
struct test_stream test_14_8_1_resp = { &preamble_14_8_1_resp, &test_case_14_8_1_resp, &postamble_14_8_1_resp };
struct test_stream test_14_8_1_list = { &preamble_14_8_1_list, &test_case_14_8_1_list, &postamble_14_8_1_list };

#define tgrp_case_14_8_2 test_group_14
#define numb_case_14_8_2 "14.8.2"
#define name_case_14_8_2 "Allowable states -- T_EXDATA_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_8_2 sref_case_14
#define desc_case_14_8_2 "\
Checks that the T_EXDATA_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_EXDATA_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_8_2_conn(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_EXDATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_8_2_resp(int child)
{
	test_data = "A";
	MORE_flag = 0;
	if (do_signal(child, __TEST_EXDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_8_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_8_2_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_8_2_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_8_2_list	preamble_ts_wreq_ordrel_list

#define postamble_14_8_2_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_8_2_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_8_2_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_8_2_conn = { &preamble_14_8_2_conn, &test_case_14_8_2_conn, &postamble_14_8_2_conn };
struct test_stream test_14_8_2_resp = { &preamble_14_8_2_resp, &test_case_14_8_2_resp, &postamble_14_8_2_resp };
struct test_stream test_14_8_2_list = { &preamble_14_8_2_list, &test_case_14_8_2_list, &postamble_14_8_2_list };

#define tgrp_case_14_9_1 test_group_14
#define numb_case_14_9_1 "14.9.1"
#define name_case_14_9_1 "Allowable states -- T_INFO_REQ -- TS_UNBND"
#define sref_case_14_9_1 sref_case_14
#define desc_case_14_9_1 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_UNBND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_UNBND state."

int
test_case_14_9(int child, t_uscalar_t CURRENT_state)
{
	if (do_signal(child, __TEST_INFO_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_INFO_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (last_info.CURRENT_state != CURRENT_state)
		goto inconclusive;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
      inconclusive:
	return (__RESULT_INCONCLUSIVE);
}

int
test_case_14_9_1_conn(int child)
{
	return test_case_14_9(child, TS_UNBND);
}

int
test_case_14_9_1_resp(int child)
{
	return test_case_14_9(child, TS_UNBND);
}

int
test_case_14_9_1_list(int child)
{
	return test_case_14_9(child, TS_UNBND);
}

#define preamble_14_9_1_conn	preamble_ts_unbnd_conn
#define preamble_14_9_1_resp	preamble_ts_unbnd_resp
#define preamble_14_9_1_list	preamble_ts_unbnd_list

#define postamble_14_9_1_conn	postamble_ts_unbnd_conn
#define postamble_14_9_1_resp	postamble_ts_unbnd_resp
#define postamble_14_9_1_list	postamble_ts_unbnd_list

struct test_stream test_14_9_1_conn = { &preamble_14_9_1_conn, &test_case_14_9_1_conn, &postamble_14_9_1_conn };
struct test_stream test_14_9_1_resp = { &preamble_14_9_1_resp, &test_case_14_9_1_resp, &postamble_14_9_1_resp };
struct test_stream test_14_9_1_list = { &preamble_14_9_1_list, &test_case_14_9_1_list, &postamble_14_9_1_list };

#define tgrp_case_14_9_2 test_group_14
#define numb_case_14_9_2 "14.9.2"
#define name_case_14_9_2 "Allowable states -- T_INFO_REQ -- TS_IDLE"
#define sref_case_14_9_2 sref_case_14
#define desc_case_14_9_2 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_IDLE state."

int
test_case_14_9_2_conn(int child)
{
	return test_case_14_9(child, TS_IDLE);
}

int
test_case_14_9_2_resp(int child)
{
	return test_case_14_9(child, TS_IDLE);
}

int
test_case_14_9_2_list(int child)
{
	return test_case_14_9(child, TS_IDLE);
}

#define preamble_14_9_2_conn	preamble_ts_idle_conn
#define preamble_14_9_2_resp	preamble_ts_idle_resp
#define preamble_14_9_2_list	preamble_ts_idle_list

#define postamble_14_9_2_conn	postamble_ts_idle_conn
#define postamble_14_9_2_resp	postamble_ts_idle_resp
#define postamble_14_9_2_list	postamble_ts_idle_list

struct test_stream test_14_9_2_conn = { &preamble_14_9_2_conn, &test_case_14_9_2_conn, &postamble_14_9_2_conn };
struct test_stream test_14_9_2_resp = { &preamble_14_9_2_resp, &test_case_14_9_2_resp, &postamble_14_9_2_resp };
struct test_stream test_14_9_2_list = { &preamble_14_9_2_list, &test_case_14_9_2_list, &postamble_14_9_2_list };

#define tgrp_case_14_9_3 test_group_14
#define numb_case_14_9_3 "14.9.3"
#define name_case_14_9_3 "Allowable states -- T_INFO_REQ -- TS_WCON_CREQ"
#define sref_case_14_9_3 sref_case_14
#define desc_case_14_9_3 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_WCON_CREQ.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_WCON_CREQ state."

int
test_case_14_9_3_conn(int child)
{
	return test_case_14_9(child, TS_WCON_CREQ);
}

int
test_case_14_9_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_9_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_9_3_conn	preamble_ts_wcon_creq_conn
#define preamble_14_9_3_resp	preamble_ts_wcon_creq_resp
#define preamble_14_9_3_list	preamble_ts_wcon_creq_list

#define postamble_14_9_3_conn	postamble_ts_wcon_creq_conn
#define postamble_14_9_3_resp	postamble_ts_wcon_creq_resp
#define postamble_14_9_3_list	postamble_ts_wcon_creq_list

struct test_stream test_14_9_3_conn = { &preamble_14_9_3_conn, &test_case_14_9_3_conn, &postamble_14_9_3_conn };
struct test_stream test_14_9_3_resp = { &preamble_14_9_3_resp, &test_case_14_9_3_resp, &postamble_14_9_3_resp };
struct test_stream test_14_9_3_list = { &preamble_14_9_3_list, &test_case_14_9_3_list, &postamble_14_9_3_list };

#define tgrp_case_14_9_4 test_group_14
#define numb_case_14_9_4 "14.9.4"
#define name_case_14_9_4 "Allowable states -- T_INFO_REQ -- TS_WRES_CIND"
#define sref_case_14_9_4 sref_case_14
#define desc_case_14_9_4 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_WRES_CIND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_WRES_CIND state."

int
test_case_14_9_4_conn(int child)
{
	test_msleep(child, LONG_WAIT);
	state++;
	return (__RESULT_SUCCESS);
}

int
test_case_14_9_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_9_4_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_14_9(child, TS_WRES_CIND);
}

#define preamble_14_9_4_conn	preamble_ts_wres_cind_conn
#define preamble_14_9_4_resp	preamble_ts_wres_cind_resp
#define preamble_14_9_4_list	preamble_ts_wres_cind_list

#define postamble_14_9_4_conn	postamble_ts_wres_cind_conn
#define postamble_14_9_4_resp	postamble_ts_wres_cind_resp
#define postamble_14_9_4_list	postamble_ts_wres_cind_list

struct test_stream test_14_9_4_conn = { &preamble_14_9_4_conn, &test_case_14_9_4_conn, &postamble_14_9_4_conn };
struct test_stream test_14_9_4_resp = { &preamble_14_9_4_resp, &test_case_14_9_4_resp, &postamble_14_9_4_resp };
struct test_stream test_14_9_4_list = { &preamble_14_9_4_list, &test_case_14_9_4_list, &postamble_14_9_4_list };

#define tgrp_case_14_9_5 test_group_14
#define numb_case_14_9_5 "14.9.5"
#define name_case_14_9_5 "Allowable states -- T_INFO_REQ -- TS_DATA_XFER"
#define sref_case_14_9_5 sref_case_14
#define desc_case_14_9_5 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_9_5_conn(int child)
{
	return test_case_14_9(child, TS_DATA_XFER);
}

int
test_case_14_9_5_resp(int child)
{
	return test_case_14_9(child, TS_DATA_XFER);
}

int
test_case_14_9_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_9_5_conn	preamble_ts_data_xfer_conn
#define preamble_14_9_5_resp	preamble_ts_data_xfer_resp
#define preamble_14_9_5_list	preamble_ts_data_xfer_list

#define postamble_14_9_5_conn	postamble_ts_data_xfer_conn
#define postamble_14_9_5_resp	postamble_ts_data_xfer_resp
#define postamble_14_9_5_list	postamble_ts_data_xfer_list

struct test_stream test_14_9_5_conn = { &preamble_14_9_5_conn, &test_case_14_9_5_conn, &postamble_14_9_5_conn };
struct test_stream test_14_9_5_resp = { &preamble_14_9_5_resp, &test_case_14_9_5_resp, &postamble_14_9_5_resp };
struct test_stream test_14_9_5_list = { &preamble_14_9_5_list, &test_case_14_9_5_list, &postamble_14_9_5_list };

#define tgrp_case_14_9_6 test_group_14
#define numb_case_14_9_6 "14.9.6"
#define name_case_14_9_6 "Allowable states -- T_INFO_REQ -- TS_WIND_ORDREL"
#define sref_case_14_9_6 sref_case_14
#define desc_case_14_9_6 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_WIND_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_WIND_ORDREL state."

int
test_case_14_9_6_conn(int child)
{
	return test_case_14_9(child, TS_WIND_ORDREL);
}

int
test_case_14_9_6_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_9_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_9_6_conn	preamble_ts_wind_ordrel_conn
#define preamble_14_9_6_resp	preamble_ts_wind_ordrel_resp
#define preamble_14_9_6_list	preamble_ts_wind_ordrel_list

#define postamble_14_9_6_conn	postamble_ts_wind_ordrel_conn
#define postamble_14_9_6_resp	postamble_ts_wind_ordrel_resp
#define postamble_14_9_6_list	postamble_ts_wind_ordrel_list

struct test_stream test_14_9_6_conn = { &preamble_14_9_6_conn, &test_case_14_9_6_conn, &postamble_14_9_6_conn };
struct test_stream test_14_9_6_resp = { &preamble_14_9_6_resp, &test_case_14_9_6_resp, &postamble_14_9_6_resp };
struct test_stream test_14_9_6_list = { &preamble_14_9_6_list, &test_case_14_9_6_list, &postamble_14_9_6_list };

#define tgrp_case_14_9_7 test_group_14
#define numb_case_14_9_7 "14.9.7"
#define name_case_14_9_7 "Allowable states -- T_INFO_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_9_7 sref_case_14
#define desc_case_14_9_7 "\
Checks that the T_INFO_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_INFO_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_9_7_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_9_7_resp(int child)
{
	return test_case_14_9(child, TS_WREQ_ORDREL);
}

int
test_case_14_9_7_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_9_7_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_9_7_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_9_7_list	preamble_ts_wreq_ordrel_list

#define postamble_14_9_7_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_9_7_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_9_7_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_9_7_conn = { &preamble_14_9_7_conn, &test_case_14_9_7_conn, &postamble_14_9_7_conn };
struct test_stream test_14_9_7_resp = { &preamble_14_9_7_resp, &test_case_14_9_7_resp, &postamble_14_9_7_resp };
struct test_stream test_14_9_7_list = { &preamble_14_9_7_list, &test_case_14_9_7_list, &postamble_14_9_7_list };

#define tgrp_case_14_10_1 test_group_14
#define numb_case_14_10_1 "14.10.1"
#define name_case_14_10_1 "Allowable states -- T_OPTDATA_REQ -- TS_DATA_XFER"
#define sref_case_14_10_1 sref_case_14
#define desc_case_14_10_1 "\
Checks that the T_OPTDATA_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTDATA_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_10_1_conn(int child)
{
	test_data = "Some data.";
	test_opts = NULL;
	test_olen = 0;
	DATA_flag = 0;
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_10_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	test_data = "Some data.";
	test_opts = NULL;
	test_olen = 0;
	DATA_flag = 0;
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_10_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_10_1_conn	preamble_ts_data_xfer_conn
#define preamble_14_10_1_resp	preamble_ts_data_xfer_resp
#define preamble_14_10_1_list	preamble_ts_data_xfer_list

#define postamble_14_10_1_conn	postamble_ts_data_xfer_conn
#define postamble_14_10_1_resp	postamble_ts_data_xfer_resp
#define postamble_14_10_1_list	postamble_ts_data_xfer_list

struct test_stream test_14_10_1_conn = { &preamble_14_10_1_conn, &test_case_14_10_1_conn, &postamble_14_10_1_conn };
struct test_stream test_14_10_1_resp = { &preamble_14_10_1_resp, &test_case_14_10_1_resp, &postamble_14_10_1_resp };
struct test_stream test_14_10_1_list = { &preamble_14_10_1_list, &test_case_14_10_1_list, &postamble_14_10_1_list };

#define tgrp_case_14_10_2 test_group_14
#define numb_case_14_10_2 "14.10.2"
#define name_case_14_10_2 "Allowable states -- T_OPTDATA_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_10_2 sref_case_14
#define desc_case_14_10_2 "\
Checks that the T_OPTDATA_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTDATA_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_10_2_conn(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_DATA_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_10_2_resp(int child)
{
	test_data = "Some data.";
	test_opts = NULL;
	test_olen = 0;
	DATA_flag = 0;
	if (do_signal(child, __TEST_OPTDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_10_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_10_2_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_10_2_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_10_2_list	preamble_ts_wreq_ordrel_list

#define postamble_14_10_2_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_10_2_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_10_2_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_10_2_conn = { &preamble_14_10_2_conn, &test_case_14_10_2_conn, &postamble_14_10_2_conn };
struct test_stream test_14_10_2_resp = { &preamble_14_10_2_resp, &test_case_14_10_2_resp, &postamble_14_10_2_resp };
struct test_stream test_14_10_2_list = { &preamble_14_10_2_list, &test_case_14_10_2_list, &postamble_14_10_2_list };

#define tgrp_case_14_11_1 test_group_14
#define numb_case_14_11_1 "14.11.1"
#define name_case_14_11_1 "Allowable states -- T_OPTMGMT_REQ -- TS_UNBND"
#define sref_case_14_11_1 sref_case_14
#define desc_case_14_11_1 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_UNBND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_UNBND state."

int
test_case_14_11(int child)
{
	test_mgmtflags = T_DEFAULT;
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_OPTMGMT_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OPTMGMT_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_11_1_conn(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_1_resp(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_1_list(int child)
{
	return test_case_14_11(child);
}

#define preamble_14_11_1_conn	preamble_ts_unbnd_conn
#define preamble_14_11_1_resp	preamble_ts_unbnd_resp
#define preamble_14_11_1_list	preamble_ts_unbnd_list

#define postamble_14_11_1_conn	postamble_ts_unbnd_conn
#define postamble_14_11_1_resp	postamble_ts_unbnd_resp
#define postamble_14_11_1_list	postamble_ts_unbnd_list

struct test_stream test_14_11_1_conn = { &preamble_14_11_1_conn, &test_case_14_11_1_conn, &postamble_14_11_1_conn };
struct test_stream test_14_11_1_resp = { &preamble_14_11_1_resp, &test_case_14_11_1_resp, &postamble_14_11_1_resp };
struct test_stream test_14_11_1_list = { &preamble_14_11_1_list, &test_case_14_11_1_list, &postamble_14_11_1_list };

#define tgrp_case_14_11_2 test_group_14
#define numb_case_14_11_2 "14.11.2"
#define name_case_14_11_2 "Allowable states -- T_OPTMGMT_REQ -- TS_IDLE"
#define sref_case_14_11_2 sref_case_14
#define desc_case_14_11_2 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_IDLE state."

int
test_case_14_11_2_conn(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_2_resp(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_2_list(int child)
{
	return test_case_14_11(child);
}

#define preamble_14_11_2_conn	preamble_ts_idle_conn
#define preamble_14_11_2_resp	preamble_ts_idle_resp
#define preamble_14_11_2_list	preamble_ts_idle_list

#define postamble_14_11_2_conn	postamble_ts_idle_conn
#define postamble_14_11_2_resp	postamble_ts_idle_resp
#define postamble_14_11_2_list	postamble_ts_idle_list

struct test_stream test_14_11_2_conn = { &preamble_14_11_2_conn, &test_case_14_11_2_conn, &postamble_14_11_2_conn };
struct test_stream test_14_11_2_resp = { &preamble_14_11_2_resp, &test_case_14_11_2_resp, &postamble_14_11_2_resp };
struct test_stream test_14_11_2_list = { &preamble_14_11_2_list, &test_case_14_11_2_list, &postamble_14_11_2_list };

#define tgrp_case_14_11_3 test_group_14
#define numb_case_14_11_3 "14.11.3"
#define name_case_14_11_3 "Allowable states -- T_OPTMGMT_REQ -- TS_WCON_CREQ"
#define sref_case_14_11_3 sref_case_14
#define desc_case_14_11_3 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_WCON_CREQ.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_WCON_CREQ state."

int
test_case_14_11_3_conn(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_3_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_11_3_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_11_3_conn	preamble_ts_wcon_creq_conn
#define preamble_14_11_3_resp	preamble_ts_wcon_creq_resp
#define preamble_14_11_3_list	preamble_ts_wcon_creq_list

#define postamble_14_11_3_conn	postamble_ts_wcon_creq_conn
#define postamble_14_11_3_resp	postamble_ts_wcon_creq_resp
#define postamble_14_11_3_list	postamble_ts_wcon_creq_list

struct test_stream test_14_11_3_conn = { &preamble_14_11_3_conn, &test_case_14_11_3_conn, &postamble_14_11_3_conn };
struct test_stream test_14_11_3_resp = { &preamble_14_11_3_resp, &test_case_14_11_3_resp, &postamble_14_11_3_resp };
struct test_stream test_14_11_3_list = { &preamble_14_11_3_list, &test_case_14_11_3_list, &postamble_14_11_3_list };

#define tgrp_case_14_11_4 test_group_14
#define numb_case_14_11_4 "14.11.4"
#define name_case_14_11_4 "Allowable states -- T_OPTMGMT_REQ -- TS_WRES_CIND"
#define sref_case_14_11_4 sref_case_14
#define desc_case_14_11_4 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_WRES_CIND.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_WRES_CIND state."

int
test_case_14_11_4_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_11_4_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_11_4_list(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	return test_case_14_11(child);
}

#define preamble_14_11_4_conn	preamble_ts_wres_cind_conn
#define preamble_14_11_4_resp	preamble_ts_wres_cind_resp
#define preamble_14_11_4_list	preamble_ts_wres_cind_list

#define postamble_14_11_4_conn	postamble_ts_wres_cind_conn
#define postamble_14_11_4_resp	postamble_ts_wres_cind_resp
#define postamble_14_11_4_list	postamble_ts_wres_cind_list

struct test_stream test_14_11_4_conn = { &preamble_14_11_4_conn, &test_case_14_11_4_conn, &postamble_14_11_4_conn };
struct test_stream test_14_11_4_resp = { &preamble_14_11_4_resp, &test_case_14_11_4_resp, &postamble_14_11_4_resp };
struct test_stream test_14_11_4_list = { &preamble_14_11_4_list, &test_case_14_11_4_list, &postamble_14_11_4_list };

#define tgrp_case_14_11_5 test_group_14
#define numb_case_14_11_5 "14.11.5"
#define name_case_14_11_5 "Allowable states -- T_OPTMGMT_REQ -- TS_DATA_XFER"
#define sref_case_14_11_5 sref_case_14
#define desc_case_14_11_5 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_11_5_conn(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_5_resp(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_5_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_11_5_conn	preamble_ts_data_xfer_conn
#define preamble_14_11_5_resp	preamble_ts_data_xfer_resp
#define preamble_14_11_5_list	preamble_ts_data_xfer_list

#define postamble_14_11_5_conn	postamble_ts_data_xfer_conn
#define postamble_14_11_5_resp	postamble_ts_data_xfer_resp
#define postamble_14_11_5_list	postamble_ts_data_xfer_list

struct test_stream test_14_11_5_conn = { &preamble_14_11_5_conn, &test_case_14_11_5_conn, &postamble_14_11_5_conn };
struct test_stream test_14_11_5_resp = { &preamble_14_11_5_resp, &test_case_14_11_5_resp, &postamble_14_11_5_resp };
struct test_stream test_14_11_5_list = { &preamble_14_11_5_list, &test_case_14_11_5_list, &postamble_14_11_5_list };

#define tgrp_case_14_11_6 test_group_14
#define numb_case_14_11_6 "14.11.6"
#define name_case_14_11_6 "Allowable states -- T_OPTMGMT_REQ -- TS_WIND_ORDREL"
#define sref_case_14_11_6 sref_case_14
#define desc_case_14_11_6 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_WIND_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_WIND_ORDREL state."

int
test_case_14_11_6_conn(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_6_resp(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_11_6_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_11_6_conn	preamble_ts_wind_ordrel_conn
#define preamble_14_11_6_resp	preamble_ts_wind_ordrel_resp
#define preamble_14_11_6_list	preamble_ts_wind_ordrel_list

#define postamble_14_11_6_conn	postamble_ts_wind_ordrel_conn
#define postamble_14_11_6_resp	postamble_ts_wind_ordrel_resp
#define postamble_14_11_6_list	postamble_ts_wind_ordrel_list

struct test_stream test_14_11_6_conn = { &preamble_14_11_6_conn, &test_case_14_11_6_conn, &postamble_14_11_6_conn };
struct test_stream test_14_11_6_resp = { &preamble_14_11_6_resp, &test_case_14_11_6_resp, &postamble_14_11_6_resp };
struct test_stream test_14_11_6_list = { &preamble_14_11_6_list, &test_case_14_11_6_list, &postamble_14_11_6_list };

#define tgrp_case_14_11_7 test_group_14
#define numb_case_14_11_7 "14.11.7"
#define name_case_14_11_7 "Allowable states -- T_OPTMGMT_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_11_7 sref_case_14
#define desc_case_14_11_7 "\
Checks that the T_OPTMGMT_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_OPTMGMT_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_11_7_conn(int child)
{
	return (__RESULT_SUCCESS);
}

int
test_case_14_11_7_resp(int child)
{
	return test_case_14_11(child);
}

int
test_case_14_11_7_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_11_7_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_11_7_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_11_7_list	preamble_ts_wreq_ordrel_list

#define postamble_14_11_7_conn	postamble_ts_wreq_ordrel_conn
#define postamble_14_11_7_resp	postamble_ts_wreq_ordrel_resp
#define postamble_14_11_7_list	postamble_ts_wreq_ordrel_list

struct test_stream test_14_11_7_conn = { &preamble_14_11_7_conn, &test_case_14_11_7_conn, &postamble_14_11_7_conn };
struct test_stream test_14_11_7_resp = { &preamble_14_11_7_resp, &test_case_14_11_7_resp, &postamble_14_11_7_resp };
struct test_stream test_14_11_7_list = { &preamble_14_11_7_list, &test_case_14_11_7_list, &postamble_14_11_7_list };

#define tgrp_case_14_12_1 test_group_14
#define numb_case_14_12_1 "14.12.1"
#define name_case_14_12_1 "Allowable states -- T_ORDREL_REQ -- TS_DATA_XFER"
#define sref_case_14_12_1 sref_case_14
#define desc_case_14_12_1 "\
Checks that the T_ORDREL_REQ primitive can be successfully issued in the allowed state\n\
TS_DATA_XFER.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ORDREL_REQ primitive in the TS_DATA_XFER state."

int
test_case_14_12_1_conn(int child)
{
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_12_1_resp(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_12_1_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_12_1_conn	preamble_ts_data_xfer_conn
#define preamble_14_12_1_resp	preamble_ts_data_xfer_resp
#define preamble_14_12_1_list	preamble_ts_data_xfer_list

#define postamble_14_12_1_conn	postamble_ts_wind_ordrel_conn
#define postamble_14_12_1_resp	postamble_ts_wind_ordrel_resp
#define postamble_14_12_1_list	postamble_ts_wind_ordrel_list

struct test_stream test_14_12_1_conn = { &preamble_14_12_1_conn, &test_case_14_12_1_conn, &postamble_14_12_1_conn };
struct test_stream test_14_12_1_resp = { &preamble_14_12_1_resp, &test_case_14_12_1_resp, &postamble_14_12_1_resp };
struct test_stream test_14_12_1_list = { &preamble_14_12_1_list, &test_case_14_12_1_list, &postamble_14_12_1_list };

#define tgrp_case_14_12_2 test_group_14
#define numb_case_14_12_2 "14.12.2"
#define name_case_14_12_2 "Allowable states -- T_ORDREL_REQ -- TS_WREQ_ORDREL"
#define sref_case_14_12_2 sref_case_14
#define desc_case_14_12_2 "\
Checks that the T_ORDREL_REQ primitive can be successfully issued in the allowed state\n\
TS_WREQ_ORDREL.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_ORDREL_REQ primitive in the TS_WREQ_ORDREL state."

int
test_case_14_12_2_conn(int child)
{
	if (expect(child, LONGER_WAIT, __TEST_ORDREL_IND) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_12_2_resp(int child)
{
	test_data = NULL;
	if (do_signal(child, __TEST_ORDREL_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_12_2_list(int child)
{
	return (__RESULT_SUCCESS);
}

#define preamble_14_12_2_conn	preamble_ts_wreq_ordrel_conn
#define preamble_14_12_2_resp	preamble_ts_wreq_ordrel_resp
#define preamble_14_12_2_list	preamble_ts_wreq_ordrel_list

#define postamble_14_12_2_conn	postamble_ts_idle_conn
#define postamble_14_12_2_resp	postamble_ts_idle_resp
#define postamble_14_12_2_list	postamble_ts_idle_list

struct test_stream test_14_12_2_conn = { &preamble_14_12_2_conn, &test_case_14_12_2_conn, &postamble_14_12_2_conn };
struct test_stream test_14_12_2_resp = { &preamble_14_12_2_resp, &test_case_14_12_2_resp, &postamble_14_12_2_resp };
struct test_stream test_14_12_2_list = { &preamble_14_12_2_list, &test_case_14_12_2_list, &postamble_14_12_2_list };

#define tgrp_case_14_13_1 test_group_14
#define numb_case_14_13_1 "14.13.1"
#define name_case_14_13_1 "Allowable states -- T_UNBIND_REQ -- TS_IDLE"
#define sref_case_14_13_1 sref_case_14
#define desc_case_14_13_1 "\
Checks that the T_UNBIND_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_UNBIND_REQ primitive in the TS_IDLE state."

int
test_case_14_13(int child)
{
	if (do_signal(child, __TEST_UNBIND_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	if (expect(child, NORMAL_WAIT, __TEST_OK_ACK) != __RESULT_SUCCESS)
		goto failure;
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_13_1_conn(int child)
{
	return test_case_14_13(child);
}

int
test_case_14_13_1_resp(int child)
{
	return test_case_14_13(child);
}

int
test_case_14_13_1_list(int child)
{
	return test_case_14_13(child);
}

#define preamble_14_13_1_conn	preamble_ts_idle_conn
#define preamble_14_13_1_resp	preamble_ts_idle_resp
#define preamble_14_13_1_list	preamble_ts_idle_list

#define postamble_14_13_1_conn	postamble_ts_unbnd_conn
#define postamble_14_13_1_resp	postamble_ts_unbnd_resp
#define postamble_14_13_1_list	postamble_ts_unbnd_list

struct test_stream test_14_13_1_conn = { &preamble_14_13_1_conn, &test_case_14_13_1_conn, &postamble_14_13_1_conn };
struct test_stream test_14_13_1_resp = { &preamble_14_13_1_resp, &test_case_14_13_1_resp, &postamble_14_13_1_resp };
struct test_stream test_14_13_1_list = { &preamble_14_13_1_list, &test_case_14_13_1_list, &postamble_14_13_1_list };

#define tgrp_case_14_14_1 test_group_14
#define numb_case_14_14_1 "14.14.1"
#define name_case_14_14_1 "Allowable states -- T_UNITDATA_REQ -- TS_IDLE"
#define sref_case_14_14_1 sref_case_14
#define desc_case_14_14_1 "\
Checks that the T_UNITDATA_REQ primitive can be successfully issued in the allowed state\n\
TS_IDLE.  The TPI specification indicates the allowable states in which primitives\n\
can be issued.  This test case tests the T_UNITDATA_REQ primitive in the TS_IDLE state."

int
test_case_14_14(int child)
{
	test_msleep(child, NORMAL_WAIT);
	state++;
	test_data = "Some data.";
	test_addr = addrs[(child + 1) % 3];
	test_alen = anums[(child + 1) % 3]*sizeof(addrs[(child + 1) % 3][0]);
	test_opts = NULL;
	test_olen = 0;
	if (do_signal(child, __TEST_UNITDATA_REQ) != __RESULT_SUCCESS)
		goto failure;
	state++;
	expect(child, NORMAL_WAIT, __TEST_UNITDATA_IND);
	state++;
	test_msleep(child, NORMAL_WAIT);
	state++;
	return (__RESULT_SUCCESS);
      failure:
	return (__RESULT_FAILURE);
}

int
test_case_14_14_1_conn(int child)
{
	return test_case_14_14(child);
}

int
test_case_14_14_1_resp(int child)
{
	return test_case_14_14(child);
}

int
test_case_14_14_1_list(int child)
{
	return test_case_14_14(child);
}

#define preamble_14_14_1_conn	preamble_ts_idle_clts_conn
#define preamble_14_14_1_resp	preamble_ts_idle_clts_resp
#define preamble_14_14_1_list	preamble_ts_idle_clts_list

#define postamble_14_14_1_conn	postamble_ts_idle_clts_conn
#define postamble_14_14_1_resp	postamble_ts_idle_clts_resp
#define postamble_14_14_1_list	postamble_ts_idle_clts_list

struct test_stream test_14_14_1_conn = { &preamble_14_14_1_conn, &test_case_14_14_1_conn, &postamble_14_14_1_conn };
struct test_stream test_14_14_1_resp = { &preamble_14_14_1_resp, &test_case_14_14_1_resp, &postamble_14_14_1_resp };
struct test_stream test_14_14_1_list = { &preamble_14_14_1_list, &test_case_14_14_1_list, &postamble_14_14_1_list };

/*
 *  -------------------------------------------------------------------------
 *
 *  Test case child scheduler
 *
 *  -------------------------------------------------------------------------
 */
int
run_stream(int child, struct test_stream *stream)
{
	int result = __RESULT_SCRIPT_ERROR;
	int pre_result = __RESULT_SCRIPT_ERROR;
	int post_result = __RESULT_SCRIPT_ERROR;

	print_preamble(child);
	state = 100;
	failure_string = NULL;
	if (stream->preamble && (pre_result = stream->preamble(child)) != __RESULT_SUCCESS) {
		switch (pre_result) {
		case __RESULT_NOTAPPL:
			print_notapplicable(child);
			result = __RESULT_NOTAPPL;
			break;
		case __RESULT_SKIPPED:
			print_skipped(child);
			result = __RESULT_SKIPPED;
			break;
		default:
			print_inconclusive(child);
			result = __RESULT_INCONCLUSIVE;
			break;
		}
	} else {
		print_test(child);
		state = 200;
		failure_string = NULL;
		switch (stream->testcase(child)) {
		default:
		case __RESULT_INCONCLUSIVE:
			print_inconclusive(child);
			result = __RESULT_INCONCLUSIVE;
			break;
		case __RESULT_NOTAPPL:
			print_notapplicable(child);
			result = __RESULT_NOTAPPL;
			break;
		case __RESULT_SKIPPED:
			print_skipped(child);
			result = __RESULT_SKIPPED;
			break;
		case __RESULT_FAILURE:
			print_failed(child);
			result = __RESULT_FAILURE;
			break;
		case __RESULT_SCRIPT_ERROR:
			print_script_error(child);
			result = __RESULT_SCRIPT_ERROR;
			break;
		case __RESULT_SUCCESS:
			print_passed(child);
			result = __RESULT_SUCCESS;
			break;
		}
		print_postamble(child);
		state = 300;
		failure_string = NULL;
		if (stream->postamble && (post_result = stream->postamble(child)) != __RESULT_SUCCESS) {
			switch (post_result) {
			case __RESULT_NOTAPPL:
				print_notapplicable(child);
				result = __RESULT_NOTAPPL;
				break;
			case __RESULT_SKIPPED:
				print_skipped(child);
				result = __RESULT_SKIPPED;
				break;
			default:
				print_inconclusive(child);
				if (result == __RESULT_SUCCESS)
					result = __RESULT_INCONCLUSIVE;
				break;
			}
		}
	}
	print_test_end(child);
	exit(result);
}

/*
 *  Fork multiple children to do the actual testing.
 *  The conn child (child[0]) is the connecting process, the resp child
 *  (child[1]) is the responding process.
 */

int
test_run(struct test_stream *stream[])
{
	int children = 0;
	pid_t this_child, child[3] = { 0, };
	int this_status, status[3] = { 0, };

	if (start_tt(test_duration) != __RESULT_SUCCESS)
		goto inconclusive;
	if (server_exec && stream[2]) {
		switch ((child[2] = fork())) {
		case 00:	/* we are the child */
			exit(run_stream(2, stream[2]));	/* execute stream[2] state machine */
		case -1:	/* error */
			if (child[0])
				kill(child[0], SIGKILL);	/* toast stream[0] child */
			if (child[1])
				kill(child[1], SIGKILL);	/* toast stream[1] child */
			return __RESULT_FAILURE;
		default:	/* we are the parent */
			children++;
			break;
		}
	} else
		status[2] = __RESULT_SUCCESS;
	if (server_exec && stream[1]) {
		switch ((child[1] = fork())) {
		case 00:	/* we are the child */
			exit(run_stream(1, stream[1]));	/* execute stream[1] state machine */
		case -1:	/* error */
			if (child[0])
				kill(child[0], SIGKILL);	/* toast stream[0] child */
			return __RESULT_FAILURE;
		default:	/* we are the parent */
			children++;
			break;
		}
	} else
		status[1] = __RESULT_SUCCESS;
	if (client_exec && stream[0]) {
		switch ((child[0] = fork())) {
		case 00:	/* we are the child */
			exit(run_stream(0, stream[0]));	/* execute stream[0] state machine */
		case -1:	/* error */
			return __RESULT_FAILURE;
		default:	/* we are the parent */
			children++;
			break;
		}
	} else
		status[0] = __RESULT_SUCCESS;
	for (; children > 0; children--) {
	      waitagain:
		if ((this_child = wait(&this_status)) > 0) {
			if (WIFEXITED(this_status)) {
				if (this_child == child[0]) {
					child[0] = 0;
					if ((status[0] = WEXITSTATUS(this_status)) != __RESULT_SUCCESS) {
						if (child[1])
							kill(child[1], SIGKILL);
						if (child[2])
							kill(child[2], SIGKILL);
					}
				}
				if (this_child == child[1]) {
					child[1] = 0;
					if ((status[1] = WEXITSTATUS(this_status)) != __RESULT_SUCCESS) {
						if (child[0])
							kill(child[0], SIGKILL);
						if (child[2])
							kill(child[2], SIGKILL);
					}
				}
				if (this_child == child[2]) {
					child[2] = 0;
					if ((status[2] = WEXITSTATUS(this_status)) != __RESULT_SUCCESS) {
						if (child[0])
							kill(child[0], SIGKILL);
						if (child[1])
							kill(child[1], SIGKILL);
					}
				}
			} else if (WIFSIGNALED(this_status)) {
				int signal = WTERMSIG(this_status);

				if (this_child == child[0]) {
					print_terminated(0, signal);
					if (child[1])
						kill(child[1], SIGKILL);
					if (child[2])
						kill(child[2], SIGKILL);
					status[0] = (signal == SIGKILL) ? __RESULT_INCONCLUSIVE : __RESULT_FAILURE;
					child[0] = 0;
				}
				if (this_child == child[1]) {
					print_terminated(1, signal);
					if (child[0])
						kill(child[0], SIGKILL);
					if (child[2])
						kill(child[2], SIGKILL);
					status[1] = (signal == SIGKILL) ? __RESULT_INCONCLUSIVE : __RESULT_FAILURE;
					child[1] = 0;
				}
				if (this_child == child[2]) {
					print_terminated(2, signal);
					if (child[0])
						kill(child[0], SIGKILL);
					if (child[1])
						kill(child[1], SIGKILL);
					status[2] = (signal == SIGKILL) ? __RESULT_INCONCLUSIVE : __RESULT_FAILURE;
					child[2] = 0;
				}
			} else if (WIFSTOPPED(this_status)) {
				int signal = WSTOPSIG(this_status);

				if (this_child == child[0]) {
					print_stopped(0, signal);
					if (child[0])
						kill(child[0], SIGKILL);
					if (child[1])
						kill(child[1], SIGKILL);
					if (child[2])
						kill(child[2], SIGKILL);
					status[0] = __RESULT_FAILURE;
					child[0] = 0;
				}
				if (this_child == child[1]) {
					print_stopped(1, signal);
					if (child[0])
						kill(child[0], SIGKILL);
					if (child[1])
						kill(child[1], SIGKILL);
					if (child[2])
						kill(child[2], SIGKILL);
					status[1] = __RESULT_FAILURE;
					child[1] = 0;
				}
				if (this_child == child[2]) {
					print_stopped(2, signal);
					if (child[0])
						kill(child[0], SIGKILL);
					if (child[1])
						kill(child[1], SIGKILL);
					if (child[2])
						kill(child[2], SIGKILL);
					status[2] = __RESULT_FAILURE;
					child[2] = 0;
				}
			}
		} else {
			if (timer_timeout) {
				timer_timeout = 0;
				print_timeout(3);
			}
			if (child[0])
				kill(child[0], SIGKILL);
			if (child[1])
				kill(child[1], SIGKILL);
			if (child[2])
				kill(child[2], SIGKILL);
			goto waitagain;
		}
	}
	if (stop_tt() != __RESULT_SUCCESS)
		goto inconclusive;
	if (status[0] == __RESULT_NOTAPPL || status[1] == __RESULT_NOTAPPL || status[2] == __RESULT_NOTAPPL)
		return (__RESULT_NOTAPPL);
	if (status[0] == __RESULT_SKIPPED || status[1] == __RESULT_SKIPPED || status[2] == __RESULT_SKIPPED)
		return (__RESULT_SKIPPED);
	if (status[0] == __RESULT_FAILURE || status[1] == __RESULT_FAILURE || status[2] == __RESULT_FAILURE)
		return (__RESULT_FAILURE);
	if (status[0] == __RESULT_SUCCESS && status[1] == __RESULT_SUCCESS && status[2] == __RESULT_SUCCESS)
		return (__RESULT_SUCCESS);
      inconclusive:
	return (__RESULT_INCONCLUSIVE);
}

/*
 *  -------------------------------------------------------------------------
 *
 *  Test case lists
 *
 *  -------------------------------------------------------------------------
 */

struct test_case {
	const char *numb;		/* test case number */
	const char *tgrp;		/* test case group */
	const char *name;		/* test case name */
	const char *desc;		/* test case description */
	const char *sref;		/* test case standards section reference */
	struct test_stream *stream[3];	/* test streams */
	int (*start) (int);		/* start function */
	int (*stop) (int);		/* stop function */
	int run;			/* whether to run this test */
	int result;			/* results of test */
} tests[] = {
	{
		numb_case_0_1, tgrp_case_0_1, name_case_0_1, desc_case_0_1, sref_case_0_1, {
	&test_0_1_conn, &test_0_1_resp, &test_0_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_1, tgrp_case_1_1, name_case_1_1, desc_case_1_1, sref_case_1_1, {
	&test_1_1_conn, &test_1_1_resp, &test_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_2, tgrp_case_1_2, name_case_1_2, desc_case_1_2, sref_case_1_2, {
	&test_1_2_conn, &test_1_2_resp, &test_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_3_1, tgrp_case_1_3_1, name_case_1_3_1, desc_case_1_3_1, sref_case_1_3_1, {
	&test_1_3_1_conn, &test_1_3_1_resp, &test_1_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_3_2, tgrp_case_1_3_2, name_case_1_3_2, desc_case_1_3_2, sref_case_1_3_2, {
	&test_1_3_2_conn, &test_1_3_2_resp, &test_1_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_3_3, tgrp_case_1_3_3, name_case_1_3_3, desc_case_1_3_3, sref_case_1_3_3, {
	&test_1_3_3_conn, &test_1_3_3_resp, &test_1_3_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_3_4, tgrp_case_1_3_4, name_case_1_3_4, desc_case_1_3_4, sref_case_1_3_4, {
	&test_1_3_4_conn, &test_1_3_4_resp, &test_1_3_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_4_1, tgrp_case_1_4_1, name_case_1_4_1, desc_case_1_4_1, sref_case_1_4_1, {
	&test_1_4_1_conn, &test_1_4_1_resp, &test_1_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_4_2, tgrp_case_1_4_2, name_case_1_4_2, desc_case_1_4_2, sref_case_1_4_2, {
	&test_1_4_2_conn, &test_1_4_2_resp, &test_1_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_4_3, tgrp_case_1_4_3, name_case_1_4_3, desc_case_1_4_3, sref_case_1_4_3, {
	&test_1_4_3_conn, &test_1_4_3_resp, &test_1_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_1, tgrp_case_1_5_1_1, name_case_1_5_1_1, desc_case_1_5_1_1, sref_case_1_5_1_1, {
	&test_1_5_1_1_conn, &test_1_5_1_1_resp, &test_1_5_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_2, tgrp_case_1_5_1_2, name_case_1_5_1_2, desc_case_1_5_1_2, sref_case_1_5_1_2, {
	&test_1_5_1_2_conn, &test_1_5_1_2_resp, &test_1_5_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_3, tgrp_case_1_5_1_3, name_case_1_5_1_3, desc_case_1_5_1_3, sref_case_1_5_1_3, {
	&test_1_5_1_3_conn, &test_1_5_1_3_resp, &test_1_5_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_4, tgrp_case_1_5_1_4, name_case_1_5_1_4, desc_case_1_5_1_4, sref_case_1_5_1_4, {
	&test_1_5_1_4_conn, &test_1_5_1_4_resp, &test_1_5_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_5, tgrp_case_1_5_1_5, name_case_1_5_1_5, desc_case_1_5_1_5, sref_case_1_5_1_5, {
	&test_1_5_1_5_conn, &test_1_5_1_5_resp, &test_1_5_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_6, tgrp_case_1_5_1_6, name_case_1_5_1_6, desc_case_1_5_1_6, sref_case_1_5_1_6, {
	&test_1_5_1_6_conn, &test_1_5_1_6_resp, &test_1_5_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_1_7, tgrp_case_1_5_1_7, name_case_1_5_1_7, desc_case_1_5_1_7, sref_case_1_5_1_7, {
	&test_1_5_1_7_conn, &test_1_5_1_7_resp, &test_1_5_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_2_1, tgrp_case_1_5_2_1, name_case_1_5_2_1, desc_case_1_5_2_1, sref_case_1_5_2_1, {
	&test_1_5_2_1_conn, &test_1_5_2_1_resp, &test_1_5_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_2_2, tgrp_case_1_5_2_2, name_case_1_5_2_2, desc_case_1_5_2_2, sref_case_1_5_2_2, {
	&test_1_5_2_2_conn, &test_1_5_2_2_resp, &test_1_5_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_2_3, tgrp_case_1_5_2_3, name_case_1_5_2_3, desc_case_1_5_2_3, sref_case_1_5_2_3, {
	&test_1_5_2_3_conn, &test_1_5_2_3_resp, &test_1_5_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_2_4, tgrp_case_1_5_2_4, name_case_1_5_2_4, desc_case_1_5_2_4, sref_case_1_5_2_4, {
	&test_1_5_2_4_conn, &test_1_5_2_4_resp, &test_1_5_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_2_5, tgrp_case_1_5_2_5, name_case_1_5_2_5, desc_case_1_5_2_5, sref_case_1_5_2_5, {
	&test_1_5_2_5_conn, &test_1_5_2_5_resp, &test_1_5_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_3_1, tgrp_case_1_5_3_1, name_case_1_5_3_1, desc_case_1_5_3_1, sref_case_1_5_3_1, {
	&test_1_5_3_1_conn, &test_1_5_3_1_resp, &test_1_5_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_1, tgrp_case_1_5_4_1, name_case_1_5_4_1, desc_case_1_5_4_1, sref_case_1_5_4_1, {
	&test_1_5_4_1_conn, &test_1_5_4_1_resp, &test_1_5_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_2, tgrp_case_1_5_4_2, name_case_1_5_4_2, desc_case_1_5_4_2, sref_case_1_5_4_2, {
	&test_1_5_4_2_conn, &test_1_5_4_2_resp, &test_1_5_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_3, tgrp_case_1_5_4_3, name_case_1_5_4_3, desc_case_1_5_4_3, sref_case_1_5_4_3, {
	&test_1_5_4_3_conn, &test_1_5_4_3_resp, &test_1_5_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_4, tgrp_case_1_5_4_4, name_case_1_5_4_4, desc_case_1_5_4_4, sref_case_1_5_4_4, {
	&test_1_5_4_4_conn, &test_1_5_4_4_resp, &test_1_5_4_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_5, tgrp_case_1_5_4_5, name_case_1_5_4_5, desc_case_1_5_4_5, sref_case_1_5_4_5, {
	&test_1_5_4_5_conn, &test_1_5_4_5_resp, &test_1_5_4_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_6, tgrp_case_1_5_4_6, name_case_1_5_4_6, desc_case_1_5_4_6, sref_case_1_5_4_6, {
	&test_1_5_4_6_conn, &test_1_5_4_6_resp, &test_1_5_4_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_7, tgrp_case_1_5_4_7, name_case_1_5_4_7, desc_case_1_5_4_7, sref_case_1_5_4_7, {
	&test_1_5_4_7_conn, &test_1_5_4_7_resp, &test_1_5_4_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_8, tgrp_case_1_5_4_8, name_case_1_5_4_8, desc_case_1_5_4_8, sref_case_1_5_4_8, {
	&test_1_5_4_8_conn, &test_1_5_4_8_resp, &test_1_5_4_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_9, tgrp_case_1_5_4_9, name_case_1_5_4_9, desc_case_1_5_4_9, sref_case_1_5_4_9, {
	&test_1_5_4_9_conn, &test_1_5_4_9_resp, &test_1_5_4_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_10, tgrp_case_1_5_4_10, name_case_1_5_4_10, desc_case_1_5_4_10, sref_case_1_5_4_10, {
	&test_1_5_4_10_conn, &test_1_5_4_10_resp, &test_1_5_4_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_11, tgrp_case_1_5_4_11, name_case_1_5_4_11, desc_case_1_5_4_11, sref_case_1_5_4_11, {
	&test_1_5_4_11_conn, &test_1_5_4_11_resp, &test_1_5_4_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_12, tgrp_case_1_5_4_12, name_case_1_5_4_12, desc_case_1_5_4_12, sref_case_1_5_4_12, {
	&test_1_5_4_12_conn, &test_1_5_4_12_resp, &test_1_5_4_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_4_13, tgrp_case_1_5_4_13, name_case_1_5_4_13, desc_case_1_5_4_13, sref_case_1_5_4_13, {
	&test_1_5_4_13_conn, &test_1_5_4_13_resp, &test_1_5_4_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_1, tgrp_case_1_5_5_1, name_case_1_5_5_1, desc_case_1_5_5_1, sref_case_1_5_5_1, {
	&test_1_5_5_1_conn, &test_1_5_5_1_resp, &test_1_5_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_2, tgrp_case_1_5_5_2, name_case_1_5_5_2, desc_case_1_5_5_2, sref_case_1_5_5_2, {
	&test_1_5_5_2_conn, &test_1_5_5_2_resp, &test_1_5_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_3, tgrp_case_1_5_5_3, name_case_1_5_5_3, desc_case_1_5_5_3, sref_case_1_5_5_3, {
	&test_1_5_5_3_conn, &test_1_5_5_3_resp, &test_1_5_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_4, tgrp_case_1_5_5_4, name_case_1_5_5_4, desc_case_1_5_5_4, sref_case_1_5_5_4, {
	&test_1_5_5_4_conn, &test_1_5_5_4_resp, &test_1_5_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_5, tgrp_case_1_5_5_5, name_case_1_5_5_5, desc_case_1_5_5_5, sref_case_1_5_5_5, {
	&test_1_5_5_5_conn, &test_1_5_5_5_resp, &test_1_5_5_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_6, tgrp_case_1_5_5_6, name_case_1_5_5_6, desc_case_1_5_5_6, sref_case_1_5_5_6, {
	&test_1_5_5_6_conn, &test_1_5_5_6_resp, &test_1_5_5_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_7, tgrp_case_1_5_5_7, name_case_1_5_5_7, desc_case_1_5_5_7, sref_case_1_5_5_7, {
	&test_1_5_5_7_conn, &test_1_5_5_7_resp, &test_1_5_5_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_8, tgrp_case_1_5_5_8, name_case_1_5_5_8, desc_case_1_5_5_8, sref_case_1_5_5_8, {
	&test_1_5_5_8_conn, &test_1_5_5_8_resp, &test_1_5_5_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_9, tgrp_case_1_5_5_9, name_case_1_5_5_9, desc_case_1_5_5_9, sref_case_1_5_5_9, {
	&test_1_5_5_9_conn, &test_1_5_5_9_resp, &test_1_5_5_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_10, tgrp_case_1_5_5_10, name_case_1_5_5_10, desc_case_1_5_5_10, sref_case_1_5_5_10, {
	&test_1_5_5_10_conn, &test_1_5_5_10_resp, &test_1_5_5_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_11, tgrp_case_1_5_5_11, name_case_1_5_5_11, desc_case_1_5_5_11, sref_case_1_5_5_11, {
	&test_1_5_5_11_conn, &test_1_5_5_11_resp, &test_1_5_5_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_12, tgrp_case_1_5_5_12, name_case_1_5_5_12, desc_case_1_5_5_12, sref_case_1_5_5_12, {
	&test_1_5_5_12_conn, &test_1_5_5_12_resp, &test_1_5_5_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_13, tgrp_case_1_5_5_13, name_case_1_5_5_13, desc_case_1_5_5_13, sref_case_1_5_5_13, {
	&test_1_5_5_13_conn, &test_1_5_5_13_resp, &test_1_5_5_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_14, tgrp_case_1_5_5_14, name_case_1_5_5_14, desc_case_1_5_5_14, sref_case_1_5_5_14, {
	&test_1_5_5_14_conn, &test_1_5_5_14_resp, &test_1_5_5_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_15, tgrp_case_1_5_5_15, name_case_1_5_5_15, desc_case_1_5_5_15, sref_case_1_5_5_15, {
	&test_1_5_5_15_conn, &test_1_5_5_15_resp, &test_1_5_5_15_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_16, tgrp_case_1_5_5_16, name_case_1_5_5_16, desc_case_1_5_5_16, sref_case_1_5_5_16, {
	&test_1_5_5_16_conn, &test_1_5_5_16_resp, &test_1_5_5_16_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_17, tgrp_case_1_5_5_17, name_case_1_5_5_17, desc_case_1_5_5_17, sref_case_1_5_5_17, {
	&test_1_5_5_17_conn, &test_1_5_5_17_resp, &test_1_5_5_17_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_18, tgrp_case_1_5_5_18, name_case_1_5_5_18, desc_case_1_5_5_18, sref_case_1_5_5_18, {
	&test_1_5_5_18_conn, &test_1_5_5_18_resp, &test_1_5_5_18_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_19, tgrp_case_1_5_5_19, name_case_1_5_5_19, desc_case_1_5_5_19, sref_case_1_5_5_19, {
	&test_1_5_5_19_conn, &test_1_5_5_19_resp, &test_1_5_5_19_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_20, tgrp_case_1_5_5_20, name_case_1_5_5_20, desc_case_1_5_5_20, sref_case_1_5_5_20, {
	&test_1_5_5_20_conn, &test_1_5_5_20_resp, &test_1_5_5_20_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_21, tgrp_case_1_5_5_21, name_case_1_5_5_21, desc_case_1_5_5_21, sref_case_1_5_5_21, {
	&test_1_5_5_21_conn, &test_1_5_5_21_resp, &test_1_5_5_21_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_22, tgrp_case_1_5_5_22, name_case_1_5_5_22, desc_case_1_5_5_22, sref_case_1_5_5_22, {
	&test_1_5_5_22_conn, &test_1_5_5_22_resp, &test_1_5_5_22_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_23, tgrp_case_1_5_5_23, name_case_1_5_5_23, desc_case_1_5_5_23, sref_case_1_5_5_23, {
	&test_1_5_5_23_conn, &test_1_5_5_23_resp, &test_1_5_5_23_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_24, tgrp_case_1_5_5_24, name_case_1_5_5_24, desc_case_1_5_5_24, sref_case_1_5_5_24, {
	&test_1_5_5_24_conn, &test_1_5_5_24_resp, &test_1_5_5_24_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_25, tgrp_case_1_5_5_25, name_case_1_5_5_25, desc_case_1_5_5_25, sref_case_1_5_5_25, {
	&test_1_5_5_25_conn, &test_1_5_5_25_resp, &test_1_5_5_25_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_26, tgrp_case_1_5_5_26, name_case_1_5_5_26, desc_case_1_5_5_26, sref_case_1_5_5_26, {
	&test_1_5_5_26_conn, &test_1_5_5_26_resp, &test_1_5_5_26_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_27, tgrp_case_1_5_5_27, name_case_1_5_5_27, desc_case_1_5_5_27, sref_case_1_5_5_27, {
	&test_1_5_5_27_conn, &test_1_5_5_27_resp, &test_1_5_5_27_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_28, tgrp_case_1_5_5_28, name_case_1_5_5_28, desc_case_1_5_5_28, sref_case_1_5_5_28, {
	&test_1_5_5_28_conn, &test_1_5_5_28_resp, &test_1_5_5_28_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_29, tgrp_case_1_5_5_29, name_case_1_5_5_29, desc_case_1_5_5_29, sref_case_1_5_5_29, {
	&test_1_5_5_29_conn, &test_1_5_5_29_resp, &test_1_5_5_29_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_30, tgrp_case_1_5_5_30, name_case_1_5_5_30, desc_case_1_5_5_30, sref_case_1_5_5_30, {
	&test_1_5_5_30_conn, &test_1_5_5_30_resp, &test_1_5_5_30_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_31, tgrp_case_1_5_5_31, name_case_1_5_5_31, desc_case_1_5_5_31, sref_case_1_5_5_31, {
	&test_1_5_5_31_conn, &test_1_5_5_31_resp, &test_1_5_5_31_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_32, tgrp_case_1_5_5_32, name_case_1_5_5_32, desc_case_1_5_5_32, sref_case_1_5_5_32, {
	&test_1_5_5_32_conn, &test_1_5_5_32_resp, &test_1_5_5_32_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_33, tgrp_case_1_5_5_33, name_case_1_5_5_33, desc_case_1_5_5_33, sref_case_1_5_5_33, {
	&test_1_5_5_33_conn, &test_1_5_5_33_resp, &test_1_5_5_33_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_34, tgrp_case_1_5_5_34, name_case_1_5_5_34, desc_case_1_5_5_34, sref_case_1_5_5_34, {
	&test_1_5_5_34_conn, &test_1_5_5_34_resp, &test_1_5_5_34_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_35, tgrp_case_1_5_5_35, name_case_1_5_5_35, desc_case_1_5_5_35, sref_case_1_5_5_35, {
	&test_1_5_5_35_conn, &test_1_5_5_35_resp, &test_1_5_5_35_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_36, tgrp_case_1_5_5_36, name_case_1_5_5_36, desc_case_1_5_5_36, sref_case_1_5_5_36, {
	&test_1_5_5_36_conn, &test_1_5_5_36_resp, &test_1_5_5_36_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_37, tgrp_case_1_5_5_37, name_case_1_5_5_37, desc_case_1_5_5_37, sref_case_1_5_5_37, {
	&test_1_5_5_37_conn, &test_1_5_5_37_resp, &test_1_5_5_37_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_5_5_38, tgrp_case_1_5_5_38, name_case_1_5_5_38, desc_case_1_5_5_38, sref_case_1_5_5_38, {
	&test_1_5_5_38_conn, &test_1_5_5_38_resp, &test_1_5_5_38_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_1, tgrp_case_1_6_1_1, name_case_1_6_1_1, desc_case_1_6_1_1, sref_case_1_6_1_1, {
	&test_1_6_1_1_conn, &test_1_6_1_1_resp, &test_1_6_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_2, tgrp_case_1_6_1_2, name_case_1_6_1_2, desc_case_1_6_1_2, sref_case_1_6_1_2, {
	&test_1_6_1_2_conn, &test_1_6_1_2_resp, &test_1_6_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_3, tgrp_case_1_6_1_3, name_case_1_6_1_3, desc_case_1_6_1_3, sref_case_1_6_1_3, {
	&test_1_6_1_3_conn, &test_1_6_1_3_resp, &test_1_6_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_4, tgrp_case_1_6_1_4, name_case_1_6_1_4, desc_case_1_6_1_4, sref_case_1_6_1_4, {
	&test_1_6_1_4_conn, &test_1_6_1_4_resp, &test_1_6_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_5, tgrp_case_1_6_1_5, name_case_1_6_1_5, desc_case_1_6_1_5, sref_case_1_6_1_5, {
	&test_1_6_1_5_conn, &test_1_6_1_5_resp, &test_1_6_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_6, tgrp_case_1_6_1_6, name_case_1_6_1_6, desc_case_1_6_1_6, sref_case_1_6_1_6, {
	&test_1_6_1_6_conn, &test_1_6_1_6_resp, &test_1_6_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_1_7, tgrp_case_1_6_1_7, name_case_1_6_1_7, desc_case_1_6_1_7, sref_case_1_6_1_7, {
	&test_1_6_1_7_conn, &test_1_6_1_7_resp, &test_1_6_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_2_1, tgrp_case_1_6_2_1, name_case_1_6_2_1, desc_case_1_6_2_1, sref_case_1_6_2_1, {
	&test_1_6_2_1_conn, &test_1_6_2_1_resp, &test_1_6_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_2_2, tgrp_case_1_6_2_2, name_case_1_6_2_2, desc_case_1_6_2_2, sref_case_1_6_2_2, {
	&test_1_6_2_2_conn, &test_1_6_2_2_resp, &test_1_6_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_2_3, tgrp_case_1_6_2_3, name_case_1_6_2_3, desc_case_1_6_2_3, sref_case_1_6_2_3, {
	&test_1_6_2_3_conn, &test_1_6_2_3_resp, &test_1_6_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_2_4, tgrp_case_1_6_2_4, name_case_1_6_2_4, desc_case_1_6_2_4, sref_case_1_6_2_4, {
	&test_1_6_2_4_conn, &test_1_6_2_4_resp, &test_1_6_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_2_5, tgrp_case_1_6_2_5, name_case_1_6_2_5, desc_case_1_6_2_5, sref_case_1_6_2_5, {
	&test_1_6_2_5_conn, &test_1_6_2_5_resp, &test_1_6_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_3_1, tgrp_case_1_6_3_1, name_case_1_6_3_1, desc_case_1_6_3_1, sref_case_1_6_3_1, {
	&test_1_6_3_1_conn, &test_1_6_3_1_resp, &test_1_6_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_1, tgrp_case_1_6_4_1, name_case_1_6_4_1, desc_case_1_6_4_1, sref_case_1_6_4_1, {
	&test_1_6_4_1_conn, &test_1_6_4_1_resp, &test_1_6_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_2, tgrp_case_1_6_4_2, name_case_1_6_4_2, desc_case_1_6_4_2, sref_case_1_6_4_2, {
	&test_1_6_4_2_conn, &test_1_6_4_2_resp, &test_1_6_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_3, tgrp_case_1_6_4_3, name_case_1_6_4_3, desc_case_1_6_4_3, sref_case_1_6_4_3, {
	&test_1_6_4_3_conn, &test_1_6_4_3_resp, &test_1_6_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_4, tgrp_case_1_6_4_4, name_case_1_6_4_4, desc_case_1_6_4_4, sref_case_1_6_4_4, {
	&test_1_6_4_4_conn, &test_1_6_4_4_resp, &test_1_6_4_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_5, tgrp_case_1_6_4_5, name_case_1_6_4_5, desc_case_1_6_4_5, sref_case_1_6_4_5, {
	&test_1_6_4_5_conn, &test_1_6_4_5_resp, &test_1_6_4_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_6, tgrp_case_1_6_4_6, name_case_1_6_4_6, desc_case_1_6_4_6, sref_case_1_6_4_6, {
	&test_1_6_4_6_conn, &test_1_6_4_6_resp, &test_1_6_4_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_7, tgrp_case_1_6_4_7, name_case_1_6_4_7, desc_case_1_6_4_7, sref_case_1_6_4_7, {
	&test_1_6_4_7_conn, &test_1_6_4_7_resp, &test_1_6_4_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_8, tgrp_case_1_6_4_8, name_case_1_6_4_8, desc_case_1_6_4_8, sref_case_1_6_4_8, {
	&test_1_6_4_8_conn, &test_1_6_4_8_resp, &test_1_6_4_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_9, tgrp_case_1_6_4_9, name_case_1_6_4_9, desc_case_1_6_4_9, sref_case_1_6_4_9, {
	&test_1_6_4_9_conn, &test_1_6_4_9_resp, &test_1_6_4_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_10, tgrp_case_1_6_4_10, name_case_1_6_4_10, desc_case_1_6_4_10, sref_case_1_6_4_10, {
	&test_1_6_4_10_conn, &test_1_6_4_10_resp, &test_1_6_4_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_11, tgrp_case_1_6_4_11, name_case_1_6_4_11, desc_case_1_6_4_11, sref_case_1_6_4_11, {
	&test_1_6_4_11_conn, &test_1_6_4_11_resp, &test_1_6_4_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_12, tgrp_case_1_6_4_12, name_case_1_6_4_12, desc_case_1_6_4_12, sref_case_1_6_4_12, {
	&test_1_6_4_12_conn, &test_1_6_4_12_resp, &test_1_6_4_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_4_13, tgrp_case_1_6_4_13, name_case_1_6_4_13, desc_case_1_6_4_13, sref_case_1_6_4_13, {
	&test_1_6_4_13_conn, &test_1_6_4_13_resp, &test_1_6_4_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_1, tgrp_case_1_6_5_1, name_case_1_6_5_1, desc_case_1_6_5_1, sref_case_1_6_5_1, {
	&test_1_6_5_1_conn, &test_1_6_5_1_resp, &test_1_6_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_2, tgrp_case_1_6_5_2, name_case_1_6_5_2, desc_case_1_6_5_2, sref_case_1_6_5_2, {
	&test_1_6_5_2_conn, &test_1_6_5_2_resp, &test_1_6_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_3, tgrp_case_1_6_5_3, name_case_1_6_5_3, desc_case_1_6_5_3, sref_case_1_6_5_3, {
	&test_1_6_5_3_conn, &test_1_6_5_3_resp, &test_1_6_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_4, tgrp_case_1_6_5_4, name_case_1_6_5_4, desc_case_1_6_5_4, sref_case_1_6_5_4, {
	&test_1_6_5_4_conn, &test_1_6_5_4_resp, &test_1_6_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_5, tgrp_case_1_6_5_5, name_case_1_6_5_5, desc_case_1_6_5_5, sref_case_1_6_5_5, {
	&test_1_6_5_5_conn, &test_1_6_5_5_resp, &test_1_6_5_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_6, tgrp_case_1_6_5_6, name_case_1_6_5_6, desc_case_1_6_5_6, sref_case_1_6_5_6, {
	&test_1_6_5_6_conn, &test_1_6_5_6_resp, &test_1_6_5_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_7, tgrp_case_1_6_5_7, name_case_1_6_5_7, desc_case_1_6_5_7, sref_case_1_6_5_7, {
	&test_1_6_5_7_conn, &test_1_6_5_7_resp, &test_1_6_5_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_8, tgrp_case_1_6_5_8, name_case_1_6_5_8, desc_case_1_6_5_8, sref_case_1_6_5_8, {
	&test_1_6_5_8_conn, &test_1_6_5_8_resp, &test_1_6_5_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_9, tgrp_case_1_6_5_9, name_case_1_6_5_9, desc_case_1_6_5_9, sref_case_1_6_5_9, {
	&test_1_6_5_9_conn, &test_1_6_5_9_resp, &test_1_6_5_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_10, tgrp_case_1_6_5_10, name_case_1_6_5_10, desc_case_1_6_5_10, sref_case_1_6_5_10, {
	&test_1_6_5_10_conn, &test_1_6_5_10_resp, &test_1_6_5_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_11, tgrp_case_1_6_5_11, name_case_1_6_5_11, desc_case_1_6_5_11, sref_case_1_6_5_11, {
	&test_1_6_5_11_conn, &test_1_6_5_11_resp, &test_1_6_5_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_12, tgrp_case_1_6_5_12, name_case_1_6_5_12, desc_case_1_6_5_12, sref_case_1_6_5_12, {
	&test_1_6_5_12_conn, &test_1_6_5_12_resp, &test_1_6_5_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_13, tgrp_case_1_6_5_13, name_case_1_6_5_13, desc_case_1_6_5_13, sref_case_1_6_5_13, {
	&test_1_6_5_13_conn, &test_1_6_5_13_resp, &test_1_6_5_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_14, tgrp_case_1_6_5_14, name_case_1_6_5_14, desc_case_1_6_5_14, sref_case_1_6_5_14, {
	&test_1_6_5_14_conn, &test_1_6_5_14_resp, &test_1_6_5_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_15, tgrp_case_1_6_5_15, name_case_1_6_5_15, desc_case_1_6_5_15, sref_case_1_6_5_15, {
	&test_1_6_5_15_conn, &test_1_6_5_15_resp, &test_1_6_5_15_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_16, tgrp_case_1_6_5_16, name_case_1_6_5_16, desc_case_1_6_5_16, sref_case_1_6_5_16, {
	&test_1_6_5_16_conn, &test_1_6_5_16_resp, &test_1_6_5_16_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_17, tgrp_case_1_6_5_17, name_case_1_6_5_17, desc_case_1_6_5_17, sref_case_1_6_5_17, {
	&test_1_6_5_17_conn, &test_1_6_5_17_resp, &test_1_6_5_17_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_18, tgrp_case_1_6_5_18, name_case_1_6_5_18, desc_case_1_6_5_18, sref_case_1_6_5_18, {
	&test_1_6_5_18_conn, &test_1_6_5_18_resp, &test_1_6_5_18_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_19, tgrp_case_1_6_5_19, name_case_1_6_5_19, desc_case_1_6_5_19, sref_case_1_6_5_19, {
	&test_1_6_5_19_conn, &test_1_6_5_19_resp, &test_1_6_5_19_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_20, tgrp_case_1_6_5_20, name_case_1_6_5_20, desc_case_1_6_5_20, sref_case_1_6_5_20, {
	&test_1_6_5_20_conn, &test_1_6_5_20_resp, &test_1_6_5_20_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_21, tgrp_case_1_6_5_21, name_case_1_6_5_21, desc_case_1_6_5_21, sref_case_1_6_5_21, {
	&test_1_6_5_21_conn, &test_1_6_5_21_resp, &test_1_6_5_21_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_22, tgrp_case_1_6_5_22, name_case_1_6_5_22, desc_case_1_6_5_22, sref_case_1_6_5_22, {
	&test_1_6_5_22_conn, &test_1_6_5_22_resp, &test_1_6_5_22_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_23, tgrp_case_1_6_5_23, name_case_1_6_5_23, desc_case_1_6_5_23, sref_case_1_6_5_23, {
	&test_1_6_5_23_conn, &test_1_6_5_23_resp, &test_1_6_5_23_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_24, tgrp_case_1_6_5_24, name_case_1_6_5_24, desc_case_1_6_5_24, sref_case_1_6_5_24, {
	&test_1_6_5_24_conn, &test_1_6_5_24_resp, &test_1_6_5_24_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_25, tgrp_case_1_6_5_25, name_case_1_6_5_25, desc_case_1_6_5_25, sref_case_1_6_5_25, {
	&test_1_6_5_25_conn, &test_1_6_5_25_resp, &test_1_6_5_25_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_26, tgrp_case_1_6_5_26, name_case_1_6_5_26, desc_case_1_6_5_26, sref_case_1_6_5_26, {
	&test_1_6_5_26_conn, &test_1_6_5_26_resp, &test_1_6_5_26_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_27, tgrp_case_1_6_5_27, name_case_1_6_5_27, desc_case_1_6_5_27, sref_case_1_6_5_27, {
	&test_1_6_5_27_conn, &test_1_6_5_27_resp, &test_1_6_5_27_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_28, tgrp_case_1_6_5_28, name_case_1_6_5_28, desc_case_1_6_5_28, sref_case_1_6_5_28, {
	&test_1_6_5_28_conn, &test_1_6_5_28_resp, &test_1_6_5_28_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_29, tgrp_case_1_6_5_29, name_case_1_6_5_29, desc_case_1_6_5_29, sref_case_1_6_5_29, {
	&test_1_6_5_29_conn, &test_1_6_5_29_resp, &test_1_6_5_29_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_30, tgrp_case_1_6_5_30, name_case_1_6_5_30, desc_case_1_6_5_30, sref_case_1_6_5_30, {
	&test_1_6_5_30_conn, &test_1_6_5_30_resp, &test_1_6_5_30_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_31, tgrp_case_1_6_5_31, name_case_1_6_5_31, desc_case_1_6_5_31, sref_case_1_6_5_31, {
	&test_1_6_5_31_conn, &test_1_6_5_31_resp, &test_1_6_5_31_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_32, tgrp_case_1_6_5_32, name_case_1_6_5_32, desc_case_1_6_5_32, sref_case_1_6_5_32, {
	&test_1_6_5_32_conn, &test_1_6_5_32_resp, &test_1_6_5_32_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_33, tgrp_case_1_6_5_33, name_case_1_6_5_33, desc_case_1_6_5_33, sref_case_1_6_5_33, {
	&test_1_6_5_33_conn, &test_1_6_5_33_resp, &test_1_6_5_33_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_34, tgrp_case_1_6_5_34, name_case_1_6_5_34, desc_case_1_6_5_34, sref_case_1_6_5_34, {
	&test_1_6_5_34_conn, &test_1_6_5_34_resp, &test_1_6_5_34_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_35, tgrp_case_1_6_5_35, name_case_1_6_5_35, desc_case_1_6_5_35, sref_case_1_6_5_35, {
	&test_1_6_5_35_conn, &test_1_6_5_35_resp, &test_1_6_5_35_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_36, tgrp_case_1_6_5_36, name_case_1_6_5_36, desc_case_1_6_5_36, sref_case_1_6_5_36, {
	&test_1_6_5_36_conn, &test_1_6_5_36_resp, &test_1_6_5_36_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_37, tgrp_case_1_6_5_37, name_case_1_6_5_37, desc_case_1_6_5_37, sref_case_1_6_5_37, {
	&test_1_6_5_37_conn, &test_1_6_5_37_resp, &test_1_6_5_37_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_6_5_38, tgrp_case_1_6_5_38, name_case_1_6_5_38, desc_case_1_6_5_38, sref_case_1_6_5_38, {
	&test_1_6_5_38_conn, &test_1_6_5_38_resp, &test_1_6_5_38_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_1, tgrp_case_1_7_1_1, name_case_1_7_1_1, desc_case_1_7_1_1, sref_case_1_7_1_1, {
	&test_1_7_1_1_conn, &test_1_7_1_1_resp, &test_1_7_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_2, tgrp_case_1_7_1_2, name_case_1_7_1_2, desc_case_1_7_1_2, sref_case_1_7_1_2, {
	&test_1_7_1_2_conn, &test_1_7_1_2_resp, &test_1_7_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_3, tgrp_case_1_7_1_3, name_case_1_7_1_3, desc_case_1_7_1_3, sref_case_1_7_1_3, {
	&test_1_7_1_3_conn, &test_1_7_1_3_resp, &test_1_7_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_4, tgrp_case_1_7_1_4, name_case_1_7_1_4, desc_case_1_7_1_4, sref_case_1_7_1_4, {
	&test_1_7_1_4_conn, &test_1_7_1_4_resp, &test_1_7_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_5, tgrp_case_1_7_1_5, name_case_1_7_1_5, desc_case_1_7_1_5, sref_case_1_7_1_5, {
	&test_1_7_1_5_conn, &test_1_7_1_5_resp, &test_1_7_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_6, tgrp_case_1_7_1_6, name_case_1_7_1_6, desc_case_1_7_1_6, sref_case_1_7_1_6, {
	&test_1_7_1_6_conn, &test_1_7_1_6_resp, &test_1_7_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_1_7, tgrp_case_1_7_1_7, name_case_1_7_1_7, desc_case_1_7_1_7, sref_case_1_7_1_7, {
	&test_1_7_1_7_conn, &test_1_7_1_7_resp, &test_1_7_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_2_1, tgrp_case_1_7_2_1, name_case_1_7_2_1, desc_case_1_7_2_1, sref_case_1_7_2_1, {
	&test_1_7_2_1_conn, &test_1_7_2_1_resp, &test_1_7_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_2_2, tgrp_case_1_7_2_2, name_case_1_7_2_2, desc_case_1_7_2_2, sref_case_1_7_2_2, {
	&test_1_7_2_2_conn, &test_1_7_2_2_resp, &test_1_7_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_2_3, tgrp_case_1_7_2_3, name_case_1_7_2_3, desc_case_1_7_2_3, sref_case_1_7_2_3, {
	&test_1_7_2_3_conn, &test_1_7_2_3_resp, &test_1_7_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_2_4, tgrp_case_1_7_2_4, name_case_1_7_2_4, desc_case_1_7_2_4, sref_case_1_7_2_4, {
	&test_1_7_2_4_conn, &test_1_7_2_4_resp, &test_1_7_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_2_5, tgrp_case_1_7_2_5, name_case_1_7_2_5, desc_case_1_7_2_5, sref_case_1_7_2_5, {
	&test_1_7_2_5_conn, &test_1_7_2_5_resp, &test_1_7_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_3_1, tgrp_case_1_7_3_1, name_case_1_7_3_1, desc_case_1_7_3_1, sref_case_1_7_3_1, {
	&test_1_7_3_1_conn, &test_1_7_3_1_resp, &test_1_7_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_1, tgrp_case_1_7_4_1, name_case_1_7_4_1, desc_case_1_7_4_1, sref_case_1_7_4_1, {
	&test_1_7_4_1_conn, &test_1_7_4_1_resp, &test_1_7_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_2, tgrp_case_1_7_4_2, name_case_1_7_4_2, desc_case_1_7_4_2, sref_case_1_7_4_2, {
	&test_1_7_4_2_conn, &test_1_7_4_2_resp, &test_1_7_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_3, tgrp_case_1_7_4_3, name_case_1_7_4_3, desc_case_1_7_4_3, sref_case_1_7_4_3, {
	&test_1_7_4_3_conn, &test_1_7_4_3_resp, &test_1_7_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_4, tgrp_case_1_7_4_4, name_case_1_7_4_4, desc_case_1_7_4_4, sref_case_1_7_4_4, {
	&test_1_7_4_4_conn, &test_1_7_4_4_resp, &test_1_7_4_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_5, tgrp_case_1_7_4_5, name_case_1_7_4_5, desc_case_1_7_4_5, sref_case_1_7_4_5, {
	&test_1_7_4_5_conn, &test_1_7_4_5_resp, &test_1_7_4_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_6, tgrp_case_1_7_4_6, name_case_1_7_4_6, desc_case_1_7_4_6, sref_case_1_7_4_6, {
	&test_1_7_4_6_conn, &test_1_7_4_6_resp, &test_1_7_4_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_7, tgrp_case_1_7_4_7, name_case_1_7_4_7, desc_case_1_7_4_7, sref_case_1_7_4_7, {
	&test_1_7_4_7_conn, &test_1_7_4_7_resp, &test_1_7_4_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_8, tgrp_case_1_7_4_8, name_case_1_7_4_8, desc_case_1_7_4_8, sref_case_1_7_4_8, {
	&test_1_7_4_8_conn, &test_1_7_4_8_resp, &test_1_7_4_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_9, tgrp_case_1_7_4_9, name_case_1_7_4_9, desc_case_1_7_4_9, sref_case_1_7_4_9, {
	&test_1_7_4_9_conn, &test_1_7_4_9_resp, &test_1_7_4_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_10, tgrp_case_1_7_4_10, name_case_1_7_4_10, desc_case_1_7_4_10, sref_case_1_7_4_10, {
	&test_1_7_4_10_conn, &test_1_7_4_10_resp, &test_1_7_4_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_11, tgrp_case_1_7_4_11, name_case_1_7_4_11, desc_case_1_7_4_11, sref_case_1_7_4_11, {
	&test_1_7_4_11_conn, &test_1_7_4_11_resp, &test_1_7_4_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_12, tgrp_case_1_7_4_12, name_case_1_7_4_12, desc_case_1_7_4_12, sref_case_1_7_4_12, {
	&test_1_7_4_12_conn, &test_1_7_4_12_resp, &test_1_7_4_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_4_13, tgrp_case_1_7_4_13, name_case_1_7_4_13, desc_case_1_7_4_13, sref_case_1_7_4_13, {
	&test_1_7_4_13_conn, &test_1_7_4_13_resp, &test_1_7_4_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_1, tgrp_case_1_7_5_1, name_case_1_7_5_1, desc_case_1_7_5_1, sref_case_1_7_5_1, {
	&test_1_7_5_1_conn, &test_1_7_5_1_resp, &test_1_7_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_2, tgrp_case_1_7_5_2, name_case_1_7_5_2, desc_case_1_7_5_2, sref_case_1_7_5_2, {
	&test_1_7_5_2_conn, &test_1_7_5_2_resp, &test_1_7_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_3, tgrp_case_1_7_5_3, name_case_1_7_5_3, desc_case_1_7_5_3, sref_case_1_7_5_3, {
	&test_1_7_5_3_conn, &test_1_7_5_3_resp, &test_1_7_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_4, tgrp_case_1_7_5_4, name_case_1_7_5_4, desc_case_1_7_5_4, sref_case_1_7_5_4, {
	&test_1_7_5_4_conn, &test_1_7_5_4_resp, &test_1_7_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_5, tgrp_case_1_7_5_5, name_case_1_7_5_5, desc_case_1_7_5_5, sref_case_1_7_5_5, {
	&test_1_7_5_5_conn, &test_1_7_5_5_resp, &test_1_7_5_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_6, tgrp_case_1_7_5_6, name_case_1_7_5_6, desc_case_1_7_5_6, sref_case_1_7_5_6, {
	&test_1_7_5_6_conn, &test_1_7_5_6_resp, &test_1_7_5_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_7, tgrp_case_1_7_5_7, name_case_1_7_5_7, desc_case_1_7_5_7, sref_case_1_7_5_7, {
	&test_1_7_5_7_conn, &test_1_7_5_7_resp, &test_1_7_5_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_8, tgrp_case_1_7_5_8, name_case_1_7_5_8, desc_case_1_7_5_8, sref_case_1_7_5_8, {
	&test_1_7_5_8_conn, &test_1_7_5_8_resp, &test_1_7_5_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_9, tgrp_case_1_7_5_9, name_case_1_7_5_9, desc_case_1_7_5_9, sref_case_1_7_5_9, {
	&test_1_7_5_9_conn, &test_1_7_5_9_resp, &test_1_7_5_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_10, tgrp_case_1_7_5_10, name_case_1_7_5_10, desc_case_1_7_5_10, sref_case_1_7_5_10, {
	&test_1_7_5_10_conn, &test_1_7_5_10_resp, &test_1_7_5_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_11, tgrp_case_1_7_5_11, name_case_1_7_5_11, desc_case_1_7_5_11, sref_case_1_7_5_11, {
	&test_1_7_5_11_conn, &test_1_7_5_11_resp, &test_1_7_5_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_12, tgrp_case_1_7_5_12, name_case_1_7_5_12, desc_case_1_7_5_12, sref_case_1_7_5_12, {
	&test_1_7_5_12_conn, &test_1_7_5_12_resp, &test_1_7_5_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_13, tgrp_case_1_7_5_13, name_case_1_7_5_13, desc_case_1_7_5_13, sref_case_1_7_5_13, {
	&test_1_7_5_13_conn, &test_1_7_5_13_resp, &test_1_7_5_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_14, tgrp_case_1_7_5_14, name_case_1_7_5_14, desc_case_1_7_5_14, sref_case_1_7_5_14, {
	&test_1_7_5_14_conn, &test_1_7_5_14_resp, &test_1_7_5_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_15, tgrp_case_1_7_5_15, name_case_1_7_5_15, desc_case_1_7_5_15, sref_case_1_7_5_15, {
	&test_1_7_5_15_conn, &test_1_7_5_15_resp, &test_1_7_5_15_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_16, tgrp_case_1_7_5_16, name_case_1_7_5_16, desc_case_1_7_5_16, sref_case_1_7_5_16, {
	&test_1_7_5_16_conn, &test_1_7_5_16_resp, &test_1_7_5_16_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_17, tgrp_case_1_7_5_17, name_case_1_7_5_17, desc_case_1_7_5_17, sref_case_1_7_5_17, {
	&test_1_7_5_17_conn, &test_1_7_5_17_resp, &test_1_7_5_17_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_18, tgrp_case_1_7_5_18, name_case_1_7_5_18, desc_case_1_7_5_18, sref_case_1_7_5_18, {
	&test_1_7_5_18_conn, &test_1_7_5_18_resp, &test_1_7_5_18_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_19, tgrp_case_1_7_5_19, name_case_1_7_5_19, desc_case_1_7_5_19, sref_case_1_7_5_19, {
	&test_1_7_5_19_conn, &test_1_7_5_19_resp, &test_1_7_5_19_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_20, tgrp_case_1_7_5_20, name_case_1_7_5_20, desc_case_1_7_5_20, sref_case_1_7_5_20, {
	&test_1_7_5_20_conn, &test_1_7_5_20_resp, &test_1_7_5_20_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_21, tgrp_case_1_7_5_21, name_case_1_7_5_21, desc_case_1_7_5_21, sref_case_1_7_5_21, {
	&test_1_7_5_21_conn, &test_1_7_5_21_resp, &test_1_7_5_21_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_22, tgrp_case_1_7_5_22, name_case_1_7_5_22, desc_case_1_7_5_22, sref_case_1_7_5_22, {
	&test_1_7_5_22_conn, &test_1_7_5_22_resp, &test_1_7_5_22_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_23, tgrp_case_1_7_5_23, name_case_1_7_5_23, desc_case_1_7_5_23, sref_case_1_7_5_23, {
	&test_1_7_5_23_conn, &test_1_7_5_23_resp, &test_1_7_5_23_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_24, tgrp_case_1_7_5_24, name_case_1_7_5_24, desc_case_1_7_5_24, sref_case_1_7_5_24, {
	&test_1_7_5_24_conn, &test_1_7_5_24_resp, &test_1_7_5_24_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_25, tgrp_case_1_7_5_25, name_case_1_7_5_25, desc_case_1_7_5_25, sref_case_1_7_5_25, {
	&test_1_7_5_25_conn, &test_1_7_5_25_resp, &test_1_7_5_25_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_26, tgrp_case_1_7_5_26, name_case_1_7_5_26, desc_case_1_7_5_26, sref_case_1_7_5_26, {
	&test_1_7_5_26_conn, &test_1_7_5_26_resp, &test_1_7_5_26_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_27, tgrp_case_1_7_5_27, name_case_1_7_5_27, desc_case_1_7_5_27, sref_case_1_7_5_27, {
	&test_1_7_5_27_conn, &test_1_7_5_27_resp, &test_1_7_5_27_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_28, tgrp_case_1_7_5_28, name_case_1_7_5_28, desc_case_1_7_5_28, sref_case_1_7_5_28, {
	&test_1_7_5_28_conn, &test_1_7_5_28_resp, &test_1_7_5_28_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_29, tgrp_case_1_7_5_29, name_case_1_7_5_29, desc_case_1_7_5_29, sref_case_1_7_5_29, {
	&test_1_7_5_29_conn, &test_1_7_5_29_resp, &test_1_7_5_29_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_30, tgrp_case_1_7_5_30, name_case_1_7_5_30, desc_case_1_7_5_30, sref_case_1_7_5_30, {
	&test_1_7_5_30_conn, &test_1_7_5_30_resp, &test_1_7_5_30_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_31, tgrp_case_1_7_5_31, name_case_1_7_5_31, desc_case_1_7_5_31, sref_case_1_7_5_31, {
	&test_1_7_5_31_conn, &test_1_7_5_31_resp, &test_1_7_5_31_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_32, tgrp_case_1_7_5_32, name_case_1_7_5_32, desc_case_1_7_5_32, sref_case_1_7_5_32, {
	&test_1_7_5_32_conn, &test_1_7_5_32_resp, &test_1_7_5_32_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_33, tgrp_case_1_7_5_33, name_case_1_7_5_33, desc_case_1_7_5_33, sref_case_1_7_5_33, {
	&test_1_7_5_33_conn, &test_1_7_5_33_resp, &test_1_7_5_33_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_34, tgrp_case_1_7_5_34, name_case_1_7_5_34, desc_case_1_7_5_34, sref_case_1_7_5_34, {
	&test_1_7_5_34_conn, &test_1_7_5_34_resp, &test_1_7_5_34_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_35, tgrp_case_1_7_5_35, name_case_1_7_5_35, desc_case_1_7_5_35, sref_case_1_7_5_35, {
	&test_1_7_5_35_conn, &test_1_7_5_35_resp, &test_1_7_5_35_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_36, tgrp_case_1_7_5_36, name_case_1_7_5_36, desc_case_1_7_5_36, sref_case_1_7_5_36, {
	&test_1_7_5_36_conn, &test_1_7_5_36_resp, &test_1_7_5_36_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_37, tgrp_case_1_7_5_37, name_case_1_7_5_37, desc_case_1_7_5_37, sref_case_1_7_5_37, {
	&test_1_7_5_37_conn, &test_1_7_5_37_resp, &test_1_7_5_37_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_7_5_38, tgrp_case_1_7_5_38, name_case_1_7_5_38, desc_case_1_7_5_38, sref_case_1_7_5_38, {
	&test_1_7_5_38_conn, &test_1_7_5_38_resp, &test_1_7_5_38_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_1, tgrp_case_1_8_1_1, name_case_1_8_1_1, desc_case_1_8_1_1, sref_case_1_8_1_1, {
	&test_1_8_1_1_conn, &test_1_8_1_1_resp, &test_1_8_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_2, tgrp_case_1_8_1_2, name_case_1_8_1_2, desc_case_1_8_1_2, sref_case_1_8_1_2, {
	&test_1_8_1_2_conn, &test_1_8_1_2_resp, &test_1_8_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_3, tgrp_case_1_8_1_3, name_case_1_8_1_3, desc_case_1_8_1_3, sref_case_1_8_1_3, {
	&test_1_8_1_3_conn, &test_1_8_1_3_resp, &test_1_8_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_4, tgrp_case_1_8_1_4, name_case_1_8_1_4, desc_case_1_8_1_4, sref_case_1_8_1_4, {
	&test_1_8_1_4_conn, &test_1_8_1_4_resp, &test_1_8_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_5, tgrp_case_1_8_1_5, name_case_1_8_1_5, desc_case_1_8_1_5, sref_case_1_8_1_5, {
	&test_1_8_1_5_conn, &test_1_8_1_5_resp, &test_1_8_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_6, tgrp_case_1_8_1_6, name_case_1_8_1_6, desc_case_1_8_1_6, sref_case_1_8_1_6, {
	&test_1_8_1_6_conn, &test_1_8_1_6_resp, &test_1_8_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_1_7, tgrp_case_1_8_1_7, name_case_1_8_1_7, desc_case_1_8_1_7, sref_case_1_8_1_7, {
	&test_1_8_1_7_conn, &test_1_8_1_7_resp, &test_1_8_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_2_1, tgrp_case_1_8_2_1, name_case_1_8_2_1, desc_case_1_8_2_1, sref_case_1_8_2_1, {
	&test_1_8_2_1_conn, &test_1_8_2_1_resp, &test_1_8_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_2_2, tgrp_case_1_8_2_2, name_case_1_8_2_2, desc_case_1_8_2_2, sref_case_1_8_2_2, {
	&test_1_8_2_2_conn, &test_1_8_2_2_resp, &test_1_8_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_2_3, tgrp_case_1_8_2_3, name_case_1_8_2_3, desc_case_1_8_2_3, sref_case_1_8_2_3, {
	&test_1_8_2_3_conn, &test_1_8_2_3_resp, &test_1_8_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_2_4, tgrp_case_1_8_2_4, name_case_1_8_2_4, desc_case_1_8_2_4, sref_case_1_8_2_4, {
	&test_1_8_2_4_conn, &test_1_8_2_4_resp, &test_1_8_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_2_5, tgrp_case_1_8_2_5, name_case_1_8_2_5, desc_case_1_8_2_5, sref_case_1_8_2_5, {
	&test_1_8_2_5_conn, &test_1_8_2_5_resp, &test_1_8_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_3_1, tgrp_case_1_8_3_1, name_case_1_8_3_1, desc_case_1_8_3_1, sref_case_1_8_3_1, {
	&test_1_8_3_1_conn, &test_1_8_3_1_resp, &test_1_8_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_1, tgrp_case_1_8_4_1, name_case_1_8_4_1, desc_case_1_8_4_1, sref_case_1_8_4_1, {
	&test_1_8_4_1_conn, &test_1_8_4_1_resp, &test_1_8_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_2, tgrp_case_1_8_4_2, name_case_1_8_4_2, desc_case_1_8_4_2, sref_case_1_8_4_2, {
	&test_1_8_4_2_conn, &test_1_8_4_2_resp, &test_1_8_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_3, tgrp_case_1_8_4_3, name_case_1_8_4_3, desc_case_1_8_4_3, sref_case_1_8_4_3, {
	&test_1_8_4_3_conn, &test_1_8_4_3_resp, &test_1_8_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_4, tgrp_case_1_8_4_4, name_case_1_8_4_4, desc_case_1_8_4_4, sref_case_1_8_4_4, {
	&test_1_8_4_4_conn, &test_1_8_4_4_resp, &test_1_8_4_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_5, tgrp_case_1_8_4_5, name_case_1_8_4_5, desc_case_1_8_4_5, sref_case_1_8_4_5, {
	&test_1_8_4_5_conn, &test_1_8_4_5_resp, &test_1_8_4_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_6, tgrp_case_1_8_4_6, name_case_1_8_4_6, desc_case_1_8_4_6, sref_case_1_8_4_6, {
	&test_1_8_4_6_conn, &test_1_8_4_6_resp, &test_1_8_4_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_7, tgrp_case_1_8_4_7, name_case_1_8_4_7, desc_case_1_8_4_7, sref_case_1_8_4_7, {
	&test_1_8_4_7_conn, &test_1_8_4_7_resp, &test_1_8_4_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_8, tgrp_case_1_8_4_8, name_case_1_8_4_8, desc_case_1_8_4_8, sref_case_1_8_4_8, {
	&test_1_8_4_8_conn, &test_1_8_4_8_resp, &test_1_8_4_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_9, tgrp_case_1_8_4_9, name_case_1_8_4_9, desc_case_1_8_4_9, sref_case_1_8_4_9, {
	&test_1_8_4_9_conn, &test_1_8_4_9_resp, &test_1_8_4_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_10, tgrp_case_1_8_4_10, name_case_1_8_4_10, desc_case_1_8_4_10, sref_case_1_8_4_10, {
	&test_1_8_4_10_conn, &test_1_8_4_10_resp, &test_1_8_4_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_11, tgrp_case_1_8_4_11, name_case_1_8_4_11, desc_case_1_8_4_11, sref_case_1_8_4_11, {
	&test_1_8_4_11_conn, &test_1_8_4_11_resp, &test_1_8_4_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_12, tgrp_case_1_8_4_12, name_case_1_8_4_12, desc_case_1_8_4_12, sref_case_1_8_4_12, {
	&test_1_8_4_12_conn, &test_1_8_4_12_resp, &test_1_8_4_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_4_13, tgrp_case_1_8_4_13, name_case_1_8_4_13, desc_case_1_8_4_13, sref_case_1_8_4_13, {
	&test_1_8_4_13_conn, &test_1_8_4_13_resp, &test_1_8_4_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_1, tgrp_case_1_8_5_1, name_case_1_8_5_1, desc_case_1_8_5_1, sref_case_1_8_5_1, {
	&test_1_8_5_1_conn, &test_1_8_5_1_resp, &test_1_8_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_2, tgrp_case_1_8_5_2, name_case_1_8_5_2, desc_case_1_8_5_2, sref_case_1_8_5_2, {
	&test_1_8_5_2_conn, &test_1_8_5_2_resp, &test_1_8_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_3, tgrp_case_1_8_5_3, name_case_1_8_5_3, desc_case_1_8_5_3, sref_case_1_8_5_3, {
	&test_1_8_5_3_conn, &test_1_8_5_3_resp, &test_1_8_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_4, tgrp_case_1_8_5_4, name_case_1_8_5_4, desc_case_1_8_5_4, sref_case_1_8_5_4, {
	&test_1_8_5_4_conn, &test_1_8_5_4_resp, &test_1_8_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_5, tgrp_case_1_8_5_5, name_case_1_8_5_5, desc_case_1_8_5_5, sref_case_1_8_5_5, {
	&test_1_8_5_5_conn, &test_1_8_5_5_resp, &test_1_8_5_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_6, tgrp_case_1_8_5_6, name_case_1_8_5_6, desc_case_1_8_5_6, sref_case_1_8_5_6, {
	&test_1_8_5_6_conn, &test_1_8_5_6_resp, &test_1_8_5_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_7, tgrp_case_1_8_5_7, name_case_1_8_5_7, desc_case_1_8_5_7, sref_case_1_8_5_7, {
	&test_1_8_5_7_conn, &test_1_8_5_7_resp, &test_1_8_5_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_8, tgrp_case_1_8_5_8, name_case_1_8_5_8, desc_case_1_8_5_8, sref_case_1_8_5_8, {
	&test_1_8_5_8_conn, &test_1_8_5_8_resp, &test_1_8_5_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_9, tgrp_case_1_8_5_9, name_case_1_8_5_9, desc_case_1_8_5_9, sref_case_1_8_5_9, {
	&test_1_8_5_9_conn, &test_1_8_5_9_resp, &test_1_8_5_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_10, tgrp_case_1_8_5_10, name_case_1_8_5_10, desc_case_1_8_5_10, sref_case_1_8_5_10, {
	&test_1_8_5_10_conn, &test_1_8_5_10_resp, &test_1_8_5_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_11, tgrp_case_1_8_5_11, name_case_1_8_5_11, desc_case_1_8_5_11, sref_case_1_8_5_11, {
	&test_1_8_5_11_conn, &test_1_8_5_11_resp, &test_1_8_5_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_12, tgrp_case_1_8_5_12, name_case_1_8_5_12, desc_case_1_8_5_12, sref_case_1_8_5_12, {
	&test_1_8_5_12_conn, &test_1_8_5_12_resp, &test_1_8_5_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_13, tgrp_case_1_8_5_13, name_case_1_8_5_13, desc_case_1_8_5_13, sref_case_1_8_5_13, {
	&test_1_8_5_13_conn, &test_1_8_5_13_resp, &test_1_8_5_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_14, tgrp_case_1_8_5_14, name_case_1_8_5_14, desc_case_1_8_5_14, sref_case_1_8_5_14, {
	&test_1_8_5_14_conn, &test_1_8_5_14_resp, &test_1_8_5_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_15, tgrp_case_1_8_5_15, name_case_1_8_5_15, desc_case_1_8_5_15, sref_case_1_8_5_15, {
	&test_1_8_5_15_conn, &test_1_8_5_15_resp, &test_1_8_5_15_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_16, tgrp_case_1_8_5_16, name_case_1_8_5_16, desc_case_1_8_5_16, sref_case_1_8_5_16, {
	&test_1_8_5_16_conn, &test_1_8_5_16_resp, &test_1_8_5_16_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_17, tgrp_case_1_8_5_17, name_case_1_8_5_17, desc_case_1_8_5_17, sref_case_1_8_5_17, {
	&test_1_8_5_17_conn, &test_1_8_5_17_resp, &test_1_8_5_17_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_18, tgrp_case_1_8_5_18, name_case_1_8_5_18, desc_case_1_8_5_18, sref_case_1_8_5_18, {
	&test_1_8_5_18_conn, &test_1_8_5_18_resp, &test_1_8_5_18_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_19, tgrp_case_1_8_5_19, name_case_1_8_5_19, desc_case_1_8_5_19, sref_case_1_8_5_19, {
	&test_1_8_5_19_conn, &test_1_8_5_19_resp, &test_1_8_5_19_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_20, tgrp_case_1_8_5_20, name_case_1_8_5_20, desc_case_1_8_5_20, sref_case_1_8_5_20, {
	&test_1_8_5_20_conn, &test_1_8_5_20_resp, &test_1_8_5_20_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_21, tgrp_case_1_8_5_21, name_case_1_8_5_21, desc_case_1_8_5_21, sref_case_1_8_5_21, {
	&test_1_8_5_21_conn, &test_1_8_5_21_resp, &test_1_8_5_21_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_22, tgrp_case_1_8_5_22, name_case_1_8_5_22, desc_case_1_8_5_22, sref_case_1_8_5_22, {
	&test_1_8_5_22_conn, &test_1_8_5_22_resp, &test_1_8_5_22_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_23, tgrp_case_1_8_5_23, name_case_1_8_5_23, desc_case_1_8_5_23, sref_case_1_8_5_23, {
	&test_1_8_5_23_conn, &test_1_8_5_23_resp, &test_1_8_5_23_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_24, tgrp_case_1_8_5_24, name_case_1_8_5_24, desc_case_1_8_5_24, sref_case_1_8_5_24, {
	&test_1_8_5_24_conn, &test_1_8_5_24_resp, &test_1_8_5_24_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_25, tgrp_case_1_8_5_25, name_case_1_8_5_25, desc_case_1_8_5_25, sref_case_1_8_5_25, {
	&test_1_8_5_25_conn, &test_1_8_5_25_resp, &test_1_8_5_25_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_26, tgrp_case_1_8_5_26, name_case_1_8_5_26, desc_case_1_8_5_26, sref_case_1_8_5_26, {
	&test_1_8_5_26_conn, &test_1_8_5_26_resp, &test_1_8_5_26_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_27, tgrp_case_1_8_5_27, name_case_1_8_5_27, desc_case_1_8_5_27, sref_case_1_8_5_27, {
	&test_1_8_5_27_conn, &test_1_8_5_27_resp, &test_1_8_5_27_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_28, tgrp_case_1_8_5_28, name_case_1_8_5_28, desc_case_1_8_5_28, sref_case_1_8_5_28, {
	&test_1_8_5_28_conn, &test_1_8_5_28_resp, &test_1_8_5_28_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_29, tgrp_case_1_8_5_29, name_case_1_8_5_29, desc_case_1_8_5_29, sref_case_1_8_5_29, {
	&test_1_8_5_29_conn, &test_1_8_5_29_resp, &test_1_8_5_29_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_30, tgrp_case_1_8_5_30, name_case_1_8_5_30, desc_case_1_8_5_30, sref_case_1_8_5_30, {
	&test_1_8_5_30_conn, &test_1_8_5_30_resp, &test_1_8_5_30_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_31, tgrp_case_1_8_5_31, name_case_1_8_5_31, desc_case_1_8_5_31, sref_case_1_8_5_31, {
	&test_1_8_5_31_conn, &test_1_8_5_31_resp, &test_1_8_5_31_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_32, tgrp_case_1_8_5_32, name_case_1_8_5_32, desc_case_1_8_5_32, sref_case_1_8_5_32, {
	&test_1_8_5_32_conn, &test_1_8_5_32_resp, &test_1_8_5_32_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_33, tgrp_case_1_8_5_33, name_case_1_8_5_33, desc_case_1_8_5_33, sref_case_1_8_5_33, {
	&test_1_8_5_33_conn, &test_1_8_5_33_resp, &test_1_8_5_33_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_34, tgrp_case_1_8_5_34, name_case_1_8_5_34, desc_case_1_8_5_34, sref_case_1_8_5_34, {
	&test_1_8_5_34_conn, &test_1_8_5_34_resp, &test_1_8_5_34_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_35, tgrp_case_1_8_5_35, name_case_1_8_5_35, desc_case_1_8_5_35, sref_case_1_8_5_35, {
	&test_1_8_5_35_conn, &test_1_8_5_35_resp, &test_1_8_5_35_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_36, tgrp_case_1_8_5_36, name_case_1_8_5_36, desc_case_1_8_5_36, sref_case_1_8_5_36, {
	&test_1_8_5_36_conn, &test_1_8_5_36_resp, &test_1_8_5_36_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_37, tgrp_case_1_8_5_37, name_case_1_8_5_37, desc_case_1_8_5_37, sref_case_1_8_5_37, {
	&test_1_8_5_37_conn, &test_1_8_5_37_resp, &test_1_8_5_37_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_8_5_38, tgrp_case_1_8_5_38, name_case_1_8_5_38, desc_case_1_8_5_38, sref_case_1_8_5_38, {
	&test_1_8_5_38_conn, &test_1_8_5_38_resp, &test_1_8_5_38_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_1_1, tgrp_case_1_9_1_1, name_case_1_9_1_1, desc_case_1_9_1_1, sref_case_1_9_1_1, {
	&test_1_9_1_1_conn, &test_1_9_1_1_resp, &test_1_9_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_1_2, tgrp_case_1_9_1_2, name_case_1_9_1_2, desc_case_1_9_1_2, sref_case_1_9_1_2, {
	&test_1_9_1_2_conn, &test_1_9_1_2_resp, &test_1_9_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_1_3, tgrp_case_1_9_1_3, name_case_1_9_1_3, desc_case_1_9_1_3, sref_case_1_9_1_3, {
	&test_1_9_1_3_conn, &test_1_9_1_3_resp, &test_1_9_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_1_4, tgrp_case_1_9_1_4, name_case_1_9_1_4, desc_case_1_9_1_4, sref_case_1_9_1_4, {
	&test_1_9_1_4_conn, &test_1_9_1_4_resp, &test_1_9_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_2_1, tgrp_case_1_9_2_1, name_case_1_9_2_1, desc_case_1_9_2_1, sref_case_1_9_2_1, {
	&test_1_9_2_1_conn, &test_1_9_2_1_resp, &test_1_9_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_2_2, tgrp_case_1_9_2_2, name_case_1_9_2_2, desc_case_1_9_2_2, sref_case_1_9_2_2, {
	&test_1_9_2_2_conn, &test_1_9_2_2_resp, &test_1_9_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_2_3, tgrp_case_1_9_2_3, name_case_1_9_2_3, desc_case_1_9_2_3, sref_case_1_9_2_3, {
	&test_1_9_2_3_conn, &test_1_9_2_3_resp, &test_1_9_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_2_4, tgrp_case_1_9_2_4, name_case_1_9_2_4, desc_case_1_9_2_4, sref_case_1_9_2_4, {
	&test_1_9_2_4_conn, &test_1_9_2_4_resp, &test_1_9_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_3_1, tgrp_case_1_9_3_1, name_case_1_9_3_1, desc_case_1_9_3_1, sref_case_1_9_3_1, {
	&test_1_9_3_1_conn, &test_1_9_3_1_resp, &test_1_9_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_3_2, tgrp_case_1_9_3_2, name_case_1_9_3_2, desc_case_1_9_3_2, sref_case_1_9_3_2, {
	&test_1_9_3_2_conn, &test_1_9_3_2_resp, &test_1_9_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_3_3, tgrp_case_1_9_3_3, name_case_1_9_3_3, desc_case_1_9_3_3, sref_case_1_9_3_3, {
	&test_1_9_3_3_conn, &test_1_9_3_3_resp, &test_1_9_3_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_9_3_4, tgrp_case_1_9_3_4, name_case_1_9_3_4, desc_case_1_9_3_4, sref_case_1_9_3_4, {
	&test_1_9_3_4_conn, &test_1_9_3_4_resp, &test_1_9_3_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_1, tgrp_case_1_10_1, name_case_1_10_1, desc_case_1_10_1, sref_case_1_10_1, {
	&test_1_10_1_conn, &test_1_10_1_resp, &test_1_10_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_2, tgrp_case_1_10_2, name_case_1_10_2, desc_case_1_10_2, sref_case_1_10_2, {
	&test_1_10_2_conn, &test_1_10_2_resp, &test_1_10_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_3, tgrp_case_1_10_3, name_case_1_10_3, desc_case_1_10_3, sref_case_1_10_3, {
	&test_1_10_3_conn, &test_1_10_3_resp, &test_1_10_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_4, tgrp_case_1_10_4, name_case_1_10_4, desc_case_1_10_4, sref_case_1_10_4, {
	&test_1_10_4_conn, &test_1_10_4_resp, &test_1_10_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_5, tgrp_case_1_10_5, name_case_1_10_5, desc_case_1_10_5, sref_case_1_10_5, {
	&test_1_10_5_conn, &test_1_10_5_resp, &test_1_10_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_6, tgrp_case_1_10_6, name_case_1_10_6, desc_case_1_10_6, sref_case_1_10_6, {
	&test_1_10_6_conn, &test_1_10_6_resp, &test_1_10_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_7, tgrp_case_1_10_7, name_case_1_10_7, desc_case_1_10_7, sref_case_1_10_7, {
	&test_1_10_7_conn, &test_1_10_7_resp, &test_1_10_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_8, tgrp_case_1_10_8, name_case_1_10_8, desc_case_1_10_8, sref_case_1_10_8, {
	&test_1_10_8_conn, &test_1_10_8_resp, &test_1_10_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_9, tgrp_case_1_10_9, name_case_1_10_9, desc_case_1_10_9, sref_case_1_10_9, {
	&test_1_10_9_conn, &test_1_10_9_resp, &test_1_10_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_10, tgrp_case_1_10_10, name_case_1_10_10, desc_case_1_10_10, sref_case_1_10_10, {
	&test_1_10_10_conn, &test_1_10_10_resp, &test_1_10_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_1_10_11, tgrp_case_1_10_11, name_case_1_10_11, desc_case_1_10_11, sref_case_1_10_11, {
	&test_1_10_11_conn, &test_1_10_11_resp, &test_1_10_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_2_2_1_1, tgrp_case_2_2_1_1, name_case_2_2_1_1, desc_case_2_2_1_1, sref_case_2_2_1_1, {
	&test_2_2_1_1_conn, &test_2_2_1_1_resp, &test_2_2_1_1_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_1_2, tgrp_case_2_2_1_2, name_case_2_2_1_2, desc_case_2_2_1_2, sref_case_2_2_1_2, {
	&test_2_2_1_2_conn, &test_2_2_1_2_resp, &test_2_2_1_2_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_1_3, tgrp_case_2_2_1_3, name_case_2_2_1_3, desc_case_2_2_1_3, sref_case_2_2_1_3, {
	&test_2_2_1_3_conn, &test_2_2_1_3_resp, &test_2_2_1_3_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_1_4, tgrp_case_2_2_1_4, name_case_2_2_1_4, desc_case_2_2_1_4, sref_case_2_2_1_4, {
	&test_2_2_1_4_conn, &test_2_2_1_4_resp, &test_2_2_1_4_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_1_5, tgrp_case_2_2_1_5, name_case_2_2_1_5, desc_case_2_2_1_5, sref_case_2_2_1_5, {
	&test_2_2_1_5_conn, &test_2_2_1_5_resp, &test_2_2_1_5_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_1_6, tgrp_case_2_2_1_6, name_case_2_2_1_6, desc_case_2_2_1_6, sref_case_2_2_1_6, {
	&test_2_2_1_6_conn, &test_2_2_1_6_resp, &test_2_2_1_6_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_2_1, tgrp_case_2_2_2_1, name_case_2_2_2_1, desc_case_2_2_2_1, sref_case_2_2_2_1, {
	&test_2_2_2_1_conn, &test_2_2_2_1_resp, &test_2_2_2_1_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_2_2, tgrp_case_2_2_2_2, name_case_2_2_2_2, desc_case_2_2_2_2, sref_case_2_2_2_2, {
	&test_2_2_2_2_conn, &test_2_2_2_2_resp, &test_2_2_2_2_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_2_3, tgrp_case_2_2_2_3, name_case_2_2_2_3, desc_case_2_2_2_3, sref_case_2_2_2_3, {
	&test_2_2_2_3_conn, &test_2_2_2_3_resp, &test_2_2_2_3_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_2_4, tgrp_case_2_2_2_4, name_case_2_2_2_4, desc_case_2_2_2_4, sref_case_2_2_2_4, {
	&test_2_2_2_4_conn, &test_2_2_2_4_resp, &test_2_2_2_4_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_2_5, tgrp_case_2_2_2_5, name_case_2_2_2_5, desc_case_2_2_2_5, sref_case_2_2_2_5, {
	&test_2_2_2_5_conn, &test_2_2_2_5_resp, &test_2_2_2_5_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_3_1, tgrp_case_2_2_3_1, name_case_2_2_3_1, desc_case_2_2_3_1, sref_case_2_2_3_1, {
	&test_2_2_3_1_conn, &test_2_2_3_1_resp, &test_2_2_3_1_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_1, tgrp_case_2_2_4_1, name_case_2_2_4_1, desc_case_2_2_4_1, sref_case_2_2_4_1, {
	&test_2_2_4_1_conn, &test_2_2_4_1_resp, &test_2_2_4_1_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_2, tgrp_case_2_2_4_2, name_case_2_2_4_2, desc_case_2_2_4_2, sref_case_2_2_4_2, {
	&test_2_2_4_2_conn, &test_2_2_4_2_resp, &test_2_2_4_2_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_3, tgrp_case_2_2_4_3, name_case_2_2_4_3, desc_case_2_2_4_3, sref_case_2_2_4_3, {
	&test_2_2_4_3_conn, &test_2_2_4_3_resp, &test_2_2_4_3_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_4, tgrp_case_2_2_4_4, name_case_2_2_4_4, desc_case_2_2_4_4, sref_case_2_2_4_4, {
	&test_2_2_4_4_conn, &test_2_2_4_4_resp, &test_2_2_4_4_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_5, tgrp_case_2_2_4_5, name_case_2_2_4_5, desc_case_2_2_4_5, sref_case_2_2_4_5, {
	&test_2_2_4_5_conn, &test_2_2_4_5_resp, &test_2_2_4_5_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_6, tgrp_case_2_2_4_6, name_case_2_2_4_6, desc_case_2_2_4_6, sref_case_2_2_4_6, {
	&test_2_2_4_6_conn, &test_2_2_4_6_resp, &test_2_2_4_6_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_7, tgrp_case_2_2_4_7, name_case_2_2_4_7, desc_case_2_2_4_7, sref_case_2_2_4_7, {
	&test_2_2_4_7_conn, &test_2_2_4_7_resp, &test_2_2_4_7_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_8, tgrp_case_2_2_4_8, name_case_2_2_4_8, desc_case_2_2_4_8, sref_case_2_2_4_8, {
	&test_2_2_4_8_conn, &test_2_2_4_8_resp, &test_2_2_4_8_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_9, tgrp_case_2_2_4_9, name_case_2_2_4_9, desc_case_2_2_4_9, sref_case_2_2_4_9, {
	&test_2_2_4_9_conn, &test_2_2_4_9_resp, &test_2_2_4_9_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_10, tgrp_case_2_2_4_10, name_case_2_2_4_10, desc_case_2_2_4_10, sref_case_2_2_4_10, {
	&test_2_2_4_10_conn, &test_2_2_4_10_resp, &test_2_2_4_10_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_11, tgrp_case_2_2_4_11, name_case_2_2_4_11, desc_case_2_2_4_11, sref_case_2_2_4_11, {
	&test_2_2_4_11_conn, &test_2_2_4_11_resp, &test_2_2_4_11_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_12, tgrp_case_2_2_4_12, name_case_2_2_4_12, desc_case_2_2_4_12, sref_case_2_2_4_12, {
	&test_2_2_4_12_conn, &test_2_2_4_12_resp, &test_2_2_4_12_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_4_13, tgrp_case_2_2_4_13, name_case_2_2_4_13, desc_case_2_2_4_13, sref_case_2_2_4_13, {
	&test_2_2_4_13_conn, &test_2_2_4_13_resp, &test_2_2_4_13_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_1, tgrp_case_2_2_5_1, name_case_2_2_5_1, desc_case_2_2_5_1, sref_case_2_2_5_1, {
	&test_2_2_5_1_conn, &test_2_2_5_1_resp, &test_2_2_5_1_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_2, tgrp_case_2_2_5_2, name_case_2_2_5_2, desc_case_2_2_5_2, sref_case_2_2_5_2, {
	&test_2_2_5_2_conn, &test_2_2_5_2_resp, &test_2_2_5_2_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_3, tgrp_case_2_2_5_3, name_case_2_2_5_3, desc_case_2_2_5_3, sref_case_2_2_5_3, {
	&test_2_2_5_3_conn, &test_2_2_5_3_resp, &test_2_2_5_3_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_4, tgrp_case_2_2_5_4, name_case_2_2_5_4, desc_case_2_2_5_4, sref_case_2_2_5_4, {
	&test_2_2_5_4_conn, &test_2_2_5_4_resp, &test_2_2_5_4_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_5, tgrp_case_2_2_5_5, name_case_2_2_5_5, desc_case_2_2_5_5, sref_case_2_2_5_5, {
	&test_2_2_5_5_conn, &test_2_2_5_5_resp, &test_2_2_5_5_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_6, tgrp_case_2_2_5_6, name_case_2_2_5_6, desc_case_2_2_5_6, sref_case_2_2_5_6, {
	&test_2_2_5_6_conn, &test_2_2_5_6_resp, &test_2_2_5_6_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_7, tgrp_case_2_2_5_7, name_case_2_2_5_7, desc_case_2_2_5_7, sref_case_2_2_5_7, {
	&test_2_2_5_7_conn, &test_2_2_5_7_resp, &test_2_2_5_7_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_8, tgrp_case_2_2_5_8, name_case_2_2_5_8, desc_case_2_2_5_8, sref_case_2_2_5_8, {
	&test_2_2_5_8_conn, &test_2_2_5_8_resp, &test_2_2_5_8_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_9, tgrp_case_2_2_5_9, name_case_2_2_5_9, desc_case_2_2_5_9, sref_case_2_2_5_9, {
	&test_2_2_5_9_conn, &test_2_2_5_9_resp, &test_2_2_5_9_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_10, tgrp_case_2_2_5_10, name_case_2_2_5_10, desc_case_2_2_5_10, sref_case_2_2_5_10, {
	&test_2_2_5_10_conn, &test_2_2_5_10_resp, &test_2_2_5_10_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_11, tgrp_case_2_2_5_11, name_case_2_2_5_11, desc_case_2_2_5_11, sref_case_2_2_5_11, {
	&test_2_2_5_11_conn, &test_2_2_5_11_resp, &test_2_2_5_11_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_12, tgrp_case_2_2_5_12, name_case_2_2_5_12, desc_case_2_2_5_12, sref_case_2_2_5_12, {
	&test_2_2_5_12_conn, &test_2_2_5_12_resp, &test_2_2_5_12_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_13, tgrp_case_2_2_5_13, name_case_2_2_5_13, desc_case_2_2_5_13, sref_case_2_2_5_13, {
	&test_2_2_5_13_conn, &test_2_2_5_13_resp, &test_2_2_5_13_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_14, tgrp_case_2_2_5_14, name_case_2_2_5_14, desc_case_2_2_5_14, sref_case_2_2_5_14, {
	&test_2_2_5_14_conn, &test_2_2_5_14_resp, &test_2_2_5_14_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_15, tgrp_case_2_2_5_15, name_case_2_2_5_15, desc_case_2_2_5_15, sref_case_2_2_5_15, {
	&test_2_2_5_15_conn, &test_2_2_5_15_resp, &test_2_2_5_15_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_16, tgrp_case_2_2_5_16, name_case_2_2_5_16, desc_case_2_2_5_16, sref_case_2_2_5_16, {
	&test_2_2_5_16_conn, &test_2_2_5_16_resp, &test_2_2_5_16_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_17, tgrp_case_2_2_5_17, name_case_2_2_5_17, desc_case_2_2_5_17, sref_case_2_2_5_17, {
	&test_2_2_5_17_conn, &test_2_2_5_17_resp, &test_2_2_5_17_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_18, tgrp_case_2_2_5_18, name_case_2_2_5_18, desc_case_2_2_5_18, sref_case_2_2_5_18, {
	&test_2_2_5_18_conn, &test_2_2_5_18_resp, &test_2_2_5_18_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_19, tgrp_case_2_2_5_19, name_case_2_2_5_19, desc_case_2_2_5_19, sref_case_2_2_5_19, {
	&test_2_2_5_19_conn, &test_2_2_5_19_resp, &test_2_2_5_19_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_20, tgrp_case_2_2_5_20, name_case_2_2_5_20, desc_case_2_2_5_20, sref_case_2_2_5_20, {
	&test_2_2_5_20_conn, &test_2_2_5_20_resp, &test_2_2_5_20_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_21, tgrp_case_2_2_5_21, name_case_2_2_5_21, desc_case_2_2_5_21, sref_case_2_2_5_21, {
	&test_2_2_5_21_conn, &test_2_2_5_21_resp, &test_2_2_5_21_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_22, tgrp_case_2_2_5_22, name_case_2_2_5_22, desc_case_2_2_5_22, sref_case_2_2_5_22, {
	&test_2_2_5_22_conn, &test_2_2_5_22_resp, &test_2_2_5_22_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_23, tgrp_case_2_2_5_23, name_case_2_2_5_23, desc_case_2_2_5_23, sref_case_2_2_5_23, {
	&test_2_2_5_23_conn, &test_2_2_5_23_resp, &test_2_2_5_23_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_24, tgrp_case_2_2_5_24, name_case_2_2_5_24, desc_case_2_2_5_24, sref_case_2_2_5_24, {
	&test_2_2_5_24_conn, &test_2_2_5_24_resp, &test_2_2_5_24_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_25, tgrp_case_2_2_5_25, name_case_2_2_5_25, desc_case_2_2_5_25, sref_case_2_2_5_25, {
	&test_2_2_5_25_conn, &test_2_2_5_25_resp, &test_2_2_5_25_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_26, tgrp_case_2_2_5_26, name_case_2_2_5_26, desc_case_2_2_5_26, sref_case_2_2_5_26, {
	&test_2_2_5_26_conn, &test_2_2_5_26_resp, &test_2_2_5_26_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_27, tgrp_case_2_2_5_27, name_case_2_2_5_27, desc_case_2_2_5_27, sref_case_2_2_5_27, {
	&test_2_2_5_27_conn, &test_2_2_5_27_resp, &test_2_2_5_27_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_28, tgrp_case_2_2_5_28, name_case_2_2_5_28, desc_case_2_2_5_28, sref_case_2_2_5_28, {
	&test_2_2_5_28_conn, &test_2_2_5_28_resp, &test_2_2_5_28_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_29, tgrp_case_2_2_5_29, name_case_2_2_5_29, desc_case_2_2_5_29, sref_case_2_2_5_29, {
	&test_2_2_5_29_conn, &test_2_2_5_29_resp, &test_2_2_5_29_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_30, tgrp_case_2_2_5_30, name_case_2_2_5_30, desc_case_2_2_5_30, sref_case_2_2_5_30, {
	&test_2_2_5_30_conn, &test_2_2_5_30_resp, &test_2_2_5_30_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_31, tgrp_case_2_2_5_31, name_case_2_2_5_31, desc_case_2_2_5_31, sref_case_2_2_5_31, {
	&test_2_2_5_31_conn, &test_2_2_5_31_resp, &test_2_2_5_31_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_32, tgrp_case_2_2_5_32, name_case_2_2_5_32, desc_case_2_2_5_32, sref_case_2_2_5_32, {
	&test_2_2_5_32_conn, &test_2_2_5_32_resp, &test_2_2_5_32_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_33, tgrp_case_2_2_5_33, name_case_2_2_5_33, desc_case_2_2_5_33, sref_case_2_2_5_33, {
	&test_2_2_5_33_conn, &test_2_2_5_33_resp, &test_2_2_5_33_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_34, tgrp_case_2_2_5_34, name_case_2_2_5_34, desc_case_2_2_5_34, sref_case_2_2_5_34, {
	&test_2_2_5_34_conn, &test_2_2_5_34_resp, &test_2_2_5_34_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_35, tgrp_case_2_2_5_35, name_case_2_2_5_35, desc_case_2_2_5_35, sref_case_2_2_5_35, {
	&test_2_2_5_35_conn, &test_2_2_5_35_resp, &test_2_2_5_35_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_36, tgrp_case_2_2_5_36, name_case_2_2_5_36, desc_case_2_2_5_36, sref_case_2_2_5_36, {
	&test_2_2_5_36_conn, &test_2_2_5_36_resp, &test_2_2_5_36_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_37, tgrp_case_2_2_5_37, name_case_2_2_5_37, desc_case_2_2_5_37, sref_case_2_2_5_37, {
	&test_2_2_5_37_conn, &test_2_2_5_37_resp, &test_2_2_5_37_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_5_38, tgrp_case_2_2_5_38, name_case_2_2_5_38, desc_case_2_2_5_38, sref_case_2_2_5_38, {
	&test_2_2_5_38_conn, &test_2_2_5_38_resp, &test_2_2_5_38_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_2_2_6, tgrp_case_2_2_6, name_case_2_2_6, desc_case_2_2_6, sref_case_2_2_6, {
	&test_2_2_6_conn, &test_2_2_6_resp, &test_2_2_6_list}, &begin_tests, &end_tests, 0, __RESULT_NOTAPPL}, {
		numb_case_3_1, tgrp_case_3_1, name_case_3_1, desc_case_3_1, sref_case_3_1, {
	&test_3_1_conn, &test_3_1_resp, &test_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_3_2, tgrp_case_3_2, name_case_3_2, desc_case_3_2, sref_case_3_2, {
	&test_3_2_conn, &test_3_2_resp, &test_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_3_3, tgrp_case_3_3, name_case_3_3, desc_case_3_3, sref_case_3_3, {
	&test_3_3_conn, &test_3_3_resp, &test_3_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_3_4, tgrp_case_3_4, name_case_3_4, desc_case_3_4, sref_case_3_4, {
	&test_3_4_conn, &test_3_4_resp, &test_3_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_3_5, tgrp_case_3_5, name_case_3_5, desc_case_3_5, sref_case_3_5, {
	&test_3_5_conn, &test_3_5_resp, &test_3_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_3_6, tgrp_case_3_6, name_case_3_6, desc_case_3_6, sref_case_3_6, {
	&test_3_6_conn, &test_3_6_resp, &test_3_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_1, tgrp_case_4_1_1, name_case_4_1_1, desc_case_4_1_1, sref_case_4_1_1, {
	&test_4_1_1_conn, &test_4_1_1_resp, &test_4_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_2, tgrp_case_4_1_2, name_case_4_1_2, desc_case_4_1_2, sref_case_4_1_2, {
	&test_4_1_2_conn, &test_4_1_2_resp, &test_4_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_3, tgrp_case_4_1_3, name_case_4_1_3, desc_case_4_1_3, sref_case_4_1_3, {
	&test_4_1_3_conn, &test_4_1_3_resp, &test_4_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_4, tgrp_case_4_1_4, name_case_4_1_4, desc_case_4_1_4, sref_case_4_1_4, {
	&test_4_1_4_conn, &test_4_1_4_resp, &test_4_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_5, tgrp_case_4_1_5, name_case_4_1_5, desc_case_4_1_5, sref_case_4_1_5, {
	&test_4_1_5_conn, &test_4_1_5_resp, &test_4_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_6, tgrp_case_4_1_6, name_case_4_1_6, desc_case_4_1_6, sref_case_4_1_6, {
	&test_4_1_6_conn, &test_4_1_6_resp, &test_4_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_7, tgrp_case_4_1_7, name_case_4_1_7, desc_case_4_1_7, sref_case_4_1_7, {
	&test_4_1_7_conn, &test_4_1_7_resp, &test_4_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_8, tgrp_case_4_1_8, name_case_4_1_8, desc_case_4_1_8, sref_case_4_1_8, {
	&test_4_1_8_conn, &test_4_1_8_resp, &test_4_1_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_1_9, tgrp_case_4_1_9, name_case_4_1_9, desc_case_4_1_9, sref_case_4_1_9, {
	&test_4_1_9_conn, &test_4_1_9_resp, &test_4_1_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_2_1, tgrp_case_4_2_1, name_case_4_2_1, desc_case_4_2_1, sref_case_4_2_1, {
	&test_4_2_1_conn, &test_4_2_1_resp, &test_4_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_2_2, tgrp_case_4_2_2, name_case_4_2_2, desc_case_4_2_2, sref_case_4_2_2, {
	&test_4_2_2_conn, &test_4_2_2_resp, &test_4_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_1_1, tgrp_case_4_3_1_1, name_case_4_3_1_1, desc_case_4_3_1_1, sref_case_4_3_1_1, {
	&test_4_3_1_1_conn, &test_4_3_1_1_resp, &test_4_3_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_1_2, tgrp_case_4_3_1_2, name_case_4_3_1_2, desc_case_4_3_1_2, sref_case_4_3_1_2, {
	&test_4_3_1_2_conn, &test_4_3_1_2_resp, &test_4_3_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_1_3, tgrp_case_4_3_1_3, name_case_4_3_1_3, desc_case_4_3_1_3, sref_case_4_3_1_3, {
	&test_4_3_1_3_conn, &test_4_3_1_3_resp, &test_4_3_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_1_4, tgrp_case_4_3_1_4, name_case_4_3_1_4, desc_case_4_3_1_4, sref_case_4_3_1_4, {
	&test_4_3_1_4_conn, &test_4_3_1_4_resp, &test_4_3_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_1_5, tgrp_case_4_3_1_5, name_case_4_3_1_5, desc_case_4_3_1_5, sref_case_4_3_1_5, {
	&test_4_3_1_5_conn, &test_4_3_1_5_resp, &test_4_3_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_1_6, tgrp_case_4_3_1_6, name_case_4_3_1_6, desc_case_4_3_1_6, sref_case_4_3_1_6, {
	&test_4_3_1_6_conn, &test_4_3_1_6_resp, &test_4_3_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_2_1, tgrp_case_4_3_2_1, name_case_4_3_2_1, desc_case_4_3_2_1, sref_case_4_3_2_1, {
	&test_4_3_2_1_conn, &test_4_3_2_1_resp, &test_4_3_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_2_2, tgrp_case_4_3_2_2, name_case_4_3_2_2, desc_case_4_3_2_2, sref_case_4_3_2_2, {
	&test_4_3_2_2_conn, &test_4_3_2_2_resp, &test_4_3_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_2_3, tgrp_case_4_3_2_3, name_case_4_3_2_3, desc_case_4_3_2_3, sref_case_4_3_2_3, {
	&test_4_3_2_3_conn, &test_4_3_2_3_resp, &test_4_3_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_2_4, tgrp_case_4_3_2_4, name_case_4_3_2_4, desc_case_4_3_2_4, sref_case_4_3_2_4, {
	&test_4_3_2_4_conn, &test_4_3_2_4_resp, &test_4_3_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_2_5, tgrp_case_4_3_2_5, name_case_4_3_2_5, desc_case_4_3_2_5, sref_case_4_3_2_5, {
	&test_4_3_2_5_conn, &test_4_3_2_5_resp, &test_4_3_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_3_1, tgrp_case_4_3_3_1, name_case_4_3_3_1, desc_case_4_3_3_1, sref_case_4_3_3_1, {
	&test_4_3_3_1_conn, &test_4_3_3_1_resp, &test_4_3_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_1, tgrp_case_4_3_4_1, name_case_4_3_4_1, desc_case_4_3_4_1, sref_case_4_3_4_1, {
	&test_4_3_4_1_conn, &test_4_3_4_1_resp, &test_4_3_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_2, tgrp_case_4_3_4_2, name_case_4_3_4_2, desc_case_4_3_4_2, sref_case_4_3_4_2, {
	&test_4_3_4_2_conn, &test_4_3_4_2_resp, &test_4_3_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_3, tgrp_case_4_3_4_3, name_case_4_3_4_3, desc_case_4_3_4_3, sref_case_4_3_4_3, {
	&test_4_3_4_3_conn, &test_4_3_4_3_resp, &test_4_3_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_4, tgrp_case_4_3_4_4, name_case_4_3_4_4, desc_case_4_3_4_4, sref_case_4_3_4_4, {
	&test_4_3_4_4_conn, &test_4_3_4_4_resp, &test_4_3_4_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_5, tgrp_case_4_3_4_5, name_case_4_3_4_5, desc_case_4_3_4_5, sref_case_4_3_4_5, {
	&test_4_3_4_5_conn, &test_4_3_4_5_resp, &test_4_3_4_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_6, tgrp_case_4_3_4_6, name_case_4_3_4_6, desc_case_4_3_4_6, sref_case_4_3_4_6, {
	&test_4_3_4_6_conn, &test_4_3_4_6_resp, &test_4_3_4_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_7, tgrp_case_4_3_4_7, name_case_4_3_4_7, desc_case_4_3_4_7, sref_case_4_3_4_7, {
	&test_4_3_4_7_conn, &test_4_3_4_7_resp, &test_4_3_4_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_8, tgrp_case_4_3_4_8, name_case_4_3_4_8, desc_case_4_3_4_8, sref_case_4_3_4_8, {
	&test_4_3_4_8_conn, &test_4_3_4_8_resp, &test_4_3_4_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_9, tgrp_case_4_3_4_9, name_case_4_3_4_9, desc_case_4_3_4_9, sref_case_4_3_4_9, {
	&test_4_3_4_9_conn, &test_4_3_4_9_resp, &test_4_3_4_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_10, tgrp_case_4_3_4_10, name_case_4_3_4_10, desc_case_4_3_4_10, sref_case_4_3_4_10, {
	&test_4_3_4_10_conn, &test_4_3_4_10_resp, &test_4_3_4_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_11, tgrp_case_4_3_4_11, name_case_4_3_4_11, desc_case_4_3_4_11, sref_case_4_3_4_11, {
	&test_4_3_4_11_conn, &test_4_3_4_11_resp, &test_4_3_4_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_12, tgrp_case_4_3_4_12, name_case_4_3_4_12, desc_case_4_3_4_12, sref_case_4_3_4_12, {
	&test_4_3_4_12_conn, &test_4_3_4_12_resp, &test_4_3_4_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_4_13, tgrp_case_4_3_4_13, name_case_4_3_4_13, desc_case_4_3_4_13, sref_case_4_3_4_13, {
	&test_4_3_4_13_conn, &test_4_3_4_13_resp, &test_4_3_4_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_1, tgrp_case_4_3_5_1, name_case_4_3_5_1, desc_case_4_3_5_1, sref_case_4_3_5_1, {
	&test_4_3_5_1_conn, &test_4_3_5_1_resp, &test_4_3_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_2, tgrp_case_4_3_5_2, name_case_4_3_5_2, desc_case_4_3_5_2, sref_case_4_3_5_2, {
	&test_4_3_5_2_conn, &test_4_3_5_2_resp, &test_4_3_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_3, tgrp_case_4_3_5_3, name_case_4_3_5_3, desc_case_4_3_5_3, sref_case_4_3_5_3, {
	&test_4_3_5_3_conn, &test_4_3_5_3_resp, &test_4_3_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_4, tgrp_case_4_3_5_4, name_case_4_3_5_4, desc_case_4_3_5_4, sref_case_4_3_5_4, {
	&test_4_3_5_4_conn, &test_4_3_5_4_resp, &test_4_3_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_5, tgrp_case_4_3_5_5, name_case_4_3_5_5, desc_case_4_3_5_5, sref_case_4_3_5_5, {
	&test_4_3_5_5_conn, &test_4_3_5_5_resp, &test_4_3_5_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_6, tgrp_case_4_3_5_6, name_case_4_3_5_6, desc_case_4_3_5_6, sref_case_4_3_5_6, {
	&test_4_3_5_6_conn, &test_4_3_5_6_resp, &test_4_3_5_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_7, tgrp_case_4_3_5_7, name_case_4_3_5_7, desc_case_4_3_5_7, sref_case_4_3_5_7, {
	&test_4_3_5_7_conn, &test_4_3_5_7_resp, &test_4_3_5_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_8, tgrp_case_4_3_5_8, name_case_4_3_5_8, desc_case_4_3_5_8, sref_case_4_3_5_8, {
	&test_4_3_5_8_conn, &test_4_3_5_8_resp, &test_4_3_5_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_9, tgrp_case_4_3_5_9, name_case_4_3_5_9, desc_case_4_3_5_9, sref_case_4_3_5_9, {
	&test_4_3_5_9_conn, &test_4_3_5_9_resp, &test_4_3_5_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_10, tgrp_case_4_3_5_10, name_case_4_3_5_10, desc_case_4_3_5_10, sref_case_4_3_5_10, {
	&test_4_3_5_10_conn, &test_4_3_5_10_resp, &test_4_3_5_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_11, tgrp_case_4_3_5_11, name_case_4_3_5_11, desc_case_4_3_5_11, sref_case_4_3_5_11, {
	&test_4_3_5_11_conn, &test_4_3_5_11_resp, &test_4_3_5_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_12, tgrp_case_4_3_5_12, name_case_4_3_5_12, desc_case_4_3_5_12, sref_case_4_3_5_12, {
	&test_4_3_5_12_conn, &test_4_3_5_12_resp, &test_4_3_5_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_13, tgrp_case_4_3_5_13, name_case_4_3_5_13, desc_case_4_3_5_13, sref_case_4_3_5_13, {
	&test_4_3_5_13_conn, &test_4_3_5_13_resp, &test_4_3_5_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_14, tgrp_case_4_3_5_14, name_case_4_3_5_14, desc_case_4_3_5_14, sref_case_4_3_5_14, {
	&test_4_3_5_14_conn, &test_4_3_5_14_resp, &test_4_3_5_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_15, tgrp_case_4_3_5_15, name_case_4_3_5_15, desc_case_4_3_5_15, sref_case_4_3_5_15, {
	&test_4_3_5_15_conn, &test_4_3_5_15_resp, &test_4_3_5_15_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_16, tgrp_case_4_3_5_16, name_case_4_3_5_16, desc_case_4_3_5_16, sref_case_4_3_5_16, {
	&test_4_3_5_16_conn, &test_4_3_5_16_resp, &test_4_3_5_16_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_17, tgrp_case_4_3_5_17, name_case_4_3_5_17, desc_case_4_3_5_17, sref_case_4_3_5_17, {
	&test_4_3_5_17_conn, &test_4_3_5_17_resp, &test_4_3_5_17_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_18, tgrp_case_4_3_5_18, name_case_4_3_5_18, desc_case_4_3_5_18, sref_case_4_3_5_18, {
	&test_4_3_5_18_conn, &test_4_3_5_18_resp, &test_4_3_5_18_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_19, tgrp_case_4_3_5_19, name_case_4_3_5_19, desc_case_4_3_5_19, sref_case_4_3_5_19, {
	&test_4_3_5_19_conn, &test_4_3_5_19_resp, &test_4_3_5_19_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_20, tgrp_case_4_3_5_20, name_case_4_3_5_20, desc_case_4_3_5_20, sref_case_4_3_5_20, {
	&test_4_3_5_20_conn, &test_4_3_5_20_resp, &test_4_3_5_20_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_21, tgrp_case_4_3_5_21, name_case_4_3_5_21, desc_case_4_3_5_21, sref_case_4_3_5_21, {
	&test_4_3_5_21_conn, &test_4_3_5_21_resp, &test_4_3_5_21_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_22, tgrp_case_4_3_5_22, name_case_4_3_5_22, desc_case_4_3_5_22, sref_case_4_3_5_22, {
	&test_4_3_5_22_conn, &test_4_3_5_22_resp, &test_4_3_5_22_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_23, tgrp_case_4_3_5_23, name_case_4_3_5_23, desc_case_4_3_5_23, sref_case_4_3_5_23, {
	&test_4_3_5_23_conn, &test_4_3_5_23_resp, &test_4_3_5_23_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_24, tgrp_case_4_3_5_24, name_case_4_3_5_24, desc_case_4_3_5_24, sref_case_4_3_5_24, {
	&test_4_3_5_24_conn, &test_4_3_5_24_resp, &test_4_3_5_24_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_25, tgrp_case_4_3_5_25, name_case_4_3_5_25, desc_case_4_3_5_25, sref_case_4_3_5_25, {
	&test_4_3_5_25_conn, &test_4_3_5_25_resp, &test_4_3_5_25_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_26, tgrp_case_4_3_5_26, name_case_4_3_5_26, desc_case_4_3_5_26, sref_case_4_3_5_26, {
	&test_4_3_5_26_conn, &test_4_3_5_26_resp, &test_4_3_5_26_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_27, tgrp_case_4_3_5_27, name_case_4_3_5_27, desc_case_4_3_5_27, sref_case_4_3_5_27, {
	&test_4_3_5_27_conn, &test_4_3_5_27_resp, &test_4_3_5_27_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_28, tgrp_case_4_3_5_28, name_case_4_3_5_28, desc_case_4_3_5_28, sref_case_4_3_5_28, {
	&test_4_3_5_28_conn, &test_4_3_5_28_resp, &test_4_3_5_28_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_29, tgrp_case_4_3_5_29, name_case_4_3_5_29, desc_case_4_3_5_29, sref_case_4_3_5_29, {
	&test_4_3_5_29_conn, &test_4_3_5_29_resp, &test_4_3_5_29_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_30, tgrp_case_4_3_5_30, name_case_4_3_5_30, desc_case_4_3_5_30, sref_case_4_3_5_30, {
	&test_4_3_5_30_conn, &test_4_3_5_30_resp, &test_4_3_5_30_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_31, tgrp_case_4_3_5_31, name_case_4_3_5_31, desc_case_4_3_5_31, sref_case_4_3_5_31, {
	&test_4_3_5_31_conn, &test_4_3_5_31_resp, &test_4_3_5_31_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_32, tgrp_case_4_3_5_32, name_case_4_3_5_32, desc_case_4_3_5_32, sref_case_4_3_5_32, {
	&test_4_3_5_32_conn, &test_4_3_5_32_resp, &test_4_3_5_32_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_33, tgrp_case_4_3_5_33, name_case_4_3_5_33, desc_case_4_3_5_33, sref_case_4_3_5_33, {
	&test_4_3_5_33_conn, &test_4_3_5_33_resp, &test_4_3_5_33_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_34, tgrp_case_4_3_5_34, name_case_4_3_5_34, desc_case_4_3_5_34, sref_case_4_3_5_34, {
	&test_4_3_5_34_conn, &test_4_3_5_34_resp, &test_4_3_5_34_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_35, tgrp_case_4_3_5_35, name_case_4_3_5_35, desc_case_4_3_5_35, sref_case_4_3_5_35, {
	&test_4_3_5_35_conn, &test_4_3_5_35_resp, &test_4_3_5_35_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_36, tgrp_case_4_3_5_36, name_case_4_3_5_36, desc_case_4_3_5_36, sref_case_4_3_5_36, {
	&test_4_3_5_36_conn, &test_4_3_5_36_resp, &test_4_3_5_36_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_37, tgrp_case_4_3_5_37, name_case_4_3_5_37, desc_case_4_3_5_37, sref_case_4_3_5_37, {
	&test_4_3_5_37_conn, &test_4_3_5_37_resp, &test_4_3_5_37_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_4_3_5_38, tgrp_case_4_3_5_38, name_case_4_3_5_38, desc_case_4_3_5_38, sref_case_4_3_5_38, {
	&test_4_3_5_38_conn, &test_4_3_5_38_resp, &test_4_3_5_38_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_5_1, tgrp_case_5_1, name_case_5_1, desc_case_5_1, sref_case_5_1, {
	&test_5_1_conn, &test_5_1_resp, &test_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_5_2, tgrp_case_5_2, name_case_5_2, desc_case_5_2, sref_case_5_2, {
	&test_5_2_conn, &test_5_2_resp, &test_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_5_3, tgrp_case_5_3, name_case_5_3, desc_case_5_3, sref_case_5_3, {
	&test_5_3_conn, &test_5_3_resp, &test_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_5_4, tgrp_case_5_4, name_case_5_4, desc_case_5_4, sref_case_5_4, {
	&test_5_4_conn, &test_5_4_resp, &test_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
#if 1
		numb_case_5_5_1, tgrp_case_5_5_1, name_case_5_5_1, desc_case_5_5_1, sref_case_5_5_1, {
	&test_5_5_1_conn, &test_5_5_1_resp, &test_5_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_5_5_2, tgrp_case_5_5_2, name_case_5_5_2, desc_case_5_5_2, sref_case_5_5_2, {
	&test_5_5_2_conn, &test_5_5_2_resp, &test_5_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_5_5_3, tgrp_case_5_5_3, name_case_5_5_3, desc_case_5_5_3, sref_case_5_5_3, {
	&test_5_5_3_conn, &test_5_5_3_resp, &test_5_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
#endif
#if 1
		numb_case_6_1, tgrp_case_6_1, name_case_6_1, desc_case_6_1, sref_case_6_1, {
	&test_6_1_conn, &test_6_1_resp, &test_6_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_6_2, tgrp_case_6_2, name_case_6_2, desc_case_6_2, sref_case_6_2, {
	&test_6_2_conn, &test_6_2_resp, &test_6_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_6_3, tgrp_case_6_3, name_case_6_3, desc_case_6_3, sref_case_6_3, {
	&test_6_3_conn, &test_6_3_resp, &test_6_3_list}, &begin_tests, &end_tests, 0, 0}, {
#endif
#if 1
		numb_case_7_1, tgrp_case_7_1, name_case_7_1, desc_case_7_1, sref_case_7_1, {
	&test_7_1_conn, &test_7_1_resp, &test_7_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_7_2, tgrp_case_7_2, name_case_7_2, desc_case_7_2, sref_case_7_2, {
	&test_7_2_conn, &test_7_2_resp, &test_7_2_list}, &begin_tests, &end_tests, 0, 0}, {
#endif
#if 1
		numb_case_8_1, tgrp_case_8_1, name_case_8_1, desc_case_8_1, sref_case_8_1, {
	&test_8_1_conn, &test_8_1_resp, &test_8_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_8_2, tgrp_case_8_2, name_case_8_2, desc_case_8_2, sref_case_8_2, {
	&test_8_2_conn, &test_8_2_resp, &test_8_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_8_3, tgrp_case_8_3, name_case_8_3, desc_case_8_3, sref_case_8_3, {
	&test_8_3_conn, &test_8_3_resp, &test_8_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_8_4, tgrp_case_8_4, name_case_8_4, desc_case_8_4, sref_case_8_4, {
	&test_8_4_conn, &test_8_4_resp, &test_8_4_list}, &begin_tests, &end_tests, 0, 0}, {
#endif
#if 1
		numb_case_9_1, tgrp_case_9_1, name_case_9_1, desc_case_9_1, sref_case_9_1, {
	&test_9_1_conn, &test_9_1_resp, &test_9_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_9_2, tgrp_case_9_2, name_case_9_2, desc_case_9_2, sref_case_9_2, {
	&test_9_2_conn, &test_9_2_resp, &test_9_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_9_3, tgrp_case_9_3, name_case_9_3, desc_case_9_3, sref_case_9_3, {
	&test_9_3_conn, &test_9_3_resp, &test_9_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_9_4, tgrp_case_9_4, name_case_9_4, desc_case_9_4, sref_case_9_4, {
	&test_9_4_conn, &test_9_4_resp, &test_9_4_list}, &begin_tests, &end_tests, 0, 0}, {
#endif
#if 1
		numb_case_10_1, tgrp_case_10_1, name_case_10_1, desc_case_10_1, sref_case_10_1, {
	&test_10_1_conn, &test_10_1_resp, &test_10_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_10_2, tgrp_case_10_2, name_case_10_2, desc_case_10_2, sref_case_10_2, {
	&test_10_2_conn, &test_10_2_resp, &test_10_2_list}, &begin_tests, &end_tests, 0, 0}, {
#endif
		numb_case_11_1_1, tgrp_case_11_1_1, name_case_11_1_1, desc_case_11_1_1, sref_case_11_1_1, {
	&test_11_1_1_conn, &test_11_1_1_resp, &test_11_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_2, tgrp_case_11_1_2, name_case_11_1_2, desc_case_11_1_2, sref_case_11_1_2, {
	&test_11_1_2_conn, &test_11_1_2_resp, &test_11_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_3, tgrp_case_11_1_3, name_case_11_1_3, desc_case_11_1_3, sref_case_11_1_3, {
	&test_11_1_3_conn, &test_11_1_3_resp, &test_11_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_4, tgrp_case_11_1_4, name_case_11_1_4, desc_case_11_1_4, sref_case_11_1_4, {
	&test_11_1_4_conn, &test_11_1_4_resp, &test_11_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_5, tgrp_case_11_1_5, name_case_11_1_5, desc_case_11_1_5, sref_case_11_1_5, {
	&test_11_1_5_conn, &test_11_1_5_resp, &test_11_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_6, tgrp_case_11_1_6, name_case_11_1_6, desc_case_11_1_6, sref_case_11_1_6, {
	&test_11_1_6_conn, &test_11_1_6_resp, &test_11_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_7, tgrp_case_11_1_7, name_case_11_1_7, desc_case_11_1_7, sref_case_11_1_7, {
	&test_11_1_7_conn, &test_11_1_7_resp, &test_11_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_8, tgrp_case_11_1_8, name_case_11_1_8, desc_case_11_1_8, sref_case_11_1_8, {
	&test_11_1_8_conn, &test_11_1_8_resp, &test_11_1_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_9, tgrp_case_11_1_9, name_case_11_1_9, desc_case_11_1_9, sref_case_11_1_9, {
	&test_11_1_9_conn, &test_11_1_9_resp, &test_11_1_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_10, tgrp_case_11_1_10, name_case_11_1_10, desc_case_11_1_10, sref_case_11_1_10, {
	&test_11_1_10_conn, &test_11_1_10_resp, &test_11_1_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_11, tgrp_case_11_1_11, name_case_11_1_11, desc_case_11_1_11, sref_case_11_1_11, {
	&test_11_1_11_conn, &test_11_1_11_resp, &test_11_1_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_12, tgrp_case_11_1_12, name_case_11_1_12, desc_case_11_1_12, sref_case_11_1_12, {
	&test_11_1_12_conn, &test_11_1_12_resp, &test_11_1_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_1_13, tgrp_case_11_1_13, name_case_11_1_13, desc_case_11_1_13, sref_case_11_1_13, {
	&test_11_1_13_conn, &test_11_1_13_resp, &test_11_1_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_1, tgrp_case_11_2_1, name_case_11_2_1, desc_case_11_2_1, sref_case_11_2_1, {
	&test_11_2_1_conn, &test_11_2_1_resp, &test_11_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_2, tgrp_case_11_2_2, name_case_11_2_2, desc_case_11_2_2, sref_case_11_2_2, {
	&test_11_2_2_conn, &test_11_2_2_resp, &test_11_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_3, tgrp_case_11_2_3, name_case_11_2_3, desc_case_11_2_3, sref_case_11_2_3, {
	&test_11_2_3_conn, &test_11_2_3_resp, &test_11_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_4, tgrp_case_11_2_4, name_case_11_2_4, desc_case_11_2_4, sref_case_11_2_4, {
	&test_11_2_4_conn, &test_11_2_4_resp, &test_11_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_5, tgrp_case_11_2_5, name_case_11_2_5, desc_case_11_2_5, sref_case_11_2_5, {
	&test_11_2_5_conn, &test_11_2_5_resp, &test_11_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_6, tgrp_case_11_2_6, name_case_11_2_6, desc_case_11_2_6, sref_case_11_2_6, {
	&test_11_2_6_conn, &test_11_2_6_resp, &test_11_2_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_7, tgrp_case_11_2_7, name_case_11_2_7, desc_case_11_2_7, sref_case_11_2_7, {
	&test_11_2_7_conn, &test_11_2_7_resp, &test_11_2_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_8, tgrp_case_11_2_8, name_case_11_2_8, desc_case_11_2_8, sref_case_11_2_8, {
	&test_11_2_8_conn, &test_11_2_8_resp, &test_11_2_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_9, tgrp_case_11_2_9, name_case_11_2_9, desc_case_11_2_9, sref_case_11_2_9, {
	&test_11_2_9_conn, &test_11_2_9_resp, &test_11_2_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_10, tgrp_case_11_2_10, name_case_11_2_10, desc_case_11_2_10, sref_case_11_2_10, {
	&test_11_2_10_conn, &test_11_2_10_resp, &test_11_2_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_11, tgrp_case_11_2_11, name_case_11_2_11, desc_case_11_2_11, sref_case_11_2_11, {
	&test_11_2_11_conn, &test_11_2_11_resp, &test_11_2_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_12, tgrp_case_11_2_12, name_case_11_2_12, desc_case_11_2_12, sref_case_11_2_12, {
	&test_11_2_12_conn, &test_11_2_12_resp, &test_11_2_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_13, tgrp_case_11_2_13, name_case_11_2_13, desc_case_11_2_13, sref_case_11_2_13, {
	&test_11_2_13_conn, &test_11_2_13_resp, &test_11_2_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_14, tgrp_case_11_2_14, name_case_11_2_14, desc_case_11_2_14, sref_case_11_2_14, {
	&test_11_2_14_conn, &test_11_2_14_resp, &test_11_2_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_15, tgrp_case_11_2_15, name_case_11_2_15, desc_case_11_2_15, sref_case_11_2_15, {
	&test_11_2_15_conn, &test_11_2_15_resp, &test_11_2_15_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_16, tgrp_case_11_2_16, name_case_11_2_16, desc_case_11_2_16, sref_case_11_2_16, {
	&test_11_2_16_conn, &test_11_2_16_resp, &test_11_2_16_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_2_17, tgrp_case_11_2_17, name_case_11_2_17, desc_case_11_2_17, sref_case_11_2_17, {
	&test_11_2_17_conn, &test_11_2_17_resp, &test_11_2_17_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_1, tgrp_case_11_3_1, name_case_11_3_1, desc_case_11_3_1, sref_case_11_3_1, {
	&test_11_3_1_conn, &test_11_3_1_resp, &test_11_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_2, tgrp_case_11_3_2, name_case_11_3_2, desc_case_11_3_2, sref_case_11_3_2, {
	&test_11_3_2_conn, &test_11_3_2_resp, &test_11_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_3, tgrp_case_11_3_3, name_case_11_3_3, desc_case_11_3_3, sref_case_11_3_3, {
	&test_11_3_3_conn, &test_11_3_3_resp, &test_11_3_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_4, tgrp_case_11_3_4, name_case_11_3_4, desc_case_11_3_4, sref_case_11_3_4, {
	&test_11_3_4_conn, &test_11_3_4_resp, &test_11_3_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_5, tgrp_case_11_3_5, name_case_11_3_5, desc_case_11_3_5, sref_case_11_3_5, {
	&test_11_3_5_conn, &test_11_3_5_resp, &test_11_3_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_6, tgrp_case_11_3_6, name_case_11_3_6, desc_case_11_3_6, sref_case_11_3_6, {
	&test_11_3_6_conn, &test_11_3_6_resp, &test_11_3_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_7, tgrp_case_11_3_7, name_case_11_3_7, desc_case_11_3_7, sref_case_11_3_7, {
	&test_11_3_7_conn, &test_11_3_7_resp, &test_11_3_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_8, tgrp_case_11_3_8, name_case_11_3_8, desc_case_11_3_8, sref_case_11_3_8, {
	&test_11_3_8_conn, &test_11_3_8_resp, &test_11_3_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_9, tgrp_case_11_3_9, name_case_11_3_9, desc_case_11_3_9, sref_case_11_3_9, {
	&test_11_3_9_conn, &test_11_3_9_resp, &test_11_3_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_10, tgrp_case_11_3_10, name_case_11_3_10, desc_case_11_3_10, sref_case_11_3_10, {
	&test_11_3_10_conn, &test_11_3_10_resp, &test_11_3_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_11, tgrp_case_11_3_11, name_case_11_3_11, desc_case_11_3_11, sref_case_11_3_11, {
	&test_11_3_11_conn, &test_11_3_11_resp, &test_11_3_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_12, tgrp_case_11_3_12, name_case_11_3_12, desc_case_11_3_12, sref_case_11_3_12, {
	&test_11_3_12_conn, &test_11_3_12_resp, &test_11_3_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_13, tgrp_case_11_3_13, name_case_11_3_13, desc_case_11_3_13, sref_case_11_3_13, {
	&test_11_3_13_conn, &test_11_3_13_resp, &test_11_3_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_11_3_14, tgrp_case_11_3_14, name_case_11_3_14, desc_case_11_3_14, sref_case_11_3_14, {
	&test_11_3_14_conn, &test_11_3_14_resp, &test_11_3_14_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_1, tgrp_case_12_1, name_case_12_1, desc_case_12_1, sref_case_12_1, {
	&test_12_1_conn, &test_12_1_resp, &test_12_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_2_1, tgrp_case_12_2_1, name_case_12_2_1, desc_case_12_2_1, sref_case_12_2_1, {
	&test_12_2_1_conn, &test_12_2_1_resp, &test_12_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_2_2, tgrp_case_12_2_2, name_case_12_2_2, desc_case_12_2_2, sref_case_12_2_2, {
	&test_12_2_2_conn, &test_12_2_2_resp, &test_12_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_2_3, tgrp_case_12_2_3, name_case_12_2_3, desc_case_12_2_3, sref_case_12_2_3, {
	&test_12_2_3_conn, &test_12_2_3_resp, &test_12_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_3_1, tgrp_case_12_3_1, name_case_12_3_1, desc_case_12_3_1, sref_case_12_3_1, {
	&test_12_3_1_conn, &test_12_3_1_resp, &test_12_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_3_2, tgrp_case_12_3_2, name_case_12_3_2, desc_case_12_3_2, sref_case_12_3_2, {
	&test_12_3_2_conn, &test_12_3_2_resp, &test_12_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_12_3_3, tgrp_case_12_3_3, name_case_12_3_3, desc_case_12_3_3, sref_case_12_3_3, {
	&test_12_3_3_conn, &test_12_3_3_resp, &test_12_3_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_1_1, tgrp_case_13_1_1, name_case_13_1_1, desc_case_13_1_1, sref_case_13_1_1, {
	&test_13_1_1_conn, &test_13_1_1_resp, &test_13_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_1_2, tgrp_case_13_1_2, name_case_13_1_2, desc_case_13_1_2, sref_case_13_1_2, {
	&test_13_1_2_conn, &test_13_1_2_resp, &test_13_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_1, tgrp_case_13_2_1, name_case_13_2_1, desc_case_13_2_1, sref_case_13_2_1, {
	&test_13_2_1_conn, &test_13_2_1_resp, &test_13_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_2, tgrp_case_13_2_2, name_case_13_2_2, desc_case_13_2_2, sref_case_13_2_2, {
	&test_13_2_2_conn, &test_13_2_2_resp, &test_13_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_3, tgrp_case_13_2_3, name_case_13_2_3, desc_case_13_2_3, sref_case_13_2_3, {
	&test_13_2_3_conn, &test_13_2_3_resp, &test_13_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_4, tgrp_case_13_2_4, name_case_13_2_4, desc_case_13_2_4, sref_case_13_2_4, {
	&test_13_2_4_conn, &test_13_2_4_resp, &test_13_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_5, tgrp_case_13_2_5, name_case_13_2_5, desc_case_13_2_5, sref_case_13_2_5, {
	&test_13_2_5_conn, &test_13_2_5_resp, &test_13_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_6_1, tgrp_case_13_2_6_1, name_case_13_2_6_1, desc_case_13_2_6_1, sref_case_13_2_6_1, {
	&test_13_2_6_1_conn, &test_13_2_6_1_resp, &test_13_2_6_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_6_2, tgrp_case_13_2_6_2, name_case_13_2_6_2, desc_case_13_2_6_2, sref_case_13_2_6_2, {
	&test_13_2_6_2_conn, &test_13_2_6_2_resp, &test_13_2_6_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_6_3, tgrp_case_13_2_6_3, name_case_13_2_6_3, desc_case_13_2_6_3, sref_case_13_2_6_3, {
	&test_13_2_6_3_conn, &test_13_2_6_3_resp, &test_13_2_6_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_6_4, tgrp_case_13_2_6_4, name_case_13_2_6_4, desc_case_13_2_6_4, sref_case_13_2_6_4, {
	&test_13_2_6_4_conn, &test_13_2_6_4_resp, &test_13_2_6_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_6_5, tgrp_case_13_2_6_5, name_case_13_2_6_5, desc_case_13_2_6_5, sref_case_13_2_6_5, {
	&test_13_2_6_5_conn, &test_13_2_6_5_resp, &test_13_2_6_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_6_6, tgrp_case_13_2_6_6, name_case_13_2_6_6, desc_case_13_2_6_6, sref_case_13_2_6_6, {
	&test_13_2_6_6_conn, &test_13_2_6_6_resp, &test_13_2_6_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_2_7, tgrp_case_13_2_7, name_case_13_2_7, desc_case_13_2_7, sref_case_13_2_7, {
	&test_13_2_7_conn, &test_13_2_7_resp, &test_13_2_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_3_1, tgrp_case_13_3_1, name_case_13_3_1, desc_case_13_3_1, sref_case_13_3_1, {
	&test_13_3_1_conn, &test_13_3_1_resp, &test_13_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_3_2, tgrp_case_13_3_2, name_case_13_3_2, desc_case_13_3_2, sref_case_13_3_2, {
	&test_13_3_2_conn, &test_13_3_2_resp, &test_13_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_1, tgrp_case_13_4_1, name_case_13_4_1, desc_case_13_4_1, sref_case_13_4_1, {
	&test_13_4_1_conn, &test_13_4_1_resp, &test_13_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_2, tgrp_case_13_4_2, name_case_13_4_2, desc_case_13_4_2, sref_case_13_4_2, {
	&test_13_4_2_conn, &test_13_4_2_resp, &test_13_4_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_3, tgrp_case_13_4_3, name_case_13_4_3, desc_case_13_4_3, sref_case_13_4_3, {
	&test_13_4_3_conn, &test_13_4_3_resp, &test_13_4_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_4, tgrp_case_13_4_4, name_case_13_4_4, desc_case_13_4_4, sref_case_13_4_4, {
	&test_13_4_4_conn, &test_13_4_4_resp, &test_13_4_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_5, tgrp_case_13_4_5, name_case_13_4_5, desc_case_13_4_5, sref_case_13_4_5, {
	&test_13_4_5_conn, &test_13_4_5_resp, &test_13_4_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_6, tgrp_case_13_4_6, name_case_13_4_6, desc_case_13_4_6, sref_case_13_4_6, {
	&test_13_4_6_conn, &test_13_4_6_resp, &test_13_4_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_7, tgrp_case_13_4_7, name_case_13_4_7, desc_case_13_4_7, sref_case_13_4_7, {
	&test_13_4_7_conn, &test_13_4_7_resp, &test_13_4_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_8_1, tgrp_case_13_4_8_1, name_case_13_4_8_1, desc_case_13_4_8_1, sref_case_13_4_8_1, {
	&test_13_4_8_1_conn, &test_13_4_8_1_resp, &test_13_4_8_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_8_2, tgrp_case_13_4_8_2, name_case_13_4_8_2, desc_case_13_4_8_2, sref_case_13_4_8_2, {
	&test_13_4_8_2_conn, &test_13_4_8_2_resp, &test_13_4_8_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_8_3, tgrp_case_13_4_8_3, name_case_13_4_8_3, desc_case_13_4_8_3, sref_case_13_4_8_3, {
	&test_13_4_8_3_conn, &test_13_4_8_3_resp, &test_13_4_8_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_8_4, tgrp_case_13_4_8_4, name_case_13_4_8_4, desc_case_13_4_8_4, sref_case_13_4_8_4, {
	&test_13_4_8_4_conn, &test_13_4_8_4_resp, &test_13_4_8_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_8_5, tgrp_case_13_4_8_5, name_case_13_4_8_5, desc_case_13_4_8_5, sref_case_13_4_8_5, {
	&test_13_4_8_5_conn, &test_13_4_8_5_resp, &test_13_4_8_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_8_6, tgrp_case_13_4_8_6, name_case_13_4_8_6, desc_case_13_4_8_6, sref_case_13_4_8_6, {
	&test_13_4_8_6_conn, &test_13_4_8_6_resp, &test_13_4_8_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_4_9, tgrp_case_13_4_9, name_case_13_4_9, desc_case_13_4_9, sref_case_13_4_9, {
	&test_13_4_9_conn, &test_13_4_9_resp, &test_13_4_9_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_1, tgrp_case_13_5_1, name_case_13_5_1, desc_case_13_5_1, sref_case_13_5_1, {
	&test_13_5_1_conn, &test_13_5_1_resp, &test_13_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_2, tgrp_case_13_5_2, name_case_13_5_2, desc_case_13_5_2, sref_case_13_5_2, {
	&test_13_5_2_conn, &test_13_5_2_resp, &test_13_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_3, tgrp_case_13_5_3, name_case_13_5_3, desc_case_13_5_3, sref_case_13_5_3, {
	&test_13_5_3_conn, &test_13_5_3_resp, &test_13_5_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_4, tgrp_case_13_5_4, name_case_13_5_4, desc_case_13_5_4, sref_case_13_5_4, {
	&test_13_5_4_conn, &test_13_5_4_resp, &test_13_5_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_5, tgrp_case_13_5_5, name_case_13_5_5, desc_case_13_5_5, sref_case_13_5_5, {
	&test_13_5_5_conn, &test_13_5_5_resp, &test_13_5_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_6, tgrp_case_13_5_6, name_case_13_5_6, desc_case_13_5_6, sref_case_13_5_6, {
	&test_13_5_6_conn, &test_13_5_6_resp, &test_13_5_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_7, tgrp_case_13_5_7, name_case_13_5_7, desc_case_13_5_7, sref_case_13_5_7, {
	&test_13_5_7_conn, &test_13_5_7_resp, &test_13_5_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_8, tgrp_case_13_5_8, name_case_13_5_8, desc_case_13_5_8, sref_case_13_5_8, {
	&test_13_5_8_conn, &test_13_5_8_resp, &test_13_5_8_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_9_1, tgrp_case_13_5_9_1, name_case_13_5_9_1, desc_case_13_5_9_1, sref_case_13_5_9_1, {
	&test_13_5_9_1_conn, &test_13_5_9_1_resp, &test_13_5_9_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_9_2, tgrp_case_13_5_9_2, name_case_13_5_9_2, desc_case_13_5_9_2, sref_case_13_5_9_2, {
	&test_13_5_9_2_conn, &test_13_5_9_2_resp, &test_13_5_9_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_9_3, tgrp_case_13_5_9_3, name_case_13_5_9_3, desc_case_13_5_9_3, sref_case_13_5_9_3, {
	&test_13_5_9_3_conn, &test_13_5_9_3_resp, &test_13_5_9_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_9_4, tgrp_case_13_5_9_4, name_case_13_5_9_4, desc_case_13_5_9_4, sref_case_13_5_9_4, {
	&test_13_5_9_4_conn, &test_13_5_9_4_resp, &test_13_5_9_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_9_5, tgrp_case_13_5_9_5, name_case_13_5_9_5, desc_case_13_5_9_5, sref_case_13_5_9_5, {
	&test_13_5_9_5_conn, &test_13_5_9_5_resp, &test_13_5_9_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_9_6, tgrp_case_13_5_9_6, name_case_13_5_9_6, desc_case_13_5_9_6, sref_case_13_5_9_6, {
	&test_13_5_9_6_conn, &test_13_5_9_6_resp, &test_13_5_9_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_10, tgrp_case_13_5_10, name_case_13_5_10, desc_case_13_5_10, sref_case_13_5_10, {
	&test_13_5_10_conn, &test_13_5_10_resp, &test_13_5_10_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_11, tgrp_case_13_5_11, name_case_13_5_11, desc_case_13_5_11, sref_case_13_5_11, {
	&test_13_5_11_conn, &test_13_5_11_resp, &test_13_5_11_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_12, tgrp_case_13_5_12, name_case_13_5_12, desc_case_13_5_12, sref_case_13_5_12, {
	&test_13_5_12_conn, &test_13_5_12_resp, &test_13_5_12_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_5_13, tgrp_case_13_5_13, name_case_13_5_13, desc_case_13_5_13, sref_case_13_5_13, {
	&test_13_5_13_conn, &test_13_5_13_resp, &test_13_5_13_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_6_1_1, tgrp_case_13_6_1_1, name_case_13_6_1_1, desc_case_13_6_1_1, sref_case_13_6_1_1, {
	&test_13_6_1_1_conn, &test_13_6_1_1_resp, &test_13_6_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_6_1_2, tgrp_case_13_6_1_2, name_case_13_6_1_2, desc_case_13_6_1_2, sref_case_13_6_1_2, {
	&test_13_6_1_2_conn, &test_13_6_1_2_resp, &test_13_6_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_6_1_3, tgrp_case_13_6_1_3, name_case_13_6_1_3, desc_case_13_6_1_3, sref_case_13_6_1_3, {
	&test_13_6_1_3_conn, &test_13_6_1_3_resp, &test_13_6_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_6_1_4, tgrp_case_13_6_1_4, name_case_13_6_1_4, desc_case_13_6_1_4, sref_case_13_6_1_4, {
	&test_13_6_1_4_conn, &test_13_6_1_4_resp, &test_13_6_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_6_1_5, tgrp_case_13_6_1_5, name_case_13_6_1_5, desc_case_13_6_1_5, sref_case_13_6_1_5, {
	&test_13_6_1_5_conn, &test_13_6_1_5_resp, &test_13_6_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_6_2, tgrp_case_13_6_2, name_case_13_6_2, desc_case_13_6_2, sref_case_13_6_2, {
	&test_13_6_2_conn, &test_13_6_2_resp, &test_13_6_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_1, tgrp_case_13_7_1, name_case_13_7_1, desc_case_13_7_1, sref_case_13_7_1, {
	&test_13_7_1_conn, &test_13_7_1_resp, &test_13_7_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_2, tgrp_case_13_7_2, name_case_13_7_2, desc_case_13_7_2, sref_case_13_7_2, {
	&test_13_7_2_conn, &test_13_7_2_resp, &test_13_7_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_3, tgrp_case_13_7_3, name_case_13_7_3, desc_case_13_7_3, sref_case_13_7_3, {
	&test_13_7_3_conn, &test_13_7_3_resp, &test_13_7_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_4, tgrp_case_13_7_4, name_case_13_7_4, desc_case_13_7_4, sref_case_13_7_4, {
	&test_13_7_4_conn, &test_13_7_4_resp, &test_13_7_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_5_1, tgrp_case_13_7_5_1, name_case_13_7_5_1, desc_case_13_7_5_1, sref_case_13_7_5_1, {
	&test_13_7_5_1_conn, &test_13_7_5_1_resp, &test_13_7_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_5_2, tgrp_case_13_7_5_2, name_case_13_7_5_2, desc_case_13_7_5_2, sref_case_13_7_5_2, {
	&test_13_7_5_2_conn, &test_13_7_5_2_resp, &test_13_7_5_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_7_6, tgrp_case_13_7_6, name_case_13_7_6, desc_case_13_7_6, sref_case_13_7_6, {
	&test_13_7_6_conn, &test_13_7_6_resp, &test_13_7_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_8_1_1, tgrp_case_13_8_1_1, name_case_13_8_1_1, desc_case_13_8_1_1, sref_case_13_8_1_1, {
	&test_13_8_1_1_conn, &test_13_8_1_1_resp, &test_13_8_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_8_1_2, tgrp_case_13_8_1_2, name_case_13_8_1_2, desc_case_13_8_1_2, sref_case_13_8_1_2, {
	&test_13_8_1_2_conn, &test_13_8_1_2_resp, &test_13_8_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_8_1_3, tgrp_case_13_8_1_3, name_case_13_8_1_3, desc_case_13_8_1_3, sref_case_13_8_1_3, {
	&test_13_8_1_3_conn, &test_13_8_1_3_resp, &test_13_8_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_8_1_4, tgrp_case_13_8_1_4, name_case_13_8_1_4, desc_case_13_8_1_4, sref_case_13_8_1_4, {
	&test_13_8_1_4_conn, &test_13_8_1_4_resp, &test_13_8_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_8_1_5, tgrp_case_13_8_1_5, name_case_13_8_1_5, desc_case_13_8_1_5, sref_case_13_8_1_5, {
	&test_13_8_1_5_conn, &test_13_8_1_5_resp, &test_13_8_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_8_2, tgrp_case_13_8_2, name_case_13_8_2, desc_case_13_8_2, sref_case_13_8_2, {
	&test_13_8_2_conn, &test_13_8_2_resp, &test_13_8_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_9_1, tgrp_case_13_9_1, name_case_13_9_1, desc_case_13_9_1, sref_case_13_9_1, {
	&test_13_9_1_conn, &test_13_9_1_resp, &test_13_9_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_9_2, tgrp_case_13_9_2, name_case_13_9_2, desc_case_13_9_2, sref_case_13_9_2, {
	&test_13_9_2_conn, &test_13_9_2_resp, &test_13_9_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_10_1_1, tgrp_case_13_10_1_1, name_case_13_10_1_1, desc_case_13_10_1_1, sref_case_13_10_1_1, {
	&test_13_10_1_1_conn, &test_13_10_1_1_resp, &test_13_10_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_10_1_2, tgrp_case_13_10_1_2, name_case_13_10_1_2, desc_case_13_10_1_2, sref_case_13_10_1_2, {
	&test_13_10_1_2_conn, &test_13_10_1_2_resp, &test_13_10_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_10_1_3, tgrp_case_13_10_1_3, name_case_13_10_1_3, desc_case_13_10_1_3, sref_case_13_10_1_3, {
	&test_13_10_1_3_conn, &test_13_10_1_3_resp, &test_13_10_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_10_1_4, tgrp_case_13_10_1_4, name_case_13_10_1_4, desc_case_13_10_1_4, sref_case_13_10_1_4, {
	&test_13_10_1_4_conn, &test_13_10_1_4_resp, &test_13_10_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_10_1_5, tgrp_case_13_10_1_5, name_case_13_10_1_5, desc_case_13_10_1_5, sref_case_13_10_1_5, {
	&test_13_10_1_5_conn, &test_13_10_1_5_resp, &test_13_10_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_1, tgrp_case_13_11_1, name_case_13_11_1, desc_case_13_11_1, sref_case_13_11_1, {
	&test_13_11_1_conn, &test_13_11_1_resp, &test_13_11_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_2, tgrp_case_13_11_2, name_case_13_11_2, desc_case_13_11_2, sref_case_13_11_2, {
	&test_13_11_2_conn, &test_13_11_2_resp, &test_13_11_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_3, tgrp_case_13_11_3, name_case_13_11_3, desc_case_13_11_3, sref_case_13_11_3, {
	&test_13_11_3_conn, &test_13_11_3_resp, &test_13_11_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_4, tgrp_case_13_11_4, name_case_13_11_4, desc_case_13_11_4, sref_case_13_11_4, {
	&test_13_11_4_conn, &test_13_11_4_resp, &test_13_11_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_5, tgrp_case_13_11_5, name_case_13_11_5, desc_case_13_11_5, sref_case_13_11_5, {
	&test_13_11_5_conn, &test_13_11_5_resp, &test_13_11_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_6, tgrp_case_13_11_6, name_case_13_11_6, desc_case_13_11_6, sref_case_13_11_6, {
	&test_13_11_6_conn, &test_13_11_6_resp, &test_13_11_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_11_7, tgrp_case_13_11_7, name_case_13_11_7, desc_case_13_11_7, sref_case_13_11_7, {
	&test_13_11_7_conn, &test_13_11_7_resp, &test_13_11_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_12_1_1, tgrp_case_13_12_1_1, name_case_13_12_1_1, desc_case_13_12_1_1, sref_case_13_12_1_1, {
	&test_13_12_1_1_conn, &test_13_12_1_1_resp, &test_13_12_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_12_1_2, tgrp_case_13_12_1_2, name_case_13_12_1_2, desc_case_13_12_1_2, sref_case_13_12_1_2, {
	&test_13_12_1_2_conn, &test_13_12_1_2_resp, &test_13_12_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_12_1_3, tgrp_case_13_12_1_3, name_case_13_12_1_3, desc_case_13_12_1_3, sref_case_13_12_1_3, {
	&test_13_12_1_3_conn, &test_13_12_1_3_resp, &test_13_12_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_12_1_4, tgrp_case_13_12_1_4, name_case_13_12_1_4, desc_case_13_12_1_4, sref_case_13_12_1_4, {
	&test_13_12_1_4_conn, &test_13_12_1_4_resp, &test_13_12_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_12_1_5, tgrp_case_13_12_1_5, name_case_13_12_1_5, desc_case_13_12_1_5, sref_case_13_12_1_5, {
	&test_13_12_1_5_conn, &test_13_12_1_5_resp, &test_13_12_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_1, tgrp_case_13_13_1, name_case_13_13_1, desc_case_13_13_1, sref_case_13_13_1, {
	&test_13_13_1_conn, &test_13_13_1_resp, &test_13_13_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_2_1, tgrp_case_13_13_2_1, name_case_13_13_2_1, desc_case_13_13_2_1, sref_case_13_13_2_1, {
	&test_13_13_2_1_conn, &test_13_13_2_1_resp, &test_13_13_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_2_2, tgrp_case_13_13_2_2, name_case_13_13_2_2, desc_case_13_13_2_2, sref_case_13_13_2_2, {
	&test_13_13_2_2_conn, &test_13_13_2_2_resp, &test_13_13_2_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_2_3, tgrp_case_13_13_2_3, name_case_13_13_2_3, desc_case_13_13_2_3, sref_case_13_13_2_3, {
	&test_13_13_2_3_conn, &test_13_13_2_3_resp, &test_13_13_2_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_2_4, tgrp_case_13_13_2_4, name_case_13_13_2_4, desc_case_13_13_2_4, sref_case_13_13_2_4, {
	&test_13_13_2_4_conn, &test_13_13_2_4_resp, &test_13_13_2_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_2_5, tgrp_case_13_13_2_5, name_case_13_13_2_5, desc_case_13_13_2_5, sref_case_13_13_2_5, {
	&test_13_13_2_5_conn, &test_13_13_2_5_resp, &test_13_13_2_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_2_6, tgrp_case_13_13_2_6, name_case_13_13_2_6, desc_case_13_13_2_6, sref_case_13_13_2_6, {
	&test_13_13_2_6_conn, &test_13_13_2_6_resp, &test_13_13_2_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_13_3, tgrp_case_13_13_3, name_case_13_13_3, desc_case_13_13_3, sref_case_13_13_3, {
	&test_13_13_3_conn, &test_13_13_3_resp, &test_13_13_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_14_1_1, tgrp_case_13_14_1_1, name_case_13_14_1_1, desc_case_13_14_1_1, sref_case_13_14_1_1, {
	&test_13_14_1_1_conn, &test_13_14_1_1_resp, &test_13_14_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_13_14_2, tgrp_case_13_14_2, name_case_13_14_2, desc_case_13_14_2, sref_case_13_14_2, {
	&test_13_14_2_conn, &test_13_14_2_resp, &test_13_14_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_1, tgrp_case_14_1_1, name_case_14_1_1, desc_case_14_1_1, sref_case_14_1_1, {
	&test_14_1_1_conn, &test_14_1_1_resp, &test_14_1_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_2, tgrp_case_14_1_2, name_case_14_1_2, desc_case_14_1_2, sref_case_14_1_2, {
	&test_14_1_2_conn, &test_14_1_2_resp, &test_14_1_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_3, tgrp_case_14_1_3, name_case_14_1_3, desc_case_14_1_3, sref_case_14_1_3, {
	&test_14_1_3_conn, &test_14_1_3_resp, &test_14_1_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_4, tgrp_case_14_1_4, name_case_14_1_4, desc_case_14_1_4, sref_case_14_1_4, {
	&test_14_1_4_conn, &test_14_1_4_resp, &test_14_1_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_5, tgrp_case_14_1_5, name_case_14_1_5, desc_case_14_1_5, sref_case_14_1_5, {
	&test_14_1_5_conn, &test_14_1_5_resp, &test_14_1_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_6, tgrp_case_14_1_6, name_case_14_1_6, desc_case_14_1_6, sref_case_14_1_6, {
	&test_14_1_6_conn, &test_14_1_6_resp, &test_14_1_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_1_7, tgrp_case_14_1_7, name_case_14_1_7, desc_case_14_1_7, sref_case_14_1_7, {
	&test_14_1_7_conn, &test_14_1_7_resp, &test_14_1_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_2_1, tgrp_case_14_2_1, name_case_14_2_1, desc_case_14_2_1, sref_case_14_2_1, {
	&test_14_2_1_conn, &test_14_2_1_resp, &test_14_2_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_1, tgrp_case_14_3_1, name_case_14_3_1, desc_case_14_3_1, sref_case_14_3_1, {
	&test_14_3_1_conn, &test_14_3_1_resp, &test_14_3_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_2, tgrp_case_14_3_2, name_case_14_3_2, desc_case_14_3_2, sref_case_14_3_2, {
	&test_14_3_2_conn, &test_14_3_2_resp, &test_14_3_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_3, tgrp_case_14_3_3, name_case_14_3_3, desc_case_14_3_3, sref_case_14_3_3, {
	&test_14_3_3_conn, &test_14_3_3_resp, &test_14_3_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_4, tgrp_case_14_3_4, name_case_14_3_4, desc_case_14_3_4, sref_case_14_3_4, {
	&test_14_3_4_conn, &test_14_3_4_resp, &test_14_3_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_5, tgrp_case_14_3_5, name_case_14_3_5, desc_case_14_3_5, sref_case_14_3_5, {
	&test_14_3_5_conn, &test_14_3_5_resp, &test_14_3_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_6, tgrp_case_14_3_6, name_case_14_3_6, desc_case_14_3_6, sref_case_14_3_6, {
	&test_14_3_6_conn, &test_14_3_6_resp, &test_14_3_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_3_7, tgrp_case_14_3_7, name_case_14_3_7, desc_case_14_3_7, sref_case_14_3_7, {
	&test_14_3_7_conn, &test_14_3_7_resp, &test_14_3_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_4_1, tgrp_case_14_4_1, name_case_14_4_1, desc_case_14_4_1, sref_case_14_4_1, {
	&test_14_4_1_conn, &test_14_4_1_resp, &test_14_4_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_5_1, tgrp_case_14_5_1, name_case_14_5_1, desc_case_14_5_1, sref_case_14_5_1, {
	&test_14_5_1_conn, &test_14_5_1_resp, &test_14_5_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_6_1, tgrp_case_14_6_1, name_case_14_6_1, desc_case_14_6_1, sref_case_14_6_1, {
	&test_14_6_1_conn, &test_14_6_1_resp, &test_14_6_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_6_2, tgrp_case_14_6_2, name_case_14_6_2, desc_case_14_6_2, sref_case_14_6_2, {
	&test_14_6_2_conn, &test_14_6_2_resp, &test_14_6_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_7_1, tgrp_case_14_7_1, name_case_14_7_1, desc_case_14_7_1, sref_case_14_7_1, {
	&test_14_7_1_conn, &test_14_7_1_resp, &test_14_7_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_7_2, tgrp_case_14_7_2, name_case_14_7_2, desc_case_14_7_2, sref_case_14_7_2, {
	&test_14_7_2_conn, &test_14_7_2_resp, &test_14_7_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_7_3, tgrp_case_14_7_3, name_case_14_7_3, desc_case_14_7_3, sref_case_14_7_3, {
	&test_14_7_3_conn, &test_14_7_3_resp, &test_14_7_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_7_4, tgrp_case_14_7_4, name_case_14_7_4, desc_case_14_7_4, sref_case_14_7_4, {
	&test_14_7_4_conn, &test_14_7_4_resp, &test_14_7_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_7_5, tgrp_case_14_7_5, name_case_14_7_5, desc_case_14_7_5, sref_case_14_7_5, {
	&test_14_7_5_conn, &test_14_7_5_resp, &test_14_7_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_8_1, tgrp_case_14_8_1, name_case_14_8_1, desc_case_14_8_1, sref_case_14_8_1, {
	&test_14_8_1_conn, &test_14_8_1_resp, &test_14_8_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_8_2, tgrp_case_14_8_2, name_case_14_8_2, desc_case_14_8_2, sref_case_14_8_2, {
	&test_14_8_2_conn, &test_14_8_2_resp, &test_14_8_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_1, tgrp_case_14_9_1, name_case_14_9_1, desc_case_14_9_1, sref_case_14_9_1, {
	&test_14_9_1_conn, &test_14_9_1_resp, &test_14_9_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_2, tgrp_case_14_9_2, name_case_14_9_2, desc_case_14_9_2, sref_case_14_9_2, {
	&test_14_9_2_conn, &test_14_9_2_resp, &test_14_9_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_3, tgrp_case_14_9_3, name_case_14_9_3, desc_case_14_9_3, sref_case_14_9_3, {
	&test_14_9_3_conn, &test_14_9_3_resp, &test_14_9_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_4, tgrp_case_14_9_4, name_case_14_9_4, desc_case_14_9_4, sref_case_14_9_4, {
	&test_14_9_4_conn, &test_14_9_4_resp, &test_14_9_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_5, tgrp_case_14_9_5, name_case_14_9_5, desc_case_14_9_5, sref_case_14_9_5, {
	&test_14_9_5_conn, &test_14_9_5_resp, &test_14_9_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_6, tgrp_case_14_9_6, name_case_14_9_6, desc_case_14_9_6, sref_case_14_9_6, {
	&test_14_9_6_conn, &test_14_9_6_resp, &test_14_9_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_9_7, tgrp_case_14_9_7, name_case_14_9_7, desc_case_14_9_7, sref_case_14_9_7, {
	&test_14_9_7_conn, &test_14_9_7_resp, &test_14_9_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_10_1, tgrp_case_14_10_1, name_case_14_10_1, desc_case_14_10_1, sref_case_14_10_1, {
	&test_14_10_1_conn, &test_14_10_1_resp, &test_14_10_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_10_2, tgrp_case_14_10_2, name_case_14_10_2, desc_case_14_10_2, sref_case_14_10_2, {
	&test_14_10_2_conn, &test_14_10_2_resp, &test_14_10_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_1, tgrp_case_14_11_1, name_case_14_11_1, desc_case_14_11_1, sref_case_14_11_1, {
	&test_14_11_1_conn, &test_14_11_1_resp, &test_14_11_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_2, tgrp_case_14_11_2, name_case_14_11_2, desc_case_14_11_2, sref_case_14_11_2, {
	&test_14_11_2_conn, &test_14_11_2_resp, &test_14_11_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_3, tgrp_case_14_11_3, name_case_14_11_3, desc_case_14_11_3, sref_case_14_11_3, {
	&test_14_11_3_conn, &test_14_11_3_resp, &test_14_11_3_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_4, tgrp_case_14_11_4, name_case_14_11_4, desc_case_14_11_4, sref_case_14_11_4, {
	&test_14_11_4_conn, &test_14_11_4_resp, &test_14_11_4_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_5, tgrp_case_14_11_5, name_case_14_11_5, desc_case_14_11_5, sref_case_14_11_5, {
	&test_14_11_5_conn, &test_14_11_5_resp, &test_14_11_5_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_6, tgrp_case_14_11_6, name_case_14_11_6, desc_case_14_11_6, sref_case_14_11_6, {
	&test_14_11_6_conn, &test_14_11_6_resp, &test_14_11_6_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_11_7, tgrp_case_14_11_7, name_case_14_11_7, desc_case_14_11_7, sref_case_14_11_7, {
	&test_14_11_7_conn, &test_14_11_7_resp, &test_14_11_7_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_12_1, tgrp_case_14_12_1, name_case_14_12_1, desc_case_14_12_1, sref_case_14_12_1, {
	&test_14_12_1_conn, &test_14_12_1_resp, &test_14_12_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_12_2, tgrp_case_14_12_2, name_case_14_12_2, desc_case_14_12_2, sref_case_14_12_2, {
	&test_14_12_2_conn, &test_14_12_2_resp, &test_14_12_2_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_13_1, tgrp_case_14_13_1, name_case_14_13_1, desc_case_14_13_1, sref_case_14_13_1, {
	&test_14_13_1_conn, &test_14_13_1_resp, &test_14_13_1_list}, &begin_tests, &end_tests, 0, 0}, {
		numb_case_14_14_1, tgrp_case_14_14_1, name_case_14_14_1, desc_case_14_14_1, sref_case_14_14_1, {
	&test_14_14_1_conn, &test_14_14_1_resp, &test_14_14_1_list}, &begin_tests, &end_tests, 0, 0}, {
	NULL,}
};

static int summary = 0;

void
print_header(void)
{
	if (verbose <= 0)
		return;
	dummy = lockf(fileno(stdout), F_LOCK, 0);
	fprintf(stdout, "\n%s - %s - %s - Conformance Test Suite\n", lstdname, lpkgname, shortname);
	fflush(stdout);
	dummy = lockf(fileno(stdout), F_ULOCK, 0);
}

int
do_tests(int num_tests)
{
	int i;
	int result = __RESULT_INCONCLUSIVE;
	int notapplicable = 0;
	int inconclusive = 0;
	int successes = 0;
	int failures = 0;
	int skipped = 0;
	int notselected = 0;
	int aborted = 0;

	print_header();
	show = 0;
	if (verbose > 0) {
		dummy = lockf(fileno(stdout), F_LOCK, 0);
		fprintf(stdout, "\nUsing device %s\n\n", devname);
		fflush(stdout);
		dummy = lockf(fileno(stdout), F_ULOCK, 0);
	}
	if (num_tests == 1 || begin_tests(0) == __RESULT_SUCCESS) {
		if (num_tests != 1)
			end_tests(0);
		show = 1;
		for (i = 0; i < (sizeof(tests) / sizeof(struct test_case)) && tests[i].numb; i++) {
		      rerun:
			if (!tests[i].run) {
				tests[i].result = __RESULT_INCONCLUSIVE;
				notselected++;
				continue;
			}
			if (aborted) {
				tests[i].result = __RESULT_INCONCLUSIVE;
				inconclusive++;
				continue;
			}
			if (verbose > 0) {
				dummy = lockf(fileno(stdout), F_LOCK, 0);
				if (verbose > 1)
					fprintf(stdout, "\nTest Group: %s", tests[i].tgrp);
				fprintf(stdout, "\nTest Case %s-%s/%s: %s\n", sstdname, shortname, tests[i].numb, tests[i].name);
				if (verbose > 1)
					fprintf(stdout, "Test Reference: %s\n", tests[i].sref);
				if (verbose > 1)
					fprintf(stdout, "%s\n", tests[i].desc);
				fprintf(stdout, "\n");
				fflush(stdout);
				dummy = lockf(fileno(stdout), F_ULOCK, 0);
			}
			if ((result = tests[i].result) == 0) {
				if ((result = (*tests[i].start) (i)) != __RESULT_SUCCESS)
					goto inconclusive;
				result = test_run(tests[i].stream);
				(*tests[i].stop) (i);
			} else {
				switch (result) {
				case __RESULT_SUCCESS:
					print_passed(3);
					break;
				case __RESULT_FAILURE:
					print_failed(3);
					break;
				case __RESULT_NOTAPPL:
					print_notapplicable(3);
					break;
				case __RESULT_SKIPPED:
					print_skipped(3);
					break;
				default:
				case __RESULT_INCONCLUSIVE:
					print_inconclusive(3);
					break;
				}
			}
			switch (result) {
			case __RESULT_SUCCESS:
				successes++;
				if (verbose > 0) {
					dummy = lockf(fileno(stdout), F_LOCK, 0);
					fprintf(stdout, "\n");
					fprintf(stdout, "*********\n");
					fprintf(stdout, "********* Test Case SUCCESSFUL\n");
					fprintf(stdout, "*********\n\n");
					fflush(stdout);
					dummy = lockf(fileno(stdout), F_ULOCK, 0);
				}
				break;
			case __RESULT_FAILURE:
				failures++;
				if (verbose > 0) {
					dummy = lockf(fileno(stdout), F_LOCK, 0);
					fprintf(stdout, "\n");
					fprintf(stdout, "XXXXXXXXX\n");
					fprintf(stdout, "XXXXXXXXX Test Case FAILED\n");
					fprintf(stdout, "XXXXXXXXX\n\n");
					fflush(stdout);
					dummy = lockf(fileno(stdout), F_ULOCK, 0);
				}
				break;
			case __RESULT_NOTAPPL:
				notapplicable++;
				if (verbose > 0) {
					dummy = lockf(fileno(stdout), F_LOCK, 0);
					fprintf(stdout, "\n");
					fprintf(stdout, "XXXXXXXXX\n");
					fprintf(stdout, "XXXXXXXXX Test Case NOT APPLICABLE\n");
					fprintf(stdout, "XXXXXXXXX\n\n");
					fflush(stdout);
					dummy = lockf(fileno(stdout), F_ULOCK, 0);
				}
				break;
			case __RESULT_SKIPPED:
				skipped++;
				if (verbose > 0) {
					dummy = lockf(fileno(stdout), F_LOCK, 0);
					fprintf(stdout, "\n");
					fprintf(stdout, "XXXXXXXXX\n");
					fprintf(stdout, "XXXXXXXXX Test Case SKIPPED\n");
					fprintf(stdout, "XXXXXXXXX\n\n");
					fflush(stdout);
					dummy = lockf(fileno(stdout), F_ULOCK, 0);
				}
				break;
			default:
			case __RESULT_INCONCLUSIVE:
			      inconclusive:
				inconclusive++;
				if (verbose > 0) {
					dummy = lockf(fileno(stdout), F_LOCK, 0);
					fprintf(stdout, "\n");
					fprintf(stdout, "?????????\n");
					fprintf(stdout, "????????? Test Case INCONCLUSIVE\n");
					fprintf(stdout, "?????????\n\n");
					fflush(stdout);
					dummy = lockf(fileno(stdout), F_ULOCK, 0);
				}
				break;
			}
			if (repeat_on_failure && (result == __RESULT_FAILURE || result == __RESULT_INCONCLUSIVE))
				goto rerun;
			if (repeat_on_success && (result == __RESULT_SUCCESS))
				goto rerun;
			tests[i].result = result;
			if (exit_on_failure && (result == __RESULT_FAILURE || result == __RESULT_INCONCLUSIVE)) {
				aborted = 1;
				continue;
			}
		}
		if (summary && verbose) {
			dummy = lockf(fileno(stdout), F_LOCK, 0);
			fprintf(stdout, "\n");
			fflush(stdout);
			dummy = lockf(fileno(stdout), F_ULOCK, 0);
			for (i = 0; i < (sizeof(tests) / sizeof(struct test_case)) && tests[i].numb; i++) {
				if (tests[i].run) {
					dummy = lockf(fileno(stdout), F_LOCK, 0);
					fprintf(stdout, "Test Case %s-%s/%-10s ", sstdname, shortname, tests[i].numb);
					fflush(stdout);
					dummy = lockf(fileno(stdout), F_ULOCK, 0);
					switch (tests[i].result) {
					case __RESULT_SUCCESS:
						dummy = lockf(fileno(stdout), F_LOCK, 0);
						fprintf(stdout, "SUCCESS\n");
						fflush(stdout);
						dummy = lockf(fileno(stdout), F_ULOCK, 0);
						break;
					case __RESULT_FAILURE:
						dummy = lockf(fileno(stdout), F_LOCK, 0);
						fprintf(stdout, "FAILURE\n");
						fflush(stdout);
						dummy = lockf(fileno(stdout), F_ULOCK, 0);
						break;
					case __RESULT_NOTAPPL:
						dummy = lockf(fileno(stdout), F_LOCK, 0);
						fprintf(stdout, "NOT APPLICABLE\n");
						fflush(stdout);
						dummy = lockf(fileno(stdout), F_ULOCK, 0);
						break;
					case __RESULT_SKIPPED:
						dummy = lockf(fileno(stdout), F_LOCK, 0);
						fprintf(stdout, "SKIPPED\n");
						fflush(stdout);
						dummy = lockf(fileno(stdout), F_ULOCK, 0);
						break;
					default:
					case __RESULT_INCONCLUSIVE:
						dummy = lockf(fileno(stdout), F_LOCK, 0);
						fprintf(stdout, "INCONCLUSIVE\n");
						fflush(stdout);
						dummy = lockf(fileno(stdout), F_ULOCK, 0);
						break;
					}
				}
			}
		}
		if (verbose > 0 && num_tests > 1) {
			dummy = lockf(fileno(stdout), F_LOCK, 0);
			fprintf(stdout, "\n");
			fprintf(stdout, "========= %3d successes     \n", successes);
			fprintf(stdout, "========= %3d failures      \n", failures);
			fprintf(stdout, "========= %3d inconclusive  \n", inconclusive);
			fprintf(stdout, "========= %3d not applicable\n", notapplicable);
			fprintf(stdout, "========= %3d skipped       \n", skipped);
			fprintf(stdout, "========= %3d not selected  \n", notselected);
			fprintf(stdout, "============================\n");
			fprintf(stdout, "========= %3d total         \n", successes + failures + inconclusive + notapplicable + skipped + notselected);
			if (!(aborted + failures))
				fprintf(stdout, "\nDone.\n\n");
			fflush(stdout);
			dummy = lockf(fileno(stdout), F_ULOCK, 0);
		}
		if (aborted) {
			dummy = lockf(fileno(stderr), F_LOCK, 0);
			if (verbose > 0)
				fprintf(stderr, "\n");
			fprintf(stderr, "Test Suite aborted due to failure.\n");
			if (verbose > 0)
				fprintf(stderr, "\n");
			fflush(stderr);
			dummy = lockf(fileno(stderr), F_ULOCK, 0);
		} else if (failures) {
			dummy = lockf(fileno(stderr), F_LOCK, 0);
			if (verbose > 0)
				fprintf(stderr, "\n");
			fprintf(stderr, "Test Suite failed.\n");
			if (verbose > 0)
				fprintf(stderr, "\n");
			fflush(stderr);
			dummy = lockf(fileno(stderr), F_ULOCK, 0);
		}
		if (num_tests == 1) {
			if (successes)
				return (0);
			if (failures)
				return (1);
			if (inconclusive)
				return (1);
			if (notapplicable)
				return (0);
			if (skipped)
				return (77);
		}
		return (aborted);
	} else {
		end_tests(0);
		show = 1;
		dummy = lockf(fileno(stderr), F_LOCK, 0);
		fprintf(stderr, "Test Suite setup failed!\n");
		fflush(stderr);
		dummy = lockf(fileno(stderr), F_ULOCK, 0);
		return (2);
	}
}

void
copying(int argc, char *argv[])
{
	if (!verbose)
		return;
	print_header();
	fprintf(stdout, "\
\n\
Copyright (c) 2001-2006  OpenSS7 Corporation <http://www.openss7.com/>\n\
Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>\n\
\n\
All Rights Reserved.\n\
\n\
Unauthorized distribution or duplication is prohibited.\n\
\n\
This software and related documentation is protected by copyright and distribut-\n\
ed under licenses restricting its use,  copying, distribution and decompilation.\n\
No part of this software or related documentation may  be reproduced in any form\n\
by any means without the prior  written  authorization of the  copyright holder,\n\
and licensors, if any.\n\
\n\
The recipient of this document,  by its retention and use, warrants that the re-\n\
cipient  will protect this  information and  keep it confidential,  and will not\n\
disclose the information contained  in this document without the written permis-\n\
sion of its owner.\n\
\n\
The author reserves the right to revise  this software and documentation for any\n\
reason,  including but not limited to, conformity with standards  promulgated by\n\
various agencies, utilization of advances in the state of the technical arts, or\n\
the reflection of changes  in the design of any techniques, or procedures embod-\n\
ied, described, or  referred to herein.   The author  is under no  obligation to\n\
provide any feature listed herein.\n\
\n\
As an exception to the above,  this software may be  distributed  under the  GNU\n\
General Public License (GPL) Version 2,  so long as the  software is distributed\n\
with, and only used for the testing of, OpenSS7 modules, drivers, and libraries.\n\
\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the  U.S. Government  (\"Government\"),  the following provisions apply to you.\n\
If the Software is  supplied by the Department of Defense (\"DoD\"), it is classi-\n\
fied as  \"Commercial Computer Software\"  under paragraph 252.227-7014 of the DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the license rights  granted\n\
herein (the license  rights customarily  provided to non-Government  users).  If\n\
the Software is supplied to any unit or agency of the Government other than DoD,\n\
it is classified as  \"Restricted Computer Software\" and the  Government's rights\n\
in the  Software are defined in  paragraph 52.227-19 of the Federal  Acquisition\n\
Regulations  (\"FAR\") (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of the  NASA Supplement  to the  FAR (or  any  successor\n\
regulations).\n\
\n\
");
}

void
version(int argc, char *argv[])
{
	if (!verbose)
		return;
	fprintf(stdout, "\
\n\
%1$s:\n\
    %2$s\n\
    Copyright (c) 1997-2006  OpenSS7 Corporation.  All Rights Reserved.\n\
\n\
    Distributed by OpenSS7 Corporation under GPL Version 2,\n\
    incorporated here by reference.\n\
\n\
    See `%1$s --copying' for copying permission.\n\
\n\
", argv[0], ident);
}

void
usage(int argc, char *argv[])
{
	if (!verbose)
		return;
	fprintf(stderr, "\
Usage:\n\
    %1$s [options]\n\
    %1$s {-h, --help}\n\
    %1$s {-V, --version}\n\
    %1$s {-C, --copying}\n\
", argv[0]);
}

void
help(int argc, char *argv[])
{
	if (!verbose)
		return;
	fprintf(stdout, "\
\n\
Usage:\n\
    %1$s [options]\n\
    %1$s {-h, --help}\n\
    %1$s {-V, --version}\n\
    %1$s {-C, --copying}\n\
Arguments:\n\
    (none)\n\
Options:\n\
    -c, --client\n\
        execute client side of test case only.\n\
    -S, --server\n\
        execute server side of test case only.\n\
    -w, --wait\n\
        have server wait indefinitely.\n\
    -r, --repeat\n\
        repeat test cases on success or failure.\n\
    -R, --repeat-fail\n\
        repeat test cases on failure.\n\
    -p, --client-port [PORT]\n\
        port number from which to connect [default: 10000+index*3]\n\
    -P, --server-port [PORT]\n\
        port number to which to connect or upon which to listen\n\
        [default: 10000+index*3+2]\n\
    -i, --client-host [HOSTNAME[,HOSTNAME]*]\n\
        client host names(s) or IP numbers\n\
        [default: 127.0.0.1,127.0.0.2,127.0.0.3]\n\
    -I, --server-host [HOSTNAME[,HOSTNAME]*]\n\
        server host names(s) or IP numbers\n\
        [default: 127.0.0.1,127.0.0.2,127.0.0.3]\n\
    -d, --device DEVICE\n\
        device name to open [default: %2$s].\n\
    -e, --exit\n\
        exit on the first failed or inconclusive test case.\n\
    -l, --list [RANGE]\n\
        list test case names within a range [default: all] and exit.\n\
    -f, --fast [SCALE]\n\
        increase speed of tests by scaling timers [default: 50]\n\
    -s, --summary\n\
        print a test case summary at end of testing [default: off]\n\
    -o, --onetest [TESTCASE]\n\
        run a single test case.\n\
    -t, --tests [RANGE]\n\
        run a range of test cases.\n\
    -m, --messages\n\
        display messages. [default: off]\n\
    -q, --quiet\n\
        suppress normal output (equivalent to --verbose=0)\n\
    -v, --verbose [LEVEL]\n\
        increase verbosity or set to LEVEL [default: 1]\n\
        this option may be repeated.\n\
    -h, --help, -?, --?\n\
        print this usage message and exit\n\
    -V, --version\n\
        print version and exit\n\
    -C, --copying\n\
        print copying permission and exit\n\
\n\
", argv[0], devname);
}

#define HOST_BUF_LEN 128

int
main(int argc, char *argv[])
{
	size_t l, n;
	int range = 0;
	struct test_case *t;
	int tests_to_run = 0;
	char *hostc = "127.0.0.1,127.0.0.2,127.0.0.3";
	char *hosts = "127.0.0.1,127.0.0.2,127.0.0.3";
	char hostbufc[HOST_BUF_LEN];
	char hostbufs[HOST_BUF_LEN];
	struct hostent *haddr;

	for (t = tests; t->numb; t++) {
		if (!t->result) {
			t->run = 1;
			tests_to_run++;
		}
	}
	for (;;) {
		int c, val;

#if defined _GNU_SOURCE
		int option_index = 0;
		/* *INDENT-OFF* */
		static struct option long_options[] = {
			{"client",	no_argument,		NULL, 'c'},
			{"server",	no_argument,		NULL, 'S'},
			{"wait",	no_argument,		NULL, 'w'},
			{"client-port",	required_argument,	NULL, 'p'},
			{"server-port",	required_argument,	NULL, 'P'},
			{"client-host",	required_argument,	NULL, 'i'},
			{"server-host",	required_argument,	NULL, 'I'},
			{"repeat",	no_argument,		NULL, 'r'},
			{"repeat-fail",	no_argument,		NULL, 'R'},
			{"device",	required_argument,	NULL, 'd'},
			{"exit",	no_argument,		NULL, 'e'},
			{"list",	optional_argument,	NULL, 'l'},
			{"fast",	optional_argument,	NULL, 'f'},
			{"summary",	no_argument,		NULL, 's'},
			{"onetest",	required_argument,	NULL, 'o'},
			{"tests",	required_argument,	NULL, 't'},
			{"messages",	no_argument,		NULL, 'm'},
			{"quiet",	no_argument,		NULL, 'q'},
			{"verbose",	optional_argument,	NULL, 'v'},
			{"help",	no_argument,		NULL, 'h'},
			{"version",	no_argument,		NULL, 'V'},
			{"copying",	no_argument,		NULL, 'C'},
			{"?",		no_argument,		NULL, 'h'},
			{NULL,		0,			NULL,  0 }
		};
		/* *INDENT-ON* */

		c = getopt_long(argc, argv, "cSwp:P:i:I:rRd:el::f::so:t:mqvhVC?", long_options, &option_index);
#else				/* defined _GNU_SOURCE */
		c = getopt(argc, argv, "cSwp:P:i:I:rRd:el::f::so:t:mqvhVC?");
#endif				/* defined _GNU_SOURCE */
		if (c == -1)
			break;
		switch (c) {
		case 'c':	/* --client */
			client_exec = 1;
			break;
		case 'S':	/* --server */
			server_exec = 1;
			break;
		case 'w':	/* --wait */
			test_duration = INFINITE_WAIT;
			break;
		case 'p':	/* --client-port */
			client_port_specified = 1;
			ports[3] = atoi(optarg);
			ports[0] = ports[3];
			break;
		case 'P':	/* --server-port */
			server_port_specified = 1;
			ports[3] = atoi(optarg);
			ports[1] = ports[3];
			ports[2] = ports[3] + 1;
			break;
		case 'i':	/* --client-host *//* client host */
			client_host_specified = 1;
			strncpy(hostbufc, optarg, HOST_BUF_LEN);
			hostc = hostbufc;
			break;
		case 'I':	/* --server-host *//* server host */
			server_host_specified = 1;
			strncpy(hostbufs, optarg, HOST_BUF_LEN);
			hosts = hostbufs;
			break;
		case 'r':	/* --repeat */
			repeat_on_success = 1;
			repeat_on_failure = 1;
			break;
		case 'R':	/* --repeat-fail */
			repeat_on_failure = 1;
			break;
		case 'd':
			if (optarg) {
				snprintf(devname, sizeof(devname), "%s", optarg);
				break;
			}
			goto bad_option;
		case 'e':
			exit_on_failure = 1;
			break;
		case 'l':
			if (optarg) {
				l = strnlen(optarg, 16);
				fprintf(stdout, "\n");
				for (n = 0, t = tests; t->numb; t++)
					if (!strncmp(t->numb, optarg, l)) {
						if (verbose > 2)
							fprintf(stdout, "Test Group: %s\n", t->tgrp);
						fprintf(stdout, "Test Case %s-%s/%s: %s\n", sstdname, shortname, t->numb, t->name);
						if (verbose > 2)
							fprintf(stdout, "Test Reference: %s\n", t->sref);
						if (verbose > 1)
							fprintf(stdout, "%s\n\n", t->desc);
						fflush(stdout);
						n++;
					}
				if (!n) {
					fprintf(stderr, "WARNING: specification `%s' matched no test\n", optarg);
					fflush(stderr);
					goto bad_option;
				}
				if (verbose <= 1)
					fprintf(stdout, "\n");
				fflush(stdout);
				exit(0);
			} else {
				fprintf(stdout, "\n");
				for (t = tests; t->numb; t++) {
					if (verbose > 2)
						fprintf(stdout, "Test Group: %s\n", t->tgrp);
					fprintf(stdout, "Test Case %s-%s/%s: %s\n", sstdname, shortname, t->numb, t->name);
					if (verbose > 2)
						fprintf(stdout, "Test Reference: %s\n", t->sref);
					if (verbose > 1)
						fprintf(stdout, "%s\n\n", t->desc);
					fflush(stdout);
				}
				if (verbose <= 1)
					fprintf(stdout, "\n");
				fflush(stdout);
				exit(0);
			}
			break;
		case 'f':
			if (optarg)
				timer_scale = atoi(optarg);
			else
				timer_scale = 50;
			fprintf(stderr, "WARNING: timers are scaled by a factor of %ld\n", (long)timer_scale);
			break;
		case 's':
			summary = 1;
			break;
		case 'o':
			if (optarg) {
				if (!range) {
					for (t = tests; t->numb; t++)
						t->run = 0;
					tests_to_run = 0;
				}
				range = 1;
				for (n = 0, t = tests; t->numb; t++)
					if (!strncmp(t->numb, optarg, 16)) {
						// if (!t->result) {
						t->run = 1;
						n++;
						tests_to_run++;
						// }
					}
				if (!n) {
					fprintf(stderr, "WARNING: specification `%s' matched no test\n", optarg);
					fflush(stderr);
					goto bad_option;
				}
				break;
			}
			goto bad_option;
		case 'q':
			verbose = 0;
			break;
		case 'v':
			if (optarg == NULL) {
				verbose++;
				break;
			}
			if ((val = strtol(optarg, NULL, 0)) < 0)
				goto bad_option;
			verbose = val;
			break;
		case 't':
			l = strnlen(optarg, 16);
			if (!range) {
				for (t = tests; t->numb; t++)
					t->run = 0;
				tests_to_run = 0;
			}
			range = 1;
			for (n = 0, t = tests; t->numb; t++)
				if (!strncmp(t->numb, optarg, l)) {
					// if (!t->result) {
					t->run = 1;
					n++;
					tests_to_run++;
					// }
				}
			if (!n) {
				fprintf(stderr, "WARNING: specification `%s' matched no test\n", optarg);
				fflush(stderr);
				goto bad_option;
			}
			break;
		case 'm':
			show_msg = 1;
			break;
		case 'H':	/* -H */
		case 'h':	/* -h, --help */
			help(argc, argv);
			exit(0);
		case 'V':
			version(argc, argv);
			exit(0);
		case 'C':
			copying(argc, argv);
			exit(0);
		case '?':
		default:
		      bad_option:
			optind--;
		      bad_nonopt:
			if (optind < argc && verbose) {
				fprintf(stderr, "%s: illegal syntax -- ", argv[0]);
				while (optind < argc)
					fprintf(stderr, "%s ", argv[optind++]);
				fprintf(stderr, "\n");
				fflush(stderr);
			}
			goto bad_usage;
		      bad_usage:
			usage(argc, argv);
			exit(2);
		}
	}
	/* 
	 * dont' ignore non-option arguments
	 */
	if (optind < argc)
		goto bad_nonopt;
	switch (tests_to_run) {
	case 0:
		if (verbose > 0) {
			fprintf(stderr, "%s: error: no tests to run\n", argv[0]);
			fflush(stderr);
		}
		exit(2);
	case 1:
		break;
	default:
		copying(argc, argv);
	}
	if (client_exec == 0 && server_exec == 0) {
		client_exec = 1;
		server_exec = 1;
	}
	if (client_host_specified) {
		int count = 0;
		char *token = hostc, *next_token, *delim = NULL;

		fprintf(stdout, "Specified client address => %s\n", token);
		do {
			if ((delim = index(token, ','))) {
				delim[0] = '\0';
				next_token = delim + 1;
			} else
				next_token = NULL;
			haddr = gethostbyname(token);
			addrs[0][count].sin_family = AF_INET;
			addrs[3][count].sin_family = AF_INET;
			if (client_port_specified) {
				addrs[0][count].sin_port = htons(ports[0]);
				addrs[3][count].sin_port = htons(ports[3]);
			} else {
				addrs[0][count].sin_port = 0;
				addrs[3][count].sin_port = 0;
			}
			addrs[0][count].sin_addr.s_addr = *(uint32_t *) (haddr->h_addr);
			addrs[3][count].sin_addr.s_addr = *(uint32_t *) (haddr->h_addr);
			count++;
		} while ((token = next_token) && count < 4);
		anums[0] = count;
		anums[3] = count;
		fprintf(stdout, "%d client addresses assigned\n", count);
	}
	if (server_host_specified) {
		int count = 0;
		char *token = hosts, *next_token, *delim = NULL;

		fprintf(stdout, "Specified server address => %s\n", token);
		do {
			if ((delim = index(token, ','))) {
				delim[0] = '\0';
				next_token = delim + 1;
			} else
				next_token = NULL;
			haddr = gethostbyname(token);
			addrs[1][count].sin_family = AF_INET;
			addrs[2][count].sin_family = AF_INET;
			addrs[3][count].sin_family = AF_INET;
			if (server_port_specified) {
				addrs[1][count].sin_port = htons(ports[1]);
				addrs[2][count].sin_port = htons(ports[2]);
				addrs[3][count].sin_port = htons(ports[3]);
			} else {
				addrs[1][count].sin_port = 0;
				addrs[2][count].sin_port = 0;
				addrs[3][count].sin_port = 0;
			}
			addrs[1][count].sin_addr.s_addr = *(uint32_t *) (haddr->h_addr);
			addrs[2][count].sin_addr.s_addr = *(uint32_t *) (haddr->h_addr);
			addrs[3][count].sin_addr.s_addr = *(uint32_t *) (haddr->h_addr);
			count++;
		} while ((token = next_token) && count < 4);
		anums[1] = count;
		anums[2] = count;
		anums[3] = count;
		fprintf(stdout, "%d server addresses assigned\n", count);
	}
	exit(do_tests(tests_to_run));
}
