'\" rtp
.\" -*- nroff -*- vim: ft=nroff nocin nosi
.\"
.\" @(#) $Id: streamio.7.man,v 0.9.2.6 2008-04-29 07:10:31 brian Exp $
.\"
.\" =========================================================================
.\"
.\" Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
.\"
.\" All Rights Reserved.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.  The author(s) will take no responsibility in it.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" -------------------------------------------------------------------------
.\"
.\" U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
.\" on behalf of the U.S. Government ("Government"), the following
.\" provisions apply to you.  If the Software is supplied by the Department
.\" of Defense ("DoD"), it is classified as "Commercial Computer Software"
.\" under paragraph 252.227-7014 of the DoD Supplement to the Federal
.\" Acquisition Regulations ("DFARS") (or any successor regulations) and the
.\" Government is acquiring only the license rights granted herein (the
.\" license rights customarily provided to non-Government users).  If the
.\" Software is supplied to any unit or agency of the Government other than
.\" DoD, it is classified as "Restricted Computer Software" and the
.\" Government's rights in the Software are defined in paragraph 52.227-19
.\" of the Federal Acquisition Regulations ("FAR") (or any successor
.\" regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
.\" NASA Supplement to the FAR (or any successor regulations).
.\"
.\" =========================================================================
.\" 
.\" Commercial licensing and support of this software is available from
.\" OpenSS7 Corporation at a fee.  See http://www.openss7.com/
.\" 
.\" =========================================================================
.\"
.\" Last Modified $Date: 2008-04-29 07:10:31 $ by $Author: brian $
.\"
.\" -------------------------------------------------------------------------
.\"
.\" $Log: streamio.7.man,v $
.\" Revision 0.9.2.6  2008-04-29 07:10:31  brian
.\" - updating headers for release
.\"
.\" Revision 0.9.2.5  2006/04/05 09:43:21  brian
.\" - moved .so line and updated headers
.\"
.\" =========================================================================
.R1
bracket-label "\fR[\fB" "\fR]" "\fR, \fB"
no-default-database
database strss7.refs
accumulate
move-punctuation
abbreviate A
join-authors ", " ", " " and "
et-al " et al" 2 3
abbreviate-label-ranges ".."
sort-adjacent-labels
.R2
.so strss7.macros
.\"
.\"
.TH STREAMIO 7 "@PACKAGE_DATE@" "@PACKAGE@-@VERSION@" "@PACKAGE_TITLE@ STREAMS I/O Controls"
.SH NAME
.B streamio
\- STREAMS ioctl commands 
.SH SYNOPSIS   
.PP
.B #include <sys/types.h>
.br
.B #include <stropts.h>
.HP
.BI "int " retval " = ioctl (int " fd ", int " command " , ... /* " arg " */);"
.SH DESCRIPTION
.PP
.PP
STREAMS I/O control commands are ioctl commands that are defined to operate on
all STREAMS character special devices.  All of these commands are interpreted
by the stream head.  Some commands are passed to the STREAMS module or driver.
.PP
STREAMS I/O control commands are invoked using the normal
.BR ioctl (2)
system call, but are defined only for STREAMS character special files.
.PP
.I fd
is an open file descriptor for a STREAMS character special file.
.PP
.I command
is the STREAMS I/O control function that the caller requests be performed.
.PP
.I arg
provides additional information required by the particular I/O
.IR command .
Specific
.IR command " and " arg
are described below.
.SH IOCTLS
.PP
.SS I_ATMARK
.PP
.PP
Checks whether the next messages on the stream head read queue is marked.
.I arg
is an integer value indicating which messages to check as follows:
.TP 12
.B ANYMARK
check whether the next message on the stream head read queue is marked.
.TP 12
.B LASTMARK
check whether the next message on the stream head read queue is the last
marked message (i.e. it is not followed by a another marked message).
.PP
Marked messages are messages that have the
.B MSGMARK
flag set in the message
.I b_flag
field.
.PP
Upon success,
.I I_ATMARK
returns (0) to indicate that the stream head read queue does not meet the
mark criteria, or (1) to indicate that it meets the mark criteria.
Upon failure,
.I I_ATMARK
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EINVAL ]
.I arg
is invalid.
.SS I_CANPUT
.PP
.PP
Checks whether messages can be written to the queue band specified by
.IR arg .
.I arg
is an integer which contains the queue band to test for flow control.
Upon success,
.I retval
is false (0) if the queue band
.I arg
is flow controlled,
true (1) if the queue band is not flow controlled.
Upon failure,
.I retval
is -1 and
.I errno
is set to one of the following errors numbers:
.TP 12
.RB [ EINVAL ]
integer
.I arg
is outside the range 0 to 255 and does not represent a valid priority band.
.SS I_CKBAND
.PP
.PP
Checks whether messages cna be read from the queue band specified by
.IR arg .
.I arg
is an integer which contains the queue band to test for an available message.
Upon success,
.B I_CKBAND
returns false (0) if there is no message for the specified queue band
.I arg
available, and true (1) if a message for the specified queue band
.I arg
is available to be read with
.BR read "(2) or " getmsg (2).
Upon failure,
.B I_CKBAND
returns -1 and
.I errno
is set to one of the following error numbers:
.TP 12
.RB [ EINVAL ]
.I arg
contains a priority band outside the range 0 - 255.
.TP 12
.RB [ EINVAL ]
the priority band does not exist.  (See
.IR "\*(lqBUGS\*(rq" ,
below.)
.SS I_FDINSERT
.PP
.PP
This command performs similar to
.BR putmsg (2),
however, it performs the additional function of inserting the read queue
pointer associated with a specified file descriptor in the resulting message.
This ioctl is often used to accepting incoming connections on
.BR tpi (7)
based protocols.
.PP
.I arg
is a pointer to a
.B strfdinsert
structure that is formatted as follows:
.sp
.nf
\fC\s-1\
struct strfdinsert {
    struct strbuf ctlbuf;
    struct strbuf databuf;
    ulong flags;
    int fildes;
    int offset;
};
\s+1\fR
.fi
.PP
.I ctlbuf
describes the control part of the message, and is formated the same as the
.B strbuf
structure pointed to by
.I ctlptr
as an argument to
.BR putmsg (2).
The
.I len
field of this
.B strbuf
structure must be large enough to accept the translated file descriptor.
Unlike
.BR putmsg (2)
this message must contain a control part.
.PP
.I databuf
describes the data part of the message, formatted the same as the
.B strbuf
structure pointed to by
.I datptr
as an argument to
.BR putmsg (2).
Unlike
.BR putmsg (2)
if the
.I len
field of this
.B strbuf
structure is zero, it indicates that no data part is to be sent with the
message.
(For
.BR putmsg (2),
a
.I len
field of zero (0) would indicate to send a zero-length data part message.)
.PP
.I flags
provides the options flags formatted the same as the
.I flags
argument to
.BR putmsg (2).
.PP
.I fildes
is the file descriptor of a stream to be translated to a read queue pointer and
placed into the control part of the message.
.PP
.I offset
is the offset into the control part to place the read queue pointer associated
with
.IR fildes .
This
.I offset
must leave sufficient room in the control part of the message to permit the
read queue pointer to be overwritten without exceeding the bounds of the
control part.
.PP
Upon succes,
.B I_FDINSERT
returns zero (0).
Upon failure,
.B I_FDINSERT
returns -1 and sets
.I errno
to one of the following error numbers:
.TP 12
.RB [ ENOSR ]
a buffer for the resulting message could not be allocated.
.TP 12
.RB [ EFAULT ]
.IR arg ", " ctlbuf ", " databuf ", " ctlbuf.buf " or " databuf.buf
points outside the caller's valid address space.
.TP 12
.RB [ EINVAL ]
.I fildes
is invalid, or
.I offset
is invalid, or
.I flags
is invalid.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.TP 12
.RB [ EINTR ]
interrupted by a signal.
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.TP 12
.RB [ ERANGE ]
The
.I len
of the data part of the message is outside the range
.I q_minpsz
to
.I q_maxpsz
inclusive for the topmost STREAMS module or driver under the stream head, or,
the
.I len
of the control or data part is larger than the maximum sized control or data
message for the STREAMS subsystem.
.TP 12
.RB [ EAGAIN ]
the stream head is set for asynchronous operation
.BR "" ( O_NONBLOCK " or " O_NDELAY
was set using
.BR open "(2) or " fcntl (2)),
the stream head was flow controlled and
.I flags
indicated a normal priority message.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.PP
In addition, any error received in an error message will be returned in
.IR errno .
.SS I_FIND
.PP
.PP
Checks whether the specified module is currently present in the stream
specified by
.IR fd .
.PP
.I arg
is a pointer to a string which provides the name of the module to find.
.PP
Upon success,
.B I_FIND
returns true (1) if the module is present in the stream under the name
.IR arg ,
and returns false (0) if the module is not present in the stream.
Upon failure,
.B I_FIND
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points to a string which exceeds the callers valid address space.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.TP 12
.RB [ EINVAL ]
.I arg
points to an invalid module name.
.TP 12
.RB [ ENOMEM ]
memory could not be allocated to
hold the string pointed to by
.IR arg .
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.TP 12
.RB [ ENAMETOOLONG ]
.I arg
contains a string that is greater than
.B (FMNAMESZ + 1)
in length.
.SS I_FLUSH
.PP
.PP
Flushes the stream.
.PP
.I arg
is an integer containing one of the following flags:
.TP 12
.B FLUSHR
flush the read queues.
.TP 12
.B FLUSHW
flush the write queues.
.TP 12
.B FLUSHRW
flush both the read and write queues.
.PP
Upon success,
.B I_FLUSH
returns zero (0).
Upon failure,
.B I_FLUSH
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ ENXIO ]
the stream head specified by
.I fd
is closing or has received a hangup.
.TP 12
.RB [ EINVAL ]
.I arg
contains invalid flags other than
.BR FLUSHR ", " FLUSHW " or " FLUSHRW .
.TP 12
.RB [ ENOMEM ]
the
.B M_FLUSH
message could not be allocated.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.PP
In addition,
.B I_FLUSH
can fail silently.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.SS I_FLUSHBAND
.PP
.PP
Flushes the stream for a specified band.
.I arg
is a
.B bandinfo
structure formatted as follows:
.sp
.nf
\fC\s-1\
struct bandinfo {
	unsigned char bi_pri;
	int bi_flag;
};
\fR\s+1
.fi
.PP
.I bi_pri
specifies the priority of the band to flush.
.PP
.I bi_flag
specifies which queues to flush and has one of the following values:
.TP 12
.B FLUSHR
flush the read queues.
.TP 12
.B FLUSHW
flush the write queues.
.TP 12
.B FLUSHRW
flush the read and write queues.
.PP
Upon success,
.B I_FLUSHBAND
returns zero (0).
Upon failure,
.B I_FLUSHBAND
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ ENXIO ]
the stream head specified by
.I fd
is closing or has received a hangup.
.TP 12
.RB [ EINVAL ]
.I bi_flag
contains invalid flags other than
.BR FLUSHR ", " FLUSHW " or " FLUSHRW .
.TP 12
.RB [ ENOMEM ]
the
.B M_FLUSH
message could not be allocated.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.PP
In addition,
.B I_FLUSHBAND
can fail silently.
(See
.IR "\*(lqBUGS\*(rq" ,
below.)
.SS I_GETBAND
.PP
.PP
Gets the priority band associated with the next message on the stream head read queue.
.I arg
is a pointer to an integer to receive the band number.
Upon success,
.B I_GETBAND
returns (0) and places the band associated with the next message on the stream
head read queue into the integer pointed to by
.IR arg .
Upon failure,
.B I_GETBAND
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.TP 12
.RB [ ENODATA ]
there is no message on the stream head read queue.
.SS I_GETCLTIME
.PP
.PP
Gets the close delay time (in milliseconds) associated with the stream head.
.I arg
points to a
.B long
(see
.IR "\*(lqBUGS\*(rq" ,
below)
to receive the delay.
.PP
Upon success,
.B I_GETCLTIME
returns zero (0) and the close delay time in the
.B long
pointed to by
.IR arg .
Upon failure,
.B I_GETCLTIME
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.SS I_GETSIG
.PP
.PP
Gets a bitmask of the events for which the calling process is registered
to be sent a
.B SIGPOLL
signal.
.I arg
points to an integer into which will be returned the bitmask.
The bitmask returned in the integer pointed to by
.I arg
will contain a bitwise OR of one or more of the following flags:
.TP 12
.B S_INPUT
any message but high priority on read queue.
.TP 12
.B S_HIPRI
high priority message on read queue.
.TP 12
.B S_OUTPUT
write queue is no longer full.
.TP 12
.B S_MSG
signal message at front of read queue.
.TP 12
.B S_ERROR
error message arrived at stream head.
.TP 12
.B S_HANGUP
hangup message arrived at stream head.
.TP 12
.B S_RDNORM
normal message on read queue
.TP 12
.B S_WRNORM
same as
.BR S_OUTPUT .
.TP 12
.B S_RDBAND
out of band message on read queue.
.TP 12
.B S_WRBAND
can write out of band message.
.TP 12
.B S_BANDURG
modifier to
.BR S_RDBAND ,
to generate
.B SIGURG
instead of
.BR SIGPOLL .
.TP 12
.B S_ALL
all flags.
.PP
Upon success,
.B I_GETSIG
returns (0) and the event bitmask in the integer pointed to by
.IR arg .
Upon failure,
.B I_GETSIG
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.TP 12
.RB [ EINVAL ]
the calling process is not registered to receive a
.B SIGPOLL
signal.
.SS I_GRDOPT
.PP
.PP
Gets the read options flags for the stream head.
.I arg
is a pointer to an integer to receive the stream head read options.
The integer pointed to by
.I arg
will return one flag from the following mode flags:
.TP 12
.B RNORM
byte-stream mode.  This is the default read mode.
.TP 12
.B RMSGD
message discard mode.
.TP 12
.B RMSGN
message non-discard mode.
.PP
bitwise OR'ed with one flag from the following protocol flags:
.TP 12
.B RPROTNORM
fail
.BR read (2)
with
.RB [ EBADMSG ]
if a message containing a control part is at the front of the stream head
read queue.
.TP 12
.B RPROTDAT
deliver control part of a message as data.
.TP 12
.B RPROTDIS
discard control part of message, delivering any data part.
.PP
Upon success,
.B I_GRDOPT
returns zero (0) and the read options flags in the integer pointed to by
.IR arg .
Upon failure,
.B I_GRDOPT
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.SS I_GWROPT
.PP
.PP
Gets the write options flags for the stream head.
.I arg
is a pointer to an integer to receive the stream head write options.  The
integer pointed to by
.I arg
will return zero or more flags from the following flags:
(These flags alter the operations of
.BR write "(2) and " putmsg (2)
on a STREAMS character special file.)
.TP 12
.B SNDZERO
send a zero-length message downstream when a write of zero bytes occurs.
.TP 12
.B SNDPIPE
send
.B SIGPIPE
on
.BR write (2)
and
.BR putmsg (2)
if the stream head has received a write error
.BR "" ( M_ERROR )
message.
.PP
Upon success,
.B I_GWROPT
returns zero (0) and the write options flags in the integer pointed to by
.IR arg .
Upon failure,
.B I_GWROPT
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
pointed outside the caller's valid address space.
.SS I_LINK
.PP
.PP
Links on stream under the multiplexing driver on stream
.IR fd .
.I arg
is the integer file descriptor of the stream to link under
.IR fd .
.PP
This call is passed as an
.B I_STR
ioctl using an
.B M_IOCTL
down the stream head write queue to be processed by the multiplexing driver on
.IR fd .
.B I_LINK
will block until an acknowledgment is received from the driver, the call
times out waiting for an acknowledgement, the call is interrupted while
blocked by a signal, or the receipt of hangup or error message.
.PP
Upon success,
.B I_LINK
returns a positive integer representing the multiplex identifier of the lower
stream.  This value can be subsequently used in a
.B I_UNLINK
command.
Upon failure,
.B I_LINK
returns -1 and sets
.I errno
to an appropriate error number as follows:
.PP
.TP 12
.RB [ EBADF ]
.I arg
is not a valid open file descriptor.
.TP 12
.RB [ ETIME ]
the command timed out before receiving an acknowledgment.
.TP 12
.RB [ ENOSR ]
a buffer for the ioctl message could not be allocated.
.TP 12
.RB [ EINVAL ]
.I fd
received an error message.
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
.TP 12
.RB [ EINVAL ]
.I fd
has no lower multiplexing driver definition.
.TP 12
.RB [ EINVAL ]
.I arg
is already linked under a multiplexor or is not a STREAMS character special
file.
.PP
In addition, any error received in an error message will be returned in
.IR errno .
Also, any error returned by the module or driver in an ioctl positive or
negative acknowledgement message will also be returned in
.IR errno .
.SS I_LIST
.PP
.PP
List all of the modules pushed on the stream specified by
.IR fd .
.I arg
is a pointer to a
.B str_list
structure to place the module names as follows:
.sp
.nf
\fC\s-1\
struct str_list {
    int sl_nmods;
    struct str_mlist *sl_modlist;
};
\fR\s+1
.fi
.PP
.I sl_nmods
indicates the number of
.B str_mlist
structures the array pointed to by
.IR sl_modlist .
.I sl_modlist
points to a list of
.B str_mlist
structures formatted as follows:
.sp
.nf
\fC\s-1\
struct str_mlist {
    char l_name[FMNAMESZ + 1];
};
\fR\s+1
.fi
.PP
If
.I arg
is
.BR NULL ,
.B I_LIST
will return a positive integer
.I retval
indicating the number of modules, including the driver, on stream
.IR fd .
This can be used to determine the number of module and driver names before
passing the
.B str_list
structure.
.PP
.B I_LIST
only lists
.I sl_nmods
number of modules and drivers starting with the module below the stream head.
If there is an insuffient number of members in the
.I sl_modlist
array to hold all of the names,
.B I_LIST
will success, but will return only the number of names in the space provided.
.PP
Upon success,
.B I_LIST
returns zero (0) and the module and driver names in the passed in
.B str_list " and " str_mlist
structures, or, when
.I arg
is
.BR NULL ,
returns a positive integer indicating the number of modules plus the driver on
the stream
.IR fd.
Upon failure,
.B I_LIST
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.IR arg " or " str_mlist
points outside the caller's valid address space.
.TP 12
.RB [ EINVAL ]
.I sl_nmods
is less than 1, or,
.I str_mlist
is
.BR NULL .
.PP
See
.IR "\*(lqBUGS\*(rq" ,
below.
.SS I_LOOK
.PP
.PP
Gets the name of the first module beneath the stream head.
.I arg
is a pointer to a character string buffer to accept the name.
This buffer must be at least
.B (FNAMESZ + 1)
in length.
.PP
Upon success,
.B I_LOOK
copies the name of the module beneath the stream head to tbe buffer pointed to
by
.IR arg .
Upon failure,
.B I_LOOK
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
pointed outside the caller's valid address space.
.TP 12
.RB [ EINVAL ]
there is no module beneath the stream head.
.SS I_NREAD
.PP
.PP
Gets the number of unread data bytes contained in
.B M_DATA
message blocks in the first messsage on the stream head read queue.
.I arg
points to an integer to contain the number of unread bytes.
.PP
Upon success,
.B I_NREAD
returns zero (0) or a positive integer indicating the number of messages on
the stream head read queue.
Upon failure,
.B I_NREAD
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.HP 12
.B Note:
.B LiS
.[
LiS
.]
uses
.BR qsize "(9) and " msgdsize (9)
to provide this command.
.SS I_PEEK
.PP
.PP
Peeks at the next message on the stream head read queue without removing the
message from the queue.
.I arg
is a pointer to a
.B strpeek
structure formatted as follows:
.sp
.nf
\fC\s-1\
struct strpeek {
    struct strbuf ctlbuf;
    struct strbuf databuf;
    long flags;
};
\fR\s+1
.fi
.PP
.I ctlbuf
describes the control part of the message, and is formatted the same as the
.B strbuf
structure pointed to by
.I ctlptr
as an argument to
.BR getmsg (2).
If there is no control part,
the
.I maxlen
field of this
.B strbuf
should be zero (0).
.I databuf
describes the data part of the message, and is formatted the same as the
.B strbuf
structure pointed to by
.I datptr
as an argument to
.BR getmsg (2).
If there is no data part,
the
.I maxlen
field of this
.B strbuf
should be zero (0).
.PP
.I flags
provides the read flags and is formatted the same as the
.I flags
argument to
.BR getmsg (2).
.PP
Upon success,
.B I_PEEK
returns zero (0)
if there was no message on the stream head read queue, and returns one (1)
and the retrieved message in the structure pointed to by
.IR arg ,
if there was a message on the stream head read queue.
Upon failure,
.B I_PEEK
returns -1 and sets
.I errno
to an appropriate error message as follows:
.TP 12
.RB [ EFAULT ]
.IR arg ", " ctlbuf.buf " or " databuf.buf
point outside the caller's valid address space.
.PP
In addition,
.B I_PEEK
can return any
.I errno
returned by
.BR getmsg (2).
See
.BR getmsg (2).
.SS I_PLINK
.PP
.PP
Links on stream under the multiplexing driver on stream
.IR fd .
.I arg
is the integer file descriptor of the stream to link under
.IR fd .
.PP
This call is passed as an
.B I_STR
ioctl using an
.B M_IOCTL
down the stream head write queue to be processed by the multiplexing driver on
.IR fd .
.B I_PLINK
will block until an acknowledgment is received from the driver, the call
times out waiting for an acknowledgement, the call is interrupted while
blocked by a signal, or the receipt of hangup or error message.
.PP
Upon success,
.B I_PLINK
returns a positive integer representing the multiplex identifier of the lower
stream.  This value can be subsequently used in a
.B I_PUNLINK
command.
Upon failure,
.B I_PLINK
returns -1 and sets
.I errno
to an appropriate error number as follows:
.PP
.TP 12
.RB [ EBADF ]
.I arg
is not a valid open file descriptor.
.TP 12
.RB [ ETIME ]
the command timed out before receiving an acknowledgment.
.TP 12
.RB [ ENOSR ]
a buffer for the ioctl message could not be allocated.
.TP 12
.RB [ EINVAL ]
.I fd
received an error message.
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
.TP 12
.RB [ EINVAL ]
.I fd
has no lower multiplexing driver definition.
.TP 12
.RB [ EINVAL ]
.I arg
is already linked under a multiplexor or is not a STREAMS character special
file.
.PP
In addition, any error received in an error message will be returned in
.IR errno .
Also, any error returned by the module or driver in an ioctl positive or
negative acknowledgement message will also be returned in
.IR errno .
.PP
.SS I_POP
.PP
.PP
Pops the STREAMS module just beneath the stream head from
.IR fd .
.I arg
is ignored.
.PP
Upon success,
.B I_POP
pops the moudule beneath the stream head by calling
.BR qdetach (9)
and
returns (0).
Upon failure,
.B I_POP
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
.TP 12
.RB [ EINVAL ]
there was no module beneath the stream head.
.PP
See
.BR qdetach (9)
for more information.
.SS I_PUNLINK
.PP
.PP
Unlink a stream from under a multiplexing driver that was previously linked
with
.BR I_PLINK .
.I arg
is the multiplexor identifier of the linked stream, or,
.B MUXID_ALL
indicating that all linked streams are requested to be unlinked.
.PP
This call is passed as an
.B I_STR
ioctl using an
.B M_IOCTL
down the stream head write queue to be processed by the multiplexing driver on
.IR fd .
.B I_PUNLINK
will block until an acknowledgement is received from the driver, the call
times out waiting for an acknowledgement, the call is interrupted while
blocked by a signal, or the receipt of hangup or error message.
.PP
Upon success,
.B I_PUNLINK
returns zero (0) and unlinks the specified stream(s).
Upon failure,
.B I_PUNLINK
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
.TP 12
.RB [ EINVAL ]
.I arg
is invalid.
.TP 12
.RB [ ETIME ]
the call timed out waiting for a response from the driver.
.TP 12
.RB [ EINTR ]
the call was interrupted by a signal.
.TP 12
.RB [ ENOSR "], [" EAGAIN ]
could not allocate the buffer for the ioctl message.
.PP
In addition, any error received in a error message will be returned
in
.IR errno .
Also, any error returned by the module or driver in a ioctl positive or
negative acknowledgement message will also be returned in
.SS I_PUSH
.PP
.PP
Pushes a STREAMS module by name on the stream specified by
.IR fd .
.I arg
is a pointer to a string that contains the name of the module to push.
.PP
Upon success,
.B I_PUSH
pushes the named module and returns zero (0).
Upon failure,
.B I_PUSH
returns -1 and sets
.T errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.TP 12
.RB [ EXNXIO ]
the stream specified by
.I fd
has received a hangup or is closing.
.TP 12
.RB [ EINVAL ]
the module name pointed to by
.I arg
is invalid.
.TP 12
.RB [ ENOSR ]
.I fd
has reached its maximum push count.  No more modules can be pushed on the
stream.
.TP 12
.RB [ ENOMEM ]
memory allocation for the queue pair for the pushed module failed.
.TP 12
.RB [ ENOPKG ]
the module has no qopen routine.
.PP
In addition, any error returned by the module's
.BR qopen (9)
function may be returned by
.BR I_PUSH .
See
.BR qattach (9)
and
.BR qopen (9)
for more information.
.SS I_RECVFD
.PP
.PP
.I arg
is a pointer to a
.B strrecvfd
structure formatted as follows:
.sp
.nf
\fC\s-1\
struct strrecvfd {
    int fd;
    uid_t uid;
    gid_t gid;
    ...
};
\fR\s+1
.fi
.PP
In the
.B strrecfd
structure,
.I fd
is the filedescriptor received, and
.IR uid " and " gid
are the credentials associated with the file descriptor.
.PP
Upon success,
.B I_RECVFD
returns zero (0) and the completed
.B strrecvfd
structure.
Upon failure,
.B I_RECVFD
returns -1 and sets
.I errno
to an appropriate error number as follows:
.PP
.TP 12
.RB [ EFAULT ]
.I arg
points outside the caller's valid address space.
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup message or is closing.
.TP 12
.RB [ EBADF ]
.I fd
is not a stream.
.TP 12
.RB [ EAGAIN ]
no file descriptor message
.BR "" ( M_PASSFP )
is waiting.
.TP 12
.RB [ ENFILE ]
no remaining file descriptors could be allocated for the receiving process.
.TP 12
.RB [ EBADMSG ]
the message on the top of the stream head read queue is not a passed file
descriptor
.BR "" ( M_PASSFD )
message.
.SS I_SENDFD
.PP
.PP
Sends a file descriptor to the other end of a pipe.
.I arg
is the integer file descriptor to send.
.PP
Upon success,
.B I_SENDFD
returns (0).
Upon failure,
.B I_SENDFD
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EBADF ]
.I arg
is not a valid file descriptor.
.TP 12
.RB [ EPIPE ]
.TP 12
.RB [ ENOSR ]
a buffer could not be allocated to send the file descriptor.
.TP 12
.RB [ ENOMEM ]
a file descriptor could not be allocated for the receiving end.
.SS I_SETCLTIME
.PP
.PP
Sets the closing delay time for the stream head.
.I arg
is a
.B long
value which specifies the delay time in milliseconds.
.PP
Upon success,
.B I_SETTLTIME
returns zero (0) and sets the close delay time for
.BR fd .
Upon failure,
.B I_SETTLTIME
returns -1 and sets
.T errno
to an appropriate error number as follows:
.TP 12
.RB [ EINVAL ]
.I arg
is outside the valid range 0 to 300,000 milliseconds.
.SS I_SETSIG
.PP
.PP
Sets the mask of events for which the stream head will send the calling
process a
.B SIGPOLL
or
.B SIGURG
signal.
.I arg
is an integer value containins one or more of the following event flags:
.TP 12
.B S_INPUT
any message but high priority on read queue.
.TP 12
.B S_HIPRI
high priority message on read queue.
.TP 12
.B S_OUTPUT
write queue is no longer full.
.TP 12
.B S_MSG
signal message at front of read queue.
.TP 12
.B S_ERROR
error message arrived at stream head.
.TP 12
.B S_HANGUP
hangup message arrived at stream head.
.TP 12
.B S_RDNORM
normal message on read queue
.TP 12
.B S_WRNORM
same as
.BR S_OUTPUT .
.TP 12
.B S_RDBAND
out of band message on read queue.
.TP 12
.B S_WRBAND
can write out of band message.
.TP 12
.B S_BANDURG
modifier to
.BR S_RDBAND ,
to generate
.B SIGURG
instead of
.BR SIGPOLL .
.TP 12
.B S_ALL
all flags.
.SS I_SRDOPT
.PP
.PP
Sets the
.BR read (2)
options flags for the stream head.
These flags alter the behavior of the
.BR read (2)
call when called for
.IR fd .
.I arg
is an integer value containing the read options flags which may be one flag
from the mode group as follows:
.TP 12
.B RNORM
byte-stream mode.  This is the default read mode.
.TP 12
.B RMSGD
message discard mode.
.TP 12
.B RMSGN
message non-discard mode.
.PP
bitwise OR'ed with one flag from the protocol group as follows:
.TP 12
.B RPROTNORM
fail
.BR read (2)
with
.RB [ EBADMSG ]
if a message containing a control part is at the front of the stream head
read queue.
.TP 12
.B RPROTDAT
deliver control part of a message as data.
.TP 12
.B RPROTDIS
discard control part of message, delivering any data part.
.SS I_STR
.PP
.PP
Generates an internal STREAMS ioctl message and places it on the stream head's
write queue for processing by the module or driver and returns the response.
.I arg
is a pointer to a
.B strioctl
structure formatted as follows:
.sp
.nf
\fC\s-1\
struct strioctl {
    int ic_cmd;
    int ic_timout;
    int ic_len;
    char *ic_dp;
};
\s+1\fR
.fi
.PP
.I ic_cmd
is the command to issue.  The command can by any of the commands listed here
that are handled by the module or driver (e.g.
.BR I_LINK )
or any other ioctl command understood by a module or driver on the stream
.IR fd .
.I ic_timout
is the period of time to wait for an acknowledgement in milliseconds, or
-1 indicating that there is no timeout.
.I ic_len
is the length of the argument data pointed to by
.IR ic_dp .
.I ic_dp
is a pointer to the argument data of length
.I ic_len
bytes.
.PP
.B I_STR
generates an
.B M_IOCTL
message an passes it downstream to the module or driver and blocks until a
positive or negative acknowledgement is received, the command times out, an
hangup or error message is received by the stream head, or a signal is
received.
.PP
Upon success,
.B I_STR
returns the return value sepcified in the positive or negative acknowledgement
message.
Upon failure,
.B I_STR
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ EFAULT ]
.IR arg " or " ic_dp
point outside the caller's valid address space.
.TP 12
.RB [ EINVAL ]
.I ic_len
is less than 0.
.TP 12
.RB [ EINVAL ]
.I ic_len
is greater than the maximum size of the data part of a message.
.TP 12
.RB [ EINVAL ]
.I ic_timout
is less than -1.
.TP 12
.RB [ ETIME "], [" EAGAIN ]
the operation timed out waiting for an acknowledgement.
.TP 12
.RB [ EINTR ]
the oepration was interrupted by a signal.
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
.TP 12
.RB [ ENOSR ]
a buffer for the ioctl message could not be allocated.
.PP
In addition,
.B I_STR
can return any
.I errno
placed in an error message received by the stream head, or
placed in the positive or negative acknowledgement message by the module or
driver.
.SS I_SWROPT
.PP
.PP
Sets the
.BR write (2)
options flags for the strem head.
These flags alter the behavior of the
.BR write "(2) and " putmsg (2)
calls when called for
.IR fd .
.I arg
is an integer value containing the write options flags which may be one or
more flags from the following:
.TP 12
.B SNDZERO
send a zero-length message downstream when a write of zero bytes occurs.
.TP 12
.B SNDPIPE
send
.B SIGPIPE
on
.BR write (2)
and
.BR putmsg (2)
if the stream head has received a write error
.BR "" ( M_ERROR )
message.
.SS I_UNLINK
.PP
.PP
Unlink a stream from under a multiplexing driver that was previously linked
with
.BR I_LINK .
.I arg
is the multiplexor identifier of the linked stream, or,
.B MUXID_ALL
indicating that all linked streams are requested to be unlinked.
.PP
This call is passed as an
.B I_STR
ioctl using an
.B M_IOCTL
down the stream head write queue to be processed by the multiplexing driver on
.IR fd .
.B I_UNLINK
will block until an acknowledgement is received from the driver, the call
times out waiting for an acknowledgement, the call is interrupted while
blocked by a signal, or the receipt of hangup or error message.
.PP
Upon success,
.B I_UNLINK
returns zero (0) and unlinks the specified stream(s).
Upon failure,
.B I_UNLINK
returns -1 and sets
.I errno
to an appropriate error number as follows:
.TP 12
.RB [ ENXIO ]
.I fd
received a hangup or is closing.
.TP 12
.RB [ EINVAL ]
.I arg
is invalid, or
.I fd
is a pipe or FIFO.
.TP 12
.RB [ ETIME ]
the call timed out waiting for a response from the driver.
.TP 12
.RB [ EINTR ]
the call was interrupted by a signal.
.TP 12
.RB [ ENOSR "], [" EAGAIN ]
could not allocate the buffer for the ioctl message.
.PP
In addition, any error received in a error message will be returned
in
.IR errno .
Also, any error returned by the module or driver in a ioctl positive or
negative acknowledgement message will also be returned in
.IR errno .
.SH "RETURN VALUE"
.PP
.PP
Upon success,
.B ioctl()
returns zero (0) or a positive integer.
Upon failure,
.B ioctl()
returns -1 and sets
.I errno
to an appropriate error number.
.SH ERRORS
.PP
.PP
When
.B ioctl()
fails, it returns -1 and sets
.I errno
to one of the following errors:
.TP 12
.RB [ ENXIO ]
.I fd
has received a hangup or is closing.
.TP 12
.RB [ EFAULT ]
.I arg
or a member of
.IR arg ,
points to an address that is outside the caller's valid address space.
.TP 12
.RB [ EINVAL ]
.IR fd ", " command ", " arg " or a member of " arg
is invalid.
.TP 12
.RB [ ENOSR ]
a buffer could not be allocated for the call.
.TP 12
.RB [ ETIME "], [" EAGAIN ]
timed out waiting for an acknowledgment.
.TP 12
.RB [ EINTR ]
interrupted by a signal.
.PP
In addition, any error delivered to the stream head in an error message can be
returned in
.IR errno .
Where the command is passed to the module or driver, or the command results in
the call to a module or driver open or close procedures, or link or unlink
procedures, the error number returned by the module or driver can be returned
in
.IR errno .
.SH CAVEATS
.PP
.PP
STREAMS
.B ioctl()
calls are complex and there is much conflicting documentation in specific
areas of behavior.  Not all bugs are bugs and not all features are features.
.SH BUGS
.PP
.SS I_ATMARK
.PP
.PP
.B LiS
fails silently (returns success) if there is no queue associated with the
stream head.
.SS I_CANPUT
.PP
.PP
.B LiS
uses
.BR bcanput (9)
to test for flow control once
.I arg
is validated.
.BR bcanput (9)
has the problem that it will return false (0) when an internal error occurs.
See the
.BR bcanput (9)
man page for more information.
.SS I_CKBAND
.PP
.B LiS
uses
.BR strqget (9)
to get the
.B QCOUNT
associated with the band specified by
.IR arg .
.BR strqget (9)
returns
.RB [ EINVAL ]
when the specified priority band does not exist.  Therefore,
.B I_CKBAND
will return
.RB [ EINVAL ]
when it should return false (0) indicating that there is no message for the
band.  See
.B QCOUNT
description in the
.BR strqget (9)
man page for more information.
.SS I_FDINSERT
.PP
.PP
.B LiS
incorrectly returns
.RB [ ENODEV ]
instead of
.RB [ ENXIO ]
when
.I fd
is linked under a multiplexor.
.PP
.B LiS
incorrectly returns
.RB [ EAGAIN ]
when
.B RS_HIPRI
is set in
.IR flags ,
and the stream is flow controlled.
It should deliver the message in this case.
.PP
.B LiS
incorrectly returns
.RB [ EINVAL ]
when
.I fd
or
.I fildes
has received an error message.  It should return the write error of the error
message in the case of
.IR fd .
.PP
.B LiS
incorrectly returns
.RB [ ENOSR ]
instead of
.RB [ ENODEV ]
when there is no queue under the stream head.
.PP
.B LiS
incorrectly returns
.RB [ ENOSTR ]
instead of
.RB [ EINVAL ]
when
.I fildes
is not a STREAMS character special file.
.PP
.B LiS
incorrectly returns
.RB [ ENODEV ]
instead of
.RB [ ENXIO ]
when a hangup was received on
.I fd
or
.I fd
is closing.
.PP
.B LiS
does not check whether
.I fildes
has received a hangup or is closing.  It should return return
.RB [ ENXIO ]
in that case.
.SS I_FIND
.PP
.PP
.B LiS
verifies read on
.I arg
for a string sized
.BR "(FNNAMESZ + 1)" .
If the name string pointed to by
.I arg
is shorter than
.B FNAMESZ
and terminates on a page boundary,
.B I_FIND
will fail with error number
.RB [ EFAULT ]
even though the provided module name is valid and resides completely within
the caller's address space.  A workaround for this is for the caller to
always allocate
.B (FNAMESZ + 1)
sized buffers to hold the module name.  There is no excuse for this bug as
.B Linux
provides one byte look-ahead verify on the kernel function
.BR strncpy_from_user ()
which is in fact called by
.B LiS
when processing
.BR I_FIND .
.PP
.B LiS
allocates memory to hold the passed in string.  The maximum size of this
string is 8 or 16 bytes.  This is not too much to place on the stack.
.B LiS
should not allocate memory for this and should never return
.RB [ ENOMEM ]
in response to
.BR I_FIND .
.SS I_FLUSH
.PP
.PP
.B LiS
incorrectly returns
.RB [ ENOMEM ]
when it cannot allocate a message block for
the
.B M_FLUSH
message.  The correct error number is
.RB [ ENOSR ].
.PP
.B LiS
uses
.BR putnext (9)
internally to send the
.B M_FLUSH
message.
.BR putnext (9)
can fail silently
under a number of conditions detailed in the
.BR putnext (9)
man page.  One of
those conditions is that
.BR qprocsoff (9)
has been called on the stream.
.SS I_FLUSHBAND
.PP
.PP
Rather than returning
.RB [ EINVAL "], " LiS
masks
.I bi_flag
with
.B FLUSHRW
to force validity.  This is a bug.   For example,
.B I_FLUSHBAND
can be called with
.I bi_flag
=
.B 0xffffffff
and
.B LiS
would threat this as
.BR FLUSHRW .
.PP
Rather than returning
.RB [ EINVAL "], " LiS
masks
.I bi_pri
with
.B 0xff
to force validity.  This is a bug.  For example,
.B I_FLUSHBAND
can be called with
.I bi_pri
=
.B 257
and
.B LiS
would flush band
.BR 1 .
.PP
.B LiS
incorrectly returns
.RB [ ENOMEM ]
when it cannot allocate a message block for the
.B M_FLUSH
message.   The correct error number is
.RB [ ENOSR ].
.PP
.B LiS
usesc 
.BR putnext (9)
to send the
.B M_FLUSH
message.
.BR putnext (9)
can fail silently under a number of con- ditions detailed in the
.BR putnext (9)
man page.  One of those conditions is that
.BR qprocsoff (9)
has been called on the stream.
.SS I_GETCLTIME
.PP
.PP
UN*X documentation shows that
.I arg
is a pointer to a
.BR long .
In
.B LiS
.I arg
is a pointer to an
.BR int .
This has an impact on architectures where a
.B long
is not the same as an
.BR int .
.SS I_RECVFD
.PP
.PP
.B LiS
does not block waiting for a passed file descriptor message to appear on the
stream head read queue if the stream indicated by
.I fd
is set for blocking operation.  It should.
.PP
.B LiS
will return
.RB [ EAGAIN ]
where it should return
.RB [ EBADMSG ].
.PP
.B LiS
does not check for hangup on the pipe.
.SS I_SETCLTIME
.PP
.PP
UN*X documentation shows that
.I arg
is a pointer to a
.BR long .
In
.B LiS
.I arg
is a pointer to an
.BR int .
This has an impact on architectures where a
.B long
is not the same as an
.BR int .
.SS I_LINK
.PP
.PP
.B LiS
returns
.RB [ ENOMEM ]
instead of
.RB [ ENOSR "] or [" EAGAIN ]
when it cannot allocate a buffer for the call.
.SS I_LIST
.PP
.PP
.B LiS I_LIST
fails silently (returns zero (0)) if there is no queue associated
with the stream head.
.SS I_LOOK
.PP
.PP
.B LiS
verifies write on
.I arg
for a string sized
.BR (FNAMESZ + 1) .
If the name string of the module under the stream head is shorter than
.B (FNAMESZ + 1)
and
.I arg
terminates on a page boundary,
.B I_LOOK
will return with error number
.RB [ EFAULT ]
even though the provided buffer is valid and resides as far as is necessary
completely within the caller's address space.  A workaround for this is for
the caller to always allocate
.B (FNAMESZ + 1)
sized buffers to hold the module name.  There is no excuse for this bug as
.B Linux
provides one byte look-ahead verify on the kernel function
.BR strncpy_to_user ()
which is in fact called by
.B LiS
when processing
.BR I_LOOK .
.SS I_PLINK
.PP
.PP
.B LiS
returns
.RB [ ENOMEM ]
instead of
.RB [ ENOSR "] or [" EAGAIN ]
when it cannot allocate a buffer for the call.
.SS I_PUNLINK
.PP
.PP
.B LiS
returns
.RB [ ENOMEM "] instead of [" ENOSR "] or [" EAGAIN ]
when it cannot allocate a buffer for the call.
.SS I_UNLINK
.PP
.PP
.B LiS
returns
.RB [ ENOMEM "] instead of [" ENOSR "] or [" EAGAIN ]
when it cannot allocate a buffer for the call.
.SH "SEE ALSO"
.PP
.BR close (2),
.BR fcntl (2),
.BR getmsg (2),
.BR ioctl (2),
.BR open (2),
.BR open (2s),
.BR poll (2),
.BR putmsg (2),
.BR read (2),
.BR signal (2),
.BR signal (2),
.BR write (2),
.BR qopen (9),
.BR qclose (9),
.BR qattach (9),
.BR qdetach (9).
.SH VERSIONS
.PP
.PP
This manpage was written for
.B LiS\c
.
.[
LiS
.]
.PP
.B ioctl()
for STREAMS first appeared in SVR 3.0.
.[
svr3
.]
.[
$LIST$
.]
.TI
