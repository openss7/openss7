% -*- texinfo -*- vim: ft=texinfo
% vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
% =========================================================================
%
% @(#) $Id: sdti.texi,v 0.9.2.8 2008-08-03 06:03:32 brian Exp $
%
% =========================================================================
%
% Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
%
% All Rights Reserved.
%
% Permission is granted to make and distribute verbatim copies of this
% manual provided the copyright notice and this permission notice are
% preserved on all copies.
%
% Permission is granted to copy and distribute modified versions of this
% manual under the conditions for verbatim copying, provided that the
% entire resulting derived work is distributed under the terms of a
% permission notice identical to this one.
% 
% Since the Linux kernel and libraries are constantly changing, this
% manual page may be incorrect or out-of-date.  The author(s) assume no
% responsibility for errors or omissions, or for damages resulting from
% the use of the information contained herein.  The author(s) may not
% have taken the same level of care in the production of this manual,
% which is licensed free of charge, as they might when working
% professionally.
% 
% Formatted or processed versions of this manual, if unaccompanied by
% the source, must acknowledge the copyright and authors of this work.
%
% -------------------------------------------------------------------------
%
% U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software
% on behalf of the U.S. Government ("Government"), the following
% provisions apply to you.  If the Software is supplied by the Department
% of Defense ("DoD"), it is classified as "Commercial Computer Software"
% under paragraph 252.227-7014 of the DoD Supplement to the Federal
% Acquisition Regulations ("DFARS") (or any successor regulations) and the
% Government is acquiring only the license rights granted herein (the
% license rights customarily provided to non-Government users).  If the
% Software is supplied to any unit or agency of the Government other than
% DoD, it is classified as "Restricted Computer Software" and the
% Government's rights in the Software are defined in paragraph 52.227-19
% of the Federal Acquisition Regulations ("FAR") (or any successor
% regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the
% NASA Supplement to the FAR (or any successor regulations).
%
% =========================================================================
% 
% Commercial licensing and support of this software is available from
% OpenSS7 Corporation at a fee.  See http://www.openss7.com/
% 
% =========================================================================
%
% Last Modified $Date: 2008-08-03 06:03:32 $ by $Author: brian $
%
% =========================================================================
\input texinfo @c -*- texinfo -*-
@c vim: ft=texinfo nosmartindent nocindent noautoindent tw=100
@c %**start of header
@setfilename sdti.info
@include texi/args.texi
@set MANUAL_TITLE Signalling Data Terminal Interface (SDTI)
@set MANUAL_TYPE Specification
@settitle @value{MANUAL_TITLE}
@c %**end of header

@dircategory OpenSS7
@direntry
* SDTI: (sdti).			Signalling Data Terminal Interface
@end direntry

@include texi/args.texi
@set MANUAL_TITLE Signalling Data Terminal Interface (SDTI)
@set MANUAL_TYPE Specification

@comment The following copyright information goes at the head of each .info file.
@ifinfo
This file documents the OpenSS7 @value{MANUAL_TITLE}.

This is Edition @value{PACKAGE_VERSION}, last updated @value{PACKAGE_DATE}, for
@value{PACKAGE_TITLE} version @value{PACKAGE_VERSION} release @value{PACKAGE_RELEASE} published by
@uref{http://www.openss7.com/,OpenSS7 Corporation}.


Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}


All Rights Reserved.

Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of OpenSS7 Corporation not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  OpenSS7 Corporation makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@ignore
Permission is granted to process this file through Tex and print the results, provided the printed
document carries copying permission notice identical to this one except for the removal of this
paragraph (this paragraph not being relevant to the printed manual).

@end ignore
OpenSS7 Corporation disclaims all warranties with regard to this documentation including all implied
warranties of merchantability, fitness for a particular purpose, non-infringement, or title; that
the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights..  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.

OpenSS7 Corporation reserves the right to revise this software and documentation for any reason,
including but not limited to, conformity with standards promulgated by various agencies, utilization
of advances in the state of the technical arts, or the reflection of changes in the design of any
techniques, or procedures embodied, described, or referred to herein.  OpenSS7 Corporation is under
no obligation to provide any feature listed herein.
@end ifinfo

@include texi/args.texi
@set MANUAL_TITLE Signalling Data Terminal Interface (SDTI)
@set MANUAL_TYPE Specification

@shorttitlepage @value{MANUAL_TITLE} @value{MANUAL_TYPE}
@titlepage
@titlefont{@value{MANUAL_TITLE}}
@sp 0.5
@title @value{MANUAL_TYPE}
@subtitle Version @value{PACKAGE_VERSION} Edition @value{PACKAGE_RELEASE}
@subtitle Updated @value{PACKAGE_DATE}
@sp 0.2
@subtitle Distributed with Package @value{PACKAGE}-@value{VERSION}
@sp 2
@subtitle Copyright @copyright{} 2008  OpenSS7 Corporation
@subtitle All Rights Reserved.
@sp 4
@quotation
@subheading Abstract
This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.  It provides abstraction of the
signalling data terminal interface to these components as well as providing a basis for signalling
data terminal control for other signalling data terminal protocols.
@end quotation
@author Brian Bidulock <@email{bidulock@@openss7.org}> for
@sp 0.2
@author The OpenSS7 Project <@uref{http://www.openss7.org/}>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2001-2008  @uref{http://www.openss7.com/, OpenSS7 Corporation} @*
Copyright @copyright{} 1997-2000  @email{bidulock@@openss7.org, Brian F. G. Bidulock}

@noindent
All Rights Reserved.

@subsubheading Published by:
@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} @*
1469 Jefferys Crescent @*
Edmonton, Alberta  T6L 6T1 @*
Canada @*

@noindent
Unauthorized distribution or duplication is prohibited.

@sp 1

@ignore
@noindent
This software and related documentation is protected by copyright and distributed under licenses
restricting its use, copying, distribution and decompilation.  No part of this software or related
documentation may be reproduced in any form by any means without the prior written authorization of
the copyright holder, and licensors, if any.

@noindent
The recipient of this document, by its retention and use, warrants that the recipient will protect
this information and keep it confidential, and will not disclose the information contained in this
document without the written permission of its owner.

@noindent
OpenSS7 Corporation reserves the right to revise this software and documentation for any reason,
including but not limited to, conformity with standards promulgated by various agencies, utilization
of advances in the state of the technical arts, or the reflection of changes in the design of any
techniques, or procedures embodied, described, or referred to herein.  OpenSS7 Corporation is under
no obligation to provide any feature listed herein.
@end ignore

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of OpenSS7 Corporation not be used in
advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  OpenSS7 Corporation makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@subsubheading Notice:

@noindent
@b{OpenSS7 Corporation disclaims all warranties with regard to this documentation including all
implied warranties of merchantability, fitness for a particular purpose, non-infringement, or title;
that the contents of the document are suitable for any purpose, or that the implementation of such
contents will not infringe on any third party patents, copyrights, trademarks or other rights..  In
no event shall OpenSS7 Corporation be liable for any direct, indirect, special or consequential
damages or any damages whatsoever resulting from loss of use, data or profits, whether in an action
of contract, negligence or other tortious action, arising out of or in connection with any use of
this document or the performance or implementation of the contents thereof.}

@sp 1

@noindent
OpenSS7 Corporation reserves the right to revise this software and documentation for any reason,
including but not limited to, conformity with standards promulgated by various agencies, utilization
of advances in the state of the technical arts, or the reflection of changes in the design of any
techniques, or procedures embodied, described, or referred to herein.  OpenSS7 Corporation is under
no obligation to provide any feature listed herein.

@vskip 0pt
@end titlepage
@iftex
@headings off
@everyheading @thistitle @| @thisfile @| @thischaptername
@evenheading @thischapter @| @| @thisfile
@oddheading @thistitle @| @| @thischaptername
@everyfooting Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE} @| @value{PACKAGE_DATE} @| @thispage
@evenfooting @thispage @| @| Version @value{PACKAGE_VERSION} Rel. @value{PACKAGE_RELEASE}
@oddfooting @value{PACKAGE_DATE} @| @| @thispage
@end iftex
@page

@c Define an index of primitives
@defcodeindex pr
@c Define an index of primitive values
@defcodeindex pv
@c Define an index of primitive error values
@defcodeindex pe
@c Define an index of protocol states
@defcodeindex st
@c Define an index of input-output controls
@defcodeindex ct
@c Define an index of manual pages.
@defcodeindex mp

@c frags out automake
@c @ifnottex
@c @c concatenate indices for text, html and info
@syncodeindex pr cp
@syncodeindex pv cp
@syncodeindex pe cp
@syncodeindex st cp
@syncodeindex mp cp
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex ct cp
@c @end ifnottex

@include texi/macros.texi
@include texi/versions.texi

@iftex

@macro prim{name}
@code{\name\}@prindex \name\
@end macro

@macro pval{name}
@code{\name\}@pvindex \name\
@end macro

@macro perr{name}
@code{\name\}@peindex \name\
@end macro

@macro psta{name}
@code{\name\}@stindex \name\
@end macro

@macro parm{name}
@code{\name\}@vrindex \name\
@end macro

@macro pioc{name}
@code{\name\}@ctindex \name\
@end macro

@end iftex

@ifnottex
@c skip deep indexing for plain text, html and info
@c it messes up column with maximums (texinfo bug)

@macro prim{name}
@code{\name\}
@end macro

@macro pval{name}
@code{\name\}
@end macro

@macro perr{name}
@code{\name\}
@end macro

@macro psta{name}
@code{\name\}
@end macro

@macro parm{name}
@code{\name\}
@end macro

@macro pioc{name}
@code{\name\}
@end macro

@end ifnottex

@ifnottex
@node Top
@top Signalling Data Terminal Interface
@end ifnottex

@menu
* Preface::
* Introduction::
* The Signalling Data Terminal Layer::
* SDTI Services Definition::
* SDTI Primitives::
* Diagnostics Requirements::
@c * Addendum for ITU-T Q.703 Conformance::
@c * Addendum for ANSI T1.111.3 Conformance::
@c * Addendum for ETSI ETS 300 008-1 Conformance::
@c * Mapping of SDTI Primitives to ITU-T Q.703::
@c * Mapping of SDTI Primitives to ANSI T1.111.3::
@c * State/Event Tables::
@c * Primitive Precedence Tables::
* LMI Header File Listing::
* SDTI Header File Listing::
* License::
* Glossary::
* Acronyms::
* References::
@c @iftex
@c * Indices::
@c @end iftex
@c @ifnottex
* Index::
@c @end ifnottex
@end menu

@iftex
@c insert list of figures and tables for printed manuals
@page
@heading List of Figures
@listoffloats Figure
@page
@heading List of Tables
@listoffloats Table
@end iftex

@node Preface
@unnumbered Preface

@section Security Warning

@noindent
Permission to use, copy and distribute this documentation without modification, for any purpose and
without fee or royalty is hereby granted, provided that both the above copyright notice and this
permission notice appears in all copies and that the name of @cite{OpenSS7 Corporation} not be used
in advertising or publicity pertaining to distribution of this documentation or its contents without
specific, written prior permission.  @cite{OpenSS7 Corporation} makes no representation about the
suitability of this documentation for any purpose.  It is provided ``as is'' without express or
implied warranty.

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} disclaims all warranties with regard to this
documentation including all implied warranties of merchantability, fitness for a particular purpose,
non-infringement, or title; that the contents of the document are suitable for any purpose, or that
the implementation of such contents will not infringe on any third party patents, copyrights,
trademarks or other rights.  In no event shall @cite{OpenSS7 Corporation} be liable for any direct,
indirect, special or consequential damages or any damages whatsoever resulting from loss of use,
data or profits, whether in an action of contract, negligence or other tortious action, arising out
of or in connection with any use of this document or the performance or implementation of the
contents thereof.

@noindent
@uref{http://www.openss7.com/,OpenSS7 Corporation} is making this documentation available as a
reference point for the industry.  While @cite{OpenSS7 Corporation} believes that these interfaces
are well defined in this release of the document, minor changes may be made prior to products
conforming to the interfaces being made available.

@section Abstract

This document is a @value{MANUAL_TYPE} containing technical details concerning the implementation of
the @value{MANUAL_TITLE} for OpenSS7.  It contains recommendations on software architecture as well
as platform and system applicability of the @value{MANUAL_TITLE}.

@noindent
This document specifies a @value{MANUAL_TITLE} Specification in support of the OpenSS7 Signalling
Data Terminal (SDT) protocol stacks.  It provides abstraction of the signalling data terminal
interface to these components as well as providing a basis for signalling data terminal control for
other data terminal control protocols.

@section Purpose

The purpose of this document is to provide technical documentation of the @value{MANUAL_TITLE}.
This document is intended to be included with the OpenSS7 @cite{STREAMS}
@cpindex STREAMS
software package released by @cite{OpenSS7 Corporation}.  It is intended to assist software
developers, maintainers and users of the @value{MANUAL_TITLE} with understanding the software
architecture and technical interfaces that are made available in the software package.

@section Intent

It is the intent of this document that it act as the primary source of information concerning the
@value{MANUAL_TITLE}.  This document is intended to provide information for writers of OpenSS7
@value{MANUAL_TITLE} applications as well as writers of OpenSS7 @value{MANUAL_TITLE} Users.

@section Audience

The audience for this document is software developers, maintainers and users and integrators of the
@value{MANUAL_TITLE}.  The target audience is developers and users of the OpenSS7 SS7 stack.

@section Disclaimer

Although the author has attempted to ensure that the information in this document is complete and
correct, neither the Author nor OpenSS7 Corporation will take any responsibility in it.

@section Revision History

Take care that you are working with a current version of this documentation: you will not be
notified of updates.  To ensure that you are working with a current version, check the
@uref{http://www.openss7.org/,OpenSS7 Project} website for a current version.

Only the texinfo or roff source is controlled.  A printed (or postscript) version of this document
is an @strong{UNCONTROLLED VERSION}.

@smallexample
@verbatim
$Log: sdti.texi,v $
Revision 0.9.2.8  2008-08-03 06:03:32  brian
- protected agains texinfo commands in log entries

Revision 0.9.2.7  2008-08-03 05:05:16  brian
- conditional @syncodeindex frags out automake, fails distcheck

Revision 0.9.2.6  2008-07-11 09:36:12  brian
- updated documentation

Revision 0.9.2.5  2008-04-29 07:10:39  brian
- updating headers for release

Revision 0.9.2.4  2007/08/14 12:17:02  brian
- GPLv3 header updates

Revision 0.9.2.3  2007/07/14 01:33:50  brian
- make license explicit, add documentation

Revision 0.9.2.2  2007/07/09 09:12:59  brian
- working up SDTI specification

Revision 0.9.2.1  2007/07/04 08:24:57  brian
- added new files
@end verbatim
@end smallexample

@node Introduction
@chapter Introduction

This document specifies a @cite{STREAMS}-based
@cpindex STREAMS
kernel-level instantiation of the ITU-T @value{MANUAL_TITLE} definition.  The @value{MANUAL_TITLE}
enables the user of a a signalling data terminal service to access and use any of a variety of
conforming signalling data terminal providers without specific knowledge of the provider's protocol.
The service interface is designed to support any network signalling data terminal protocol and user
signalling data terminal protocol.  This interface only specifies access to signalling data terminal
service providers, and does not address issues concerning signalling data terminal management,
protocol performance, and performance analysis tools.

This specification assumes that the reader is familiar with ITU-T state machines and signalling data
terminal interfaces (e.g.  Q.703, Q.2210), and @cite{STREAMS}.
@cpindex STREAMS

@section Related Documentation

@itemize ---
@item @strong{ITU-T Recommendation Q.703 (White Book)}
@item @strong{ITU-T Recommendation Q.2210 (White Book)}
@item @strong{ANSI T1.111.3/2002}
@item @strong{System V Interface Definition, Issue 2 - Volume 3}
@end itemize

@subsection Role

This document specifies an interface that supports the services provided by the @dfn{Signalling
System No. 7 (SS7)} for ITU-T, ANSI and ETSI applications as described in ITU-T Recommendation
Q.703, ITU-T Recommendation Q.2210, ANSI T1.111.3, ETSI ETS 300 008-1.  These specifications are
targeted for use by developers and testers of protocol modules that require signalling data terminal
service.

@section Definitions, Acronyms, Abbreviations
@cpindex STREAMS

@table @dfn
@item LM
Local Management.
@item LMS
Local Management Service.
@item LMS User
A user of Local Management Services.
@item LMS Provider
A provider of Local Management Services.
@item Originating SDT User
A SDT-User that initiates a Signalling Data Terminal.
@item Destination SDT User
A SDT-User with whom an originating SDT user wishes to establish a Signalling Data Terminal.
@item ISO
International Organization for Standardization
@item SDT User
Kernel level protocol or user level application that is accessing the services
of the Signalling Data Terminal sub-layer.
@item SDT Provider
Signalling Data Terminal sub-layer entity/entities that provide/s the services of the
Signalling Data Terminal interface.
@item SDTI
Signalling Data Terminal Interface
@item TIDU
Signalling Data Terminal Interface Data Unit
@item TSDU
Signalling Data Terminal Service Data Unit
@item OSI
Open Systems Interconnection
@item QOS
Quality of Service
@item STREAMS
A communication services development facility first available with UNIX System V Release 3.
@end table

@node The Signalling Data Terminal Layer
@chapter The Signalling Data Terminal Layer

@menu
* Model of the SDTI::
* SDTI Services::
* Purpose of the SDTI::
@end menu

The Signalling Data Terminal Layer provides the means to manage the association of SDT-Users into
connections.  It is responsible for the routing and management of data to and from signalling data
terminal connections between SDT-user entities.

@node Model of the SDTI
@section Model of the SDTI
@cpindex STREAMS

The SDTI defines the services provided by the signalling data terminal layer to the signalling data
terminal user at the boundary between the signalling data terminal provider and the signalling data
terminal user entity.  The interface consists of a set of primitives defined as @cite{STREAMS}
messages that provide access to the signalling data terminal layer services, and are transferred
between the SDTS user entity and the SDTS provider.  These primitives are of two types; ones that
originate from the SDTS user, and other that originate from the SDTS provider.  The primitives that
originate from the SDTS user make requests to the SDTS provider, or respond to an indication of an
event of the SDTS provider.  The primitives that originate from the SDTS provider are either
confirmations of a request or are indications to the CCS user that an event has occurred.
@figref{1} shows the model of the SDTI.

@figuresized{sdti01,1,Model of the SDTI,3.0in}

The SDTI allows the SDTS provider to be configured with any signalling data terminal layer user (such as
a signalling link application) that also conforms to the SDTI.  A signalling data terminal layer
user can also be a user program that conforms to the SDTI and accesses the SDTS provider via
@command{@b{putmsg}(2s)} and @command{@b{getmsg}(2s)} system calls.  The typical configuration,
however, is to place a signalling link module above the signalling data terminal layer.

@node SDTI Services
@section SDTI Services

The features of the SDTI are defined in terms of the services provided by the SDTS provider, and the
individual primitives that may flow between the SDTS user and the SDTS provider.

The SDTI Services are broken into two groups: local management services and protocol services.
Local management services are responsible for the local management of streams, assignment of streams
to physical points of attachment, enabling and disabling of streams, management of options
associated with a stream, and general acknowledgement and event reporting for the stream.  Protocol
services consist of connecting a stream to a medium, exchanging data with the medium, and
disconnecting the stream from the medium.

@subsection Local Management

Local management services are listed in @tabref{1}.

@tabfig{lmit01,1,Local Management Services}

The local management services interface is described in @ref{Local Management Services}, and the
primitives are detailed in @ref{Local Management Service Primitives}.  The local management services
interface is defined by the @file{ss7/lmi.h} header file (@pxref{LMI Header File Listing}).

@subsection Protocol

Protocol services are listed in @tabref{2}.

@tabfig{sdtit02,2,Protocol Services}

The protocol services interface is described in @ref{Protocol Services}, and the primitives are
detailed in @ref{Protocol Service Primitives}.  The protocol services interface is defined by the
@file{ss7/sdti.h} header file (@pxref{SDTI Header File Listing}).

@node Purpose of the SDTI
@section Purpose of the SDTI

The SDTI is typically implemented as a device driver controlling a MPCC (Multi-Protocol Controller Chip)
device that provides access to channels.  The purpose behind exposing this low level interface is
that almost all communications channel devices can be placed into a SS7 HDLC mode, where a data
stream can be exchanged between the driver and the medium.  The SDTI provides and inteface that, once
implemented as a driver for a new device, can provide complete and verified SS7 signalling link
capabilities by pushing generic SL (Signalling Link) modules over
an open device stream.

This allows SL modules to be verified independently for correct operation and then simply
used for all manner of new device drivers that can implement the SDTI interface.

@node SDTI Services Definition
@chapter SDTI Services Definition

@menu
* Local Management Services::
* Protocol Services::
@end menu

@node Local Management Services
@section Local Management Services

@menu
* Acknowledgement Service::
* Information Reporting Service::
* Physical Point of Attachment Service::
* Initialization Service::
* Options Management Service::
* Error Reporting Service::
* Statistics Reporting Service::
* Event Reporting Service::
@end menu

@node Acknowledgement Service
@subsection Acknowledgement Service

The acknowledgement service provides the LMS user with the ability to receive positive and negative
acknowledgements regarding the successful or unsuccessful completion of services.

@itemize @bullet

@item @b{@prim{LMI_OK_ACK}}:
The @prim{LMI_OK_ACK} message is used by the LMS provider to indicate successful receipt and
completion of a service primitive request that requires positive acknowledgement.

@item @b{@prim{LMI_ERROR_ACK}}:
The @prim{LMI_ERROR_ACK} message is used by the LMS provider to indicate successful receipt and
failure to complete a service primitive request that requires negative acknowledgement.

@end itemize

A successful invocation of the acknowledgement service is illustrated in @figref{15}.

@figuresized{lmi15,15,Message Flow: Successful Acknowledgement Service,4.0in}

As illustrated in @figref{15}, the
service primitives for which a positive acknowledgement may be returned are the
@prim{LMI_ATTACH_REQ} and @prim{LMI_DETACH_REQ}.

An unsuccessful invocation of the acknowledgement service is illustrated in @figref{16}.

@figuresized{lmi16,16,Message Flow: Unsuccessful Acknowledgement Service,4.0in}

As illustrated in @figref{16}, the service primitives for which a negative acknowledgement may be
returned are the @prim{LMI_INFO_REQ}, @prim{LMI_ATTACH_REQ}, @prim{LMI_DETACH_REQ},
@prim{LMI_ENABLE_REQ}, @prim{LMI_DISABLE_REQ} and @prim{LMI_OPTMGMT_REQ} messages.

@node Information Reporting Service
@subsection Information Reporting Service

The information reporting service provides the LMS user with the ability to elicit information from
the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_INFO_REQ}}:
The @prim{LMI_INFO_REQ} message is used by the LMS user to request information about the LMS
provider.

@item @b{@prim{LMI_INFO_ACK}}:
The @prim{LMI_INFO_ACK} message is issued by the LMS provider to provide requested information about
the LMS provider.

@end itemize

A successful invocation of the information reporting service is illustrated in @figref{2}.

@figuresized{lmi02,2,Message Flow: Successful Information Reporting Service,4.0in}

@node Physical Point of Attachment Service
@subsection Physical Point of Attachment Service

The local management interface provides the LMS user with the ability to associate a stream to a
physical point of appearance (@dfn{PPA}) or to disassociate a stream from a PPA.  The local
management interface provides for two styles of LMS provider:

@subsubheading Style 1 LMS Provider

A @dfn{Style 1} LMS provider is a provider that associates a stream with a PPA at the time of the
first @manref{open(2)} call for the device, and disassociates a stream from a PPA at the time of the
last @manref{close(2)} call for the device.

Physical points of attachment (PPA) are assigned to major and minor device number combinations.
When the major and minor device number combination is opened, the opened stream is automatically
associated with the PPA for the major and minor device number combination.  The last close of the
device disassociates the PPA from the stream.

Freshly opened @dfn{Style 1} LMS provider streams start life in the @psta{LMI_DISABLED} state.

This approach is suitable for LMS providers implemented as real or pseudo-device drivers and is
applicable when the number of minor devices is small and static.

@subsubheading Style 2 LMS Provider

A @dfn{Style 2} LMS provider is a provider that associates a stream with a PPA at the time that the
LMS user issues the @prim{LMI_ATTACH_REQ} message.  Freshly opened streams are not associated with
any PPA.  The @dfn{Style 2} LMS provider stream is disassociated from a PPA when the stream is
closed or when the LMS user issues the @prim{LMI_DETACH_REQ} message.

Freshly opened @dfn{Style 2} LMS provider streams start life in the @psta{LMI_UNATTACHED} state.

This approach is suitable for LMS providers implemented as clone real or pseudo-device drivers  and
is applicable when the number of minor devices is large or dynamic.

@menu
* PPA Attachment Service::
* PPA Detachment Service::
@end menu

@node PPA Attachment Service
@subsubsection PPA Attachment Service

The PPA attachment service provides the LMS user with the ability to attach a @dfn{Style 2} LMS
provider stream to a physical point of appearance (PPA).

@itemize @bullet

@item @b{@prim{LMI_ATTACH_REQ}}:
The @prim{LMI_ATTACH_REQ} message is issued by the LMS user to request that a @dfn{Style 2} LMS
provider stream be attached to a specified physical point of appearance (PPA).

@item @b{@prim{LMI_OK_ACK}}:
Upon successful receipt and processing of the @prim{LMI_ATTACH_REQ} message, the LMS provider
acknowledges the success of the service completion with a @prim{LMI_OK_ACK} message.

@item @b{@prim{LMI_ERROR_ACK}}:
Upon successful receipt but failure to process the @prim{LMI_ATTACH_REQ} message, the LMS provider
acknowledges the failure of the service completion with a @prim{LMI_ERROR_ACK} message.

@end itemize

A successful invocation of the attachment service is illustrated in @figref{3}.

@figuresized{lmi03,3,Message Flow: Successful Attachment Service,4.0in}


@node PPA Detachment Service
@subsubsection PPA Detachment Service

The PPA detachment service provides the LMS user with the ability to detach a @dfn{Style 2} LMS
provider stream from a physical point of attachment (PPA).

@itemize @bullet

@item @b{@prim{LMI_DETACH_REQ}}:
The @prim{LMI_DETACH_REQ} message is issued by the LMS user to request that a @dfn{Style 2} LMS
provider stream be detached from the attached physical point of appearance (PPA).

@item @b{@prim{LMI_OK_ACK}}:
Upon successful receipt and processing of the @prim{LMI_DETACH_REQ} message, the LMS provider
acknowledges the success of the service completion with a @prim{LMI_OK_ACK} message.

@item @b{@prim{LMI_ERROR_ACK}}:
Upon successful receipt but failure to process the @prim{LMI_DETACH_REQ} message, the LMS provider
acknowledges the failure of the service completion with a @prim{LMI_ERROR_ACK} message.

@end itemize

A successful invocation of the detachment service is illustrated in @figref{4}.

@figuresized{lmi04,4,Message Flow: Successful Detachment Service,4.0in}

@node Initialization Service
@subsection Initialization Service

The initialization service provides the LMS user with the abilty to enable and disable the stream
for the associated PPA.

@menu
* Interface Enable Service::
* Interface Disable Service::
@end menu

@node Interface Enable Service
@subsubsection Interface Enable Service

The interface enable service provides the LMS user with the ability to enable an LMS provider
stream that is associated with a PPA.  Enabling the interface permits the LMS user to exchange
protocol service interface messages with the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_ENABLE_REQ}}:
The @prim{LMI_ENABLE_REQ} message is issued by the LMS user to request that the protocol service
interface be enabled.

@item @b{@prim{LMI_ENABLE_CON}}:
Upon successful enabling of the protocol service interface, the LMS provider acknowledges successful
completion of the service by issuing a @prim{LMI_ENABLE_CON} message to the LMS user.

@item @b{@prim{LMI_ERRORK_ACK}}:
Upon unsuccessful enabling of the protocol service interface, the LMS provider acknowledges the
failure to complete the service by issuing an @prim{LMI_ERROR_ACK} message to the LMS user.

@end itemize

A successful invocation of the enable service is illustrated in @figref{5}.

@figuresized{lmi05,5,Message Flow: Successful Enable Service,4.0in}

@node Interface Disable Service
@subsubsection Interface Disable Service

The interface disable service provides the LMS user with the ability to disable an LMS provider
stream that is associated with a PPA.  Disabling the interface withdraws the LMS user's ability to
exchange protocol service interface messages with the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_DISABLE_REQ}}:
The @prim{LMI_DISABLE_REQ} message is issued by the LMS user to request that the protocol service
interface be disabled.

@item @b{@prim{LMI_DISABLE_CON}}:
Upon successful disabling of the protocol service interface, the LMS provider acknowledges
successful completion of the service by issuing a @prim{LMI_DISABLE_CON} message to the LMS user.

@item @b{@prim{LMI_ERRORK_ACK}}:
Upon unsuccessful disabling of the protocol service interface, the LMS provider acknowledges the
failure to complete the service by issuing an @prim{LMI_ERROR_ACK} message to the LMS user.

@end itemize

A successful invocation of the disable service is illustrated in @figref{6}.

@figuresized{lmi06,6,Message Flow: Successful Disable Service,4.0in}

@node Options Management Service
@subsection Options Management Service

The options management service provides the LMS user with the ability to control and affect various
generic and provider-specific options associated with the LMS provider.

@itemize @bullet

@item @b{@prim{LMI_OPTMGMT_REQ}}:
The LMS user issues a @prim{LMI_OPTMGMT_REQ} message when it wishes to interrogate or affect the
setting of various generic or provider-specific options associated with the LMS provider for the
stream upon which the message is issued.

@item @b{@prim{LMI_OPTMGMT_ACK}}:
Upon successful receipt of the @prim{LMI_OPTMGMT_REQ} message, and successful options processing, the
LMS provider acknowledges the successful completion of the service with an @prim{LMI_OPTMGMT_ACK}
message.

@item @b{@prim{LMI_ERROR_ACK}}:
Upon successful receipt of the @prim{LMI_OPTMGMT_REQ} message, and unsuccessful options processing, the
LMS provider acknowledges the failure to complete the service by issuing an @prim{LMI_ERROR_ACK}
message to the LMS user.

@end itemize

A successful invocation of the options management service is illustrated in @figref{7}.

@figuresized{lmi07,7,Message Flow: Successful Options Management Service,4.0in}

@node Error Reporting Service
@subsection Error Reporting Service

The error reporting service provides the LMS provider with the ability to indicate asynchronous
errors to the LMS user.

@itemize @bullet

@item @b{@prim{LMI_ERROR_IND}}:
The LMS provider issues the @prim{LMI_ERROR_IND} message to the LMS user when it needs to indicate an
asynchronous error (such as the unusability of the communications medium).

@end itemize

A successful invocation of the error reporting service is illustrated in @figref{8}.

@figuresized{lmi08,8,Message Flow: Successful Error Reporting Service,4.0in}

@node Statistics Reporting Service
@subsection Statistics Reporting Service

@itemize @bullet

@item @b{@prim{LMI_STATS_IND}}:

@end itemize

A successful invocation of the statistics reporting service is illustrated in @figref{9}.

@figuresized{lmi09,9,Message Flow: Successful Statistics Reporting Service,4.0in}

@node Event Reporting Service
@subsection Event Reporting Service

The event reporting service provides the LMS provider with the ability to indicate specific
asynchronous management events to the LMS user.

@itemize @bullet

@item @b{@prim{LMI_EVENT_IND}}:
The LMS provider issues the @prim{LMI_EVENT_IND} message to the LMS user when it wishes to indicate
an asynchronous (management) event to the LMS user.

@end itemize

A successful invocation of the event reporting service is illustrated in @figref{10}.

@figuresized{lmi10,10,Message Flow: Successful Event Reporting Service,4.0in}

@node Protocol Services
@section Protocol Services

Protocol services are specific to the Signalling Data Terminal interface.  These services consist of
connection services that permit the transmit and receive directions to be connected to or
disconnected from the medium, and data transfer services that permit the exchange of data between
SDTS users.

The service primitives that implement the protocol services are described in detail in @ref{Protocol
Service Primitives}.

@menu
* Power On Service::
* Data Transfer Service::
* Initial Alignment Service::
* Error Rate Monitoring Service::
* Receive Congestion Service::
@end menu

@node Power On Service
@subsection Power On Service

The power on service provides the SDTS user with the ability to power up the receive and trasmitters
associated with the medium.  Transmitters and receivers can be powered up independently.  Data
trasnfer cannot occur until the transmitters or receivers have been powered up.

@itemize @bullet

@item @prim{SDT_DAEDT_START_REQ}:
This service primitive allows the SDTS user to request that transmission of bits begin on the
medium.

@item @prim{SDT_DAEDR_START_REQ}:
This service primitive allows the SDTS user to request that receiption of bits from the medium begin.

@end itemize

@node Data Transfer Service
@subsection Data Transfer Service

The data transfer service provides the SDTS user with the ability to exchange signal units with the
SDTS provider.  Signal units may be sent to the SDTS provider for transmission and received
signal units are delivered to the SDTS user by the SDTS provider.  Timing queues can also be
indicated by the SDTS provider.

@itemize @bullet

@item @prim{SDT_DAEDT_TRANSMISSION_REQ}:
This service primitive allows the SDTS user to request the transmission of a signal unit.

@item @prim{SDT_RC_SIGNAL_UNIT_IND}:
This service primitive allows the SDTS provider to indicate when a signal unit has been received.

@item @prim{SDT_TXC_TRANSMISSION_REQUEST_IND}:
This service primitive allows the SDTS provider to indicate when it is idle (that is, it is
requesting transmission).

@end itemize

@node Initial Alignment Service
@subsection Initial Alignment Service

The initial alignment service provides for all of the mechanisms associated with the Alignment Error
Rate Monitor (AERM).  This includes the ability for the SDTS user to start and stop the AERM, set
the proving period to either normal proving or emergency proving, to receive correct signal unit
indications and indications of when the error rate exceeds the configured threshold.

@itemize @bullet

@item @prim{SDT_AERM_START_REQ}:
This service primitive allows the SDTS user to request that the ERM for alignment be started.  This
is normally performed when initial alignment begins on the signalling link.

@item @prim{SDT_AERM_SET_TI_TO_TIN_REQ}:
This service primitive allows the SDTS user to request that the ERM for alignment use the error
threshold values for normal alignment.

@item @prim{SDT_AERM_SET_TI_TO_TIE_REQ}:
This service primitive allows the SDTS user to request that the ERM for alignment use the error
threshold values for emergency alignment.

@item @prim{SDT_IAC_CORRECT_SU_IND}:
This service primitive allows the SDTS provider to indicate when a signal unit has sucessfully been
received during initial alignment.

@item @prim{SDT_IAC_ABORT_PROVING_IND}:
This service primitive allows the SDTS provider to indicate when the Alignment Error Rate Monitor
(AERM) exceeds it threshold.

@item @prim{SDT_AERM_STOP_REQ}:
This service primitive allows the SDTS user to request that the ERM for alignment be stopped.  This
is normally performed when initial alignement ends for the signalling link.

@end itemize

@node Error Rate Monitoring Service
@subsection Error Rate Monitoring Service

The error rate monitoring service provides all of the mechanisms associated with the Signal Unit
Error Rate Monitor (SUERM) or Errored Interval Monitor (EIM).  This includes the ability for the
SDTS user to start and stop the SUERM/EIM, and be notified when the error rate exceeds the
configured threshold.

@itemize @bullet

@item @prim{SDT_SUERM_START_REQ}:
This service primitive allows the SDTS user to request that the ERM for normal operation be started.
This is normally performed when intial alignment ends for the signalling link.

@item @prim{SDT_LSC_LINK_FAILURE_IND}:
This service primitive allows the SDTS provider to indicate when the Signal Unit Error Rate Monitor
(SUERM) exceeds its threshold.

@item @prim{SDT_SUERM_STOP_REQ}:
This service primitive allows the SDTS user to request that the ERM for normal operation be stopped.
This is normally performed when initial alignment begins for the signalling link.

@end itemize

@node Receive Congestion Service
@subsection Receive Congestion Service

The receive congestion service providers mechanisms to implement provider-specific receive
congestion indications to the SDTS user.

@itemize @bullet

@item @prim{SDT_RC_CONGESTION_ACCEPT_IND}:
This service primitive allows the SDTS provider to indicate when receive congestion has onset, but
not to the point that it is dicarding signal units.

@item @prim{SDT_RC_CONGESTION_DISCARD_IND}:
This service primitive allows the SDTS provider to indicate when receive congestion has onset, and
signal units are being dicarded.

@item @prim{SDT_RC_NO_CONGESTION_IND}:
This service primitive allows the SDTS provider to indicate when receive congestion abates.

@end itemize

@node SDTI Primitives
@chapter SDTI Primitives

@menu
* Local Management Service Primitives::
* Protocol Service Primitives::
@end menu

@node Local Management Service Primitives
@section Local Management Service Primitives

These service primitives implement the local management services (@pxref{Local Management
Services}).

@menu
* Acknowledgement Service Primitives::
* Information Reporting Service Primitives::
* Physical Point of Attachment Service Primitives::
* Initialization Service Primitives::
* Options Management Service Primitives::
* Event Reporting Service Primitives::
@end menu

@node Acknowledgement Service Primitives
@subsection Acknowledgement Service Primitives

These service primitives implement the acknowledgement service (@pxref{Acknowledgement Service}).

@menu
* LMI_OK_ACK::
* LMI_ERROR_ACK::
@end menu

@node LMI_OK_ACK
@subsubsection LMI_OK_ACK

@subsubheading Description

This primitive is used to acknowledge receipt and successful service completion for
primitives requiring acknowledgement that have no confirmation primitive.

@subsubheading Format
@tpindex lmi_ok_ack_t

This primitive consists of one @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_long lmi_correct_primitive;
    lmi_ulong lmi_state;
} lmi_ok_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_OK_ACK}.

@item lmi_correct_primitive
Indicates the service primitive that was received and serviced correctly.  This field can be one of
the following values:

@table @prim

@ignore
@item LMI_INFO_REQ
Information request.
@end ignore
@item LMI_ATTACH_REQ
Attach request.
@item LMI_DETACH_REQ
Detach request.
@ignore
@item LMI_ENABLE_REQ
Enable request.
@item LMI_DISABLE_REQ
Disable request.
@item LMI_OPTMGMT_REQ
Options management request.
@item LMI_INFO_ACK
Information acknowledgement.
@item LMI_OK_ACK
Successful receipt acknowledgement.
@item LMI_ERROR_ACK
Error acknowledgement.
@item LMI_ENABLE_CON
Enable confirmation.
@item LMI_DISABLE_CON
Disable confirmation.
@item LMI_OPTMGMT_ACK
Options Management acknowledgement.
@item LMI_ERROR_IND
Error indication.
@item LMI_STATS_IND
Statistics indication.
@item LMI_EVENT_IND
Event indication.
@end ignore

@end table

@item lmi_state

Indicates the current state of the LMS provider at the time that the primitive was issued.
This field can be one of the following values:

@table @psta

@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@ignore
@item LMI_ATTACH_PENDING
Waiting for attach.
@end ignore
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@ignore
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@end ignore
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@ignore
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end ignore

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in the @psta{LMI_ATTACH_PENDING} or
@psta{LMI_DETACH_PENDING} state.

@subsubheading New State

The new state is @psta{LMI_UNATTACHED} or @psta{LMI_DISABLED}, depending on thee primitive to
which the message is responding.

@page
@node LMI_ERROR_ACK
@subsubsection LMI_ERROR_ACK

@subsubheading Description

The error acknowledgement primitive is used to acknowledge receipt and unsuccessful service
completion for primitives requiring acknowledgement.

@subsubheading Format
@tpindex lmi_error_ack_t

The error acknowledgement primitive consists of one @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_errno;
    lmi_ulong lmi_reason;
    lmi_long lmi_error_primitive;
    lmi_ulong lmi_state;
} lmi_error_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The error acknowledgement primitive contains the following parameters:

@table @parm

@item lmi_primitive

Indicates the primitive type.  Always @prim{LMI_ERROR_ACK}.

@item lmi_errno

Indicates the LM error number.
This field can have one of the following values:

@table @perr
@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.
@end table

@item lmi_reason

Indicates the reason for failure.  This field is protocol-specific.  When the @parm{lmi_errno} field
is @perr{LMI_SYSERR}, the @parm{lmi_reason} field is the UNIX error number as described in
@manref{errno(3)}.

@item lmi_error_primitive

Indicates the primitive that was in error.
This field can have one of the following values:

@table @prim
@item LMI_INFO_REQ
Information request.
@item LMI_ATTACH_REQ
Attach request.
@item LMI_DETACH_REQ
Detach request.
@item LMI_ENABLE_REQ
Enable request.
@item LMI_DISABLE_REQ
Disable request.
@item LMI_OPTMGMT_REQ
Options management request.
@item LMI_INFO_ACK
Information acknowledgement.
@item LMI_OK_ACK
Successful receipt acknowledgement.
@item LMI_ERROR_ACK
Error acknowledgement.
@item LMI_ENABLE_CON
Enable confirmation.
@item LMI_DISABLE_CON
Disable confirmation.
@item LMI_OPTMGMT_ACK
Options Management acknowledgement.
@item LMI_ERROR_IND
Error indication.
@item LMI_STATS_IND
Statistics indication.
@item LMI_EVENT_IND
Event indication.
@end table

@item lmi_state

Indicates the state of the LMS provider at the time that the primitive was issued.  This field can
have one of the following values:

@table @psta
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end table

@end table

@subsubheading State

This primitive can be issued in any state for which a local acknowledgement is not pending.  The
LMS provider state at the time that the primitive was issued is indicated in the primitive.

@subsubheading New State

The new state remains unchanged.

@page
@node Information Reporting Service Primitives
@subsection Information Reporting Service Primitives

These service primitives implement the information reporting service (@pxref{Information Reporting
Service}).

@menu
* LMI_INFO_REQ::
* LMI_INFO_ACK::
@end menu

@node LMI_INFO_REQ
@subsubsection LMI_INFO_REQ

@subsubheading Description

This LMS user originated primitive is issued by the LMS user to request that the LMS provider
return information concerning the capabilities and state of the LMS provider.

@subsubheading Format
@tpindex lmi_info_req_t

The primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_ulong lmi_primitive;
} lmi_info_req_t;
@end verbatim
@end display

@subsubheading Parameters

This primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the primitive type.  Always @prim{LMI_INFO_REQ}.

@end table

@subsubheading State

This primitive may be issued in any state but only when a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Response

This primitive requires the LMS provider to acknowledge receipt of the primitive as follows:

@itemize @minus

@item @b{Successful}:
The LMS provider is required to acknowledge receipt of the primitive and provide the requested
information using the @prim{LMI_INFO_ACK} primitive.

@item @b{Unsuccessful (non-fatal errors)}:
The LMS provider is required to negatively acknowledge the primitive using the @prim{LMI_ERROR_ACK}
primitive, and include the reason for failure in the primitive.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}: applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_INFO_ACK
@subsubsection LMI_INFO_ACK

@subsubheading Description

This LMS provider originated primitive acknowledges receipt and successful processing of the
@prim{LMI_INFO_REQ} primitive and provides the request information concerning the LMS provider.

@subsubheading Format
@tpindex lmi_info_ack_t

This message is formatted a one @msg{M_PROTO} or @msg{M_PCPROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_version;
    lmi_ulong lmi_state;
    lmi_ulong lmi_max_sdu;
    lmi_ulong lmi_min_sdu;
    lmi_ulong lmi_header_len;
    lmi_ulong lmi_ppa_style;
    lmi_uchar lmi_ppa_addr[0];
} lmi_info_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The information acknowledgement service primitive has the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_INFO_ACK}.

@item lmi_version
Indicates the version of this specification that is being used by the LMS provider.

@item lmi_state
Indicates the state of the LMS provider at the time that the information acknowledgement service
primitive was issued.  This field can be one of the following values:

@table @psta

@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.

@end table

@item lmi_max_sdu
Indicates the maximum size of a Service Data Unit.

@item lmi_min_sdu
Indicates the minimum size of a Service Data Unit.

@item lmi_header_len
Indicates the amount of header space that should be reserved for placing LMS provider headers.

@item lmi_ppa_style
Indicates the PPA style of the LMS provider.  This value can be one of the following values:

@table @pval

@item LMI_STYLE1
PPA is implicitly attached by @manref{open(2)}.

@item LMI_STYLE2
PPA must be explicitly attached using @prim{LMI_ATTACH_REQ}.

@end table

@item lmi_ppa_addr
This is a variable length field.  The length of the field is determined by the length of the
@msg{M_PROTO}
or @msg{M_PCPROTO} message block.

For a @dfn{Style 2} driver, when @parm{lmi_ppa_style} is @pval{LMI_STYLE2}, and when in an attached state,
this field providers the current PPA associated with the stream; the length is typically 4 bytes.

For a @dfn{Style 1} driver, when @parm{lmi_ppa_style} is @pval{LMI_STYLE1}, the length it 0 bytes.

@end table

@subsubheading State

This primitive can be issued in any state where a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@page
@node Physical Point of Attachment Service Primitives
@subsection Physical Point of Attachment Service Primitives

These service primitives implement the physical point of attachment service (@pxref{Physical Point
of Attachment Service}).

@menu
* LMI_ATTACH_REQ::
* LMI_DETACH_REQ::
@end menu

@node LMI_ATTACH_REQ
@subsubsection LMI_ATTACH_REQ

@subsubheading Description

This LMS user originated primitive requests that the stream upon which the primitive is issued by
associated with the specified Physical Point of Attachment (PPA).  This primitive is only applicable
to @dfn{Style 2} LMS provider streams, that is, streams that return @pval{LMI_STYLE2} in the
@parm{lmi_ppa_style} field of the @prim{LMI_INFO_ACK}.

@subsubheading Format
@tpindex lmi_attach_req_t

This primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_uchar lmi_ppa[0];
} lmi_attach_req_t;
@end verbatim
@end display

@subsubheading Parameters

The attach request primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_ATTACH_REQ}.

@item lmi_ppa
Specifies the Physical Point of Attachment (PPA) to which to associated the @dfn{Style 2} stream.
This is a variable length identifier whose length is determined by the length of the @msg{M_PROTO} message
block.

@end table

@subsubheading State

This primitive is only valid in state @psta{LMI_UNATTACHED} and when a local acknowledgement is not
pending.

@subsubheading New State

Upon success, the new state is @psta{LMI_ATTACH_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The attach request service primitive requires that the LMS provider respond as follows:

@itemize @minus

@item @b{Successful}:
The LMS provider acknowledges receipt of the primitive and successful outcome of the attach service
with a @prim{LMI_OK_ACK} primitive.  The new state is @psta{LMI_DISABLED}.

@item @b{Unsuccessful (non-fatal errors)}:
The LMS provider acknowledges receipt of the primitive and failure of the attach service with a
@prim{LMI_ERROR_ACK} primitive containing the reason for failure.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_DETACH_REQ
@subsubsection LMI_DETACH_REQ

@subsubheading Description

This LMS user originated primitive request that the stream upon which the primitive is issued be
disassociated from the Physical Point of Appearance (PPA) to which it is currently attached.  This
primitive is only applicable to @dfn{Style 2} LMS provider streams, that is, streams that return
@pval{LMI_STYLE2} in the @parm{lmi_ppa_style} field of the @prim{LMI_INFO_ACK}.

@subsubheading Format
@tpindex lmi_detach_req_t

The detach request service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
} lmi_detach_req_t;
@end verbatim
@end display

@subsubheading Parameters

The detach request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_DETACH_REQ}.

@end table

@subsubheading State

This primitive is valid in the @psta{LMI_DISABLED} state and when no local acknowledgement is pending.

@subsubheading New State

Upon success, the new state is @psta{LMI_DETACH_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The detach request service primitive requires that the LMS provider respond as follows:

@itemize @minus

@item @b{Successful}:
The LMS provider acknowledges receipt of the primitive and successful outcome of the detach service
with a @prim{LMI_OK_ACK} primitive.  The new state is @psta{LMI_UNATTACHED}.

@item @b{Unsuccessful (non-fatal errors)}:
The LMS provider acknowledges receipt of the primitive and failure of the detach service with a
@prim{LMI_ERROR_ACK} primitive containing the reason for failure.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node Initialization Service Primitives
@subsection Initialization Service Primitives

Initialization service primitives allow the LMS user to enable or disable the protocol service
interface.  Enabling the protocol service interface may require that some action be taken to prepare
the protocol service interface for use or to remove it from use.  For example, where the PPA
corresponds to a signalling data link identifier as defined in Q.704, it may be necessary to perform
switching to connect or disconnect the circuit identification code associated with the signalling
data link identifier.

These service primitives implement the initialization service (@pxref{Initialization Service}).

@menu
* LMI_ENABLE_REQ::
* LMI_ENABLE_CON::
* LMI_DISABLE_REQ::
* LMI_DISABLE_CON::
@end menu

@node LMI_ENABLE_REQ
@subsubsection LMI_ENABLE_REQ

@subsubheading Description

This LMS user originated primitive request that the LMS provider perform the actions necessary to
enable the protocol service interface and confirm that it is enabled.  This primitive is applicable
to both styles of PPA.

@subsubheading Format
@tpindex lmi_enable_req_t

The enable request service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_uchar lmi_rem[0];
} lmi_enable_req_t;
@end verbatim
@end display

@subsubheading Parameters

The enable request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_ENABLE_REQ}.

@item lmi_rem
Specifies a remote address to which to connect the PPA.  The need for and form of this address is
provider-specific.  The length of the field is determined by the length of the @msg{M_PROTO} message
block.  This remote address could be a circuit identification code, an IP address, or some other
form of circuit or channel identifier.

@end table

@subsubheading State

This primitive is valid in the @psta{LMI_DISABLED} state and when no local acknowledgement is pending.

@subsubheading New State

Upon success the new state is @psta{LMI_ENABLE_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The enable request service primitive requires that the LMS provider acknowledge receipt of the
primitive as follows:

@itemize @minus

@item @b{Successful}:
When successful, the LMS provider acknowledges successful completion of the enable service with an
@prim{LMI_ENABLE_CON} primitive.  The new state is @psta{LMI_ENABLED}.

@item @b{Unsuccessful (non-fatal errors)}:
When unsuccessful, the LMS provider acknowledges the failure of the  enable service wtih an
@prim{LMI_ERROR_ACK} primitive containing the error.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_ENABLE_CON
@subsubsection LMI_ENABLE_CON

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to confirm the successful
completion of the enable service.

@subsubheading Format
@tpindex lmi_enable_con_t

The enable confirmation service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_state;
} lmi_enable_con_t;
@end verbatim
@end display

@subsubheading Parameters

The enable confirmation service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_ENABLE_CON}.

@item lmi_state
Indicates the state following issuing the enable confirmation primitive.  This field can take on one
of the following values:

@table @psta

@ignore
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@end ignore
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@ignore
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end ignore

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in the @psta{LMI_ENABLE_PENDING} state.

@subsubheading New State

The new state is @psta{LMI_ENABLED}.

@page
@node LMI_DISABLE_REQ
@subsubsection LMI_DISABLE_REQ

@subsubheading Description

This LMS user originated primitive requests that the LMS provider perform the actions necessary to
disable the protocol service interface and confirm that it is disabled.  The primitive is applicable
to both styles of PPA.

@subsubheading Format
@tpindex lmi_disable_req_t

The disable request service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
} lmi_disable_req_t;
@end verbatim
@end display

@subsubheading Parameters

The disable request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_DISABLE_REQ}.

@end table

@subsubheading State

The disable request service primitive is valid in the @psta{LMI_ENABLED} state and when no local
acknowledgement is pending.

@subsubheading New State

Upon success, the new state is @psta{LMI_DISABLE_PENDING}.  Upon failure, the state remains unchanged.

@subsubheading Response

The disable request service primitive requires the LMS provider to acknowledge receipt of the
primitive as follows:

@itemize @minus

@item @b{Successful}:
When successful, the LMS provider acknowledges successful completion of the disable service with an
@prim{LMI_DISABLE_CON} primitive.  The new state is @psta{LMI_DISABLED}.

@item @b{Unsuccessful (non-fatal errors)}:
When unsuccessful, the LMS provider acknowledges the failure of the disable service with an
@prim{LMI_ERROR_ACK} primitive containing the error.  The new state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_DISABLE_CON
@subsubsection LMI_DISABLE_CON

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to confirm the successful
completion of the disable service.

@subsubheading Format
@tpindex lmi_disable_con_t

The disable confirmation service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_state;
} lmi_disable_con_t;
@end verbatim
@end display

@subsubheading Parameters

The disable confirmation service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_DISABLE_CON}.

@item lmi_state
Indicates the state following issuing the disable confirmation primitive.  This field can take on one
of the following values:

@table @psta

@ignore
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@end ignore
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@ignore
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end ignore

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in the @psta{LMI_DISABLE_PENDING} state.

@subsubheading New State

The new state is @psta{LMI_DISABLED}.

@page
@node Options Management Service Primitives
@subsection Options Management Service Primitives

The options management service primitives allow the LMS user to negotiate options with the LMS
provider, retrieve the current and default values of options, and check that values specified for
options are correct.

The options management service primitive implement the options management service (@pxref{Options
Management Service}).

@menu
* LMI_OPTMGMT_REQ::
* LMI_OPTMGMT_ACK::
@end menu

@node LMI_OPTMGMT_REQ
@subsubsection LMI_OPTMGMT_REQ

@subsubheading Description

This LMS user originated primitive requests that LMS provider options be managed.

@subsubheading Format
@tpindex lmi_optmgmt_req_t

The option management request service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_opt_length;
    lmi_ulong lmi_opt_offset;
    lmi_ulong lmi_mgmt_flags;
} lmi_optmgmt_req_t;
@end verbatim
@end display

@subsubheading Parameters

The option management request service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Specifies the service primitive type.  Always @prim{LMI_OPTMGMT_REQ}.

@item lmi_opt_length
Specifies the length of the options.

@item lmi_opt_offset
Specifies the offset, from the beginning of the @msg{M_PROTO} message block, of the start of the options.

@item lmi_mgmt_flags
Specifies the management flags which determine what operation the LMS provider is expected to
perform on the specified options.  This field can assume one of the following values:

@table @pval

@item LMI_NEGOTIATE
Negotiate the specified value of each specified option and return the negotiated value.

@item LMI_CHECK
Check the validity of the specified value of each specified option and return the result.  Do not
alter the current value assumed by the LMS provider.

@item LMI_DEFAULT
Return the default value for the specified options (or all options).  Do not alter the current value
assumed by the LMS provider.

@item LMI_CURRENT
Return the current value for the specified options (or all options).  Do not alter the current value
assumed by the LMS provider.

@end table

@end table

@subsubheading State

This primitive is valid in any state where a local acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@subsubheading Response

The option management request service primitive requires the LMS provider to acknowledge receipt of
the primitive as follows:

@itemize @minus

@item @b{Successful}:
Upon success, the LMS provider acknowledges receipt of the service primitive and successful
completion of the options management service with an @prim{LMI_OPTMGMT_ACK} primitive containing the
options management result.  The state remains unchanged.

@item @b{Unsuccessful (non-fatal errors)}:
Upon failure, the LMS provider acknowledges receipt of the service primitive and failure to
complete the options management service with an @prim{LMI_ERROR_ACK} primitive containing the error.
The state remains unchanged.

@end itemize

@subsubheading Reasons for Failure

@b{Non-Fatal Errors}:  applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node LMI_OPTMGMT_ACK
@subsubsection LMI_OPTMGMT_ACK

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider upon successful completion of
the options management service.  It indicates the outcome of the options management operation
requested by the LMS user in a @prim{LMI_OPTMGMT_REQ} primitive.

@subsubheading Format
@tpindex lmi_optmgmt_ack_t

The option management acknowledgement service primitive consists of one @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_opt_length;
    lmi_ulong lmi_opt_offset;
    lmi_ulong lmi_mgmt_flags;
} lmi_optmgmt_ack_t;
@end verbatim
@end display

@subsubheading Parameters

The option management acknowledgement service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_OPTMGMT_ACK}.

@item lmi_opt_length
Indicates the length of the returned options.

@item lmi_opt_offset
Indicates the offset of the returned options from the start of the @msg{M_PCPROTO} message block.

@item lmi_mgmt_flags
Indicates the returned management flags.  These flags indicate the overall success of the options
management service.  This field can assume one of the following values:

@table @pval

@item LMI_SUCCESS
The LMS provider succeeded in negotiating or returning all of the options specified by the LMS
user in the @prim{LMI_OPTMGMT_REQ} primitive.

@item LMI_FAILURE
The LMS provider failed to negotiate one or more of the options specified by the LMS user.

@item LMI_PARTSUCCESS
The LMS provider negotiated a value of lower quality for one or more of the options specified by
the LMS user.

@item LMI_READONLY
The LMS provider failed to negotiate one ore more of the options specified by the LMS user because
the option is treated as read-only by the LMS provider.

@item LMI_NOTSUPPORT
The LMS provider failed to recognize one or more of the options specified by the LMS user.

@end table

@end table

@subsubheading State

This primitive is issued by the LMS provider in direct response to an @prim{LMI_OPTMGMT_REQ} primitive.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The LMS provider follows the following rules when processing option management service requests:

@itemize ---

@item
When the @parm{lmi_mgmt_flags} field in the @prim{LMI_OPTMGMT_REQ} primitive is set to @pval{LMI_NEGOTIATE},
the LMS provider will attempt to negotiate a value for each of the options specified in the
request.

@item
When the flags are @pval{LMI_DEFAULT}, the LMS provider will return the default values of the specified
options, or the default values of all options known to the LMS provider if no options were
specified.

@item
When the flags are @pval{LMI_CURRENT}, the LMS provider will return the current values of the specified
options, or all options.

@item
When the flags are @pval{LMI_CHECK}, the LMS provider will attempt to negotiate a value for each of the
options specified in the request and return the resulg of the negotiation, but will not affect the
current value of the option.

@end itemize

@page
@node Event Reporting Service Primitives
@subsection Event Reporting Service Primitives

The event reporting service primitives allow the LMS provider to indicate asynchronous errors,
events and statistics collection to the LMS user.

These service primitives implement the event reporting service (@pxref{Event Reporting Service}).

@menu
* LMI_ERROR_IND::
* LMI_STATS_IND::
* LMI_EVENT_IND::
@end menu

@node LMI_ERROR_IND
@subsubsection LMI_ERROR_IND

@subsubheading Description

This LMS provider originated service primitive is issued by the LMS provider when it detects and
asynchronous error event.  The service primitive is applicable to all styles of PPA.

@subsubheading Format
@tpindex lmi_error_ind_t

The error indication service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_errno;
    lmi_ulong lmi_reason;
    lmi_ulong lmi_state;
} lmi_error_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The error indication service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_ERROR_IND}.

@item lmi_errno
Indicates the LMI error number describing the error.  This field can have one of the following
values:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADADDRESS
Address was invalid.
@item LMI_BADADDRTYPE
Invalid address type.
@item LMI_BADDIAL
(Not used.)
@item LMI_BADDIALTYPE
(Not used.)
@item LMI_BADDISPOSAL
Invalid disposal parameter.
@item LMI_BADFRAME
Defective SDU received.
@item LMI_BADPPA
Invalid PPA identifier.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_WRITEFAIL
Unitdata request failed.
@item LMI_CRCERR
CRC or FCS error.
@item LMI_DLE_EOT
DLE EOT detected.
@item LMI_FORMAT
Format error detected.
@item LMI_HDLC_ABORT
Aborted frame detected.
@item LMI_OVERRUN
Input overrun.
@item LMI_TOOSHORT
Frame too short.
@item LMI_INCOMPLETE
Partial frame received.
@item LMI_BUSY
Telephone was busy.
@item LMI_NOANSWER
Connection went unanswered.
@item LMI_CALLREJECT
Connection rejected.
@item LMI_HDLC_IDLE
HDLC line went idle.
@item LMI_HDLC_NOTIDLE
HDLC link no longer idle.
@item LMI_QUIESCENT
Line being reassigned.
@item LMI_RESUMED
Line has been reassigned.
@item LMI_DSRTIMEOUT
Did not see DSR in time.
@item LMI_LAN_COLLISIONS
LAN excessive collisions.
@item LMI_LAN_REFUSED
LAN message refused.
@item LMI_LAN_NOSTATION
LAN no such station.
@item LMI_LOSTCTS
Lost Clear to Send signal.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@item lmi_reason

Indicates the reason for failure.  This field is protocol-specific.  When the @parm{lmi_errno} field
is @perr{LMI_SYSERR}, the @parm{lmi_reason} field is the UNIX error number as described in
@manref{errno(3)}.

@item lmi_state

Indicates the state of the LMS provider at the time that the primitive was issued.
This field can have one of the following values:

@table @psta
@item LMI_UNATTACHED
No PPA attached, awaiting @prim{LMI_ATTACH_REQ}.
@item LMI_ATTACH_PENDING
Waiting for attach.
@item LMI_UNUSABLE
Device cannot be used, STREAM in hung state.
@item LMI_DISABLED
PPA attached, awaiting @prim{LMI_ENABLE_REQ}.
@item LMI_ENABLE_PENDING
Waiting to send @prim{LMI_ENABLE_CON}.
@item LMI_ENABLED
Ready for use, awaiting primitive exchange.
@item LMI_DISABLE_PENDING
Waiting to send @prim{LMI_DISABLE_CON}.
@item LMI_DETACH_PENDING
Waiting for detach.
@end table

@end table

@subsubheading State

This primitive can be issued in any state for which a local acknowledgement is not pending.  The
LMS provider state at the time that the primitive was issued is indicated in the primitive.

@subsubheading New State

The new state remains unchanged.

@page
@node LMI_STATS_IND
@subsubsection LMI_STATS_IND

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to indicate a periodic
statistics collection event.  The service primitive is applicable to all styles of PPA.

@subsubheading Format
@tpindex lmi_stats_ind_t

The statistics indication service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_interval;
    lmi_ulong lmi_timestamp;
} lmi_stats_ind_t;
@end verbatim
@end display

Following this structure within the @msg{M_PROTO} message block is the provider-specific statistics.

@subsubheading Parameters

The statistics indication service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_STATS_IND}.

@item lmi_interval
Indicates the statistics collection interval to which the statistics apply.  This interval is
specified in milliseconds.

@item lmi_timestamp
Indicates the UNIX time (from epoch) at which statistics were collected.  The timestamp is given in
milliseconds from epoch.

@end table

@subsubheading State

This service primitive may be issued by the LMS provider in any state in which a local
acknowledgement is not pending.

@subsubheading New State

The new state remains unchanged.

@page
@node LMI_EVENT_IND
@subsubsection LMI_EVENT_IND

@subsubheading Description

This LMS provider originated primitive is issued by the LMS provider to indicate an asynchronous
event.  The service primitive is applicable to all styles of PPA.

@subsubheading Format
@tpindex lmi_event_ind_t

The event indication service primitive consists of one @msg{M_PROTO} message block, structured as follows:

@display
@verbatim
typedef struct {
    lmi_long lmi_primitive;
    lmi_ulong lmi_objectid;
    lmi_ulong lmi_timestamp;
    lmi_ulong lmi_severity;
} lmi_event_ind_t;
@end verbatim
@end display

Following this structure within the @msg{M_PROTO} message block is the provider-specific event
information.

@subsubheading Parameters

THe event indication service primitive contains the following parameters:

@table @parm

@item lmi_primitive
Indicates the service primitive type.  Always @prim{LMI_EVENT_IND}.

@item lmi_objectid
Indicates the provider-specific object identifier that identifies the managed object to which the
event is associated.

@item lmi_timestamp
Indicates the UNIX time from epoch (in milliseconds).

@item lmi_severity
Indicates the provider-specific severity of the event.

@end table

@subsubheading State

This service primitive can be issued by the LMS provider in any state where a local
acknowledgement is not pending.  Normally the LMS provider must be in the @psta{LMI_ENABLED} state for
event reporting to occur.

@subsubheading New State

The new state remains unchanged.

@page
@node Protocol Service Primitives
@section Protocol Service Primitives

The protocol service primitives implement the services of the DAEDT, DAEDR, AERM, SUERM/EIM and a
provider specific receive congestion function, including power on, initial alignment support, error
rate monitoring, receive cnogestion detection, and data transfer.

These service primitives implement the protocol services (@pxref{Protocol Services}).

@menu
* Power On Service Primitives::
* Data Transfer Service Primitives::
* Initial Alignment Service Primitives::
* Error Rate Monitoring Service Primitives::
* Receive Congestion Service Primitives::
@end menu

@node Power On Service Primitives
@subsection Power On Service Primitives

The power on service primitives provide the ability for the SDTS user to power on the DAEDR and
DAEDT functions within the SDTS provider.

These service primitives implement the power on service (@pxref{Power On Service}).

@menu
* SDT_DAEDT_START_REQ::
* SDT_DAEDR_START_REQ::
@end menu

@node SDT_DAEDT_START_REQ
@subsubsection SDT_DAEDT_START_REQ

@subsubheading Description

The DAEDT start request service primitive is originated by the SDTS user when it wishes to start the
transmitters as part of a power-on sequence.  Once started, the transmitters cannot be stopped under
protocol control.

@subsubheading Format
@tpindex sdt_daedt_start_req_t

The DAEDT start request service primitive consists of one @msg{M_PROTO} message block, formatted as
follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_daedt_start_req_t;
@end verbatim
@end display

@subsubheading Parameters

The DAEDT start request service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_DAEDT_START_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and is valid when the DAEDT
is in the @psta{IDLE} state.

@subsubheading New State

The new DAEDT state is the @psta{IN-SERVICE} state.

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The link state is
unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

When the terminal is in the @psta{LMI_ENABLED} management state and the DAEDT is already in the
@psta{IN-SERVICE} state, this primitive should be ignored and the SDTS provider should @emph{not}
generate a non-fatal error.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SDT_DAEDR_START_REQ
@subsubsection SDT_DAEDR_START_REQ

@subsubheading Description

The DAEDR start request service primitive is originated by the SDTS user when it wishes to start the
receivers as part of a power-on sequence.  Once started, the receivers cannot be stopped under
protocol control.  This primitive is a request from the Reception Control (RC) function in the SDTS
user to the DAEDR function in the SDTS provider.

@subsubheading Format
@tpindex sdt_daedr_start_req_t

The DAEDR start request service primitive consists of one @msg{M_PROTO} message block, formatted as
follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_daedr_start_req_t;
@end verbatim
@end display

@subsubheading Parameters

The DAEDR start request service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_DAEDR_START_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and is valid when the DAEDR
is in the @psta{IDLE} state.

@subsubheading New State

The new DAEDR state is the @psta{IN-SERVICE} state.

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The link state is
unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

When the terminal is in the @psta{LMI_ENABLED} management state and the DAEDR is already in the
@psta{IN-SERVICE} state, this primitive should be ignored and the SDTS provider should @emph{not}
generate a non-fatal error.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node Data Transfer Service Primitives
@subsection Data Transfer Service Primitives

The data transfer service primitives provide the means for transfering data between SDTS users
across a signalling data link.  Data is sent and received in signal units.  Signal units are the
data contained in frames that occur between flags on the line excluding the checksum octets.  These
are packets of data that contain an integer number of octets (a multiple of 8 bits).  When
performing data transfer, signal units that are correctly received on the signalling data link are
delivered to the SDTS user as they arrive.  Signal units for transmission are delivered to the SDTS
provider on demand, however, during quiescent periods it is sometimes advantageous from the point of
view of synchronous driver design to request trasnmission of additional signal units in a @dfn{pull}
arrangement rather than a @dfn{push} arrangement.  Therefore there is a primitive to allow the SDTS
provider to  request additional data for trasnsmission.

These service primitives implement the data transfer service (@pxref{Data Transfer Service}).

@menu
* SDT_DAEDT_TRANSMISSION_REQ::
* SDT_RC_SIGNAL_UNIT_IND::
* SDT_TXC_TRANSMISSION_REQUEST_IND::
@end menu

@node SDT_DAEDT_TRANSMISSION_REQ
@subsubsection SDT_DAEDT_TRANSMISSION_REQ

@subsubheading Description

The DAEDT transmission request service primitive is originated by the SDTS user to request that the
SDTS provider trasnmit a signal unit on the medium.  A signal unit is a self-contained packet of
data containing an integer number of octets of information.  This primitive is a request from the
Transmission Control (TXC) function in the SDTS user to the DAEDT function in the SDTS provider.

@subsubheading Format
@tpindex sdt_daedt_transmission_req_t

The DAEDT transmission request service primitive consists of zero or one @msg{M_PROTO} message
block, followed by one or more @msg{M_DATA} message blocks containing the signal unit to transmit.
The @msg{M_PROTO} mesage block, when present, is structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_daedt_transmission_req_t;
@end verbatim
@end display

@subsubheading Parameters

The DAEDT transmission request service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_DAEDT_TRANSMISSION_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state with the DAEDT in the
@psta{IN-SERVICE} state.

@subsubheading New State

The new state is unchanged.

@subsubheading Rules

The SDTS user must observe the following rules when issuing the DAEDT transmission request service
primitive:

@itemize ---

@item
This primitive should only be issued by the SDTS provider after the transmitters have been enabled
with a @prim{SDT_DAEDT_START_REQ} and the DAEDT is in the @psta{IN-SERVICE} state.

@item
After the transmitter have been enabled while in the @psta{LMI_ENABLED} management state, the
DAEDT state is always appropriate for the SDTS user to issue this primitive.

@item
The @msg{M_PROTO} message block is optional.  The SDTS provider will be prepared to accept
@msg{M_DATA} message blocks from the SDTS user, without any @msg{M_PROTO} message block, as service
primitive of this type.

@item
Most narrowband SS7 SDTS providers peform what is known as SU repetition.  When SUs that correspond
to FISUs (Fill-In Signal Units) or LSSUs (Link Status Signal Units) which are sent continuously on
the signalling link, the SDTS user need only send the first such signal unit.  The SDTS provider
will continuously repeat a FISU or LSSU, when appropriate,@footnote{Note that the only LSSU that is
not repeated continuously is the SIB.} until the next signal unit is presented for transmission.  To
perform this function, a narrowband SS7 SDTS provider must know the protocol options associated with
the signalling link (i.e. the size of the sequence numbers and length indicator).

Activate or deactivation of @dfn{SU Repeating} is a provider-specific function.

@end itemize

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The link state is
unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

When the terminal is in the @psta{LMI_ENABLED} management state, but the DAEDT is still in the
@psta{IDLE} state, the primitive should be ignored and the corresponding data discarded without
generating a non-fatal error.


@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SDT_RC_SIGNAL_UNIT_IND
@subsubsection SDT_RC_SIGNAL_UNIT_IND

@subsubheading Description

The RC signal unit indication service primitive is issued by the SDTS provider when a signal unit
arrives on the signalling data link and passes error detection.  The primitive is named the
@samp{RC} signal unit indication because this signal is normally sent to reception control (RC)
within the SS7 Level 2 state machine.  This primitive is an indication from the DAEDR function in
the SDTS provider to the Reception Control (RC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_rc_signal_unit_ind_t

The RC signal unit indication service primtive consists of one optional @msg{M_PROTO} message block
followed by one or more @msg{M_DATA} message blocks containing the receive signal unit.  The
@msg{M_PROTO} message block, when present, is structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
    sdt_ulong sdt_count;
} sdt_rc_signal_unit_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The RC signal unit indication service primtive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_RC_SIGNAL_UNIT_IND}.

@item sdt_count
When signal unit compression is in effect, this field contains a count of the number of compressed
identical signal units (not counting the original).  When signal unit compression is not in effect,
or the signal unit was not compressed (it was not repeated on the line), this field is set to the
value 0.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state.

@subsubheading New State

The state remains unchanged.

@subsubheading Rules

The SDTS provider observes the following rules when generating the RC signal unit indication
primitive:

@itemize ---

@item
The primitive is only issued when the signalling data terminal is in the @psta{LMI_ENABLED}
management state.

@item
Received signal units are indicated only after the receivers have been enabled using the
@prim{SDT_DAEDR_START_REQ} command and the DAEDR is in the @psta{IN-SERVICE} state.

@item
Once the SDTS user is receiving signal units, it will continue to do so until a fatal error occurs,
the stream is closed, or the signalling data terminal is disabled with the
@prim{LMI_DISABLE_REQ} primitive.

@item
The @msg{M_PROTO} message block is optional and is only really required for indicating the count of
compressed signal units.  When signal unit compression is not in effect, or when a signal unit is
not compressed (i.e. has a @parm{sdt_count} of zero), the @msg{M_PROTO} message block is
unnecessary and SDTS providers are encouraged to not include it.  When the @msg{M_PROTO} message
block is not included, the signal unit is delivered simply as a chain of one or more @msg{M_DATA}
message blocks to the SDTS user.  The SDTS user must be prepared to receive RC signal unit
indications consisting of only @msg{M_DATA} message blocks.

@item
Most narrowband SS7 SDTS providers provider for signal unit compression.  Under this scheme, the
first non-identical signal unit is indicated with a @parm{sdt_count} of zero.  Should additional
identical signal units be received, the will be counted until another non-identical signal unit is
received.  At that point, an RC signal unit indication with a @parm{sdt_count} indicating the
number of compressed signal units is indicated followed by an indication of the new non-identical
signal unit with a @parm{sdt_count} of zero.  And the cycle repeats.

To support this feature, SDTS users must be prepared to accept a compressed frame representing all
of the contiguous identical signalling units in this fashion.  For example, the SDTS user cannot
rely by its design on the third identical signal unit causing a state transsition in a timely
manner.

@item
Invocation and applicability of a signal unit compression feature is provider-specific.  So, for
example, Q.703 drivers use FISU and LSSU compression techniques, whereas, M2PA (RFC 4165) does not
require them.

@end itemize

@subsubheading Response

This primitive does not require a response from the SDTS user.

@page
@node SDT_TXC_TRANSMISSION_REQUEST_IND
@subsubsection SDT_TXC_TRANSMISSION_REQUEST_IND

@subsubheading Description

The TXC transmission request indication service primitive is originated by the SDTS provider to
indicate that if a signal unit is not available for transmission that the signalling terminal will
idle the signalling data link.  Depending on the specific SDTS provider, idling the signalling data
link may consist of idling continuous flags, FISUs or LSSUs.  This indication provides timing ques
to the SDTS user.  This primitive is an indication from the DAEDT function in the SDTS provider to
the Transmission Control (TXC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_txc_transmission_request_ind_t

The TXC transmission request indication service primitive consists of one @msg{M_PROTO} message
block, structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_txc_transmission_request_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The TXC transmission request indication service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_TXC_TRANSMISSION_REQUEST_IND}.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state and when the DAEDT is
in the @psta{IN-SERVICE} state.

@subsubheading New State

The new state is unchanged.

@subsubheading Rules

The SDTS provider observes the following rules when issuing the TXC transmission request indication
service primitive:

@itemize ---

@item
This service primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED}
management state.

@item
This service primitive is only issued when the DAEDT is in the @psta{IN-SERVICE} state; that is, a
@prim{SDT_DAEDT_START_REQ} primitive has been received by the SDTS provider for the signalling
terminal.

@item
This service primitive is only issued by the SDTS provider when its transmission queue is empty.

@item
This service primitive is only issued by the SDTS provider when the provider is configured to
generate these indications.  Configuration of the SDTS provider is a provider-specific matter.

@end itemize


@subsubheading Response

This primitive does not require a specific response from the SDTS user.  Upon receiving this
primitive, if the SDTS user does not wish the signalling data link to idle flags, FISUs or LSSUs, it
should generate another trasnmission request using the @prim{SDT_DAEDT_TRANSMISSION_REQ}
primitive.

@page
@node Initial Alignment Service Primitives
@subsection Initial Alignment Service Primitives

The initial alignment service primitives peform the functions of the Alignment Error Rate Monitor
(AERM).  They provide the SDTS user with the ability to start and stop the AERM, set normal or
emergency proving periods, and receive correct signal unit indications and indications that the
error rate has exceeded the threshold.

Not all SDTS providers implement nor require an AERM function.  For example, broadband signalling
links can be configured to not perform proving, in which case the AERM function is not necessary.
Regardless of whether the AERM function is necessary or not, each SDTS provider should be prepared
to handle requests and generate appropriate indications as though an AERM function existed, and
without generating non-fatal errors.

Note that some designs do no permit the AERM function and the SUERM or EIM function to be active
simultaneously.

These service primitives implement the initial alignment service (@pxref{Initial Alignment
Service}).

@menu
* SDT_AERM_START_REQ::
* SDT_AERM_SET_TI_TO_TIN_REQ::
* SDT_AERM_SET_TI_TO_TIE_REQ::
* SDT_IAC_CORRECT_SU_IND::
* SDT_IAC_ABORT_PROVING_IND::
* SDT_AERM_STOP_REQ::
@end menu

@node SDT_AERM_START_REQ
@subsubsection SDT_AERM_START_REQ

@subsubheading Description

The AERM start request service primitive is originated by the SDTS use to request that the Alignment
Error Rate Monitor be started.  This primitive is a request from the Initial Alignment Control (IAC)
function in the SDTS user to the AERM function in the SDTS provider.

@subsubheading Format
@tpindex sdt_aerm_start_req_t

The AERM start request service primitive consists of one @msg{M_PROTO} message block, structured
as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_aerm_start_req_t;
@end verbatim
@end display

@subsubheading Parameters

The AERM start request service primitive containst the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_AERM_START_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state and valid when the DAEDR
function is in the @psta{IN-SERVICE} state and the AERM function is in the @psta{IDLE} state.

@subsubheading New State

The new state of the AERM function is the @psta{IN-SERVICE} state.

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The AERM function is moved
to the @psta{IN-SERVICE} state.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

When the signalling terminal is in the @psta{LMI_ENABLED} management state, the DAEDR is in the
@psta{IN-SERIVCE} state and the AERM is already in the @psta{IN-SERVICE} state, this service
primitive should be ignored without generating a non-fatal error.  Some STDS providers may generate
a non-fatal error when the SUERM/EIM function is not in the @psta{IDLE} state.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SDT_AERM_SET_TI_TO_TIN_REQ
@subsubsection SDT_AERM_SET_TI_TO_TIN_REQ

@subsubheading Description

The AERM set Ti to Tin request service primitive is originated by the SDTS user to request that the
normal proving period be used for the current or next initial alignment error rate monitoring.  This
primitive is a request from the Initial Alignment Control (IAC) function in the SDTS user to the
AERM function in the SDTS provider.

@subsubheading Format
@tpindex sdt_aerm_set_ti_to_tin_req_t

The AERM set Ti to Tin request service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_aerm_set_ti_to_tin_req_t;
@end verbatim
@end display

@subsubheading Parameters

The AERM set Ti to Tin request service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_AERM_SET_TI_TO_TIN_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state but may be issued in any
signalling terminal state.

@subsubheading New State

The new state remains unchanged and normal proving is asserted.

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The link state is
unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SDT_AERM_SET_TI_TO_TIE_REQ
@subsubsection SDT_AERM_SET_TI_TO_TIE_REQ

@subsubheading Description

The AERM set Ti to Tie request service primitive is originated by the SDTS user to request that the
emergency proving period be used for the current or next initial alignment error rate monitoring.
This primitive is a request from the Initial Alignment Control (IAC) function in the SDTS user to
the AERM function in the SDTS provider.

@subsubheading Format
@tpindex sdt_aerm_set_ti_to_tie_req_t

The AERM set Ti to Tie request service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_aerm_set_ti_to_tie_req_t;
@end verbatim
@end display

@subsubheading Parameters

The AERM set Ti to Tie request service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_AERM_SET_TI_TO_TIE_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state but may be issued in any
signalling terminal state.

@subsubheading New State

The new state is unchanged and emergency proving is asserted.

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The link state is
unchanged.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SDT_IAC_CORRECT_SU_IND
@subsubsection SDT_IAC_CORRECT_SU_IND

@subsubheading Description

The IAC correct SU indication service primitive is issued by the SDTS provider during the intial
alignment phase to indicate that a correct signal unit has been received.  Some STDS user state
machines require this primitive; others can use the @prim{SDT_RC_SIGNAL_UNIT_IND} primitive
in its stead.  This primitive is an indication from the AERM function in the SDTS provider to the
Initial Alignment Control (IAC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_iac_correct_su_ind_t

The IAC correct SU indication service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_iac_correct_su_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The IAC correct SU indication service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_IAC_CORRECT_SU_IND}.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state and when the DAEDR
function is in the @psta{IN-SERVICE} state and the AERM function is in the @psta{IN-SERVICE} state.
It is only issued for the first correct signal unit received in this total state.

@subsubheading New State

The new state remains unchanged.

@subsubheading Rules

The SDTS provider observes the following rules when issuing the IAC correct SU indication service
primitive:

@itemize ---

@item
The primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED} management
state.

@item
The primitive is only issued when the DEADR function is in the @psta{IN-SERVICE} state.

@item
The primitive is only issued when the AERM function is in the @psta{IN-SERVICE} state.

@item
The primitive is only issued for the first correct signal unit that is received in the appropriate
states.

@item
Whether the primitive is issued in the appropriate state is SDTS provider-specific.  Some SDTS
providers may need configuration options set before this primitive will be issued.  The SDTS user
should be prepared to use a @prim{SDT_RC_SIGNAL_UNIT_IND} primitive in its stead.

@end itemize

@subsubheading Response

This primitive does not require a specific response from the SDTS user.

@page
@node SDT_IAC_ABORT_PROVING_IND
@subsubsection SDT_IAC_ABORT_PROVING_IND

@subsubheading Description

The IAC abort proving indication service primitive is issued by the SDTS provider to indicate that
the error rate experience on the signalling data link has exceeded the operating threshold.  This
primitive is an indication from the AERM function in the SDTS provider to the Initial Alignment
Control (IAC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_iac_abort_proving_ind_t

The IAC abort proving indication service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_iac_abort_proving_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The IAC abort proving indication service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_IAC_ABORT_PROVING_IND}.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state with the DAEDR function
in the @psta{IN-SERIVCE} state and the AERM function in the @psta{IN-SERVICE} state.

@subsubheading New State

The new AERM state is @psta{IDLE}.

@subsubheading Rules

The SDTS provider observes the following rules when issuing the IAC abort proving indication service
primitive:

@itemize ---

@item
The primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED} management
state.

@item
The primitive is only issued when the DAEDR function is in the @psta{IN-SERVICE} state.

@item
The primitive is only issued when the AERM function is in the @psta{IN-SERVICE} state.  After
issuing the primitive the AERM is placed into the @psta{IDLE} state.

@item
The primitive is only issued from the appropriate state when the error rate is detected as exceeding
the operating threshold.  The setting of the operating threshold is a SDTS provider-specific
configuration matter.

@item
Not all SDTS providers have a fully functional AERM.  Some providers may never issue this
primitive.

@end itemize

@subsubheading Response

This primitive does not require a response from the SDTS user.

@page
@node SDT_AERM_STOP_REQ
@subsubsection SDT_AERM_STOP_REQ

@subsubheading Description

The AERM stop request service primitive is originated by the SDTS user to request that the AERM
function be stopped (moved to the @psta{IDLE} state).
This primitive is a request from the Initial Alignment Control (IAC) function in the SDTS user to
the AERM function in the SDTS provider.

@subsubheading Format
@tpindex sdt_aerm_stop_req_t

The AERM stop request service primitive consists of one @msg{M_PROTO} message block, structured as
follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_aerm_stop_req_t;
@end verbatim
@end display

@subsubheading Parameters

The AERM stop request service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_AERM_STOP_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state with the DAEDR function in
the @psta{IN-SERVICE} state and the AERM function in the @psta{IN-SERVICE} state.

@subsubheading New State

The new state of the AERM function is the @psta{IDLE} state.

@subsubheading Response

This primitive does not require receipt acknowledgement.

@itemize @minus

@item @b{Successful:}
When successful, the primitive does not require receipt acknowledgement.  The AERM state is moved to
the @psta{IDLE} state.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider negatively acknowledges the primitive using a
@prim{LMI_ERROR_ACK} primitive containing the error and reason for failure.  The state remains
unchanged.

@end itemize

When the signalling terminal is in the @psta{LMI_ENABLED} management state and the AERM function
is already in the @psta{IDLE} state, this primitive should be ignored and no non-fatal error
generated.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event occurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_INITFAILED
Link initialization failed.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node Error Rate Monitoring Service Primitives
@subsection Error Rate Monitoring Service Primitives

The error rate monitoring service primitives perform the functions of the Signal Unit Error Rate
Monitor (SUERM) or Errored Interval Monitor (EIM).  They provide the SDTS user with the ability to
start and stop the SUERM/EIM, and receive indications that the error rate has exceeded the operating
threshold.

Not all SDTS providers implement nor require a SUERM/EIM function.  Regardless of whether the
SUERM/EIM function is necessary or not, each SDTS provider should be prepared to handle requests and
generate appropriate indications as though a SUERM or EIM function existed, and without generating
non-fatal errors.

Note that some designs do no permit the AERM function and the SUERM or EIM function to be active
simultaneously.

These service primitives implement the error rate monitoring service (@pxref{Error Rate Monitoring
Service}).

@menu
* SDT_SUERM_START_REQ::
* SDT_LSC_LINK_FAILURE_IND::
* SDT_SUERM_STOP_REQ::
@end menu

@node SDT_SUERM_START_REQ
@subsubsection SDT_SUERM_START_REQ

@subsubheading Description

This SDTS user originated primitive is used to start the Signal Unit Error Rate Monitor (SUERM) or
Errorred Interval Monitor (EIM) service.
This primitive is a request from the Link State Control (LSC) function in the SDTS user to the
SUERM/EIM function in the SDTS provider.

@subsubheading Format
@tpindex sdt_suerm_start_req_t

The SUERM start service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_suerm_start_req_t;
@end verbatim
@end display

@subsubheading Parameters

The SUERM start service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_SUERM_START_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state, when the DAEDR is in the
@psta{IN-SERVICE} state, when the AERM is in the @psta{IDLE} state and when the SUERM/EIM is in the
@psta{IDLE} state.

@subsubheading New State

The new management state remains unchanged.  The state of the SUERM is moved to @psta{IN-SERVICE}
state.

@subsubheading Response

This service primitive is not acknowledged, but can cause a non-fatal error as follows:

@itemize @minus

@item @b{Successful:}
When successful, the primitive is not acknowledged.  The SUERM/EIM function is moved to the
@psta{IN-SERVICE} state.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider responds with a @prim{LMI_ERROR_ACK} primitive containing
the error.

@end itemize

When the signalling terminal is in the @psta{LMI_ENABLED} state and the SUERM/EIM function is
already in the @psta{IN-SERVICE} state, this primitive should be ignored without generating a
non-fatal error.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event ocurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_FORMAT
Format error detected.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node SDT_LSC_LINK_FAILURE_IND
@subsubsection SDT_LSC_LINK_FAILURE_IND

@subsubheading Description

This SDTS provider originated primitive is issued by the SDTS provider while the SUERM/EIM service
is active to indicate that the error rate monitor has detected errors that exceed the configured
threshold and that the link should be failed for execessive errors.
This primitive is an indication from the SUERM/EIM function in the SDTS provider to the Link State
Control (LSC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_lsc_link_failure_ind_t

The link failure indication service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO}
message block, structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_lsc_link_failure_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The link failure service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_LSC_LINK_FAILURE_IND}.

@end table

@subsubheading State

This primitive will only be issued when the signalling terminal is in the @psta{LMI_ENABLED}
management state and the SUERM/EIM is in the @psta{IN-SERVICE} state.

@subsubheading New State

The new state for the SUERM is the @psta{IDLE} state.

@subsubheading Rules

The following rules apply to the link failure indication service primitive:

@itemize ---

@item
The SDTS provider will only issue an @prim{SDT_LSC_LINK_FAILURE_IND} primitive while the
SUERM or EIM is in the @psta{IN-SERVICE} state and the monitored error rate exceeds the operating
threshold configured for the error monitor.  After issuing the primitive, the SUERM is placed in the
@psta{IDLE} state.

@item
Not all STDS providers have a fully functional SUERM/EIM.  Some providers may never issue this
primitive.

@end itemize

@subsubheading Response

This primitive does not require a response from the SDTS user.

@page
@node SDT_SUERM_STOP_REQ
@subsubsection SDT_SUERM_STOP_REQ

@subsubheading Description

This SDTS user originated primitive is used to stop the Signal Unit Error Rate Monitor (SUERM) or Errorred
Interval Monitor (EIM) service.
This primitive is a request from the Link State Control (LSC) function in the SDTS user to the
SUERM/EIM function in the SDTS provider.

@subsubheading Format
@tpindex sdt_suerm_stop_req_t

The SUERM stop service primitive consists of one @msg{M_PROTO} or @msg{M_PCPROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_suerm_stop_req_t;
@end verbatim
@end display

@subsubheading Parameters

The SUERM stop service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Specifies the service primitive type.  Always @prim{SDT_SUERM_STOP_REQ}.

@end table

@subsubheading State

This primitive is only valid in the @psta{LMI_ENABLED} management state, and when the SUERM/EIM is
in the @psta{IN-SERVICE} state.

@subsubheading New State

The state of the SUERM/EIM is moved to @psta{IDLE} state.

@subsubheading Response

This service primitive is not acknowledged, but can cause a non-fatal error as follows:

@itemize @minus

@item @b{Successful:}
When successful, the primitive is not acknowledged.  The SUERM function is moved to the @psta{IDLE}
state.

@item @b{Unsuccessful (non-fatal errors):}
When unsuccessful, the SDTS provider responds with a @prim{LMI_ERROR_ACK} primitive containing
the error.  The state remains unchanged.

@end itemize

When the signalling terminal is in the @psta{LMI_ENABLED} management state and the SUERM/EIM is
already in the @psta{IDLE} state, this primitive should be ignored without generating a non-fatal
error.

@subsubheading Reason for Failure

@b{Non-Fatal Errors:} applicable non-fatal errors are as follows:

@table @perr

@item LMI_UNSPEC
Unknown or unspecified.
@item LMI_BADPRIM
Unrecognized primitive.
@item LMI_DISC
Disconnected.
@item LMI_EVENT
Protocol-specific event ocurred.
@item LMI_FATALERR
Device has become unusable.
@item LMI_NOTSUPP
Primitive not supported by this device.
@item LMI_OUTSTATE
Primitive was issued from invalid state.
@item LMI_PROTOSHORT
@msg{M_PROTO} block too short.
@item LMI_SYSERR
UNIX system error.
@item LMI_FORMAT
Format error detected.
@item LMI_DEVERR
Start of device-specific error codes.

@end table

@page
@node Receive Congestion Service Primitives
@subsection Receive Congestion Service Primitives

The receive congestion service primitives provide the SDTS user with the ability to be informed by
the SDTS provider when it detects receive congestion conditions and can determine a receive
congestion policy.  Receive congestion is a provider-specific matter.  The SDTS user is also
capable of detecting receive congestion without the assistance of these primitives.  They are used
to indicate receive congestion to the SDTS user that can only be detected within the SDTS provider. 

These service primitives implement the receive congestion service (@pxref{Receive Congestion
Service}).

@menu
* SDT_RC_CONGESTION_ACCEPT_IND::
* SDT_RC_CONGESTION_DISCARD_IND::
* SDT_RC_NO_CONGESTION_IND::
@end menu

@node SDT_RC_CONGESTION_ACCEPT_IND
@subsubsection SDT_RC_CONGESTION_ACCEPT_IND

@subsubheading Description

The RC convestion accept indication service primitive is indicated by the SDTS provider when it is
experiencing receive congestion but signal units continue to be delivered by the SDTS provider.
This primitive is an indication from a provider-specific function in the SDTS provider to the
Reception Control (RC) function in the SDTS user. 

@subsubheading Format
@tpindex sdt_rc_congestion_accept_ind_t

The RC congestion accept indication service primtive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_rc_congestion_accept_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The RC congestion accept indication service primtive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_RC_CONGESTION_ACCEPT_IND}.

@end table

@subsubheading State

This primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED} management
state and the DAEDR function is in the @psta{IN-SERVICE} state.

@subsubheading New State

The receive congestion state is moved to @psta{CONGESTION-ACCEPT}.

@subsubheading Rules

The SDTS provider observes the following rules when issuing the RC congestion accept service
primitive:

@itemize ---

@item
This primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED} management
state, the DAEDR function is in the @psta{IN-SERVICE} state, and the SDTS provider has detected
receive congestion but is not discarding signal units.

@item
Not all SDTS providers have a fully functional receive congestion function.  Some SDTS providers
may never generate this primitive.

@end itemize

@subsubheading Response

This primitive does not require a response from the SDTS user.

@page
@node SDT_RC_CONGESTION_DISCARD_IND
@subsubsection SDT_RC_CONGESTION_DISCARD_IND

@subsubheading Description

The RC convestion discard indication service primitive is indicated by the SDTS provider when it is
experiencing receive congestion and signal units are being discarded by the SDTS provider.
This primitive is an indication from a provider-specific function in the SDTS provider to the
Reception Control (RC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_rc_congestion_discard_ind_t

The RC congestion discard indication service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_rc_congestion_discard_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The RC congestion discard indication service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_RC_CONGESTION_DISCARD_IND}.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state.

@subsubheading New State

The receive congestion state is moved to @psta{CONGESTION-DISCARD}.

@subsubheading Rules

The SDTS provider observes the following rules when issuing the RC congestion discard service
primitive:

@itemize ---

@item
This primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED} management
state, the DAEDR function is in the @psta{IN-SERVICE} state, and the SDTS provider has detected
receive congestion and is discarding signal units.

@item
Not all SDTS providers have a fully functional receive congestion function.  Some SDTS providers
may never generate this primitive.

@end itemize

@subsubheading Response

This primitive does not require a response from the SDTS user.

@page
@node SDT_RC_NO_CONGESTION_IND
@subsubsection SDT_RC_NO_CONGESTION_IND

@subsubheading Description

This SDTS provider originated primitive
This primitive is an indication from a provider-specific function in the SDTS provider to the
Reception Control (RC) function in the SDTS user.

@subsubheading Format
@tpindex sdt_rc_no_congestion_ind_t

The RC no congestion indication service primitive consists of one @msg{M_PROTO} message block,
structured as follows:

@display
@verbatim
typedef struct {
    sdt_long sdt_primitive;
} sdt_rc_no_congestion_ind_t;
@end verbatim
@end display

@subsubheading Parameters

The RC no congestion indication service primitive contains the following parameters:

@table @parm

@item sdt_primitive
Indicates the service primitive type.  Always @prim{SDT_RC_NO_CONGESTION_IND}.

@end table

@subsubheading State

This primitive is only issued from the @psta{LMI_ENABLED} management state.

@subsubheading New State

The receive congestion state is moved to @psta{NO-CONGESTION}.

@subsubheading Rules

The SDTS provider observes the following rules when issuing the RC no congestion service
primitive:

@itemize ---

@item
This primitive is only issued when the signalling terminal is in the @psta{LMI_ENABLED} management
state, the DAEDR function is in the @psta{IN-SERVICE} state, and the SDTS provider has detected
that receive congestion has abated.

@item
Not all SDTS providers have a fully functional receive congestion function.  Some SDTS providers
may never generate this primitive.

@end itemize

@subsubheading Response

This primitive does not require a response from the SDTS user.


@node Diagnostics Requirements
@chapter Diagnostics Requirements

Two error handling facilities should be provided to the SDTS user: one to handle non-fatal errors,
and the other to handle fatal errors.

@section Non-Fatal Error Handling Facility

These are errors that do not change the state of the SDTS interface as seen by the SDTS user and
provide the user with the option of reissuing the SDT primitive with the corrected options
specification.  The non-fatal error handling is provided only to those primitives that require
acknowledgements, and uses the @prim{LMI_ERROR_ACK} to report these errors.  These errors retain the
state of the SDTS interface the same as it was before the SDT provider received the primitive that
was in error.  Syntax errors and rule violations are reported via the non-fatal error handling
facility.

@section Fatal Error Handling Facility

These errors are issued by the SDT provider when it detects errors that are not correctable by the
SDT user, or if it is unable to report a correctible error to the SDTS user.  Fatal errors are
indicated via the STREAMS message type @code{M_ERROR} with the UNIX system error @code{EPROTO}.  The
@code{M_ERROR} STREAMS message type will result in the failure of all the UNIX system calls on the
stream.  The SDTS user can recover from a fatal error by having all the processes close the files
associated with the stream, and then reopening them for processing.

@ignore
@node Addendum for ITU-T Q.703 Conformance
@unnumbered Addendum for ITU-T Q.703 Conformance

@node Addendum for ANSI T1.111.3 Conformance
@unnumbered Addendum for ANSI T1.111.3 Conformance

@node Addendum for ETSI ETS 300 008-1 Conformance
@unnumbered Addendum for ETSI ETS 300 008-1 Conformance

@node Mapping of SDTI Primitives to ITU-T Q.703
@appendix Mapping of SDTI Primitives to ITU-T Q.703

@node Mapping of SDTI Primitives to ANSI T1.111.3
@appendix Mapping of SDTI Primitives to ANSI T1.111.3

@node State/Event Tables
@appendix State/Event Tables

@node Primitive Precedence Tables
@appendix Primitive Precedence Tables
@end ignore

@node LMI Header File Listing
@appendix LMI Header File Listing

@noindent
@smallformat
@verbatiminclude lmi.h
@end smallformat

@node SDTI Header File Listing
@appendix SDTI Header File Listing

@noindent
@smallformat
@verbatiminclude sdti.h
@end smallformat

@node License
@unnumbered License

@menu
* GNU Free Documentation License::
@end menu

@include texi/fdl.texi

@node Glossary
@unnumbered Glossary

@table @emph

@item Signalling Data Terminal Service Data Unit

A grouping of SDT user data whose boundaries are preserved from one end of the signalling data terminal
connection to the other.

@item Data transfer

The phase in connection and connectionless modes that supports the transfer of data between to
signalling data terminal users.

@item SDT provider

The signalling data terminal layer protocol that provides the services of the signalling data terminal
interface.

@item SDT user

The user-level application or user-level or kernel-level protocol that accesses the services of the
signalling data terminal layer.

@item Local management

The phase in connection and connectionless modes in which a SDT user initializes a stream and
attaches a PPA address to the stream.  Primitives in this phase generate local operations only.

@item PPA

The point at which a system attaches itself to a physical communications medium.

@item PPA identifier

An identifier of a particular physical medium over which communication transpires.
@end table

@node Acronyms
@unnumbered Acronyms

@multitable {LMS Provider}{International Telecommunication Union - Telecom Sector}
@item AERM @tab Alignment Error Rate Monitor
@item CC @tab Congestion Control
@item DAEDR @tab Delimitation Alignment and Error Detection (Receive)
@item DAEDT @tab Delimitation Alignment and Error Detection (Transmit)
@item EIM @tab Errored Interval Monitor
@item IAC @tab Initial Alignment Control
@item ITU-T @tab International Telecommunications Union - Telecom Sector
@item LMS Provider @tab A provider of Local Management Services
@item LMS @tab Local Management Service
@item LMS User @tab A user of Local Management Services
@item LM @tab Local Management
@item LSC @tab Link State Control
@item PPA @tab Physical Point of Attachment
@item RC @tab Reception Control
@item SDLI @tab Signalling Data Link Interface
@item SDL SDU @tab Signalling Data Link Service Data Unit
@item SDLS @tab Signalling Data Link Service
@item SDL @tab Signalling Data Link
@item SDTI @tab Signalling Data Terminal Interface
@item SDTS @tab Signalling Data Terminal Service
@item SDT @tab Signalling Data Terminal
@item SLI @tab Signalling Link Interface
@item SLS @tab Signalling Link Service
@item SL @tab Signalling Link
@item SL @tab Signalling Link
@item SS7 @tab Signalling System No. 7
@item TXC @tab Transmission Control
@end multitable

@node References
@unnumbered References

@multitable {000}{Geoffrey Gerrien, ``CDI - Application Program Interface Guide,'' Gcom, Inc., March 1999.}
@item [1] @anchor{Q.700} @tab @uref{http://www.itu.int/rec/T-REC-Q.700/,ITU-T Recommendation Q.700},
@cite{Introduction to CCITT Signalling System No. 7},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [2] @anchor{Q.701} @tab @uref{http://www.itu.int/rec/T-REC-Q.701/,ITU-T Recommendation Q.701},
@cite{Functional Description of the Message Transfer Part (MTP) of Signalling System No. 7},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [3] @anchor{Q.702} @tab @uref{http://www.itu.int/rec/T-REC-Q.702/,ITU-T Recommendation Q.702},
@cite{Signalling System No. 7---Signalling Data Link},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [4] @anchor{Q.703} @tab @uref{http://www.itu.int/rec/T-REC-Q.703/,ITU-T Recommendation Q.703},
@cite{Signalling System No. 7---Signalling Link},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [5] @anchor{Q.704} @tab @uref{http://www.itu.int/rec/T-REC-Q.704/,ITU-T Recommendation Q.704},
@cite{Message Transfer Part---Signalling Network Functions and Messages},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@item [6] @anchor{CDIAPI} @tab
Geoffrey Gerrietts; Dave Grothe, Mikel Matthews, Dave Healy,
@cite{CDI---Application Program Interface Guide},
March 1999,
(Savoy, IL),
GCOM, Inc.
@item [7] @anchor{Q.771} @tab @uref{http://www.itu.int/rec/T-REC-Q.771/,ITU-T Recommendation Q.771},
@cite{Signalling System No. 7---Functional Description of Transaction Capabilities},
March 1993, (Geneva), ITU,
@uref{http://www.itu.int/,,ITU-T Telecommunication Standardization Sector of ITU}, 
(Previously ``CCITT Recommendation'').
@end multitable

@ifnotplaintext
@c skip indexes for plain text (regex search works better)
@c @iftex
@c @node Indices
@c @unnumbered Indices
@c @end iftex

@c @ifnottex
@c @c concatenate indices for html and info
@node Index
@unnumbered Index
@printindex cp
@c @end ifnottex

@c @iftex
@c @menu
@c * Concept Index::
@c * Protocol State Index::
@c * Primitive Index::
@c * Primitive Structure and Type Index::
@c * Primitive Structure Field Index::
@c * Primitive Values Index::
@c * Primitive Error Values Index::
@c * Input-Output Control Index::
@c * Manual Page Index::
@c @end menu
@c 
@c @node Concept Index
@c @section Concept Index
@c @printindex cp
@c 
@c @page
@c @node Protocol State Index
@c @section Protocol State Index
@c @printindex st
@c 
@c @page
@c @node Primitive Index
@c @section Primitive Index
@c @printindex pr
@c 
@c @page
@c @node Primitive Structure and Type Index
@c @section Primitive Structure and Type Index
@c @printindex tp
@c 
@c @page
@c @node Primitive Structure Field Index
@c @section Primitive Structure Field Index
@c @printindex vr
@c 
@c @page
@c @node Primitive Values Index
@c @section Primitive Values Index
@c @printindex pv
@c 
@c @page
@c @node Primitive Error Values Index
@c @section Primitive Error Values Index
@c @printindex pe
@c 
@c @page
@c @node Input-Output Control Index
@c @section Input-Output Control Index
@c @printindex ct
@c 
@c @page
@c @node Manual Page Index
@c @section Manual Page Index
@c @printindex mp
@c @end iftex
@end ifnotplaintext

@page
@shortcontents
@page
@contents
@bye
