#!/usr/bin/perl
# =============================================================================
#
# @(#) src/perl/mibbrowser
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
# Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>, or write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# =============================================================================

#eval 'exec perl -S $0 ${1+"@"}'
#    if $running_under_some_shell;

$\ = "\n";

use strict;

my $program = $0; $program =~ s/^.*\///;
my $ident = 'src/perl/mibbrowser 2015-01-24T12:30+0000';
my $version = '1.1.2.3';
my $date = '2010-11-28 14:34:48';
my $title = 'OpenSS7 Network Manager';

my $statusbar;

my $Title = <<EOF;
Linux Fast-STREAMS
$title
$version, $date
EOF

$Title =~ s/\n*$//;
$Title =~ s/^\n*//;

my $Version = <<EOF;
Version $version
$ident
Copyright (c) 2008-2009  Monavacon Limited.    All Rights Reserved.
Copyright (c) 2001-2008  OpenSS7 Corporation.  All Rights Reserved.
Copyright (c) 1997-2000  Brian F. G. Bidulock. All Rights Reserved.
Distributed under Affero GPL Version 3, included here by reference.
See `$program --copying' for copying permissions.
EOF

$Version =~ s/\n*$//;
$Version =~ s/^\n*//;

my $Copying = <<EOF;
________________________________________________________________________________

$ident
________________________________________________________________________________

Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock\@openss7.org>

All Rights Reserved.
________________________________________________________________________________

This program is free software; you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation; version 3 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License along with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
________________________________________________________________________________

U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf of the U.S. Government ("Government"), the following provisions apply to you. If the Software is supplied by the Department of Defense ("DoD"), it is classified as "Commercial Computer Software" under paragraph 252.227-7014 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any successor regulations) and the Government is acquiring only the license rights granted herein (the license rights customarily provided to non-Government users). If the Software is supplied to any unit or agency of the Government other than DoD, it is classified as "Restricted Computer Software" and the Government's rights in the Software are defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR (or any successor regulations).
________________________________________________________________________________

Commercial licensing and support of this software is available from OpenSS7 Corporation at a fee.  See http://www.openss7.com/
________________________________________________________________________________
EOF

$Copying =~ s/\n*$//;
$Copying =~ s/^\n*//;

my $CopyingMono = <<EOF;
--------------------------------------------------------------------------------
$ident
--------------------------------------------------------------------------------
Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock\@openss7.org>

All Rights Reserved.
--------------------------------------------------------------------------------
This program is free software; you can  redistribute  it and/or modify  it under
the terms  of the  GNU Affero General Public License  as  published by the  Free
Software Foundation; version 3 of the License.

This program is distributed in the hope that it will  be useful, but WITHOUT ANY
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.

You should have received a copy of the  GNU Affero General Public License  along
with this program.   If not,  see  <http://www.gnu.org/licenses/>,  or  write to
the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
--------------------------------------------------------------------------------
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf
of the U.S. Government ("Government"), the following provisions apply to you. If
the Software is supplied by the  Department of Defense ("DoD"), it is classified
as "Commercial  Computer  Software"  under  paragraph  252.227-7014  of the  DoD
Supplement  to the  Federal Acquisition Regulations  ("DFARS") (or any successor
regulations) and the  Government  is acquiring  only the  license rights granted
herein (the license rights customarily provided to non-Government users). If the
Software is supplied to any unit or agency of the Government  other than DoD, it
is  classified as  "Restricted Computer Software" and the Government's rights in
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition
Regulations ("FAR")  (or any successor regulations) or, in the cases of NASA, in
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor
regulations).
--------------------------------------------------------------------------------
Commercial  licensing  and  support of this  software is  available from OpenSS7
Corporation at a fee.  See http://www.openss7.com/
--------------------------------------------------------------------------------
EOF

$CopyingMono =~ s/\n*$//;
$CopyingMono =~ s/^\n*//;

my $Help = <<EOF;
$program:
    $ident
Usage:
    $program [options] [MODULE ...]
    $program {-h|--help}
    $program {-V|--version}
    $program {-C|--copying}
Arguments:
    NONE
Options:
    -n, --dryrun
        don't perform the actions, just check them
    -q, --quiet
        suppress normal output
    -D, --debug [LEVEL]
        increase or set debugging verbosity
    -v, --verbose [LEVEL]
        increase or set output verbosity
    -h, --help
        prints this usage information and exits
    -V, --version
        prints the version and exits
    -C, --copying
        prints copying permissions and exits
EOF

$Help =~ s/\n*$//;
$Help =~ s/^\n*//;

my $Usage = <<EOF;
$program
    $ident
Usage:
    $program [options] [MODULE ...]
    $program {-h|--help}
    $program {-V|--version}
    $program {-C|--copying}
EOF

$Usage =~ s/\n*$//;
$Usage =~ s/^\n*//;

my $debug = 0;
my $verbose = 1;
my $show = 'yes';

sub version {
	return if $show eq 'no';
	print STDOUT<<EOF;
Version $version
$ident
Copyright (c) 2008-2009  Monavacon Limited.    All Rights Reserved.
Copyright (c) 2001-2008  OpenSS7 Corporation.  All Rights Reserved.
Copyright (c) 1997-2000  Brian F. G. Bidulock. All Rights Reserved.
Distributed under Affero GPL Version 3, included here by reference.
See `$program --copying' for copying permissions.
EOF
}

sub usage {
	return if $show eq 'no';
	print STDERR<<EOF;
$program
    $ident
Usage:
    $program [options] [MODULE ...]
    $program {-h|--help}
    $program {-V|--version}
    $program {-C|--copying}
EOF
}

sub help {
	return if $show eq 'no';
	print STDOUT<<EOF;
$program:
    $ident
Usage:
    $program [options] [MODULE ...]
    $program {-h|--help}
    $program {-V|--version}
    $program {-C|--copying}
Arguments:
    NONE
Options:
    -n, --dryrun
        don't perform the actions, just check them
    -q, --quiet
        suppress normal output
    -D, --debug [LEVEL]
        increase or set debugging verbosity
    -v, --verbose [LEVEL]
        increase or set output verbosity
    -h, --help
        prints this usage information and exits
    -V, --version
        prints the version and exits
    -C, --copying
        prints copying permissions and exits
EOF
}

sub copying {
	return if $show eq 'no';
	print STDOUT<<EOF;
--------------------------------------------------------------------------------
$ident
--------------------------------------------------------------------------------
Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock\@openss7.org>

All Rights Reserved.
--------------------------------------------------------------------------------
This program is free software; you can  redistribute  it and/or modify  it under
the terms  of the GNU General Public License  as  published by the Free Software
Foundation; version 3 of the License.

This program is distributed in the hope that it will  be useful, but WITHOUT ANY
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should  have received a copy of the GNU  General  Public License  along with
this program.   If not, see <http://www.gnu.org/licenses/>, or write to the Free
Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
--------------------------------------------------------------------------------
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf
of the U.S. Government ("Government"), the following provisions apply to you. If
the Software is supplied by the  Department of Defense ("DoD"), it is classified
as "Commercial  Computer  Software"  under  paragraph  252.227-7014  of the  DoD
Supplement  to the  Federal Acquisition Regulations  ("DFARS") (or any successor
regulations) and the  Government  is acquiring  only the  license rights granted
herein (the license rights customarily provided to non-Government users). If the
Software is supplied to any unit or agency of the Government  other than DoD, it
is  classified as  "Restricted Computer Software" and the Government's rights in
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition
Regulations ("FAR")  (or any successor regulations) or, in the cases of NASA, in
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor
regulations).
--------------------------------------------------------------------------------
Commercial  licensing  and  support of this  software is  available from OpenSS7
Corporation at a fee.  See http://www.openss7.com/
--------------------------------------------------------------------------------
EOF
}

sub syntax_error($)
{
    my $error = shift;
    if ($verbose > 0) {
	print STDERR "$program: syntax error -- $error";
	usage;
    }
    exit 2;
}

sub option_unrec($)
{
    my $opt = shift;
    $opt =~ s/=.*//;
    syntax_error "`$opt' unrecognized";
}

sub option_noarg($)
{
    my $opt = shift;
    syntax_error "`$opt' does accept an argument";
}

sub option_needarg($)
{
    my $opt = shift;
    syntax_error "`$opt' requires an argument";
}

sub option_after($$)
{
    my $opt = shift;
    my $oth = shift;
    syntax_error "`$opt' cannot occur with `$oth'";
}

my ($more,$arg,$optarg,$prev,$prevopt,$run,@nonopt);
my ($show_help,$show_usage,$show_copy);

$more = '';

while (scalar(@ARGV) or $more ne '') {
    if ($more) {
	$arg = "-$more";
	$more = '';
    } else {
	$arg = shift;
    }
    if ($arg =~ /^--(debug|verbose)=(.*)$/) {
	$optarg = $2;
    } elsif ($arg =~ /^--.*=/) {
	option_noarg $arg;
    } elsif ($arg =~ /^-[nqDvhVC]$/) {
	$optarg = '';
    } elsif ($arg =~ /^(-[nqDvhVC])(.*)$/) {
	$arg = $1;
	$more = $2;
	$optarg = '';
    } elsif ($arg =~ /^-[x]$/) {
	$optarg = '';
    } elsif ($arg =~ /^(-[x])(.*)$/) {
	$arg = $1;
	$optarg = $2;
    } else {
	$optarg = '';
    }
    if (ref($prev)) {
	if ($arg =~ /^-/) {
	    if (ref($prev) eq 'SUB') {
	    } elsif (ref($prev) =~ /^(SCALAR|ARRAY)$/) {
		option_needarg $prevopt;
	    }
	    $prev = ''; $prevopt = '';
	} else {
	    if (ref($prev) eq 'ARRAY') {
		push @$prev, $arg;
	    } elsif (ref($prev) eq 'SCALAR') {
		$$prev = $arg;
	    } elsif (ref($prev) eq 'SUB') {
		&$prev($optarg);
	    }
	    $prev = ''; $prevopt = '';
	    next;
	}
    }

         if ($arg =~ /^-(-help|-h|-Help|-H|-\?|h|H|\?)$/) {
	$show_help = 'yes';
	help;
	exit 0;
    } elsif ($arg =~ /^-(-version|-versio|-versi|-vers|V)$/) {
	$show_usage = 'yes';
	version;
	exit 0;
    } elsif ($arg =~ /^-(-copying|-copyin|-copy|-cop|-co|-c|C)$/) {
	$show_copy = 'yes';
	copying;
	exit 0;
    } elsif ($arg =~ /^-(-verbose|-verbos|-verb)$/) {
	$prevopt = $arg;
	$prev = sub {
	    if ($optarg eq '') {
		$verbose++;
	    } elsif ($optarg =~ /^[0-9]+$/) {
		$verbose = $optarg;
	    } else {
		syntax_error "$arg $optarg";
	    }
	}
    } elsif ($arg =~ /^-(v)$/) {
	$verbose++;
    } elsif ($arg =~ /^-(-verbose=|-verbos=|-verb=).*$/) {
	if ($optarg eq '') {
	    $verbose++;
	} elsif ($optarg =~ /^[0-9]+$/) {
	    $verbose = $optarg;
	} else {
	    syntax_error $arg;
	}
    } elsif ($arg =~ /^-(-debug|-debu|-deb)$/) {
	$prevopt = $arg;
	$prev = sub {
	    if ($optarg eq '') {
		$debug++;
	    } elsif ($optarg =~ /^[0-9]+$/) {
		$debug = $optarg;
	    } else {
		syntax_error "$arg $optarg";
	    }
	}
    } elsif ($arg =~ /^-(D)$/) {
	$debug++;
    } elsif ($arg =~ /^-(-debug=|-debu=|-deb=|D).*$/) {
	if ($optarg eq '') {
	    $debug++;
	} elsif ($optarg =~ /^[0-9]+$/) {
	    $debug = $optarg;
	} else {
	    syntax_error "$arg $optarg";
	}
    } elsif ($arg =~ /^-(-dry-run|-dryrun|-n|n)$/) {
	$run = 'no';
    } elsif ($arg =~ /^-(-quiet|-silent|q)$/) {
	$show = 'no';
	$verbose = 0;
	$debug = 0;
    } elsif ($arg eq '--') {
	last;
    } elsif ($arg =~ /^-.*/) {
	option_unrec $arg;
    } else {
	push @nonopt, $arg;
    }
}

if (ref($prev)) {
    if (ref($prev) eq 'SUB') {
	&$prev('');
    } else {
	option_needarg $prevopt;
    }
}

push @nonopt, @ARGV;
@ARGV = ( @nonopt );

my @defaults = (
    'verbose', \$verbose, 1,
    'debug', \$debug, 0,
    'show', \$show, 1,
    'show_help', \$show_help, 0,
    'show_usage', \$show_usage, 0,
    'show_copy', \$show_copy, 0,
);

while ($#defaults >= 2) {
    my $lab = shift @defaults;
    my $ref = shift @defaults;
    my $val = shift @defaults;

    if (not defined $$ref) {
	$$ref = $val;
    } else {
    }
}

if (!eval { require SNMP; }) {
	print STDERR<<EOF;
ERROR: You do not have the SNMP perl module installed.  Please obtain
this by getting the latest source release of the ucd-snmp toolkit from
http://www.net-snmp.org/download/ .  The perl module is contained in
the perl/SNMP directory.  See the INSTALL file there for instructions.
EOF
	exit;
} else {
	eval { import SNMP; }
}

if (!eval { require Tk; }) {
    print STDERR<<EOF;
ERROR: Use of the $0 program requires the availablity of the perl
Tk module.  It can either be obtained from CPAN or by insgalling the
necessary package on your system.
EOF
} else {
    eval { import Tk; }
}

use Carp;
use Data::Dumper;
#use XML::Simple;

#my $xml = new XML::Simple;

use SNMP;

#if (!eval { require Gtk2; }) {
#	print STDERR<<EOF;
#ERROR: Use of the $0 program requires the availability of the perl
#Gtk2 module.  It can either be obtained from CPAN or by installing
#the necessary package on your system.
#EOF
#} else {
#	eval { import Gtk2; }
#}

#Gtk2->init;
#
#my $w = Gtk2::Window->new('toplevel');
#my $b = Gtk2::Button->new('Quit');
#my $m = Gtk2::MenuBar->new;
#$m->set_pack_direction('ltr');
#$m->set_child_pack_direction('ttb');
#$b->signal_connect(clicked=>sub { Gtk2->main_quit; });
#$w->add($b);
#$w->show_all;
#Gtk2->main;

use Tk;
use Tk::Xrm;
require Tk::Adjuster;
require Tk::Dialog;
require Tk::HList;
require Tk::ROText;
require Tk::NoteBook;
require Tk::Pane;
require Tk::Balloon;
require Tk::DragDrop;
require Tk::DropSite;
require Tk::TableMatrix;
require Tk::TableMatrix::Spreadsheet;
require Tk::Frame;

use Storable qw(lock_store lock_nstore lock_retrieve);

my $mibs = {};

$SNMP::verbose = 0;
$SNMP::use_long_names = 0;
$SNMP::use_sprint_value = 0;
$SNMP::use_enums = 1;
$SNMP::use_numeric = 0;
$SNMP::best_guess = 2;
$SNMP::save_descriptions = 1;
SNMP::initMib();
#SNMP::addMibDirs(qw//);
SNMP::loadModules('ALL');

sub sess {
    my (%args) = @_;
    foreach (keys %args) {
    }
    return new SNMP::Session(%args);
}

my $dragobj;

sub same_ancestor {
    my ($oida,$oidb) = @_;
    $oida =~ s/\.[^\.]*$//;
    $oidb =~ s/\.[^\.]*$//;
    return $oidb if index($oida,$oidb) == 0;
    return $oida if index($oidb,$oida) == 0;
    return '';
}

sub ancestor {
    my ($oida,$oidb);
    return $oida if index($oida,$oidb) == 0;
    return '';
}

sub siblings {
    my ($oida,$oidb) = @_;
    $oida =~ s/\.[^\.]*$//;
    $oidb =~ s/\.[^\.]*$//;
    return $oida if ($oida eq $oidb);
    return '';
}

sub cmp_lexical {
    my ($oida,$oidb) = @_;
    my @compa = split(/\./, $oida);
    my @compb = split(/\./, $oidb);
    my $len = (@compa < @compb) ? @compa : @compb;
    for (my $i = 0; $i < $len; $i++) {
	return -1 if ($compa[$i] < $compb[$i]);
	return 1 if ($compa[$i] > $compb[$i]);
    }
    return -1 if @compa < @compb;
    return 1 if @compa > @compb;
    return 0;
}

sub unwrap {
    my $msg = shift;
    $msg =~ s/[ ]\n[ ]*//sg;
    return $msg;
}

# ---------------------------------
# An option list widget.
# ---------------------------------
package Tk::Optionlist;
require Tk::Menubutton;
require Tk::Menu;
use Carp;

use base qw(Tk::Derived Tk::Menubutton);

use strict;

Construct Tk::Widget 'Optionlist';

sub Populate
{
    my ($w,$args) = @_;
    $w->SUPER::Populate($args);
    $args->{-indicatoron} = 1;
    my $menu = $w->menu(-tearoff=>0);

    $w->ConfigSpecs(
	-command            => ['CALLBACK',          undef,undef,undef],
	-options            => ['METHOD',            undef,undef,undef],
	-font               => [['SELF',$menu],      undef,undef,undef],
	-foreground         => [['SELF','CHILDREN'], undef,undef,undef],

	-takefocus          => ['SELF','takefocus',         'Takefocus',         1],
	-highlightthickness => ['SELF','highlightThickness','HighlightThickness',1],
	-relief             => ['SELF','relief',            'Relief',            'raised'],
    );

    my $tvar = delete $args->{-textvariable};
    my $comm = delete $args->{-command};
    if (!defined $tvar) {
	my $new = '';
	$tvar = \$new;
    }
    $$tvar = '' unless defined $$tvar;
    $w->configure(-textvariable=>$tvar);
    $w->configure(-command=>$comm) if $comm;
}

sub setItem {
    my ($w,$label) = @_;
    my $tvar = $w->cget(-textvariable);
    my $ival = $w->entrycget($label,-variable);
    if ($$ival) {
	if ($$tvar !~ /\b$label\b/) {
	    $$tvar .= "\n" if $$tvar;
	    $$tvar .= $label;
	}
    } else {
	if ($$tvar =~ /\b$label\b/) {
	    $$tvar =~ s/\b$label\b\n+//sg;
	    $$tvar =~ s/\n+\b$label\b//sg;
	    $$tvar =~ s/\b$label\b//g;
	}
    }
    $w->Callback(-command=>$$tvar);
}

sub addList {
    my $w = shift;
    my $menu = $w->menu;
    my $tvar = $w->cget(-textvariable);
    my $width = $w->cget('-width');
    while (@_) {
	my $label = shift;
	my $ival;
	if (ref $label) {
	    ($label,$ival) = @$label;
	    $ival = $ival ? 1 : 0;
	}
	if (defined $ival) {
	    if ($ival) {
		if ($$tvar !~ /\b$label\b/) {
		    $$tvar .= "\n" if $$tvar;
		    $$tvar .= $label;
		}
	    } else {
		if ($$tvar =~ /\b$label\b/) {
		    $$tvar =~ s/\b$label\b\n+//sg;
		    $$tvar =~ s/\n+\b$label\b//sg;
		    $$tvar =~ s/\b$label\b//g;
		}
	    }
	} else {
	    if ($$tvar =~ /\b$label\b/) {
		$ival = 1;
	    } else {
		$ival = 0;
	    }
	}
	my $len = length($label);
	$width = $len if !defined($width) || $len > $width;
	$menu->checkbutton(
	    -label=>$label,
	    -command=>[$w,'setItem',$label],
	    -variable=>\$ival,
	);
    }
    $w->configure('-width'=>$width);
}

sub options {
    my ($w,$opts) = @_;
    if (@_ > 1) {
	$w->menu->delete(0,'end');
	$w->addList(@$opts);
    } else {
	return $w->cget('-options');
    }
}
# ---------------------------------

package MyPersistent;
package MyOptions;
package MyPixmaps;
package MyWidget;
package MyToplevel;
package MyMainWindow;
package MySession;
package MyPage;
package MyROText;
package MyMatrix;
package MyNoteBook;
package MyGroup;
package MyScalars;
package MyTables;
package MyTree;
package MyObject;
package MyConceptualRow;
package MyConceptualColumn;
package MyConceptualIndex;
package MyConceptualTable;
package MyObjectIdentifier;
package MyModuleIdentity;
package MyNotification;
package MyNotifyParameter;
package MyObjectType;
package MyObjectIdentity;
package MyLeaf;
package MyEntry;
package MyEntryHost;
package MyEntryItem;
package MyEntryIndex;
package MyEntryInstanceId;
package MyEntryInstance;
package MyEntryScalar;
package MyEntryValue;
package MyEntryCreate;
package MyData;
package MyValue;
package MyOctetString;
package MyOpaque;
package MyObjectId;
package MyBits;
package MyInteger;
package MyEnumerated;
package MyInteger32;
package MyEnumerated32;
package MyCounter64;
package MyUnsigned32;
package MyCounter;
package MyGauge;
package MyTicks;
package MyUinteger;
package MyIpaddr;
package MyNetaddr;
package MyNull;
package MyHList;
package MyMibList;
package MyTop;
package main;

# ---------------------------------
# A storable object
# ---------------------------------
package MyPersistent;
use strict;

sub new {
    my ($type,$owner,@args) = @_;
    my $self = {};
    bless $self,$type;
    $self->{'data'} = {};
    $self->{'data'}->{'class'} = $type;
    $self->{'owner'} = $owner;
    $self->{'owned'} = [];
    push @{$owner->{'owned'}}, $self if $owner;
    return $self;
}
sub destroy {
    my ($self,@args) = @_;
    my $owner = $self->{'owner'};
    if ($owner) {
	$owner->deleteowned($self);
	delete $self->{'owner'};
    }
    my @owned = @{$self->{'owned'}};
    foreach (@owned) {
	$_->destroy;
    }
    unless (@{$self->{'owned'}} == 0) {
	warn "some owned not destroyed ".join(', ',@{$self->{'owned'}});
    }
}
sub deleteowned {
    my ($self,$owned) = @_;
    my $deleted = 1;
    while ($deleted) {
	$deleted = 0;
	for (my $i = 0; $i < @{$self->{'owned'}}; $i++) {
	    if ($self->{'owned'}->[$i] eq $owned) {
		splice @{$self->{'owned'}}, $i, 1;
		$deleted = 1;
		last;
	    }
	}
    }
}
sub dumphash {
    my $self = shift;
    my $data = $self->{'data'};
    $data->{'class'} = ref($self);
    return $data;
}
sub reconstruct {
    my ($self,$data,@args) = @_;
    %{$self->{'data'}} = %{$data};
}
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyPersistent->new($parent,@args);
    $self->reconstruct($data,@args);
    return $self;
}

# ---------------------------------

# ---------------------------------
# package of options.
# ---------------------------------
package MyOptions;
use strict;

sub assign {
    my $mw = shift;
    #$mw->optionAdd('*font'=>'-*-helvetica-medium-r-*--*-100-*-*-*-*-*-*');
    #$mw->optionAdd('*.Button.*.font'=>'-*-helvetica-bold-r-*--*-100-*-*-*-*-*-*');
    #$mw->optionAdd('*.Label.*.font'=>'-*-helvetica-bold-r-*--*-100-*-*-*-*-*-*');
    #$mw->optionAdd('*font'=>'Arial 9');
    #$mw->optionAdd('*font'=>'Helvetica 10');
    #$mw->optionAdd('*Button*font'=>'Helvetica-Bold 10');
    #$mw->optionAdd('*Label*font'=>'Helvetica-Bold 10');
    #$mw->optionAdd('*disabledBackground'=>'dark grey');
    #$mw->optionAdd('*highlightBackground'=>'light grey');
    #$mw->optionAdd('*highlightThickness'=>1);
    #$mw->optionAdd('*borderThickness'=>1);
    #$mw->optionAdd('*borderWidth'=>1);
    #$mw->optionAdd('*border'=>0);
    #$mw->optionAdd('*Menu*Width'=>1);
    #$mw->optionAdd('*Menu*Heigth'=>1);

    #$mw->optionAdd('*Balloon*font'=>'Arial 8');
    #$mw->optionAdd('*padX'=>0);
    #$mw->optionAdd('*padY'=>0);
    #$mw->optionAdd('*relief'=>'groove');
    #$mw->optionAdd('*Scrollbar*Width'=>8);
}

# ---------------------------------

# ---------------------------------
# package of images.
# ---------------------------------
package MyPixmaps;
use strict;

my $parmImage = <<EOF;
/* XPM */
static char * mini_parm_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"         aa     ",
"       aabba    ",
"     aabbbbaa   ",
"   aabbbcbbba   ",
" aabbbcbbbbbaa  ",
" abbcbbbbcbbba  ",
" aabbbbcbbbbbaa ",
"  abbcbbbbcbbba ",
"  aabbbbcbbbaacc",
"   abbcbbbaaccc ",
"   aabbbaaccc   ",
"    abaaccc     ",
"    aaccc       ",
"     cc         "};
EOF

my $noteImage = <<EOF;
/* XPM */
static char * mini_note_xpm[] = {
"16 12 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"                ",
" aaaaaaaaaaaaa  ",
" abbbbbbaaaabac ",
" abbbbbbabbabac ",
" abbbbbbaaaabac ",
" abbbbbbbbbbbac ",
" abcccccbccbbac ",
" abccbbcccccbac ",
" abbbbbbbbbbbac ",
" aaaaaaaaaaaaac ",
"  ccccccccccccc ",
"                "};
EOF

my $objsImage = <<EOF;
/* XPM */
static char * mini_obj1_xpm[] = {
"16 12 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"      aaa       ",
"    aabbbaa     ",
"   abbbbbbba    ",
"  abbbbbbbbba   ",
"  abbbbbbbbbac  ",
" abbbbbbbbbbba  ",
"  abbbbbbbbbacc ",
"  abbbbbbbbbac  ",
"   abbbbbbbacc  ",
"    aabbbaacc   ",
"     caaaccc    ",
"       ccc      "};
EOF

my $objsRedImage = <<EOF;
/* XPM */
static char * mini_obj2_xpm[] = {
"16 12 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"      aaa       ",
"    aabbbaa     ",
"   abbbbbbba    ",
"  abbbbbbbbba   ",
"  abbbbbbbbbac  ",
" abbbbbbbbbbba  ",
"  abbbbbbbbbacc ",
"  abbbbbbbbbac  ",
"   abbbbbbbacc  ",
"    aabbbaacc   ",
"     caaaccc    ",
"       ccc      "};
EOF

my $objsGrnImage = <<EOF;
/* XPM */
static char * mini_obj3_xpm[] = {
"16 12 4 1",
" 	c None",
"a	c black",
"b	c green",
"c	c green4",
"      aaa       ",
"    aabbbaa     ",
"   abbbbbbba    ",
"  abbbbbbbbba   ",
"  abbbbbbbbbac  ",
" abbbbbbbbbbba  ",
"  abbbbbbbbbacc ",
"  abbbbbbbbbac  ",
"   abbbbbbbacc  ",
"    aabbbaacc   ",
"     caaaccc    ",
"       ccc      "};
EOF

my $objsBluImage = <<EOF;
/* XPM */
static char * mini_obj4_xpm[] = {
"16 12 4 1",
" 	c None",
"a	c black",
"b	c grey75",
"c	c grey25",
"      aaa       ",
"    aabbbaa     ",
"   abbbbbbba    ",
"  abbbbbbbbba   ",
"  abbbbbbbbbac  ",
" abbbbbbbbbbba  ",
"  abbbbbbbbbacc ",
"  abbbbbbbbbac  ",
"   abbbbbbbacc  ",
"    aabbbaacc   ",
"     caaaccc    ",
"       ccc      "};
EOF

my $odocsImage = <<EOF;
/* XPM */
static char * mini_doc1_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"   aaaaaaa      ",
"   abbbbbaa     ",
"   abcccbaba    ",
"   abbbbbaaaa   ",
"   abccccbccac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $cdocsImage = <<EOF;
/* XPM */
static char * mini_doc2_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"   aaaaaaaaaa   ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $odocsRedImage = <<EOF;
/* XPM */
static char * mini_doc3_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"   aaaaaaa      ",
"   abbbbbaa     ",
"   abcccbaba    ",
"   abbbbbaaaa   ",
"   abccccbccac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $cdocsRedImage = <<EOF;
/* XPM */
static char * mini_doc4_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"   aaaaaaaaaa   ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $oindsImage = <<EOF;
/* XPM */
static char * mini_ind1_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"   aaaaaaa      ",
"   abbbbbaa     ",
"   abcccbaba    ",
"   abbbaaaaaa   ",
"   abccaabccac  ",
"   abbbbbbbbac  ",
"   abcaaaccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbaabbbac  ",
"   abccaaacbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $cindsImage = <<EOF;
/* XPM */
static char * mini_ind2_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"   aaaaaaaaaa   ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbbbbbbac  ",
"   abcaaaccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbaabbbac  ",
"   abccaaacbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $oindsRedImage = <<EOF;
/* XPM */
static char * mini_ind3_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"   aaaaaaa      ",
"   abbbbbaa     ",
"   abcccbaba    ",
"   abbbaaaaaa   ",
"   abccaabccac  ",
"   abbbbbbbbac  ",
"   abcaaaccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbaabbbac  ",
"   abccaaacbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $cindsRedImage = <<EOF;
/* XPM */
static char * mini_ind4_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"   aaaaaaaaaa   ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbbbbbbac  ",
"   abcaaaccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbaabbbac  ",
"   abccaaacbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $oindsGrnImage = <<EOF;
/* XPM */
static char * mini_ind5_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c green",
"c	c green4",
"   aaaaaaa      ",
"   abbbbbaa     ",
"   abcccbaba    ",
"   abbbaaaaaa   ",
"   abccaabccac  ",
"   abbbbbbbbac  ",
"   abcaaaccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbaabbbac  ",
"   abccaaacbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $cindsGrnImage = <<EOF;
/* XPM */
static char * mini_ind6_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c green",
"c	c green4",
"   aaaaaaaaaa   ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbbbbbbac  ",
"   abcaaaccbac  ",
"   abbbaabbbac  ",
"   abccaaccbac  ",
"   abbbaabbbac  ",
"   abccaaacbac  ",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $orowsImage = <<EOF;
/* XPM */
static char * mini_doc5_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"   aaaaaaa      ",
"   abbbbbaa     ",
"   abcccbaba    ",
"   abbbbbaaaa   ",
"   abccccbccac  ",
"   abbbbbbbbac  ",
" aaaaaaaaaaaaaa ",
" abaccccccccacac",
" ababbbbbbbbacac",
" aaaaaaaaaaaaaac",
"   abccccccbaccc",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $crowsImage = <<EOF;
/* XPM */
static char * mini_doc6_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"   aaaaaaaaaa   ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
"   abccccccbac  ",
"   abbbbbbbbac  ",
" aaaaaaaaaaaaaa ",
" abaccccccccacac",
" ababbbbbbbbacac",
" aaaaaaaaaaaaaac",
"   abccccccbaccc",
"   abbbbbbbbac  ",
"   aaaaaaaaaac  ",
"    cccccccccc  "};
EOF

my $ocolsImage = <<EOF;
/* XPM */
static char * mini_col1_xpm[] = {
"16 16 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"     aaaa       ",
"     abbac      ",
"   aaaaaaa      ",
"   ababbaaa     ",
"   abaccaaba    ",
"   ababbaaaaa   ",
"   abaccabccac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   aaaaaaaaaac  ",
"    caccaccccc  ",
"     aaaac      ",
"      cccc      "};
EOF

my $ccolsImage = <<EOF;
/* XPM */
static char * mini_col2_xpm[] = {
"16 16 4 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"     aaaa       ",
"     abbac      ",
"   aaaaaaaaaa   ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   aaaaaaaaaac  ",
"    caccaccccc  ",
"     aaaac      ",
"      cccc      "};
EOF

my $ocolsRedImage = <<EOF;
/* XPM */
static char * mini_col3_xpm[] = {
"16 16 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"     aaaa       ",
"     abbac      ",
"   aaaaaaa      ",
"   ababbaaa     ",
"   abaccaaba    ",
"   ababbaaaaa   ",
"   abaccabccac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   aaaaaaaaaac  ",
"    caccaccccc  ",
"     aaaac      ",
"      cccc      "};
EOF

my $ccolsRedImage = <<EOF;
/* XPM */
static char * mini_col4_xpm[] = {
"16 16 4 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red3",
"     aaaa       ",
"     abbac      ",
"   aaaaaaaaaa   ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   aaaaaaaaaac  ",
"    caccaccccc  ",
"     aaaac      ",
"      cccc      "};
EOF

my $ocolsGrnImage = <<EOF;
/* XPM */
static char * mini_col5_xpm[] = {
"16 16 4 1",
" 	c None",
"a	c black",
"b	c green",
"c	c green4",
"     aaaa       ",
"     abbac      ",
"   aaaaaaa      ",
"   ababbaaa     ",
"   abaccaaba    ",
"   ababbaaaaa   ",
"   abaccabccac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   aaaaaaaaaac  ",
"    caccaccccc  ",
"     aaaac      ",
"      cccc      "};
EOF

my $ccolsGrnImage = <<EOF;
/* XPM */
static char * mini_col6_xpm[] = {
"16 16 4 1",
" 	c None",
"a	c black",
"b	c green",
"c	c green4",
"     aaaa       ",
"     abbac      ",
"   aaaaaaaaaa   ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   abaccaccbac  ",
"   ababbabbbac  ",
"   aaaaaaaaaac  ",
"    caccaccccc  ",
"     aaaac      ",
"      cccc      "};
EOF

my $obookImage = <<EOF;
/* XPM */
static char * mini_book1_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c gray50",
"c	c white",
"  aa            ",
" abca    aaa    ",
" abcca aacca    ",
" abcccabcccaaa  ",
" abcccaccccaba  ",
" abcccabcccaba  ",
" abcccaccccaba  ",
" abcccabcccaba  ",
" abcccaccccaba  ",
"  abccabccaaba  ",
"   abcacaaccba  ",
"    abaabbbbba  ",
"    aabaaaaaaa  ",
"     aa         "};
EOF

my $obookBluImage = <<EOF;
/* XPM */
static char * mini_book6_xpm[] = {
"16 14 4 1",
" 	c None",
"a	c black",
"b	c grey25",
"c	c grey75",
"  aa            ",
" abca    aaa    ",
" abcca aacca    ",
" abcccabcccaaa  ",
" abcccaccccaba  ",
" abcccabcccaba  ",
" abcccaccccaba  ",
" abcccabcccaba  ",
" abcccaccccaba  ",
"  abccabccaaba  ",
"   abcacaaccba  ",
"    abaabbbbba  ",
"    aabaaaaaaa  ",
"     aa         "};
EOF

my $cbookImage = <<EOF;
/* XPM */
static char * mini_book2_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"d	c white",
"e	c gray50",
"       aa       ",
"     aabba      ",
"   aabbbbba     ",
" aabbbbbbbba    ",
"accbbbbbbbbba   ",
"aaccbbbbbbbbba  ",
"abaccbbbbbbbbba ",
"abbaccbbbbbbaa  ",
" abbaccbbbaade  ",
"  abbaccaaddeea ",
"   abbaaddeeaa  ",
"    abadeeaa    ",
"     aaeaa      ",
"      aa        "};
EOF

my $cbookRedImage = <<EOF;
/* XPM */
static char * mini_book3_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c red",
"c	c red4",
"d	c white",
"e	c gray50",
"       aa       ",
"     aabba      ",
"   aabbbbba     ",
" aabbbbbbbba    ",
"accbbbbbbbbba   ",
"aaccbbbbbbbbba  ",
"abaccbbbbbbbbba ",
"abbaccbbbbbbaa  ",
" abbaccbbbaade  ",
"  abbaccaaddeea ",
"   abbaaddeeaa  ",
"    abadeeaa    ",
"     aaeaa      ",
"      aa        "};
EOF

my $cbookGrnImage = <<EOF;
/* XPM */
static char * mini_book4_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c green",
"c	c green4",
"d	c white",
"e	c gray50",
"       aa       ",
"     aabba      ",
"   aabbbbba     ",
" aabbbbbbbba    ",
"accbbbbbbbbba   ",
"aaccbbbbbbbbba  ",
"abaccbbbbbbbbba ",
"abbaccbbbbbbaa  ",
" abbaccbbbaade  ",
"  abbaccaaddeea ",
"   abbaaddeeaa  ",
"    abadeeaa    ",
"     aaeaa      ",
"      aa        "};
EOF

my $cbookBluImage = <<EOF;
/* XPM */
static char * mini_book5_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c grey75",
"c	c grey25",
"d	c white",
"e	c gray50",
"       aa       ",
"     aabba      ",
"   aabbbbba     ",
" aabbbbbbbba    ",
"accbbbbbbbbba   ",
"aaccbbbbbbbbba  ",
"abaccbbbbbbbbba ",
"abbaccbbbbbbaa  ",
" abbaccbbbaade  ",
"  abbaccaaddeea ",
"   abbaaddeeaa  ",
"    abadeeaa    ",
"     aaeaa      ",
"      aa        "};
EOF

my $ohostImage = <<EOF;
/* XPM */
static char * mini_host1_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"d	c white smoke",
"e	c gray75",
"  aaaaaaaaaaa   ",
" aeeeeeeeeeeea  ",
" ae         ea  ",
" aedddddd  dea  ",
" aed    ddddea  ",
" aed    d  dea  ",
" aedddddddddea  ",
" ae         ea  ",
" aeeeeeeeeeeea  ",
"  aaaaaaaaaaa   ",
"  a c c c c a   ",
" a c c c c c a  ",
"a c c c c c c a ",
"aaaaaaaaaaaaaaa "};
EOF
my $chostImage = <<EOF;
/* XPM */
static char * mini_host2_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c gray50",
"d	c white smoke",
"e	c gray75",
"  aaaaaaaaaaa   ",
" accccccccccca  ",
" acaaaaaaaaaca  ",
" acaaaaaaaaaca  ",
" acaaaaaaaaaca  ",
" acaaaaaaaaaca  ",
" acaaaaaaaaaca  ",
" acaaaaaaaaaca  ",
" accccccccccca  ",
"  aaaaaaaaaaa   ",
"  a c c c c a   ",
" a c c c c c a  ",
"a c c c c c c a ",
"aaaaaaaaaaaaaaa "};
EOF

my $ohostRedImage = <<EOF;
/* XPM */
static char * mini_host3_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c red4",
"d	c white smoke",
"e	c red",
"  ccccccccccc   ",
" ceeeeeeeeeeec  ",
" ce         ec  ",
" cedddddd  dec  ",
" ced    ddddec  ",
" ced    d  dec  ",
" cedddddddddec  ",
" ce         ec  ",
" ceeeeeeeeeeec  ",
"  ccccccccccc   ",
"  aececececea   ",
" aecececececea  ",
"aececececececea ",
"aaaaaaaaaaaaaaa "};
EOF
my $chostRedImage = <<EOF;
/* XPM */
static char * mini_host4_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c red4",
"d	c white smoke",
"e	c red",
"  aaaaaaaaaaa   ",
" aeeeeeeeeeeea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aeeeeeeeeeeea  ",
"  aaaaaaaaaaa   ",
"  aececececea   ",
" aecececececea  ",
"aececececececea ",
"aaaaaaaaaaaaaaa "};
EOF

my $ohostGrnImage = <<EOF;
/* XPM */
static char * mini_host5_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c green4",
"d	c white smoke",
"e	c green",
"  ccccccccccc   ",
" ceeeeeeeeeeec  ",
" ce         ec  ",
" cedddddd  dec  ",
" ced    ddddec  ",
" ced    d  dec  ",
" cedddddddddec  ",
" ce         ec  ",
" ceeeeeeeeeeec  ",
"  ccccccccccc   ",
"  aececececea   ",
" aecececececea  ",
"aececececececea ",
"aaaaaaaaaaaaaaa "};
EOF
my $chostGrnImage = <<EOF;
/* XPM */
static char * mini_host6_xpm[] = {
"16 14 6 1",
" 	c None",
"a	c black",
"b	c white",
"c	c green4",
"d	c white smoke",
"e	c green",
"  aaaaaaaaaaa   ",
" aeeeeeeeeeeea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aecccccccccea  ",
" aeeeeeeeeeeea  ",
"  aaaaaaaaaaa   ",
"  aececececea   ",
" aecececececea  ",
"aececececececea ",
"aaaaaaaaaaaaaaa "};
EOF

my $iconImage = <<EOF;
/* XPM */
static char * streams_icon_xpm[] = {
"48 48 484 2",
"  	c #575757",
". 	c #C4C4C4",
"+ 	c #FFFFFF",
"\@ 	c #FBFBFE",
"# 	c #DCDDF4",
"\$ 	c #969BDD",
"\% 	c #6B73D2",
"\& 	c #6F75D4",
"* 	c #8389D8",
"= 	c #C4C6ED",
"- 	c #ECEDF9",
"; 	c #FEFEFF",
"> 	c #F0F0F0",
", 	c #CECECE",
"' 	c #797979",
") 	c #3D3D3D",
"! 	c #313131",
"~ 	c #333333",
"{ 	c #6B6B6B",
"] 	c #CACACA",
"^ 	c #FCFCFC",
"/ 	c #FCFDFE",
"( 	c #C1C5EC",
"_ 	c #5057C8",
": 	c #434CC1",
"< 	c #8D91DB",
"[ 	c #A0A4E2",
"} 	c #8489D9",
"| 	c #4F58C8",
"1 	c #7178D4",
"2 	c #CCCFEF",
"3 	c #EFEFEF",
"4 	c #808080",
"5 	c #242424",
"6 	c #414141",
"7 	c #878787",
"8 	c #ACACAC",
"9 	c #8E8E8E",
"0 	c #3B3B3B",
"a 	c #323232",
"b 	c #C2C2C2",
"c 	c #E7E8F7",
"d 	c #4B53C7",
"e 	c #4750C7",
"f 	c #C5C8ED",
"g 	c #FAFAFD",
"h 	c #F7F7FD",
"i 	c #CCCEEF",
"j 	c #6D73D1",
"k 	c #4751C5",
"l 	c #5D5D68",
"m 	c #1A1A1A",
"n 	c #4A4A4A",
"o 	c #DADADA",
"p 	c #FBFBFB",
"q 	c #CBCBCB",
"r 	c #3E3E3E",
"s 	c #424242",
"t 	c #EAEAEA",
"u 	c #FDFDFE",
"v 	c #7E85D7",
"w 	c #3840C1",
"x 	c #B9BBEA",
"y 	c #FDFDFF",
"z 	c #E2E3EA",
"A 	c #40435F",
"B 	c #090B17",
"C 	c #72738A",
"D 	c #F0F0F4",
"E 	c #C5C5C5",
"F 	c #212121",
"G 	c #858585",
"H 	c #E2E2F6",
"I 	c #414AC4",
"J 	c #6E74D2",
"K 	c #F2F2FB",
"L 	c #F3F3F3",
"M 	c #151515",
"N 	c #525581",
"O 	c #4C53BE",
"P 	c #C6C9EE",
"Q 	c #585858",
"R 	c #454545",
"S 	c #E0E0E0",
"T 	c #AAAEE5",
"U 	c #353FBC",
"V 	c #A8ADE5",
"W 	c #FEFEFE",
"X 	c #B2B2B2",
"Y 	c #1C1C1C",
"Z 	c #636363",
"` 	c #DDDEEE",
" .	c #6D73D2",
"..	c #535BCB",
"+.	c #F0F1FB",
"\@.	c #B0B0B0",
"#.	c #B9B9B9",
"\$.	c #F9FAFE",
"\%.	c #777DD5",
"\&.	c #3940C1",
"*.	c #E5E7F8",
"=.	c #E2E2E2",
"-.	c #262626",
";.	c #DBDCF3",
">.	c #555ECA",
",.	c #7F84D6",
"'.	c #F6F7FD",
").	c #909090",
"!.	c #E8E9F8",
"~.	c #5F65CD",
"{.	c #5158C8",
"].	c #FCFCFF",
"^.	c #F8F8F8",
"/.	c #6E6E6E",
"(.	c #1F1F1F",
"_.	c #B3B3B3",
":.	c #FDFDFD",
"<.	c #B9BCE9",
"[.	c #3C45C0",
"}.	c #B5B9E9",
"|.	c #EDEDED",
"1.	c #4D4D4D",
"2.	c #686868",
"3.	c #D8D9F3",
"4.	c #4F55C9",
"5.	c #7176D4",
"6.	c #202020",
"7.	c #6F6F6F",
"8.	c #F5F5F5",
"9.	c #6E73D3",
"0.	c #6268CE",
"a.	c #E4E5F7",
"b.	c #4B4B4B",
"c.	c #ECECEC",
"d.	c #C9CCEF",
"e.	c #3E48C0",
"f.	c #8F94DC",
"g.	c #E6E6E6",
"h.	c #525252",
"i.	c #E9E9E9",
"j.	c #D3D7F3",
"k.	c #454EC6",
"l.	c #9CA1E1",
"m.	c #FCFCFE",
"n.	c #F9F9F9",
"o.	c #E7E7E7",
"p.	c #BFC2EC",
"q.	c #363FC1",
"r.	c #A2A5E2",
"s.	c #AAAAAA",
"t.	c #171717",
"u.	c #8C8C8C",
"v.	c #F6F7FC",
"w.	c #8F94DB",
"x.	c #4D56C9",
"y.	c #E9E9F9",
"z.	c #979797",
"A.	c #232323",
"B.	c #E3E3E3",
"C.	c #BBBEEA",
"D.	c #323ABF",
"E.	c #ABAEE6",
"F.	c #4F4F4F",
"G.	c #D7D7D7",
"H.	c #D1D4F1",
"I.	c #4F57C9",
"J.	c #A5AAE4",
"K.	c #9E9E9E",
"L.	c #B9BDE9",
"M.	c #2F3ABB",
"N.	c #AFB4E5",
"O.	c #C1C1C1",
"P.	c #111111",
"Q.	c #898989",
"R.	c #FBFBFD",
"S.	c #5D66CE",
"T.	c #EAECF9",
"U.	c #A4A4A4",
"V.	c #BDC1EB",
"W.	c #3C46C3",
"X.	c #B2B6E7",
"Y.	c #656565",
"Z.	c #363636",
"`.	c #CCCCCC",
" +	c #5A61CC",
".+	c #B5B7E8",
"++	c #353535",
"\@+	c #E4E4E4",
"#+	c #CBCCEE",
"\$+	c #5E64CD",
"\%+	c #B8BCEA",
"\&+	c #727272",
"*+	c #F7F7F7",
"=+	c #8C92DB",
"-+	c #989DDF",
";+	c #F3F4FB",
">+	c #DEE0F5",
",+	c #9499DD",
"'+	c #C7CAEE",
")+	c #B6B6B6",
"!+	c #676767",
"~+	c #D8DAF3",
"{+	c #9CA1E0",
"]+	c #E3E4F6",
"^+	c #BFBFBF",
"/+	c #888888",
"(+	c #EDEDF9",
"_+	c #BCBFEA",
":+	c #D3D5F1",
"<+	c #B1B1B1",
"[+	c #999999",
"}+	c #F5F5FC",
"|+	c #B9BDEA",
"1+	c #D6D8F3",
"2+	c #FAFAFB",
"3+	c #C9C9C9",
"4+	c #D0D3F0",
"5+	c #D9DBF3",
"6+	c #EEEEEE",
"7+	c #BBBBBB",
"8+	c #CBCDEF",
"9+	c #F6F6F9",
"0+	c #CDCDCD",
"a+	c #FAFAFA",
"b+	c #F1F1F1",
"c+	c #EFEFF7",
"d+	c #F4F4F4",
"e+	c #E1E1E1",
"f+	c #DEDEDE",
"g+	c #DCDCDD",
"h+	c #D2D3E3",
"i+	c #C6C7DD",
"j+	c #BFBFC1",
"k+	c #D9D9D9",
"l+	c #E8E8E8",
"m+	c #D6D8F2",
"n+	c #D4D5E5",
"o+	c #D5D5D5",
"p+	c #E5E5E5",
"q+	c #404040",
"r+	c #777777",
"s+	c #7C7C7C",
"t+	c #7D7E88",
"u+	c #6D6D79",
"v+	c #333334",
"w+	c #3C3C3C",
"x+	c #BEBEBE",
"y+	c #B5B5B5",
"z+	c #464646",
"A+	c #989898",
"B+	c #DEDFF5",
"C+	c #9495A8",
"D+	c #F6F6F6",
"E+	c #C0C0C0",
"F+	c #494949",
"G+	c #C6C6C6",
"H+	c #535353",
"I+	c #9D9D9D",
"J+	c #F2F2F2",
"K+	c #8B8B8B",
"L+	c #444444",
"M+	c #9B9B9B",
"N+	c #4E4E4E",
"O+	c #DFE0E9",
"P+	c #55555C",
"Q+	c #D3D3D3",
"R+	c #D8D8D8",
"S+	c #3A3A3A",
"T+	c #EBEBEB",
"U+	c #6D6D6D",
"V+	c #090909",
"W+	c #2E2E2E",
"X+	c #E9EAF8",
"Y+	c #7E7F8D",
"Z+	c #030303",
"`+	c #929292",
" \@	c #131313",
".\@	c #0D0D0D",
"+\@	c #474747",
"\@\@	c #6C6C6C",
"#\@	c #A2A2A2",
"\$\@	c #D1D1D1",
"\%\@	c #9C9C9C",
"\&\@	c #828282",
"*\@	c #DCDCDC",
"=\@	c #646464",
"-\@	c #57575B",
";\@	c #B8B8B8",
">\@	c #7E7E7E",
",\@	c #0F0F0F",
"'\@	c #9F9F9F",
")\@	c #666666",
"!\@	c #1D1D1D",
"~\@	c #F5F6FC",
"{\@	c #7F7F88",
"]\@	c #3F3F3F",
"^\@	c #959595",
"/\@	c #B4B4B4",
"(\@	c #343434",
"_\@	c #A3A3A3",
":\@	c #585859",
"<\@	c #252525",
"[\@	c #C3C3C3",
"}\@	c #0A0A0A",
"|\@	c #484848",
"1\@	c #6A6A6A",
"2\@	c #F6F7F8",
"3\@	c #7F8082",
"4\@	c #383838",
"5\@	c #A0A0A0",
"6\@	c #505050",
"7\@	c #5C5C5C",
"8\@	c #707070",
"9\@	c #303030",
"0\@	c #DDDDDD",
"a\@	c #696969",
"b\@	c #4B4B4E",
"c\@	c #E2E2E6",
"d\@	c #2A2A2A",
"e\@	c #161616",
"f\@	c #A5A5A5",
"g\@	c #4C4C4C",
"h\@	c #1B1B1B",
"i\@	c #D2D2D2",
"j\@	c #3F3F40",
"k\@	c #626263",
"l\@	c #8A8A8A",
"m\@	c #717171",
"n\@	c #565656",
"o\@	c #4D4E55",
"p\@	c #ABABAB",
"q\@	c #9A9A9A",
"r\@	c #7A7A7A",
"s\@	c #3C3C3F",
"t\@	c #8F8F93",
"u\@	c #969696",
"v\@	c #DFDFDF",
"w\@	c #838390",
"x\@	c #EBECF9",
"y\@	c #F7F7F8",
"z\@	c #7F7F7F",
"A\@	c #8F8F8F",
"B\@	c #97979A",
"C\@	c #787887",
"D\@	c #C4C4CA",
"E\@	c #D4D4D4",
"F\@	c #838383",
"G\@	c #CDCDCE",
"H\@	c #D1D2E4",
"I\@	c #E1E2F5",
"J\@	c #C8C8C8",
"K\@	c #CFCFD5",
"L\@	c #C4C7E6",
"M\@	c #EAEBF6",
"N\@	c #CBCBCC",
"O\@	c #E0E2F1",
"P\@	c #CDD0F0",
"Q\@	c #E4E4EA",
"R\@	c #BEC2EC",
"S\@	c #E4E6F7",
"T\@	c #B3B4B5",
"U\@	c #E7E8F6",
"V\@	c #B6B9E9",
"W\@	c #D3D5F2",
"X\@	c #A6A6A6",
"Y\@	c #ECEDF3",
"Z\@	c #AEB2E6",
"`\@	c #D5D7F2",
" #	c #8A8A8B",
".#	c #8990DB",
"+#	c #AEAEAE",
"\@#	c #F0F0F8",
"##	c #979DDF",
"\$#	c #BCBEEA",
"\%#	c #ADB2E6",
"\&#	c #525AC9",
"*#	c #C4C6EC",
"=#	c #8085D8",
"-#	c #9DA2E0",
";#	c #F8F9FD",
">#	c #DFE1F6",
",#	c #4C55C7",
"'#	c #7C83D7",
")#	c #F8F8FD",
"!#	c #626262",
"~#	c #767DD5",
"{#	c #8A90DB",
"]#	c #515151",
"^#	c #8084D6",
"/#	c #434EC2",
"(#	c #CCCFF0",
"_#	c #C7C7C7",
":#	c #A8A8A8",
"<#	c #7379D4",
"[#	c #8288D8",
"}#	c #DCDCF4",
"|#	c #333CBF",
"1#	c #858ADA",
"2#	c #F6F6FC",
"3#	c #F1F2FB",
"4#	c #6F76D3",
"5#	c #8289DA",
"6#	c #7980D6",
"7#	c #4149C4",
"8#	c #D6D7F2",
"9#	c #F0F0FA",
"0#	c #676ECF",
"a#	c #8B90DA",
"b#	c #C8CBEE",
"c#	c #4049C4",
"d#	c #8287D9",
"e#	c #686869",
"f#	c #484849",
"g#	c #5B62CC",
"h#	c #979DDE",
"i#	c #FAFBFE",
"j#	c #8C92DD",
"k#	c #323BC0",
"l#	c #ADADAD",
"m#	c #292929",
"n#	c #474FC7",
"o#	c #ABAEE5",
"p#	c #1E1E1E",
"q#	c #DEE0F4",
"r#	c #6971D0",
"s#	c #EBECF8",
"t#	c #DEDFF4",
"u#	c #BDC0EA",
"v#	c #B7B9E9",
"w#	c #333BBF",
"x#	c #9FA3E2",
"y#	c #FAFAFE",
"z#	c #373737",
"A#	c #4D54C7",
"B#	c #D2D4F1",
"C#	c #2D2D2D",
"D#	c #5F5F5F",
"E#	c #838ADA",
"F#	c #3D46C2",
"G#	c #BABDE9",
"H#	c #2B2B2B",
"I#	c #787DD5",
"J#	c #6C72D1",
"K#	c #E3E5F7",
"L#	c #676ECE",
"M#	c #4B53C6",
"N#	c #9C9EAF",
"O#	c #4B52C7",
"P#	c #9AA0E1",
"Q#	c #848484",
"R#	c #D6D9F3",
"S#	c #4A4FA5",
"T#	c #1D1D2A",
"U#	c #6F6F75",
"V#	c #9DA1E1",
"W#	c #454CC4",
"X#	c #E1E3F6",
"Y#	c #A1A1A1",
"Z#	c #E6E6E7",
"`#	c #979798",
" \$	c #3F4376",
".\$	c #4D56C4",
"+\$	c #B8BCE9",
"\@\$	c #B6B9E8",
"#\$	c #464FC2",
"\$\$	c #A6A9E3",
"\%\$	c #787878",
"\&\$	c #5A5A5A",
"*\$	c #DEDEEF",
"=\$	c #8288D7",
"-\$	c #4A52C7",
";\$	c #8388D8",
">\$	c #B8BBEA",
",\$	c #C6C8EE",
"'\$	c #979CDF",
")\$	c #F2F3FC",
"!\$	c #7B7B7B",
"~\$	c #CCCDEE",
"{\$	c #8289D7",
"]\$	c #6A72D0",
"^\$	c #6970D1",
"/\$	c #7077D4",
"(\$	c #B2B4E7",
"_\$	c #EFF0FA",
"                                                                                              . ",
"  + + + + + + + + + + + + + + \@ # \$ \% \& * = - ; + > , ' ) ! ~ { ] ^ + + + + + + + + + + + + + . ",
"  + + + + + + + + + + + + + / ( _ : < [ } | 1 2 3 4 5 6 7 8 9 0 a b + + + + + + + + + + + + + . ",
"  + + + + + + + + + + + + + c d e f g + h i j k l m n o p + ^ q r s t + + + + + + + + + + + + . ",
"  + + + + + + + + + + + + u v w x y + + + + z A B C D + + + + + E F G ^ + + + + + + + + + + + . ",
"  + + + + + + + + + + + + H I J K + + + + L G M N O P ; + + + + ^ Q R S + + + + + + + + + + + . ",
"  + + + + + + + + + + + + T U V + + + + W X Y Z `  ...+.+ + + + + \@.Y #.+ + + + + + + + + + + . ",
"  + + + + + + + + + + + \$.\%.\&.*.+ + + + =.-.n S + ;.>.,.'.+ + + + =.5 ).p + + + + + + + + + + . ",
"  + + + + + + + + + + + !.~.{.].+ + + ^./.(._.:.+ + <.[.}.; + + + |.1.2.L + + + + + + + + + + . ",
"  + + + + + + + + + + + 3.4.5.+ + + + #.6.7.8.+ + + g 9.0.a.+ + + L { b.c.+ + + + + + + + + + . ",
"  + + + + + + + + + + + d.e.f.+ + + g.h.(.i.+ + + + + j.k.l.m.+ + n.G a o.+ + + + + + + + + + . ",
"  + + + + + + + + + + + p.q.r.+ + :.s.t.u.+ + + + + + v.w.x.y.+ + :.z.A.B.+ + + + + + + + + + . ",
"  + + + + + + + + + + + C.D.E.+ + 8.F.~ G.+ + + + + + + H.I.J.+ + W K.6.=.+ + + + + + + + + + . ",
"  + + + + + + + + + + + L.M.N.+ + O.P.Q.n.+ + + + + + + R.f.S.T.+ W U.5 =.+ + + + + + + + + + . ",
"  + + + + + + + + + + + V.W.X.+ p Y.Z.`.+ + + + + + + + + #  +.+; W s.++\@++ + + + + + + + + + . ",
"  + + + + + + + + + + + #+\$+\%++ o s \&+*++ + + + + + + + + u =+-+;+:.X Q i.+ + + + + + + + + + . ",
"  + + + + + + + + + + + >+,+'+W )+!+`.+ + + + + + + + + + + ~+{+]+^ ^+/+> + + + + + + + + + + . ",
"  + + + + + + + + + + + (+_+:+8.<+[+n.+ + + + + + + + + + + }+|+1+2+3+X *++ + + + + + + + + + . ",
"  + + + + + + + + + + + }+4+5+6+7+, + + + + + + + + + + + + m.~+8+9+0+] a++ + + + + + + + + + . ",
"  + + + + + + + + + + + g >+;.o.3+b++ + + + + + + + + + + + + - i c+, o ^ + + + + + + + + + + . ",
"  + + d+e+=.n.+ i.f+f+f+g+h+i+j+7+k+l++ W f+f+f+f+l+^ + 8.e+d+h m+n+X o+:.*+=.S + |.f+o.+ + + . ",
"  + p+/.q+s r+B.s+) ) ) ) t+u+v+Z.w+1.x+^.) ) ) ) s+|.+ y+z+A+y B+C+! /+D+E+s F+G+H+) b.I+J++ . ",
"  + K+r . G+L+M+l+=.N+Q =.O+P+s Q+R+S+Y.o.M [+=.=.T+^ J+U+V+W+t X+Y+Z+F+l+`+ \@.\@+\@\@\@o #\@S+\$\@+ . ",
"  + \%\@(.\&\@X <+*\@W + Q =\@+ v.-\@0 )+;\@+\@>\@T+,\@\@\@'\@'\@0++ k+! )\@!\@s.~\@{\@Y a o+Y.]\@t.Q S+^\@;\@/\@> + . ",
"  + t K+L+(\@~ _\@p + Q =\@+ m.:\@Y H+s <\@[\@D+}\@|\@1\@1\@X + #\@! q ) 7.2\@3\@4\@4\@5\@6\@7\@(.0+8\@w+9\@n 0++ . ",
"  + ^+)+e+0\@a\@R d++ Q =\@+ p   b\@c\@o d\@^\@D+e\@f\@d+d+n.:.g\@M 9\@h\@0 i\@>\@j\@k\@{ q+' m f\@G+l+[\@S+l\@+ . ",
"  + ).<\@G A+R m\@^.+ Q =\@+ d+n\@o\@K L 0 7 d+,\@7._\@_\@O.`.h\@).3+p\@F q\@r\@s\@t\@M Y.M+e\@N+6 A+G 9\@\@.+ . ",
"  + c.u\@\@\@{ `+v\@W + M+_\@+ 3 Q.w\@x\@y\@l\@p\@d+!+!+!+!+A+;\@z\@B.+ b+A\@M+B\@C\@D\@' )+. ' E\@F\@!+m\@s.J++ . ",
"  + + p d+L a++ + + *+*++ i.G\@H\@I\@R.8.*+W J+J+J+J+*+^.d+:.+ W 3 J\@K\@L\@M\@d+a+a+d++ ^.J+8.:.+ + . ",
"  + + + + + + + + + + + + f+N\@O\@P\@;++ + + + + + + + + + + + + \@+y+Q\@R\@S\@+ + + + + + + + + + + . ",
"  + + + + + + + + + + + ^ J\@T\@U\@V\@W\@+ + + + + + + + + + + + a+O.X\@Y\@Z\@`\@; + + + + + + + + + + . ",
"  + + + + + + + + + + + 8.K. #K [ .#g + + + + + + + + + + + t r++#\@###\$#m.+ + + + + + + + + + . ",
"  + + + + + + + + + + + T+m\@2.; \%#\&#*#+ + + + + + + + + + + /\@s q K =#-#;#+ + + + + + + + + + . ",
"  + + + + + + + + + + + g.  Q + >#,#'#)#+ + + + + + + + + :.H+!#6+K ~#{#v.+ + + + + + + + + + . ",
"  + + + + + + + + + + + B.n ]#+ / ^#/#(#+ + + + + + + + + _#<\@:#W K <#[#~\@+ + + + + + + + + + . ",
"  + + + + + + + + + + + p+|\@|\@+ + }#|#1#2#+ + + + + + + d+Z z+J++ 3#4#5#2#+ + + + + + + + + + . ",
"  + + + + + + + + + + + T+N+]\@+ + ;#6#7#8#+ + + + + + + x+-.8 + + 9#0#a#)#+ + + + + + + + + + . ",
"  + + + + + + + + + + + d+Q W+W + ; b#c#d#; + + + + + 3 e#f#3 + + (+g#h#i#+ + + + + + + + + + . ",
"  + + + + + + + + + + + W U+Y |.+ + )#j#k#P\@+ + + + + l#m##.W + + !.n#o#; + + + + + + + + + + . ",
"  + + + + + + + + + + + + A\@p#0++ + + q#_ r#s#+ + + |.r 7.> + + + t#7#u#+ + + + + + + + + + + . ",
"  + + + + + + + + + + + + ;\@6.'\@+ + + W v#w#x#y#+ n.z\@z#R++ + + + _+A#B#+ + + + + + + + + + + . ",
"  + + + + + + + + + + + + 6+C#D#D++ + + m.E#F#G#^.\%\@H#E++ + + + + I#J#9#+ + + + + + + + + + + . ",
"  + + + + + + + + + + + + + m\@9\@0++ + + + K#L#M#N#S+K+^ + + + + X+O#P#; + + + + + + + + + + + . ",
"  + + + + + + + + + + + + + 0+t.Q#*++ + + ; R#S#T#U#6++ + + + ; V#W#X#+ + + + + + + + + + + + . ",
"  + + + + + + + + + + + + + n.Q.Y Y#D++ + Z#`#~  \$.\$+\$}++ + i#\@\$#\$\$\$+ + + + + + + + + + + + + . ",
"  + + + + + + + + + + + + + + l+' d\@\%\$U.A+\&\$H+f\@*\$=\$-\$;\$>\$,\$'\$\&#;\$)\$+ + + + + + + + + + + + + . ",
"  + + + + + + + + + + + + + + + 3 ;\@!\$\%\$4 <+S p + K ~\${\$]\$^\$/\$(\$_\$+ + + + + + + + + + + + + + . ",
". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "};
EOF

sub assign {
    my $mw = shift;
    $mw->Pixmap('icon', -data=>$iconImage,);
    $mw->Pixmap('oobjs', -data=>$objsImage,);
    $mw->Pixmap('cobjs', -data=>$objsImage,);
    $mw->Pixmap('oobjs-red', -data=>$objsRedImage,);
    $mw->Pixmap('cobjs-red', -data=>$objsRedImage,);
    $mw->Pixmap('oobjs-grn', -data=>$objsGrnImage,);
    $mw->Pixmap('cobjs-grn', -data=>$objsGrnImage,);
    $mw->Pixmap('oobjs-blu', -data=>$objsBluImage,);
    $mw->Pixmap('cobjs-blu', -data=>$objsBluImage,);
    $mw->Pixmap('onote', -data=>$noteImage,);
    $mw->Pixmap('cnote', -data=>$noteImage,);
    $mw->Pixmap('oparm', -data=>$parmImage,);
    $mw->Pixmap('cparm', -data=>$parmImage,);
    $mw->Pixmap('odocs', -data=>$odocsImage,);
    $mw->Pixmap('cdocs', -data=>$cdocsImage,);
    $mw->Pixmap('odocs-red', -data=>$odocsRedImage,);
    $mw->Pixmap('cdocs-red', -data=>$cdocsRedImage,);
    $mw->Pixmap('oinds', -data=>$oindsImage,);
    $mw->Pixmap('cinds', -data=>$cindsImage,);
    $mw->Pixmap('oinds-red', -data=>$oindsRedImage,);
    $mw->Pixmap('cinds-red', -data=>$cindsRedImage,);
    $mw->Pixmap('oinds-grn', -data=>$oindsGrnImage,);
    $mw->Pixmap('cinds-grn', -data=>$cindsGrnImage,);
    $mw->Pixmap('orows', -data=>$orowsImage,);
    $mw->Pixmap('crows', -data=>$crowsImage,);
    $mw->Pixmap('ocols', -data=>$ocolsImage,);
    $mw->Pixmap('ccols', -data=>$ccolsImage,);
    $mw->Pixmap('ocols-red', -data=>$ocolsRedImage,);
    $mw->Pixmap('ccols-red', -data=>$ccolsRedImage,);
    $mw->Pixmap('ocols-grn', -data=>$ocolsGrnImage,);
    $mw->Pixmap('ccols-grn', -data=>$ccolsGrnImage,);
    $mw->Pixmap('cbook', -data=>$cbookImage,);
    $mw->Pixmap('obook', -data=>$obookImage,);
    $mw->Pixmap('obook-blu', -data=>$obookBluImage,);
    $mw->Pixmap('cbook-red', -data=>$cbookRedImage,);
    $mw->Pixmap('cbook-grn', -data=>$cbookGrnImage,);
    $mw->Pixmap('cbook-blu', -data=>$cbookBluImage,);
    $mw->Pixmap('ohost', -data=>$ohostImage,);
    $mw->Pixmap('chost', -data=>$chostImage,);
    $mw->Pixmap('ohost-red', -data=>$ohostRedImage,);
    $mw->Pixmap('chost-red', -data=>$chostRedImage,);
    $mw->Pixmap('ohost-grn', -data=>$ohostGrnImage,);
    $mw->Pixmap('chost-grn', -data=>$chostGrnImage,);
}

# ---------------------------------

# ---------------------------------
# A proxy object for any widget.
# ---------------------------------
package MyWidget;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);

#package MyWidget;
sub new {
    my ($type,$parent,@args) = @_;
    my $self = MyPersistent::new($type,$parent) || return undef;
    $self->{'parent'} = $parent;
    return $self;
}
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    delete $self->{'parent'};
    delete $self->{'widget'};
    delete $self->{'tree'};
}
sub setframe {
    my ($self,$frame,@args) = @_;
    $self->{'frame'} = $frame;
    $frame->{_myobject} = $self;
    return $frame;
}
sub setwidget {
    my ($self,$widget,@args) = @_;
    $self->{'widget'} = $widget;
    $widget->{_myobject} = $self;
    return $widget;
}
sub setmainwindow {
    my ($self,$widget,@args) = @_;
    $self->setwidget($widget);
    $widget->bind('<Destroy>',
	[sub {
	    my ($widget,$self,@args) = @_;
	    if ($widget) {
		if ($self = $widget->{_myobject}) {
		    delete $widget->{_myobject};
		    $self->destroy;
		}
	    }
	}, $self],
    );
    return $widget;
}

sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    my $widget = $self->widget;
    my $frame = $self->frame;
    if (defined $frame) {
	$data->{'-width'} = $frame->cget('-width');
    }
    if (defined $widget) {
	$data->{'width'} = $widget->width;
	$data->{'height'} = $widget->height;
	$data->{'X'} = $widget->X;
	$data->{'Y'} = $widget->Y;
	$data->{'x'} = $widget->x;
	$data->{'y'} = $widget->y;
	$data->{'rootx'} = $widget->rootx;
	$data->{'rooty'} = $widget->rooty;
	if (ref($widget) eq 'Tk::MainWindow' ||
	    ref($widget) eq 'Tk::Toplevel') {
	    $data->{'title'} = $widget->title;
	    $data->{'minsize'} = [ $widget->minsize ];
	    $data->{'maxsize'} = [ $widget->maxsize ];
	    $data->{'geometry'} = $widget->geometry;
	} else {
	    $data->{'geometry'} = "$data->{'width'}x$data->{'height'}+$data->{'rootx'}+$data->{'rooty'}";
	}
    }
    if ($self->{'tree'}) {
	$data->{'tree'} = $self->{'tree'}->dumphash(@args);
    }
    return $data;
}

sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    if ($data->{'tree'}) {
	my $tree = $self->tree;
	$tree->reconstruct($data->{'tree'},@args);
    }
    if (my $widget = $self->widget) {
	if (ref($widget) eq 'Tk::Toplevel' ||
	    ref($widget) eq 'Tk::MainWindow') {
	    $widget->title($data->{'title'}) if $data->{'title'};
	    $widget->geometry($data->{'geometry'}) if $data->{'geometry'};
	    $widget->minsize(@{$data->{'minsize'}}) if $data->{'minsize'};
	    $widget->maxsize(@{$data->{'maxsize'}}) if $data->{'minsize'};
	} else {
	    $widget->GeometryRequest($data->{'width'},$data->{'height'});
	}
    }
    if (my $frame = $self->frame) {
	if (defined $data->{'-width'}) {
	    $frame->configure(-width=>$data->{'-width'});
	}
    }
}

sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyWidget::new($data->{'class'},$parent,@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyWidget;
sub tree {
    my $self = shift;
    $self->{'tree'} = MyTree->new($self) unless $self->{'tree'};
    return $self->{'tree'};
}

#package MyWidget;
sub parent {
    shift->{'parent'};
}

#package MyWidget;
sub top {
    my $self = shift;
    my $top = $self;
    while (defined $top->{'parent'}) {
	$top = $top->{'parent'};
    }
    return $top;
}

#package MyWidget;
sub toplevel {
    my $self = shift;
    if (defined $self->widget) {
	return $self->widget->toplevel;
    }
    return $self->parent->toplevel;
}

#package MyWidget;
sub widget {
    shift->{'widget'};
}
#package MyWidget;
sub frame {
    shift->{'frame'};
}

#package MyWidget;
sub attachballoon {
    my ($self,@args) = @_;
    return $self->parent->attachballoon(@args);
}

#package MyWidget;
sub statusmsg {
    my ($self,@args) = @_;
    return $self->parent->statusmsg(@args);
}

#package MyWidget;
sub addscalars {
    my ($self,@args) = @_;
    return $self->parent->addscalars(@args);
}

#package MyWidget;
sub addtables {
    my ($self,@args) = @_;
    return $self->parent->addtables(@args);
}

#package MyWidget;
sub addobjects {
    my ($self,@args) = @_;
    return $self->parent->addobjects(@args);
}

#package MyWidget;
sub rotext {
    my ($self,@args) = @_;
    return $self->parent->rotext(@args);
}

#package MyWidget;
sub sessions {
    my ($self,@args) = @_;
    return $self->top->{'sessions'};
}

#package MyWidget;
sub configure {
    my ($self,@args) = @_;
    return $self->widget->configure(@args);
}

#package MyWidget;
sub cget {
    my ($self,@args) = @_;
    return $self->widget->cget(@args);
}

#package MyWidget;
sub pack {
    my ($self,@args) = @_;
    return $self->widget->pack(@args);
}


# ---------------------------------

# ---------------------------------
# A toplevel window proxy object.
# ---------------------------------
package MyToplevel;
use strict;
use vars qw(@ISA);
@ISA = qw(MyWidget);

#package MyToplevel;
sub new {
    my ($type,$parent,$title,@args) = @_;
    my $self = MyWidget::new($type,$parent,@args);
    $self->{'data'}->{'title'} = $title;
    my $tl = $parent->widget->MainWindow->Toplevel(
	-title=>$title,
    );
    $tl->title($title);
    $self->setwidget($tl);
    return $self;
}
#package MyToplevel;
sub destroy {
    my ($self,@args) = @_;
}
#package MyToplevel;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    return $data;
}
#package MyToplevel;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
}
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyToplevel::new($parent,$data->{'class'},$data->{'title'},@args);
    $self->reconstruct($data,@args);
    return $self;
}

# ---------------------------------

# ---------------------------------
# A mainwindow proxy object.
# ---------------------------------
package MyMainWindow;
use strict;
use vars qw(@ISA);
@ISA = qw(MyWidget);

@MyMainWindow::windows = ();

#package MyMainWindow;
sub new {
    my ($type,$title,@args) = @_;
    my $self = MyWidget::new($type,undef,@args);
    $self->{'data'}->{'title'} = $title;
    my $mw = Tk::MainWindow->new;
    $self->setmainwindow($mw);
    $mw->title($title);
    $mw->minsize(600,400);
    $mw->geometry('1024x768');
    $mw->protocol('WM_DELETE_WINDOW',[\&wm_delete_window,$self],);
    $mw->protocol('WM_SAVE_YOURSELF',[\&wm_save_yourself,$self],);
    #$mw->protocol('WM_TAKE_FOCUS',[\&wm_take_focus,$self],);
    push @MyMainWindow::windows, $self;
    MyOptions::assign($mw);
    MyPixmaps::assign($mw);
    $mw->iconimage('icon');
    $mw->iconname($title);
    return $self;
}
#package MyMainWindow;
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    for (my $i = 0; $i < @MyMainWindow::windows; $i++) {
	if ($MyMainWindow::windows[$i] eq $self) {
	    splice @MyMainWindow::windows, $i, 1;
	    last;
	}
    }
}

#package MyMainWindow;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $data->{'title'} = $self->widget->cget($_);
    return $data;
}

#package MyMainWindow;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    $self->widget->configure(-title=>$data->{'title'}) if defined $data->{'title'};
}

#package MyMainWindow;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyMainWindow::new($data->{'class'},$data->{'title'},@args);
    $self->reconstruct($data,@args);
    return $self;
}


#package MyMainWindow;
sub wm_delete_window {
    my ($self,@args) = @_;
    $self->widget->destroy;
}

#package MyMainWindow;
sub wm_save_yourself {
    my ($self,@args) = @_;
}

#package MyMainWindow;
sub wm_take_focus {
    my ($self,@args) = @_;
}

# ---------------------------------

# ---------------------------------
# Each session object represents a connection to a host.  It is created with the
# name of the host and any host information.  The session details can be editted
# in a dialog.
# ---------------------------------
package MySession;
use strict;
use vars qw(@ISA @EXPORT);
@ISA = qw(MyPersistent);

@MySession::specs = (
    {
	label=>'DestHost', type=>'String', units=>'Host Name',
	txtvalue=>'DestHost', txtdefault=>'localhost',
	lmsg=><<EOF,
The host name or IP address of the SNMP agent for this
session.  A DNS lookup will be performed if necessary.
This defaults to 'localhost'.
EOF
    },
    {
	label=>'Community', type=>'String', units=>'Text String',
	txtvalue=>'Community', txtdefault=>'openss7',
	lmsg=><<EOF,
The SNMP community string (used for both reading and
writing).  This defaults to 'public'.
EOF
    },
    {
	label=>'Version', type=>'Enum', units=>'Selection', numvalue=>'Version',
	txtvalue=>'VersionText', numdefault=>2, txtdefault=>'Version 2c',
	enums=>[
	    [ 'Version 1'=>1, ],
	    [ 'Version 2'=>2, ],
	    [ 'Version 2c'=>2, ],
	    [ 'Version 3'=>3, ],
	],
	lmsg=><<EOF,
The SNMP version string.  The default version is 2
(Version 2c).  Many of the fields that follow are not
used for lower version numbers.
EOF
    },
    {
	label=>'RemotePort', type=>'Number', units=>'Port Number',
	numvalue=>'RemotePort', numdefault=>161,
	min=>1,
	max=>65535,
	lmsg=><<EOF,
The remote TCP/IP port number upon which the agent is
listening.  This defaults to port 161, the well-known
port number for SNMP.
EOF
    },
    {
	label=>'Timeout', type=>'Number', units=>'Microseconds',
	numvalue=>'Timeout', numdefault=>1000000, min=>1000, max=>120000000,
	lmsg=><<EOF,
When retrying, the number of microseconds that the
manager will wait before retrying the request.  The
default is 1000000 microseconds (1 second).
EOF
    },
    {
	label=>'Retries', type=>'Number', units=>'Retries', numvalue=>'Retries',
	numdefault=>5, min=>0, max=>100,
	lmsg=><<EOF,
The maximum number of retries for a given request
before it is considered failed.  The default value is
5 (retries).
EOF
    },
    {
	label=>'RetryNoSuch', type=>'Enum', units=>'Selection',
	numvalue=>'RetryNoSuch', numdefault=>0, txtvalue=>'RetryNoSuchText',
	txtdefault=>'False',
	enums=>[
	    [ 'False'=>0, ],
	    [ 'True'=>1, ],
	],
	lmsg=><<EOF,
When enabled (True), NOSUCH errors in GET PDUs will be
repaired, removing the varbind in error, and resent -
undef will be returned for all NOSUCH varbinds, when
disabled (False), this feature is disabled and the
entire GET request will faile on any NOSUCH error
(applies to SNMP Version 1 only).  The default is
disabled (False).
EOF
    },
    {
	label=>'SecName', type=>'String', units=>'Text String',
	txtvalue=>'SecName', txtdefault=>'initial',
	lmsg=><<EOF,
Specifies the security name.  There default is
'initial'.
EOF
    },
    {
	label=>'SecLevel', type=>'Enum', units=>'Selection',
	numvalue=>'SecLevelNum', txtvalue=>'SecLevel', numdefault=>0,
	txtdefault=>'noAuthNoPriv',
	enums=>[
	    [ 'noAuthNoPriv'=>0, ],
	    [ 'authNoPriv'=>1, ],
	    [ 'authPriv'=>2, ],
	],
	lmsg=><<EOF,
Specifies the security level.  This can be one of the
selections show.  This selection applies only to SNMP
Version 3.  The default value is 'noAuthNoPriv'.
EOF
    },
    {
	label=>'SecEngineId', type=>'String', units=>'Text String',
	txtvalue=>'SecEngineId', txtdefault=>undef,
	lmsg=><<EOF,
Specifies the security engine ID (will be probed for
SNMP Version 3 if not supplied).  This field is
applicable only to SNMP Version 3 and defaults to
none.
EOF
    },
    {
	label=>'ContextEngineId', type=>'String', units=>'Text String',
	txtvalue=>'ContextEngineId', txtdefault=>undef,
	lmsg=><<EOF,
Specifies the context engine ID (will be probed for
SNMP Version 3 if not supplied).  This field is
applicable only to SNMP Version 3 and defaults to
none.
EOF
    },
    {
	label=>'Context', type=>'String', units=>'Text String',
	txtvalue=>'Context', txtdefault=>'',
	lmsg=><<EOF,
EOF
    },
    {
	label=>'AuthProto', type=>'Enum', units=>'Selection',
	numvalue=>'AuthProtoNum', txtvalue=>'AuthProto', numdefault=>0,
	txtdefault=>'MD5',
	enums=>[
	    [ 'MD5'=>0, ],
	    [ 'SHA'=>1, ],
	],
	lmsg=><<EOF,
EOF
    },
    {
	label=>'AuthPass', type=>'String', units=>'Text String',
	txtvalue=>'AuthPass', txtdefault=>undef,
	password=>1,
	lmsg=><<EOF,
EOF
    },
    {
	label=>'PrivProto', type=>'Enum', units=>'Selection',
	numvalue=>'PrivProtoNum', txtvalue=>'PrivProto', numdefault=>0,
	txtdefault=>'DES',
	enums=>[
	    [ 'DES'=>0, ],
	    [ 'AES'=>1, ],
	],
	lmsg=><<EOF,
EOF
    },
    {
	label=>'PrivPass', type=>'String', units=>'Text String',
	txtvalue=>'PrivPass', txtdefault=>undef,
	password=>1,
	lmsg=><<EOF,
EOF
    },
    {
	label=>'authMasterKey', type=>'String', units=>'Text String',
	txtvalue=>'authMasterKey', txtdefault=>undef,
	lmsg=><<EOF,
EOF
    },
    {
	label=>'privMasterKey', type=>'String', units=>'Text String',
	txtvalue=>'privMasterKey', txtdefault=>undef,
	lmsg=><<EOF,
EOF
    },
    {
	label=>'authLocalizedKey', type=>'String', units=>'Text String',
	txtvalue=>'authLocalizedKey', txtdefault=>undef,
	lmsg=><<EOF,
EOF
    },
    {
	label=>'privLocalizedKey', type=>'String', units=>'Text String',
	txtvalue=>'privLocalizedKey', txtdefault=>undef,
	lmsg=><<EOF,
EOF
    },
    {
	label=>'UseLongNames', type=>'Enum', units=>'Selection', readonly=>1,
	numvalue=>'UseLongNames', numdefault=>0, txtvalue=>'UseLongNamesText',
	txtdefault=>'False',
	enums=>[
	    [ 'False'=>0, ],
	    [ 'True'=>1, ],
	],
	lmsg=><<EOF,
EOF
    },
    {
	label=>'UseSprintValue', type=>'Enum', units=>'Selection', readonly=>1,
	numvalue=>'UseSprintValue', numdefault=>0, txtvalue=>'UseSprintValueText',
	txtdefault=>'False',
	enums=>[
	    [ 'False'=>0, ],
	    [ 'True'=>1, ],
	],
	lmsg=><<EOF,
EOF
    },
    {
	label=>'UseEnums', type=>'Enum', units=>'Selection', readonly=>1,
	numvalue=>'UseEnums', numdefault=>0, txtvalue=>'UseEnumsText',
	txtdefault=>'False',
	enums=>[
	    [ 'False'=>0, ],
	    [ 'True'=>1, ],
	],
	lmsg=><<EOF,
EOF
    },
    {
	label=>'UseNumeric', type=>'Enum', units=>'Selection', readonly=>1,
	numvalue=>'UseNumeric', numdefault=>0, txtvalue=>'UseNumericText',
	txtdefault=>'False',
	enums=>[
	    [ 'False'=>0, ],
	    [ 'True'=>1, ],
	],
	lmsg=><<EOF,
EOF
    },
    {
	label=>'BestGuess', type=>'Enum', units=>'Selection', readonly=>1,
	numvalue=>'BestGuess', txtvalue=>'BestGuessText', numdefault=>2,
	txtdefault=>'Random Access Lookup',
	enums=>[
	    [ 'Regular Loopup'=>0 ],
	    [ 'Regular Expression Match'=>1 ],
	    [ 'Random Access Lookup'=>2 ],
	],
	lmsg=><<EOF,
Defaults to the value of the SNMP::best_guess at time
of session creation.  This setting controls how <tags>
are parsed.  Setting to 0 (Regular Lookup) caues a
regular lookup.  Setting to 1 (Regular Expression
Match) causes a regular expression match (defined as
-Ib in snmpcmd) and setting to 2 (Random Access
Lookup) causes a random access lookup (defined as -IR
in snmpcmd).
EOF
	emsg=>'Make a selection.',
	umsg=>'Selected values only.',
    },
);

#package MySession;
$MySession::sessionnum = 0;
#package MySession;
sub new {
    my ($type,$parent,%args) = @_;
    my $self = MyPersistent::new($type,$parent,%args);
    $self->{'name'} = 'session.'.$MySession::sessionnum++;
    $self->{'vdata'} = {};
    $self->{'sstate'} = 'disconnected';
    my $hostspecified = defined $args{'DestHost'} ? 1 : undef;
    foreach my $spec (@MySession::specs) {
	chomp $spec->{'lmsg'} if defined $spec->{'lmsg'};
	chomp $spec->{'emsg'} if defined $spec->{'emsg'};
	chomp $spec->{'umsg'} if defined $spec->{'umsg'};
	if ($spec->{'type'} eq 'Number') {
	    unless (defined $args{$spec->{'numvalue'}}) {
		$args{$spec->{'numvalue'}} = $spec->{'numdefault'}
	    }
	} elsif ($spec->{'type'} eq 'Enum') {
	    unless (defined $args{$spec->{'numvalue'}} or defined
		$args{$spec->{'txtvalue'}}) {
		$args{$spec->{'numvalue'}} = $spec->{'numdefault'};
		$args{$spec->{'txtvalue'}} = $spec->{'txtdefault'};
	    } else {
		unless (defined $args{$spec->{'numvalue'}}) {
		    foreach (@{$spec->{'enums'}}) {
			if ($_->[0] eq $args{$spec->{'txtvalue'}}) {
			    $args{$spec->{'numvalue'}} = $_->[1];
			    last;
			}
		    }
		}
		unless (defined $args{$spec->{'txtvalue'}}) {
		    foreach (@{$spec->{'enums'}}) {
			if ($_->[1] == $args{$spec->{'numvalue'}}) {
			    $args{$spec->{'txtvalue'}} = $_->[0];
			    last;
			}
		    }
		}
	    }
	} elsif ($spec->{'type'} eq 'String') {
	    unless (defined $args{$spec->{'txtvalue'}}) {
		$args{$spec->{'txtvalue'}} = $spec->{'txtdefault'};
	    }
	} else {
	    warn "ERROR: spec has illegal type '$spec->{'type'}'";
	}
    }
    $self->{'data'}->{'options'} = \%args;
    if ($hostspecified) {
	$self->{'data'}->{'hostname'} = $self->{'data'}->{'options'}->{'DestHost'};
    } else {
	my $answer = $self->dialog($parent->toplevel);
	return undef unless $answer eq 'OK';
	$self->{'data'}->{'hostname'} = $self->{'data'}->{'options'}->{'DestHost'};
    }
    $self->{'parent'} = $parent;
    $parent->top->addsession($self);
    $self->connect;
    return $self;
}

#package MySession;
sub name {
    shift->{'name'};
}

#package MySession;
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    if (my $parent = $self->{'parent'}) {
	$parent->top->delsession($self);
	delete $self->{'parent'};
    }
}

#package MySession;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $data->{'connected'} = $self->{'snmp'} ? 1 : 0;
    return $data;
}

#package MySession;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    $self->disconnect;
    $self->connect if $data->{'connected'};
}

#package MySession;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MySession->new($parent,%{$data->{'options'}},@args);
    $self->connect if $data->{'connected'};
    return $self;
}

#package MySession;
sub hostname {
    shift->{'data'}->{'hostname'};
}

#package MySession;
sub tagname {
    shift->{'sstate'};
}

#package MySession;
sub connected {
    shift->{'snmp'} ? 1 : 0;
}

#package MySession;
sub connect {
    my $self = shift;
    return $self->{'snmp'} if defined $self->{'snmp'};
    $self->{'snmp'} = ::sess(%{$self->{'data'}->{'options'}});
    if ($self->{'snmp'}) {
	$self->{'sstate'} = 'connected';
	$self->{'data'}->{'connected'} = 1;
    } else {
	$self->{'sstate'} = 'disconnected';
	$self->{'data'}->{'connected'} = 0;
    }
    return $self->{'snmp'};
}

#package MySession;
sub testconnection {
    my $self = shift;
    my $success = undef;
    my $sess = $self->connect;
    unless (defined $sess) {
    }
    my $val = $sess->get('sysUpTime.0');
    if ($sess->{'ErrorStr'}) {
	$self->{'sstate'} = 'failed';
    } else {
	if (defined $val && $val eq 'NOSUCHINSTANCE') {
	    $self->{'sstate'} = 'errored';
	} else {
	    $success = 1;
	    $self->{'sstate'} = 'connected';
	}
    }
    return $success;
}

#package MySession;
sub disconnect {
    my $self = shift;
    $self->{'snmp'} = undef;
    $self->{'data'}->{'connected'} = 0;
    $self->{'sstate'} = 'disconnected';
    return $self->{'snmp'};
}

#package MySession;
sub getdialog {
    my ($self,$toplevel) = @_;
    return $self->{'dialog'} if defined $self->{'dialog'};
    my $dialog = $toplevel->DialogBox(
	-title=>'Session Dialog',
	-buttons=>[qw/OK Cancel Revert Defaults/],
	-default_button=>'OK',
    );
    $self->{'dialog'} = $dialog;
    $dialog->OnDestroy([sub {
	    shift->{'Host'} = undef;
	}, $self],
    );
    my ($b, $h);
    $h = $dialog->Balloon;
    $b = $dialog->Subwidget('B_OK');
    $h->attach($b,
	-balloonmsg=>'Commit all changes and exit.',
    );
    $b = $dialog->Subwidget('B_Cancel');
    $h->attach($b,
	-balloonmsg=>'Cancel all changes and exit.',
    );
    $b = $dialog->Subwidget('B_Revert');
    $b->configure(
	-command=>[sub {
	    my $self = shift;
	    my $opt = $self->{'edit'};
	    my $old = $self->{'data'}->{'options'};
	    foreach (@MySession::specs) {
		if ($_->{'type'} eq 'Number') {
		    $opt->{$_->{'numvalue'}} = $old->{$_->{'numvalue'}};
		} elsif ($_->{'type'} eq 'Enum') {
		    $opt->{$_->{'numvalue'}} = $old->{$_->{'numvalue'}};
		    $opt->{$_->{'txtvalue'}} = $old->{$_->{'txtvalue'}};
		} elsif ($_->{'type'} eq 'String') {
		    $opt->{$_->{'txtvalue'}} = $old->{$_->{'txtvalue'}};
		}
	    }
	}, $self],
    );
    $h->attach($b,
	-balloonmsg=>"Revert all values to the values present 
when this dialog was opened.  Do not exit.",
    );
    $b = $dialog->Subwidget('B_Defaults');
    $b->configure(
	-command=>[sub {
	    my $self = shift;
	    my $opt = $self->{'edit'};
	    foreach (@MySession::specs) {
		next if $_->{'label'} eq 'DestHost';
		if ($_->{'type'} eq 'Number') {
		    $opt->{$_->{'numvalue'}} = $_->{'numdefault'};
		} elsif ($_->{'type'} eq 'Enum') {
		    $opt->{$_->{'numvalue'}} = $_->{'numdefault'};
		    $opt->{$_->{'txtvalue'}} = $_->{'txtdefault'};
		} elsif ($_->{'type'} eq 'String') {
		    $opt->{$_->{'txtvalue'}} = $_->{'txtdefault'};
		}
	    }
	}, $self],
    );
    $h->attach($b,
	-balloonmsg=>"Set all values to defaults.\nDo not exit.",
    );
    my $pane = $dialog->Pane( #Scrolled('Pane',
    )->pack(
	-expand=>1,
	-fill=>'both',
	-side=>'top',
    );
    my ($row,$col,$l) = (0,0);
    foreach (qw/Label Entry Units/) {
	$pane->Label(
	    -anchor=>'center',
	    -justify=>'center',
	    -text=>$_,
	)->grid(
	    -column=>$col++,
	    -row=>$row,
	    -sticky=>'ewns',
	);
    }
    foreach my $spec (@MySession::specs) {
	$row++; $col = 0;
	$b = $pane->Label(
	    -anchor=>'w',
	    -justify=>'left',
	    -text=>$spec->{'label'},
	)->grid(
	    -column=>$col++,
	    -row=>$row,
	    -sticky=>'ewns',
	);
	$h->attach($b, 
	    -balloonmsg=>$spec->{'lmsg'},
	) if defined $spec->{'lmsg'};
	if ($spec->{'type'} eq 'Number') {
	    $b = $pane->Spinbox(
		-exportselection=>1,
		#-buttons=>1,
		#-orient=>'horizontal',
		-justify=>'left',
		-from=>$spec->{'min'},
		-to=>$spec->{'max'},
		-increment=>1,
		#-maxvalue=>$spec->{'max'},
		#-minvalue=>$spec->{'min'},
		-readonly=>$spec->{'readonly'},
		-textvariable=>\$self->{'edit'}->{$spec->{'numvalue'}},
		-state=>$spec->{'readonly'} ?  'disabled' : 'normal',
	    );
	} elsif ($spec->{'type'} eq 'Enum') {
	    $b = $pane->Optionmenu(
		-anchor=>'w',
		-justify=>'left',
		-options=>$spec->{'enums'},
		-textvariable=>\$self->{'edit'}->{$spec->{'txtvalue'}},
		-variable=>\$self->{'edit'}->{$spec->{'numvalue'}},
		-state=>$spec->{'readonly'} ?  'disabled' : 'normal',
	    );
	} else { # ($spec->{'type'} eq 'String')
	    $b = $pane->Entry(
		-exportselection=>1,
		-justify=>'left',
		-textvariable=>\$self->{'edit'}->{$spec->{'txtvalue'}},
		-state=>$spec->{'readonly'} ?  'disabled' : 'normal',
		-show=>$spec->{'password'} ? '*' : undef,
	    );
	}
	$b->grid(
	    -column=>$col++,
	    -row=>$row,
	    -sticky=>'ewns',
	);
	$h->attach($b, 
	    -balloonmsg=>$spec->{'emsg'},
	) if defined $spec->{'emsg'};
	$b = $pane->Label(
	    -anchor=>'w',
	    -justify=>'left',
	    -text=>$spec->{'units'},
	)->grid(
	    -column=>$col++,
	    -row=>$row,
	    -sticky=>'ewns',
	);
	$h->attach($b, 
	    -balloonmsg=>$spec->{'umsg'},
	) if defined $spec->{'umsg'};
    }
    return $dialog;
}

#package MySession;
sub dialog {
    my ($self,$toplevel) = @_;
    foreach (@MySession::specs) {
	$self->{'edit'}->{$_->{'numvalue'}} = $self->{'data'}->{'options'}->{$_->{'numvalue'}} if defined $_->{'numvalue'};
	$self->{'edit'}->{$_->{'txtvalue'}} = $self->{'data'}->{'options'}->{$_->{'txtvalue'}} if defined $_->{'txtvalue'};
    }
    my $dialog = $self->getdialog($toplevel);
    my $answer = $dialog->Show;
    if ($answer eq 'OK') {
	foreach (@MySession::specs) {
	    $self->{'data'}->{'options'}->{$_->{'numvalue'}} = $self->{'edit'}->{$_->{'numvalue'}} if defined $_->{'numvalue'};
	    $self->{'data'}->{'options'}->{$_->{'txtvalue'}} = $self->{'edit'}->{$_->{'txtvalue'}} if defined $_->{'txtvalue'};
	}
	$self->{'data'}->{'hostname'} = $self->{'data'}->{'options'}->{'DestHost'};
    }
    return $answer;
}

#package MySession;
sub snmp {
    shift->{'snmp'};
}

#package MySession;
sub detail {
    my ($self,@args) = @_;
    my $string = '';
    foreach (@MySession::specs) {
	my $label = "$_->{'label'}:..........................";
	$label =~ s/^(..................)(.*)$/$1/;
	$string .= $label.$self->{'data'}->{'options'}->{$_->{'label'}}."\n"
	    if defined $self->{'data'}->{'options'}->{$_->{'label'}};
    }
    return $string;
}

# ---------------------------------

# ---------------------------------
package MyPage;
use strict;
use vars qw(@ISA);
@ISA = qw(MyWidget);

#package MyPage;
sub new {
    my ($type,$parent,$page,$label,%args) = @_;
    my $self = MyWidget::new($type,$parent,%args) || return undef;
    $self->{'data'}->{'page'} = $page;
    $self->{'data'}->{'label'} = $label;
    $self->{'data'}->{'title'} = $label;
    my $widget;
    if ($args{'-tearout'}) {
	$self->{'data'}->{'torn'} = 1;
	$widget = $parent->widget->MainWindow->Toplevel(
	    -title=>$label,
	);
	$widget->title($title);
	$widget->protocol('WM_DELETE_WINDOW',
	    [\&wm_delete,$self],
	);
	$widget->protocol('WM_TAKE_FOCUS',
	    [sub {
		my ($self,$frame) = @_;
		$self->raisecmd($frame);
	    },$self,$widget],
	);
	$self->setwidget($widget);
	$self->createcmd($widget);
    } else {
	$self->{'data'}->{'torn'} = 0;
	$widget = $parent->widget->add($page,
	    -anchor=>'w',
	    -justify=>'center',
	    -label=>$label,
	    -state=>'normal',
	    -createcmd=>[sub {
		my ($self,$frame) = @_;
		$self->createcmd($frame);
	    }, $self],
	    -raisecmd=>[sub {
		my ($self,$frame) = @_;
		$self->raisecmd($frame);
	    }, $self],
	);
	$self->setwidget($widget);
    }
    return $self;
}
#package MyPage;
sub wm_delete {
    my ($self,@args) = @_;
    my $parent = $self->parent;
    my $page = $self->{'data'}->{'page'};
    $parent->gluepage($page,$self,@args);
}
#package MyPage;
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    my $page = $self->{'data'}->{'page'};
    my $parent = $self->parent;
    if ($parent) {
	if ($self->{'data'}->{'torn'}) {
	    delete $self->parent->{'loose'}->{$page};
	} else {
	    delete $self->parent->{'pages'}->{$page};
	}
    }
}
#package MyPage;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    my $widget = $self->parent->widget;
    $data->{'width'} = $widget->width;
    $data->{'height'} = $widget->height;
    $data->{'geometry'} = "$data->{'width'}x$data->{'height'}+$data->{'rootx'}+$data->{'rooty'}";
    return $data;
}
#package MyPage;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    $self->setlabel;
}
#package MyPage;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyPage->new($parent,$data->{'page'},$data->{'label'},@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyPage;
sub label {
    shift->{'data'}->{'label'};
}

#package MyPage;
sub pageconfigure {
    my ($self,@args) = @_;
    return $self->parent->widget->pageconfigure(@args);
}
#package MyPage;
sub pagecget {
    my ($self,@args) = @_;
    return $self->parent->widget->pagecget(@args);
}

#package MyPage;
sub restorelabel {
    my ($self,@args) = @_;
    $self->{'data'}->{'label'} = $self->pagecget($self->{'data'}->{'page'},'-label');
}

#package MyPage;
sub setlabel {
    my ($self,$label,@args) = @_;
    if (defined $label) {
	$self->{'data'}->{'label'} = $label;
    }
    if ($self->{'data'}->{'torn'}) {
	$self->widget->configure(
	    -title=>$self->{'data'}->{'label'},
	);
    } else {
	$self->pageconfigure($self->{'data'}->{'page'},
	    -label=>$self->{'data'}->{'label'},
	);
    }
}
#package MyPage;
sub updatelabel {
    my ($self,$label,@args) = @_;
    unless ($self->{'data'}->{'labelled'}) {
	$self->setlabel($label);
    }
}
#package MyPage;
sub rename {
    my ($self,$label,@args) = @_;
    $self->setlabel($label);
    $self->{'data'}->{'labelled'} = 1;
}

# ---------------------------------

# ---------------------------------
package MyROText;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPage);

#package MyROText;
sub new {
    my ($type,$parent,$page,$label,$width,@args) = @_;
    $label = 'Details' unless defined $label;
    my $self = MyPage::new($type,$parent,$page,$label,@args) || return undef;
    $self->{'data'}->{'txtwidth'} = $width;
    return $self;
}
#package MyROText;
sub createcmd {
    my ($self,$frame,@args) = @_;
    return if $self->{'created'};
    my $width = $self->{'data'}->{'txtwidth'};
    $width = 80 unless $width;
    my $rotext = $self->widget->Scrolled('ROText',
	-scrollbars=>'onow',
	-width=>$width,
	-wrap=>'none',
    )->pack(
	-expand=>1, -fill=>'both', -side=>'left', -anchor=>'w',
#    )->place(
#	-x=>0,-y=>0,-relwidth=>1.0,-relheight=>1.0,
    );
    $rotext = $rotext->Subwidget('scrolled');
    $self->{'dropsite'} = $rotext->DropSite(
	-droptypes=>[qw/XDND Sun Local/],
	-dropcommand=>[\&MyROText::dropcommand,$self],
    );
    $self->{'rotext'} = $rotext;
    $self->{'contained'} = $rotext;
    $self->{'created'} = 1;
    if ($self->{'needreconstruct'}) {
	$self->reconstruct($self->{'data'});
    }
    return $self;
}
#package MyROText;
sub raisecmd {
    my ($self,$frame,@args) = @_;
}

#package MyROText;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    unless ($self->{'created'}) {
	$self->{'needreconstruct'} = 1;
	return;
    }
    $self->{'rotext'}->delete('0.0', 'end') if $self->{'created'};
    if ($data->{'oid'}) {
	if (my $mib = MyObject->new($self->tree, $data->{'oid'})) {
	    $self->filltext($mib);
	}
    }
}

#package MyROText;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyROText->new($parent,$data->{'page'},$data->{'label'},$data->{'width'},@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyROText;
sub dropcommand {
    my ($self,$seln,$action,$targets,$xo,$yo,@args) = @_;
    if ($action eq 'LocalDrop' || $::dragobj) {
	$self->filltext($::dragobj);
    } else {
	if (my $oid = $self->widget->toplevel->SelectionGet(-selection=>$seln)) {
	    chomp $oid;
	    $oid =~ s/(\s|\n)*$//;
	    if (my $mib = MyObject->new($self->tree, $oid)) {
		$self->filltext($mib);
		$self->{'data'}->{'oid'} = $oid;
	    }
	}
    }
}

#package MyROText;
sub filltextobject {
    my ($self,$mib,$entry,@args) = @_;
    $self->{'data'}->{'oid'} = $mib->{'objectID'};
    my $tx = $self->{'rotext'};
    $tx->delete('0.0', 'end');
    $tx->insert('end', $mib->detail($entry,@args));
    return;
}

#package MyROText;
sub filltextdata {
    my ($self,$value,$entry,@args) = @_;
    my $tx = $self->{'rotext'};
    $tx->delete('0.0', 'end');
    $tx->insert('end', $value->detail($entry,@args));
    return;
}

#package MyROText;
sub filltextentry {
    my ($self,$value,$entry,@args) = @_;
    my $tx = $self->{'rotext'};
    $tx->delete('0.0', 'end');
    $tx->insert('end', $value->detail($entry,@args));
    return;
}

#package MyROText;
sub filltextvalue {
    my ($self,$value,$entry,@args) = @_;
    my $tx = $self->{'rotext'};
    $tx->delete('0.0', 'end');
    $tx->insert('end', $value->detail($entry,@args));
    return;
}

#package MyROText;
sub filltextentity {
    my ($self,$entity,$entry,@args) = @_;
    my $tx = $self->{'rotext'};
    $tx->delete('0.0', 'end');
    $tx->insert('end', $entity->detail($entry,@args));
    return;
}

#
# Clear the text object and fill it with information about the mib.
#
#package MyROText;
sub filltext {
    my ($self,$ref,@args) = @_;
    my $tx = $self->{'rotext'};
    if (UNIVERSAL::isa($ref,'MyObject')) {
	return $self->filltextobject($ref,@args);
    } elsif (UNIVERSAL::isa($ref,'MyData')) {
	return $self->filltextdata($ref,@args);
    } elsif (UNIVERSAL::isa($ref,'MyEntry')) {
	return $self->filltextentry($ref,@args);
    } elsif (UNIVERSAL::isa($ref,'MyEntity')) {
	return $self->filltextentity($ref,@args);
    } else {
	warn "Unknown object to filltext: ".ref($ref);
    }
}

#package MyROText;
sub fillvarbind {
    my ($self,$idx,$val,@args) = @_;
    my $tx = $self->{'rotext'};
    $tx->insert('end', "Value:   ".$idx.": ".$val."\n");
}

#package MyROText;
sub filltable {
    my ($self,$idx,$label,$val,@args) = @_;
    my $tx = $self->{'rotext'};
    $tx->insert('end', "Value:   $idx: $label: $val\n");
}

# ---------------------------------

# ---------------------------------
package MyMatrix;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPage);

#package MyMatrix;
sub new {
    my ($type,$parent,$page,$label,$width,@args) = @_;
    $label = 'Editor' unless defined $label;
    my $self = MyPage::new($type,$parent,$page,$label,@args) || return undef;
    return $self;
}
#package MyMatrix;
sub createcmd {
    my ($self,$frame,@args) = @_;
    return if $self->{'created'};
    $self->{'groups'} = [];
    my $pane = $frame->Scrolled('Pane',
	-scrollbars=>'onow',
	-sticky=>'ewns',
    )->pack(
	-expand=>1, -fill=>'both', -side=>'left', -anchor=>'w',
    );
    $self->{'contained'} = $pane;
    $pane = $pane->Subwidget('scrolled');
    $self->setframe($pane);
    my $msg = <<EOF;
Use the left button, <Button-1>, to drag arcs or
objects from the hierarchical list on the left and
drop them into this window to create entries for
editing.

Drag and drop file names from the desktop into this
window to recreate the configuration saved in the
file.  The file must of course be of the correct type
for this to work.
EOF
    chomp $msg;
    $self->attachballoon($pane,
	-balloonmsg=>$msg,
    );
    $self->{'dropsite'} = $pane->DropSite(
	-droptypes=>[qw/XDND Sun Local/],
	-dropcommand=>[\&MyMatrix::dropcommand,$self],
    );
    $pane->bind('<Control-v>', # paste
	[sub {
	    my ($pane,$self) = @_;
	    my $tl = $pane->toplevel;
	    if (my $oid = $tl->SelectionGet(-selection=>'CLIPBOARD')) {
		chomp $oid;
		if (my $mib = MyObject->new($self->tree, $oid)) {
		    $self->addobjects($mib);
		} else {
		    warn "Could not find oid '$oid'.";
		    $tl->bell;
		}
	    } else {
		warn "Clipboard empty.";
		$tl->bell;
	    }
	}, $self],
    );
    $pane->bind('<Button-2>', # paste
	[sub {
	    my ($pane,$self) = @_;
	    my $tl = $pane->toplevel;
	    if (my $oid = $tl->SelectionGet(-selection=>'PRIMARY')) {
		chomp $oid;
		if (my $mib = MyObject->new($self->tree, $oid)) {
		    $self->addobjects($mib);
		} else {
		    warn "Could not find oid '$oid'.";
		    $tl->bell;
		}
	    } else {
		warn "No selection.";
		$tl->bell;
	    }
	}, $self],
    );
    $self->{'created'} = 1;
    if ($self->{'needreconstruct'}) {
	$self->reconstruct($self->{'data'});
    }
    return $self;
}
#package MyMatrix;
sub raisecmd {
    my ($self,$frame,@args) = @_;
}

#package MyMatrix;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $self->createcmd($self->widget);
    $data->{'groups'} = [];
    foreach (@{$self->{'groups'}}) {
	push @{$data->{'groups'}}, $_->dumphash(@args);
    }
    return $data;
}
#package MyMatrix;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    unless ($self->{'created'}) {
	$self->{'needreconstruct'} = 1;
	return;
    }
    # NOTE -- we can't really reconstruct these, delete the page and then
    # recreate it.
    foreach (@{$self->{'groups'}}) {
	$_->widget->destroy;
    }
    $self->{'groups'} = [];
    foreach (@{$data->{'groups'}}) {
	my $group;
	if ($_->{'class'} eq 'MyScalars') {
	    $group = MyScalars::construct($self,$_,@args);
	} elsif ($_->{'class'} eq 'MyTables') {
	    $group = MyTables::construct($self,$_,@args);
	} else {
	    eval("\$group = $_->{'class'}::construct(\$self,\$_,\@args)");
	}
	unless ($group) {
	    warn "call to $_->{'class'}::construct failed";
	    return;
	}
	push @{$self->{'groups'}}, $group;
	$group->widget->pack(
	    -expand=>1,
	    -fill=>'both',
	    -side=>'top',
	    -anchor=>'n',
	);
	#$self->frame->Adjuster()->packAfter($group->widget, -side=>'top',);
    }
}
#package MyMatrix;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyMatrix->new($parent,$data->{'page'},$data->{'label'},$data->{'width'},@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyMatrix;
sub dropcommand {
    # $self = shift;	# local argument
    # $seln = shift;	# Selection (e.g. XdndSelection)
    # $action = shift;	# Action (e.g. LocalDrop, SunDrop or XDND #action)
    # $targets = shift;	# array reference to supported target atoms
    # $xo = shift;	# X offset within dropsite (for canvases)
    # $yo = shift;	# Y offset within dropsite (for canvases)
    my ($self,$seln,$action,$targets,$xo,$yo,@args) = @_;
    if ($action eq 'LocalDrop' || $::dragobj) {
	if (UNIVERSAL::isa($::dragobj, 'MyObject')) {
	    $self->addobjects($::dragobj);
	} elsif (UNIVERSAL::isa($::dragobj, 'MyValue')) {
	    warn "MyMatrix::dropcommand: cannot handle dropped values.";
	} else {
	    warn "MyMatrix::dropcommand: unexpected object type.";
	}
    } else {
	if (my $oid = $self->widget->toplevel->SelectionGet(-selection=>$seln)) {
	    chomp $oid;
	    $oid =~ s/(\s|\n)*$//;
	    if (my $mib = MyObject->new($self->tree, $oid)) {
		$self->addobjects($mib);
	    } else {
		warn "MyMatrix::dropcommand: oid '$oid' not known.";
	    }
	} else {
	    warn "MyMatrix::dropcommand: no oid '$oid'.";
	}
    }
}

#package MyMatrix;
sub addobjects {
    my ($self,$mib,@args) = @_;
    $mib = MyObject->new($self->tree, $mib->{'objectID'});
    push @{$self->{'mibs'}}, $mib;
    unless (@{$self->{'groups'}}) {
	$self->updatelabel($mib->{'label'});
    }
    my @scalars = $mib->findscalars;
    my @tables = $mib->findtables;
    my @tabscalars = ();
    my ($ts,$sib);
    foreach (@tables) {
	$ts = [];
	$sib = $_->{'prevSibling'};
	while ($sib) {
	    last unless UNIVERSAL::isa($sib, 'MyObjectType');
	    push @{$ts}, $sib;
	    for (my $i = 0; $i < @scalars; $i++) {
		if ($sib eq $scalars[$i]) {
		    splice @scalars, $i, 1;
		    last;
		}
	    }
	    $sib = $sib->{'prevSibling'};
	}
	push @tabscalars, $ts;
    }
    # now we should have all scalars not associated with a table in the @scalars
    # array and all of the tables in the @tables array, and all of the scalars
    # associated with tables in the double @tabscalars array.  So, now what we
    # want to do is to build a scalar table for the scalars, and a scalar table
    # and table for each of the tables and associated table scalars.
    my $table;
    if (@scalars) {
	$table = MyScalars->new($self,[@scalars]);
	if ($table) {
	    push @{$self->{'groups'}}, $table;
	    $table->widget->pack(
		-expand=>1,
		-fill=>'both',
		-side=>'top',
		-anchor=>'n',
	    );
	    #$self->frame->Adjuster()->packAfter($table->widget, -side=>'top',);
	} else {
	    warn "ERROR: MyMatrix::addobjects: could not build scalars";
	}
    }
    for (my $i = 0; $i < scalar @tables; $i++) {
	if (@{$tabscalars[$i]}) {
	    $table = MyScalars->new($self,$tabscalars[$i]);
	    if ($table) {
		push @{$self->{'groups'}}, $table;
		$table->widget->pack(
		    -expand=>1,
		    -fill=>'both',
		    -side=>'top',
		    -anchor=>'n',
		);
		#$self->frame->Adjuster()->packAfter($table->widget, -side=>'top',);
	    } else {
		warn "ERROR: MyMatrix::addobjects: could not build table scalars";
	    }
	}
	$table = MyTables->new($self,[$tables[$i]]);
	if ($table) {
	    push @{$self->{'groups'}}, $table;
	    $table->widget->pack(
		-expand=>1,
		-fill=>'both',
		-side=>'top',
		-anchor=>'n',
	    );
	    #$self->frame->Adjuster()->packAfter($table->widget, -side=>'top',);
	} else {
	    warn "ERROR: MyMatrix::addobjects: could not build table";
	}
    }
    return scalar @{$self->{'groups'}};
}

#package MyMatrix;
sub addscalars {
    my ($self,$mib,@args) = @_;
    $mib = MyObject->new($self->tree, $mib->{'objectID'});
    unless (@{$self->{'groups'}}) {
	$self->updatelabel($mib->{'label'});
    }
    my @scalars = $mib->findscalars;
    my $table;
    if (@scalars) {
	$table = MyScalars->new($self,[@scalars]);
	if ($table) {
	    push @{$self->{'groups'}}, $table;
	    $table->widget->pack(
		-expand=>1,
		-fill=>'both',
		-side=>'top',
		-anchor=>'n',
	    );
	    #$self->frame->Adjuster()->packAfter($table->widget, -side=>'top',);
	} else {
	    warn "ERROR: MyMatrix::addobjects: could not build scalars";
	}
    }
    return scalar @{$self->{'groups'}};
}

#package MyMatrix;
sub addtables {
    my ($self,$mib,@args) = @_;
    $mib = MyObject->new($self->tree, $mib->{'objectID'});
    unless (@{$self->{'groups'}}) {
	$self->updatelabel($mib->{'label'});
    }
    my @tables = $mib->findtables;
    my @tabscalars = ();
    my ($ts,$sib);
    foreach (@tables) {
	$ts = [];
	$sib = $_->{'prevSibling'};
	while ($sib) {
	    last unless UNIVERSAL::isa($sib, 'MyObjectType');
	    push @{$ts}, $sib;
	    $sib = $sib->{'prevSibling'};
	}
	push @tabscalars, $ts;
    }
    my $table;
    for (my $i = 0; $i < scalar @tables; $i++) {
	if (@{$tabscalars[$i]}) {
	    $table = MyScalars->new($self,$tabscalars[$i]);
	    if ($table) {
		push @{$self->{'groups'}}, $table;
		$table->widget->pack(
		    -expand=>1,
		    -fill=>'both',
		    -side=>'top',
		    -anchor=>'n',
		);
		#$self->frame->Adjuster()->packAfter($table->widget, -side=>'top',);
	    } else {
		warn "ERROR: MyMatrix::addobjects: could not build table scalars";
	    }
	}
	$table = MyTables->new($self,[$tables[$i]]);
	if ($table) {
	    push @{$self->{'groups'}}, $table;
	    $table->widget->pack(
		-expand=>1,
		-fill=>'both',
		-side=>'top',
		-anchor=>'n',
	    );
	    #$self->frame->Adjuster()->packAfter($table->widget, -side=>'top',);
	} else {
	    warn "ERROR: MyMatrix::addobjects: could not build table";
	}
    }
    return scalar @{$self->{'groups'}};
}
#package MyMatrix;
sub getgroups {
    my $self = shift;
    foreach (@{$self->{'groups'}}) {
	my $mib;
	if ($_->{'table'}) {
	    $mib = $_->{'table'};
	} else {
	    $mib = $_->{'ancestor'};
	}
	$_->getgroup(0,0,$mib);
    }
}
#package MyMatrix;
sub setgroups {
    my $self = shift;
    foreach (@{$self->{'groups'}}) {
	my $mib;
	if ($_->{'table'}) {
	    $mib = $_->{'table'};
	} else {
	    $mib = $_->{'ancestor'};
	}
	$_->setgroup(0,0,$mib);
    }
}

# ---------------------------------


# ---------------------------------
package MyNoteBook;
use strict;
use vars qw(@ISA);
@ISA = qw(MyWidget);

#package MyNoteBook;
sub new {
    my ($type,$parent,$width,@args) = @_;
    my $self = MyWidget::new($type,$parent,$width,@args);
    $self->{'pagenum'} = 1;
    $self->{'pages'} = {};
    $self->{'loose'} = {};
    $width = 340 unless defined $width;
    my $pane = $parent->widget->Scrolled('Pane',
	-scrollbars=>'on',
	-sticky=>'nswe',
	-width=>$width,
#    )->grid(
#	-sticky=>'ewns',
#    )->pack(
#	-expand=>1,
#	-fill=>'both',
#	-side=>'left',
#	-anchor=>'w',
    );
    $self->setframe($pane);
    my $nb = $pane->Scrolled('NoteBook',
	-scrollbars=>'onow',
	-dynamicgeometry=>1,
#    )->grid(
#	-column=>0,
#	-row=>0,
#	-sticky=>'ewns',
    )->pack(
	-expand=>1, -fill=>'both', -side=>'left', -anchor=>'w',
#    )->place(
#	-x=>0,
#	-y=>0,
#	-relwidth=>1.0,
#	-relheight=>1.0,
    );
    $self->{'top'} = $parent->widget;
    $self->setwidget($nb);
#    $self->{'dropsite'} = $nb->DropSite(
#	-droptypes=>[qw/XDND Sun Local/],
#	-dropcommand=>[sub { my ($self,@args) = @_; $self->drop(@args); }, $self],
#    );
    $nb->bind('<Button-3>',
	[\&MyNoteBook::button3, $self, Tk::Ev('x'), Tk::Ev('y')],
    );
#    $nb->bind('<B1-Motion>',
#	[\&MyNoteBook::dragpage, $self, Tk::Ev('x'), Tk::Ev('y')],
#    );
    return $self;
}
#package MyNoteBook;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $data->{'pagenum'} = $self->{'pagenum'};
    $data->{'pages'} = {};
    foreach (keys %{$self->{'pages'}}) {
	$data->{'pages'}->{$_} = $self->{'pages'}->{$_}->dumphash(@args);
    }
    $data->{'loose'} = {};
    foreach (keys %{$self->{'loose'}}) {
	$data->{'loose'}->{$_} = $self->{'loose'}->{$_}->dumphash(@args);
    }
    my $w = $self->widget;
    $data->{'info'} = {};
    foreach (qw/pages focus focusnext focusprev active/) {
	$data->{'info'}->{$_} = $w->info($_);
    }
    $data->{'info'}->{'raised'} = $w->raised;
    return $data;
}
#package MyNoteBook;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    foreach (sort keys %{$self->{'pages'}}) {
	$self->widget->delete($_);
	delete $self->{'pages'}->{$_};
    }
    foreach (sort keys %{$self->{'loose'}}) {
	my $item = $self->{'loose'}->{$_};
	$item->widget->destroy;
	delete $self->{'loose'}->{$_};
    }
    foreach (sort keys %{$data->{'pages'}}) {
	my $page = $data->{'pages'}->{$_};
	my $item;
	if ($page->{'class'} eq 'MyROText') {
	    $item = MyROText::construct($self,$page,@args);
	} elsif ($page->{'class'} eq 'MyMatrix') {
	    $item = MyMatrix::construct($self,$page,@args);
	} elsif ($page->{'class'} eq 'MyHostList') {
	    $item = MyHostList::construct($self,$page,@args);
	} elsif ($page->{'class'} eq 'MyMibList') {
	    $item = MyMibList::construct($self,$page,@args);
	} else {
	    eval("\$item = $page->{'class'}::construct(\$self,\$page,\@args)");
	}
	unless ($item) {
	    warn "call to ".$page->{'class'}."::construct failed";
	    next;
	}
	$self->{'pages'}->{$_} = $item;
    }
    foreach (sort keys %{$data->{'loose'}}) {
	my $page = $data->{'loose'}->{$_};
	my $item;
	if ($page->{'class'} eq 'MyROText') {
	    $item = MyROText::construct($self,$page,-tearout=>1,@args);
	} elsif ($page->{'class'} eq 'MyMatrix') {
	    $item = MyMatrix::construct($self,$page,-tearout=>1,@args);
	} elsif ($page->{'class'} eq 'MyHostList') {
	    $item = MyHostList::construct($self,$page,-tearout=>1,@args);
	} elsif ($page->{'class'} eq 'MyMibList') {
	    $item = MyMibList::construct($self,$page,-tearout=>1,@args);
	} else {
	    eval("\$item = $page->{'class'}::construct(\$self,\$page,-tearout=>1,\@args)");
	}
	unless ($item) {
	    warn "call to ".$page->{'class'}."::construct failed";
	    next;
	}
	$self->{'loose'}->{$_} = $item;
    }
    foreach (sort keys %{$self->{'pages'}}) {
	$self->{'pages'}->{$_}->reconstruct($data->{'pages'}->{$_},@args);
    }
    foreach (sort keys %{$self->{'loose'}}) {
	$self->{'loose'}->{$_}->reconstruct($data->{'loose'}->{$_},@args);
    }
    $self->widget->raise($data->{'raised'}) if $data->{'raised'};
    $self->{'pagenum'} = $data->{'pagenum'};
}
#package MyNoteBook;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self;
    eval("\$self = $data->{'class'}::construct(\$parent,\$data,\@args)");
    unless ($self) {
	warn "call to $data->{'class'}::construct failed";
	return undef;
    }
    $self->reconstruct($data,@args);
    return $self;
}
#package MyNoteBook;
sub gluepage {
    my ($self,$page,$item,@args) = @_;
    return unless $item;
    my $type = ref($item);
    my $data = $item->dumphash;
    $data->{'torn'} = 0;
    delete $self->{'loose'}->{$page};
    $item->widget->destroy;
    $item = undef;
    my $pg;
    if ($type eq 'MyHostList') {
	$pg = MyHostList::construct($self,$data);
    } elsif ($type eq 'MyMibList') {
	$pg = MyMibList::construct($self,$data);
    } elsif ($type eq 'MyMatrix') {
	$pg = MyMatrix::construct($self,$data);
    } elsif ($type eq 'MyROText') {
	$pg = MyROText::construct($self,$data);
    } else {
	eval("\$pg = ".$type."::construct(\$self,\$data)");
    }
    unless ($pg) {
	warn "call to ".$type."::construct failed";
	return;
    }
    $self->{'pages'}->{$page} = $pg;
}
#package MyNoteBook;
sub tearpage {
    my ($self,$page,$item,@args) = @_;
    return unless $item;
    my $type = ref($item);
    $item->createcmd($item->widget);
    my $data = $item->dumphash;
    $data->{'torn'} = 1;
    delete $self->{'pages'}->{$page};
    $self->widget->delete($page);
    $item = undef;
    my $tl;
    if ($type eq 'MyHostList') {
	$tl = MyHostList::construct($self,$data,-tearout=>1);
    } elsif ($type eq 'MyMibList') {
	$tl = MyMibList::construct($self,$data,-tearout=>1);
    } elsif ($type eq 'MyMatrix') {
	$tl = MyMatrix::construct($self,$data,-tearout=>1);
    } elsif ($type eq 'MyROText') {
	$tl = MyROText::construct($self,$data,-tearout=>1);
    } else {
	eval("\$tl = ".$type."::construct(\$self,\$data,-tearout=>1)");
    }
    unless ($tl) {
	warn "call to ".$type."::construct failed";
	return;
    }
    $self->{'loose'}->{$page} = $tl;
}
#package MyNoteBook;
sub dropcommand {
    my ($self,$seln,$action,$targets,$xo,$yo,@args) = @_;
    if ($action eq 'LocalDrop') {
    } else {
	warn "MyNoteBook::dropcommand: unexpected action '$action'.";
    }
}

#
# Provides a popup menu for notebook tabs or tab zone.
#
#package MyNoteBook;
sub button3 {
    my ($nb,$self,$x,$y,@args) = @_;
    my $page = $nb->identify($x,$y);
    $self->{'currentpage'} = $page;
    $self->getpopup($page)->Popup(
	-popanchor=>'nw',
	-popover=>'cursor',
    );
}
#package MyNoteBook;
sub dragpage {
    my ($nb,$self,$x,$y,@args) = @_;
    my $page = $nb->identify($x,$y) || $nb->info('active') || $nb->info('focus') || $nb->raised;
    return unless $page;
    if (my $item = $self->{'pages'}->{$page}) {
	$self->tearpage($page,$item);
    }
}
#package MyNoteBook;
sub menuitemaction {
    my ($self,$cmd,$page,@args) = @_;
    return unless (defined($page) && defined($$page));
    my $item = $self->{'pages'}->{$$page};
    return unless defined $item;
    $self->$cmd($$page,$item);
}
#package MyNoteBook;
sub keyitemaction {
    my ($nb,$cmd,$self,$x,$y,@args) = @_;
    my $page = $nb->identify($x,$y);
    $self->menuitemaction($cmd,\$page,@args);
}
#package MyNoteBook;
sub menuaction {
    my ($self,$cmd,$page,$type,@args) = @_;
    $self->$cmd($$page,$type);
}
#package MyNoteBook;
sub keyaction {
    my ($nb,$cmd,$self,$type,$x,$y,@args) = @_;
    my $page = $nb->identify($x,$y);
    $self->menuaction($cmd,\$page,$type,@args);
}
#package MyNoteBook;
sub getpopup {
    my ($self,$page,@args) = @_;
    $self->{'popup'} = $self->createpopup unless defined $self->{'popup'};
    return $self->setpopup($page);
}
#package MyNoteBook;
sub setpopup {
    my ($self,$page,@args) = @_;
    my $m = $self->{'popup'};
    if ($page) {
	$m->entryconfigure('Delete',
	    -state=>'normal',);
	$m->entryconfigure('Rename...',
	    -state=>'normal',);
	$m->entryconfigure('Tear Out...',
	    -state=>'normal',);
    } else {
	$m->entryconfigure('Delete',
	    -state=>'disabled',);
	$m->entryconfigure('Rename...',
	    -state=>'disabled',);
	$m->entryconfigure('Tear Out...',
	    -state=>'disabled',);
    }
    return $m;
}
#package MyNoteBook;
sub createpopup {
    my ($self,@args) = @_;
    my $w = $self->widget;
    my $m = $w->toplevel->Menu(
	-tearoff=>1,
	-title=>'Page Menu',
	-type=>'normal',
    );
    my $mc = $m->Menu(
	-tearoff=>1,
	-title=>'New Page',
    );
    $m->add('cascade',
	-menu=>$mc,
	-label=>'New...',
	-underline=>0,
    );

    $mc->add('command',
	#-accelerator=>'s',
	-command=>[\&MyNoteBook::menuaction, $self, 'newpage',
	\$self->{'currentpage'},'MyHostList'],
	-label=>'New Session...',
	-underline=>4,);
    $w->bind('<Key-s>',
	[\&MyNoteBook::keyaction, 'newpage',
	$self, 'MyHostList', Tk::Ev('x'), Tk::Ev('y')],);

    $mc->add('command',
	#-accelerator=>'b',
	-command=>[\&MyNoteBook::menuaction, $self, 'newpage',
	\$self->{'currentpage'},'MyMibList'],
	-label=>'New Browser...',
	-underline=>4,);
    $w->bind('<Key-b>',
	[\&MyNoteBook::keyaction, 'newpage',
	$self, 'MyMibList', Tk::Ev('x'), Tk::Ev('y')],);

    $mc->add('command',
	#-accelerator=>'e',
	-command=>[\&MyNoteBook::menuaction, $self, 'newpage',
	\$self->{'currentpage'},'MyMatrix'],
	-label=>'New Editor...',
	-underline=>4,);
    $w->bind('<Key-e>',
	[\&MyNoteBook::keyaction, 'newpage',
	$self, 'MyMatrix', Tk::Ev('x'), Tk::Ev('y')],);

    $mc->add('command',
	#-accelerator=>'l',
	-command=>[\&MyNoteBook::menuaction, $self, 'newpage',
	\$self->{'currentpage'},'MyROText'],
	-label=>'New Listing...',
	-underline=>4,);
    $w->bind('<Key-l>',
	[\&MyNoteBook::keyaction, 'newpage',
	$self, 'MyROText', Tk::Ev('x'), Tk::Ev('y')],);

    $m->add('command',
	#-accelerator=>'d',
	-command=>[\&MyNoteBook::menuitemaction, $self, 'delpage',
	\$self->{'currentpage'}],
	-label=>'Delete',
	-underline=>0,);
    $w->bind('<Key-d>',
	[\&MyNoteBook::keyitemaction, 'delpage',
	$self, Tk::Ev('x'), Tk::Ev('y')],);

    $m->add('command',
	#-accelerator=>'r',
	-command=>[\&MyNoteBook::menuitemaction, $self, 'relabel',
	\$self->{'currentpage'}],
	-label=>'Rename...',
	-underline=>0,);
    $w->bind('<Key-r>',
	[\&MyNoteBook::keyitemaction, 'relabel',
	$self, Tk::Ev('x'), Tk::Ev('y')],);

    $m->add('command',
	#-accelerator=>'t',
	-command=>[\&MyNoteBook::menuitemaction, $self, 'tearpage',
	\$self->{'currentpage'}],
	-label=>'Tear Out...',
	-underline=>0,);
    $w->bind('<Key-t>',
	[\&MyNoteBook::keyitemaction, 'tearpage',
	$self, Tk::Ev('x'), Tk::Ev('y')],);

    return $m;
}
#package MyNoteBook;
sub relabel {
    my ($self,$page,$host,@args) = @_;
    my $nb = $self->widget;
    my $tl = $nb->toplevel;
    my $dialog;
    my $pageobj = $self->{'pages'}->{$page};
    unless ($dialog = $self->{'rename'}) {
	$dialog = $tl->DialogBox(
	    -title=>'Rename Page Dialog',
	    -buttons=>[qw/OK Cancel/],
	    -default_button=>'OK',
	);
	$dialog->Label(
	    -text=>'New name:',
	)->grid(
	    -row=>0,
	    -column=>0,
	    -sticky=>'ew',
	);
	$dialog->Entry(
	    -exportselection=>1,
	    -textvariable=>\$pageobj->{'data'}->{'label'},
	)->grid(
	    -row=>0,
	    -column=>1,
	    -sticky=>'ew',
	);
    }
    if ($dialog->Show eq 'OK') {
	$pageobj->rename;
    } else {
	$pageobj->restorelabel;
    }
}
#package MyNoteBook;
sub newpage {
    my ($self,$page,$type,$label,@args) = @_;
    $page = "page$self->{'pagenum'}";
    my $pageobj;
    if ($type eq 'MyHostList') {
	$pageobj = MyHostList->new($self,$page,$label,@args);
    } elsif ($type eq 'MyMibList') {
	$pageobj = MyMibList->new($self,$page,$label,@args);
    } else {
	eval("\$pageobj = $type->new(\$self, \$page, \$label, \@args)");
    }
    unless ($pageobj) {
	warn "call to $type\->new failed";
	return undef;
    }
    $self->{'pages'}->{$page} = $pageobj;
    $self->{'pagenum'}++;
    return $self->{'pages'}->{$page};
}
#package MyNoteBook;
sub delpage {
    my ($self,$page,$pageobj,@args) = @_;
    delete $self->{'pages'}->{$page};
    $self->widget->delete($page);
    return $pageobj;
}

#package MyNoteBook;
sub rotext {
    my ($self,@args) = @_;
    my $rotext;
    unless ($self->{'supertest'}) { # keep from looping
	$self->{'supertest'} = 1;
	$rotext = $self->SUPER::rotext(@args);
	$self->{'supertest'} = 0;
	return $rotext if $rotext;
    }
    foreach (map { $self->{'pages'}->{$_}; } sort keys %{$self->{'pages'}}) {
	if (UNIVERSAL::isa($_,'MyROText')) {
	    $rotext = $_;
	    last;
	}
    }
    return $rotext if $rotext;
    foreach (map { $self->{'loose'}->{$_}; } sort keys %{$self->{'loose'}}) {
	if (UNIVERSAL::isa($_,'MyROText')) {
	    $rotext = $_;
	    last;
	}
    }
    return $rotext;
}

#package MyNoteBook;
sub addscalars {
    my ($self,$mib,@args) = @_;
    my $edit = $self->newpage(undef,'MyMatrix',$mib->{'label'}) || return undef;
    my $count = $edit->addscalars($mib);
    if ($count == 0) {
	$self->delpage($edit->{'data'}->{'page'},$edit);
    }
    return $count;
}

#package MyNoteBook;
sub addtables {
    my ($self,$mib,@args) = @_;
    my $edit = $self->newpage(undef,'MyMatrix',$mib->{'label'}) || return undef;
    my $count = $edit->addtables($mib);
    if ($count == 0) {
	$self->delpage($edit->{'data'}->{'page'},$edit);
    }
    return $count;
}

#package MyNoteBook;
sub addobjects {
    my ($self,$mib,@args) = @_;
    my $edit = $self->newpage(undef,'MyMatrix',$mib->{'label'}) || return undef;
    my $count = $edit->addobjects($mib);
    if ($count == 0) {
	$self->delpage($edit->{'data'}->{'page'},$edit);
    }
    return $count;
}

# ---------------------------------

# ---------------------------------
package MyGroup;
use strict;
use vars qw(@ISA);
use SNMP;
@ISA = qw(MyWidget);

#package MyGroup;
sub new {
    my ($type,$parent,$mibs,@args) = @_;
    return undef unless scalar @{$mibs};
    my $self = MyWidget::new($type,$parent,@args);
    $self->{'mibs'} = $mibs;
    $self->{'values'} = [];
    $self->{'creates'} = [];
    $self->{'scalars'} = [];
    $self->{'indexes'} = [];
    $self->{'columns'} = [];
    $self->{'tree'} = $parent->tree;
    my $ancestor = $mibs->[0]->{'objectID'};
    $ancestor =~ s/\.[^\.]*$//;
    foreach (@{$mibs}) {
	$_->populate;
	while ($ancestor && index($_->{'objectID'},$ancestor) != 0) {
	    $ancestor =~ s/\.[^\.]*$//;
	}
    }
    $self->{'ancestor'} = MyObject->new($self->tree,$ancestor);
    $self->{'prefix'} = '';
    return $self;
}

#package MyGroup;
sub creatematrix {
    my ($self,@args) = @_;
    my $matrix = $self->parent->frame->Scrolled( 'Spreadsheet', # 'TableMatrix', #'Spreadsheet',
	-scrollbars=>'sow',
	-anchor=>'w',
	#-background=>,
	#-cursor=>,
	-exportselection=>1,
	#-font=>,
	#-foreground=>'black',
	#-highlightbackground=>,
	#-highlightcolor=>,
	#-highlightthickness=>,
	#-insertbackground=>,
	#-insertborderwidth=>,
	#-insertofftime=>,
	#-insertontime=>,
	#-insertwidth=>,
	-invertselected=>1,
	#-relief=>'sunken',
	-takefocus=>1,
	-autoclear=>0,
	#-bordercursor=>crosshair,
	#-borderwidth=>1,
	-cache=>1, # default 0
	-drawmode=>'compatible', # 'compatible', # slow, fast, single
	-flashmode=>1,
	#-flashtime=>2, # 1/4 second increments
	#-ipadx=>0,
	#-ipady=>0,
	#-justify=>'left', # right, center
	-multiline=>1,
	#-pady=>0,
	-resizeborders=>'both', # row, col, none, both
	-selectmode=>'extended', # single, browse, multiple, extended
	-selecttitle=>0,
	-selecttype=>'cell', # row, col, cell, both
	#-sparsearray=>1, # 1 spare or 0 full
	#-state=>'normal', # normal, disabled

	#-colorigin=>0,
	-colseparator=>';',
	-colstretchmode=>'none', # (none), unset, all, last, fill
	-colwidth=>12,
	-cols=>2 + $self->entrynum, # default 10
	-titlecols=>1, # default 0
	#-width=>5,
	-maxwidth=>$self->parent->frame->screenwidth, # (800 pixels)

	#-roworigin=>0,
	-rowseparator=>',',
	-rowstretchmode=>'none', # (none), unset, all, last, fill
	#-rowheight=>1,
	-rows=>2 + $self->childnum, # default 10
	#-height=>2 + $self->childnum,
	-titlerows=>1, # default 0
	-maxheight=>$self->parent->frame->screenheight, # (600 pixels)

	#-usecommand=>1,
	-validate=>1,
	#-variable=>$self->{'array'},
	-wrap=>0,
#    )->pack(
#	-expand=>1,
#	-fill=>'x',
#	-side=>'top',
#	-anchor=>'n',
    );
#    $self->parent->frame->Adjuster(
#	-widget=>$matrix,
#	-side=>'top',
#	-restore=>1,
#    )->pack(
#	-expand=>1,
#	-fill=>'x',
#	-side=>'top',
#	-anchor=>'n',
#    );
    $self->setwidget($matrix);
    $matrix = $matrix->Subwidget('scrolled');
    if ($matrix->bind(ref($matrix))) {
    }
    $matrix->MainWindow->bind(ref($matrix),'<Return>',
	[sub {
	    my $w = shift;
	    my $index;
	    eval { $index = $w->index('active') };
	    $index = '' if $@ || $index eq '0,0';
	    if ($index) {
		$w->MoveCell(1,0);
		return;
	    }
	    eval { $index = $w->index('anchor') };
	    $index = '' if $@ || $index eq '0,0';
	    if ($index) {
		if ($w->selectionIncludes('anchor')) {
		    $w->activate($index);
		    return;
		}
	    }
	    $w->MoveCell(1,0);
	}],
    );
    $matrix->MainWindow->bind(ref($matrix),'<Shift-KP_Tab>',
	undef,
    );
    $matrix->MainWindow->bind(ref($matrix),'<<LeftTab>>',[sub {
	    shift->MoveCell(0,-1);
	    Tk->break;
	}],
    );
#    $matrix->bind('<Control-v>', # paste
#	[sub {
#	    my ($matrix,$self) = @_;
#	    my $tl = $matrix->toplevel;
#	    if (my $string = $tl->SelectionGet(-selection=>'CLIPBOARD')) {
#		chomp $string;
#		my $e = $matrix->XEvent || return;
#		my ($x,$y) = ($e->x,$e->y);
#		my $index = $matrix->index("\@$x,$y");
#		my ($row,$col) = split(/,/,$index);
#		if ($col > 0 && $col < 1 + $self->entrynum) {
#		    my $tag = $self->tagforcol($col);
#		    my $host = $self->hostforcol($col);
#		    if ($row > 1 && $row < 2 + $self->childnum) {
#			my $mib = $self->mibforrow($row,$col);
#			unless ($self->isindex($row)) {
#			    if (my $value = $mib->value) {
#				$value->data($tag,$host)->set($string);
#			    }
#			}
#		    }
#		}
#	    } else {
#		#warn "Clipboard empty.";
#		$tl->bell;
#	    }
#	}, $self],
#    );
#    $matrix->bind('<Double-1>', # edit
#	[sub {
#	    #warn "double button with args ".join(', ',@_);
#	    my ($matrix,$self,$x,$y,@args) = @_;
#	    my $index = $matrix->index("\@$x,$y");
#	    my ($row,$col) = split(/,/,$index);
#	}, $self, Tk::Ev('x'), Tk::Ev('y')],
#    );
#    $matrix->bind('<Button-1>', # edit
#	[sub {
#	    #warn "button with args ".join(', ',@_);
#	    my ($matrix,$self,$x,$y,@args) = @_;
#	    my $index = $matrix->index("\@$x,$y");
#	    my ($row,$col) = split(/,/,$index);
#	}, $self, Tk::Ev('x'), Tk::Ev('y')],
#    );
#    $matrix->bind('<Return>',
#	[sub {
#	    #warn "return with args ".join(', ',@_);
#	    my ($matrix,$self,@args) = @_;
#	    my $index = $matrix->index('anchor');
#	    if ($index) {
#		$matrix->activate($index);
#	    }
#	}, $self],
#    );
    $matrix->bind('<ButtonRelease-1>', # edit
	[sub {
	    my ($matrix,$self,$x,$y,@args) = @_;
	    my $index = $matrix->index("\@$x,$y");
	    my $active;
	    eval { $active = $matrix->index('active'); };
	    $active = '' if ($@);
	    if ($index ne $active) {
		if ($active ne '0,0') {
		    $matrix->activate('0,0');
		}
	    }
	    my $anchor;
	    eval { $anchor = $matrix->index('anchor'); };
	    $anchor = '' if ($@);
	    my ($row,$col);
	    if ($anchor) {
		($row,$col) = split(/,/,$anchor);
	    } else {
		($row,$col) = (0,0);
	    }
	    $self->{'anchorrow'} = $row;
	    $self->{'anchorcol'} = $col;
	    $self->setselection($row,$col);
	}, $self, Tk::Ev('x'), Tk::Ev('y')],
    );
#    $matrix->bind('<Button-1>', # select
#	[sub {
#	    my ($matrix,$self,$x,$y,@args) = @_;
#	    my $index = $matrix->index("\@$x,$y");
#	    my ($row,$col) = split(/,/,$index);
#	    $matrix->selectionClear('all');
#	    $self->{'rowselection'} = undef;
#	    $self->{'colselection'} = undef;
#	    $self->{'tabselection'} = undef;
#	    $self->{'celselection'} = undef;
#	    if ($col > 0 && $col < 1 + $self->entrynum) {
#		if ($row > 0 && $row < 2 + $self->childnum) {
#		    $self->{'celselection'} = "$row,$col";
#		    $matrix->selectionSet("$row,$col");
#		    $matrix->selectionAnchor("$row,$col");
#		} elsif ($row == 0) {
#		    $self->{'colselection'} = $col;
#		    $matrix->selectionSet("2,$col",($self->childnum+1).",$col");
#		    $matrix->selectionAnchor("2,$col");
#		}
#	    } elsif ($col == 0 || $col == 1 + $self->entrynum) {
#		if ($row > 0 && $row < 2 + $self->childnum) {
#		    $self->{'rowselection'} = $row;
#		    $matrix->selectionSet("$row,1","$row,".$self->entrynum);
#		    $matrix->selectionAnchor("$row,1");
#		} elsif ($row == 0) {
#		    $self->{'tabselection'} = 1;
#		    $matrix->selectionSet("2,1",($self->childnum+2).','.$self->entrynum);
#		    $matrix->selectionAnchor("2,1");
#		}
#	    }
#	}, $self, Tk::Ev('x'), Tk::Ev('y')],
#    );
#    $matrix->bind('<Button-2>', # paste
#	[sub {
#	    my ($matrix,$self) = @_;
#	    my $tl = $matrix->toplevel;
#	    if (my $string = $tl->SelectionGet(-selection=>'PRIMARY')) {
#		chomp $string;
#		my $e = $matrix->XEvent || return;
#		my ($x,$y) = ($e->x,$e->y);
#		my $index = $matrix->index("\@$x,$y");
#		my ($row,$col) = split(/,/,$index);
#		if ($col > 0 && $col < 1 + $self->entrynum) {
#		    my $tag = $self->tagforcol($col);
#		    my $host = $self->hostforcol($col);
#		    if ($row > 1 && $row < 2 + $self->childnum) {
#			my $mib = $self->mibforrow($row,$col);
#			unless ($self->isindex($row)) {
#			    if (my $value = $mib->value) {
#				$value->data($tag,$host)->set($string);
#			    }
#			}
#		    }
#		}
#	    } else {
#		#warn "Selection empty.";
#		$tl->bell;
#	    }
#	}, $self],
#    );
    $matrix->bind('<Button-3>', # popup
	[sub {
	    my ($matrix,$self) = @_;
	    my $tl = $matrix->toplevel;
	    my $e = $matrix->XEvent || return;
	    my ($x,$y) = ($e->x,$e->y);
	    my $index = $matrix->index("\@$x,$y");
	    my ($row,$col,$mib) = (0,0);
	    if ($index) {
		($row,$col) = split(/,/,$index);
		$self->{'buttonrow'} = $row;
		$self->{'buttoncol'} = $col;
	    } elsif ($self->{'browserow'} && $self->{'browsecol'}) {
		$row = $self->{'browserow'};
		$col = $self->{'browsecol'};
	    } elsif ($self->{'anchorrow'} && $self->{'anchorcol'}) {
		$row = $self->{'anchorrow'};
		$col = $self->{'anchorcol'};
	    }
	    $mib = $self->mibforrow($row,$col);
	    $self->setselection($row,$col,$mib)->Popup(
		-popanchor=>'nw',
		-popover=>'cursor',
	    );
	}, $self],
    );
    $matrix->configure(
	-browsecommand=>[\&MyGroup::browsecommand,$self,$matrix],
	-command=>[\&MyGroup::accesscommand,$self],
	-selectioncommand=>[\&MyGroup::selectioncommand,$self],
	-coltagcommand=>[\&MyGroup::coltagcommand,$self],
	-rowtagcommand=>[\&MyGroup::rowtagcommand,$self],
	-validatecommand=>[\&MyGroup::validatecommand,$self],
    );
    $self->{'balloonmsg'} = 'a default message';
    $self->attachballoon($matrix,
	-balloonmsg=>\$self->{'balloonmsg'},
	#-balloonposition=>'mouse',
	-postcommand=>[\&MyGroup::postcommand,$self],
	#-motioncommand=>[\&MyGroup::motioncommand,$self],
    );
    $self->createtags;
    $self->tagcells;
    $matrix->selectionClear('all');
    $matrix->selectionAnchor('0,0');
    $matrix->selectionSet('0,0');
    $matrix->activate('0,0');
    return $matrix;
}

#package MyGroup;
sub createtags {
    my ($self,@args) = @_;
    my $w = $self->widget;
    my ($bg,$fg,$rl);


    # cell tags for scalars and column data
    unless (($bg = $w->optionGet('connectedTagBackground','ConnectedTagBackground'))) {
	$bg = 'green';
	$w->optionAdd('Mibbrowser.*.ConnectedTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('connectedTagForeground','ConnectedTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.ConnectedTagForeground'=>$fg);
    }
    $w->tagConfigure('connected',
	-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('disconnectedTagBackground','DisconnectedTagBackground'))) {
	$bg = 'grey';
	$w->optionAdd('Mibbrowser.*.DisconnectedTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('disconnectedTagForeground','DisconnectedTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.DisconnectedTagForeground'=>$fg);
    }
    $w->tagConfigure('disconnected',
	-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('erroredTagBackground','ErroredTagBackground'))) {
	$bg = 'blue';
	$w->optionAdd('Mibbrowser.*.ErroredTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('erroredTagForeground','ErroredTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.ErroredTagForeground'=>$fg);
    }
    $w->tagConfigure('errored',
	-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('failedTagBackground','FailedTagBackground'))) {
	$bg = 'red';
	$w->optionAdd('Mibbrowser.*.FailedTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('failedTagForeground','FailedTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.FailedTagForeground'=>$fg);
    }
    $w->tagConfigure('failed',
	-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('defaultTagBackground','DefaultTagBackground'))) {
	$bg = 'cyan';
	$w->optionAdd('Mibbrowser.*.DefaultTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('defaultTagForeground','DefaultTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.DefaultTagForeground'=>$fg);
    }
    $w->tagConfigure('default',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    $w->tagConfigure('unset',
-state=>'disabled',
    );
    unless (($bg = $w->optionGet('setTagBackground','SetTagBackground'))) {
	$bg = 'orange';
	$w->optionAdd('Mibbrowser.*.SetTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('setTagForeground','SetTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.SetTagForeground'=>$fg);
    }
    $w->tagConfigure('set',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('readTagBackground','ReadTagBackground'))) {
	$bg = 'green';
	$w->optionAdd('Mibbrowser.*.ReadTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('readTagForeground','ReadTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.ReadTagForeground'=>$fg);
    }
    $w->tagConfigure('read',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('nosuchTagBackground','NosuchTagBackground'))) {
	$bg = 'red';
	$w->optionAdd('Mibbrowser.*.NosuchTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('nosuchTagForeground','NosuchTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.NosuchTagForeground'=>$fg);
    }
    $w->tagConfigure('nosuch',
	-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('geterrTagBackground','GeterrTagBackground'))) {
	$bg = 'red';
	$w->optionAdd('Mibbrowser.*.GeterrTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('geterrTagForeground','GeterrTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.GeterrTagForeground'=>$fg);
    }
    $w->tagConfigure('geterr',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('seterrTagBackground','SeterrTagBackground'))) {
	$bg = 'red';
	$w->optionAdd('Mibbrowser.*.SeterrTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('seterrTagForeground','SeterrTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.SeterrTagForeground'=>$fg);
    }
    $w->tagConfigure('seterr',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );

    # these are cell tags for indices
    $w->tagConfigure('index',
	-state=>'disabled',
    );
    $w->tagConfigure('create',
-state=>'disabled',
	#-state=>'normal',
    );

    # these are row tags
    unless (($rl = $w->optionGet('relief','Relief'))) {
	$rl = 'groove';
    }
    $w->tagConfigure('header',
-state=>'disabled',
	-anchor=>'center',
	-relief=>$rl,
    );
    # these are column tags
    unless (($bg = $w->optionGet('labelTagBackground','LabelTagBackground'))) {
	$bg = 'grey';
	$w->optionAdd('Mibbrowser.*.LabelTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('labelTagForeground','LabelTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.LabelTagForeground'=>$fg);
    }
    $w->tagConfigure('label',
-state=>'disabled',
	-anchor=>'e',
	-relief=>$rl,
	-bg=>$bg,
	-fg=>$fg,
    );
    unless (($bg = $w->optionGet('unitsTagBackground','UnitsTagBackground'))) {
	$bg = 'grey';
	$w->optionAdd('Mibbrowser.*.UnitsTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('unitsTagForeground','UnitsTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.UnitsTagForeground'=>$fg);
    }
    $w->tagConfigure('units',
-state=>'disabled',
	-anchor=>'w',
	-relief=>$rl,
	-bg=>$bg,
	-fg=>$fg,
    );
    # these are row tags
    $w->tagConfigure('scalar',
-state=>'disabled',
    );
    $w->tagConfigure('column',
-state=>'disabled',
    );

    # additional row tags for refinement of 'scalar' or 'column'
    unless (($bg = $w->optionGet('readTagBackground','ReadTagBackground'))) {
	$bg = 'light grey';
	$w->optionAdd('Mibbrowser.*.ReadTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('readTagForeground','ReadTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.ReadTagForeground'=>$fg);
    }
    $w->tagConfigure('ReadOnly',
	-state=>'disabled',
    );
    unless (($bg = $w->optionGet('noaccessTagBackground','NoaccessTagBackground'))) {
	$bg = 'grey';
	$w->optionAdd('Mibbrowser.*.NoaccessTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('noaccessTagForeground','NoaccessTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.NoaccessTagForeground'=>$fg);
    }
    $w->tagConfigure('NoAccess',
	-state=>'disabled',
    );
    $w->tagConfigure('Notify',
	-state=>'disabled',
    );
    $w->tagConfigure('selected',
-state=>'disabled',
	#-relief=>'sunken',
    );
    unless (($bg = $w->optionGet('editTagBackground','EditTagBackground'))) {
	$bg = 'white';
	$w->optionAdd('Mibbrowser.*.EditTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('editTagForeground','EditTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.EditTagForeground'=>$fg);
    }
    $w->tagConfigure('ReadWrite',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    $w->tagConfigure('Create',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );
    $w->tagConfigure('WriteOnly',
-state=>'disabled',
	-bg=>$bg,
	-fg=>$fg,
    );

    # these are column tags
    $w->tagConfigure('value',
-state=>'disabled',
    );
    $w->tagConfigure('entry',
-state=>'disabled',
    );

    unless (($bg = $w->optionGet('titleTagBackground','TitleTagBackground'))) {
	$bg = 'grey';
	$w->optionAdd('Mibbrowser.*.TitleTagBackground'=>$bg);
    }
    unless (($fg = $w->optionGet('titleTagForeground','TitleTagForeground'))) {
	$fg = 'black';
	$w->optionAdd('Mibbrowser.*.TitleTagForeground'=>$fg);
    }
    $w->tagConfigure('title',
-state=>'disabled',
	-relief=>$rl,
	-bg=>$bg,
	-fg=>$fg,
    );
}

#package MyGroup;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $data->{'mibs'} = [];
    foreach (@{$self->{'mibs'}}) {
	push @{$data->{'mibs'}}, $_->{'objectID'};
    }
    return $data;
}
#package MyGroup;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    $self->{'mibs'} = [];
    foreach (@{$data->{'mibs'}}) {
	push @{$self->{'mibs'}}, MyObject->new($self->tree, $_);
    }
    # the easiest was to reconstruct these is to delete the object and frame
    # containing them (i.e. the notebook page) and then rebuilding them.
}
#package MyGroup;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyGroup->new($parent,[],@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyGroup;
sub menumatrixaction {
    my ($self,$cmd,@args) = @_;
    return $self->$cmd(@args);
}
#package MyGroup;
sub keymatrixaction {
    my ($matrix,$self,$cmd,$x,$y,@args) = @_;
    return $self->$cmd(@args);
}

#package MyGroup;
sub menugroupaction {
    my ($self,$cmd,@args) = @_;
    return $self->$cmd(0,0,$self->mibforrow(0,0),@args);
}

#package MyGroup;
sub keygroupaction {
    my ($matrix,$self,$cmd,$x,$y,@args) = @_;
    return $self->$cmd(0,0,$self->mibforrow(0,0),@args);
}

#package MyGroup;
sub menucellaction {
    my ($self,$cmd,@args) = @_;
    my $row = $self->{'buttonrow'};
    my $col = $self->{'buttoncol'};
    my $mib = $self->mibforrow($row,$col);
    my $tag = $self->tagforcol($col);
    my $host = $self->hostforcol($col);
    return $self->$cmd($row,$col,$mib,$tag,$host,@args);
}

#package MyGroup;
sub keycellaction {
    my ($matrix,$self,$cmd,$x,$y,@args) = @_;
    $matrix->CancelRepeat;
    my $index = $matrix->index("\@$x,$y");
    my ($row,$col,$mib) = (0,0);
    if ($index) {
	($row,$col) = split(/,/,$index);
	$self->{'buttonrow'} = $row;
	$self->{'buttoncol'} = $col;
	$self->setselection($row,$col,$self->mibforrow($row,$col));
    } elsif ($self->{'browserow'} && $self->{'browsecol'}) {
	$row = $self->{'browserow'};
	$col = $self->{'browsecol'};
    } elsif ($self->{'anchorrow'} && $self->{'anchorcol'}) {
	$row = $self->{'anchorrow'};
	$col = $self->{'anchorcol'};
    }
    $mib = $self->mibforrow($row,$col);
    $self->setselection($row,$col,$mib);
    my $tag = $self->tagforcol($col);
    my $host = $self->hostforcol($col);
    return $self->$cmd($row,$col,$mib,$tag,$host,@args);
}

#package MyGroup;
sub menuselectedaction {
    my ($self,$cmd,@args) = @_;
    return $self->$cmd(@args);
}
#package MyGroup;
sub keyselectedaction {
    my ($matrix,$self,$cmd,$x,$y,@args) = @_;
    return $self->$cmd(@args);
}

#package MyGroup;
sub setselection {
    my ($self,$row,$col,@args) = @_;
    my $m = $self->getpopup;
    if ($self->{'buttonrow'} && $self->{'buttoncol'}) {
	$row = $self->{'buttonrow'};
	$col = $self->{'buttoncol'};
    } elsif ($self->{'browserow'} && $self->{'browsecol'}) {
	$row = $self->{'browserow'};
	$col = $self->{'browsecol'};
    } elsif ($self->{'anchorrow'} && $self->{'anchorrow'}) {
	$row = $self->{'anchorrow'};
	$col = $self->{'anchorcol'};
    } else {
	$row = 0;
	$col = 0;
    }
    my $mib = $self->mibforrow($row,$col);
    $m->entryconfigure('Help', -state=>'normal',);
    $m->entryconfigure('Properties...', -state=>'normal',);
    if ($self->{'anchorrow'} && $self->{'anchorcol'}) {
	$m->entryconfigure('Get', # Selected',
	    -state=>'normal',);
	$m->entryconfigure('Set', # Selected',
	    -state=>'normal',);
	$m->entryconfigure('Reset', # Selected',
	    -state=>'normal',);
	$m->entryconfigure('Clear', # Selected',
	    -state=>'normal',);
	$m->entryconfigure('Default', # Selected',
	    -state=>'normal',);
    } else {
	$m->entryconfigure('Get', # Selected',
	    -state=>'disabled',);
	$m->entryconfigure('Set', # Selected',
	    -state=>'disabled',);
	$m->entryconfigure('Reset', # Selected',
	    -state=>'disabled',);
	$m->entryconfigure('Clear', # Selected',
	    -state=>'disabled',);
	$m->entryconfigure('Default', # Selected',
	    -state=>'disabled',);
    }
    if (defined $row && $row > 1 && $row < 2 + $self->childnum) {
	if ($col > 0 && $col < 1 + $self->entrynum) {
	    if ($mib->{'access'} !~ /NoAccess|Notify|ReadOnly/) {
		$m->entryconfigure('Edit', -state=>'normal',);
	    } else {
		$m->entryconfigure('Edit', -state=>'disabled',);
	    }
	} else {
	    $m->entryconfigure('Edit', -state=>'disabled',);
	}
    } else {
	$m->entryconfigure('Edit', -state=>'disabled',);
    }
    $m->entryconfigure('Walk', # Group',
	-state=>'normal',);
    if ($self->{'table'}) {
	$m->entryconfigure('New Entry', -state=>'normal',);
    } else {
	$m->entryconfigure('New Entry', -state=>'disabled',);
    }
    $m->entryconfigure('Refresh', # 'Walk All',
	-state=>'normal',);
    $m->entryconfigure('Commit', # 'Set All',
	-state=>'normal',);
    return $m;
}

#package MyGroup;
sub getpopup {
    my ($self,@args) = @_;
    return $self->{'popup'} if defined $self->{'popup'};
    my $title = $self->{'table'} ? $self->{'table'}->{'label'} : $self->{'ancestor'}->{'label'};
    my $w = $self->widget;
    my $m = $self->{'popup'} = $self->widget->Menu(
	-tearoff=>1,
	-title=>$title,
	-type=>'normal',
    );
    $m->add('command',
	-command=>[\&MyGroup::menucellaction,$self,'editcell'],
	-label=>'Edit',
	-underline=>0,);
    $w->bind('<Any-e>',
	[\&MyGroup::keycellaction,$self,'editcell',
	Tk::Ev('x'),Tk::Ev('y')],);

    $m->add('separator');

    $m->add('command',
	-command=>[\&MyGroup::menuselectedaction,$self,'getselected'],
	-label=>'Get', # Selected',
	-underline=>0,);
    $w->bind('<Any-g>',
	[\&MyGroup::keyselectedaction,$self,'getselected',
	Tk::Ev('x'),Tk::Ev('y')],);
    $m->add('command',
	-command=>[\&MyGroup::menuselectedaction,$self,'setselected'],
	-label=>'Set', # Selected',
	-underline=>0,);
    $w->bind('<Any-s>',
	[\&MyGroup::keyselectedaction,$self,'setselected',
	Tk::Ev('x'),Tk::Ev('y')],);
    $m->add('command',
	-command=>[\&MyGroup::menuselectedaction,$self,'resetselected'],
	-label=>'Reset', # Selected',
	-underline=>0,);
    $w->bind('<Any-r>',
	[\&MyGroup::keyselectedaction,$self,'resetselected',
	Tk::Ev('x'),Tk::Ev('y')],);
    $m->add('command',
	-command=>[\&MyGroup::menuselectedaction,$self,'clearselected'],
	-label=>'Clear', # Selected',
	-underline=>0,);
    $w->bind('<Any-c>',
	[\&MyGroup::keyselectedaction,$self,'clearselected',
	Tk::Ev('x'),Tk::Ev('y')],);
    $m->add('command',
	-command=>[\&MyGroup::menuselectedaction,$self,'defaultselected'],
	-label=>'Default', # Selected',
	-underline=>0,);
    $w->bind('<Any-d>',
	[\&MyGroup::keyselectedaction,$self,'defaultselected',
	Tk::Ev('x'),Tk::Ev('y')],);

    $m->add('separator');

    $m->add('command',
	-command=>[\&MyGroup::menugroupaction,$self,'getgroup'],
	-label=>'Walk', # Group',
	-underline=>0,);
    $w->bind('<Any-w>',
	[\&MyGroup::keygroupaction,$self,'getgroup',
	Tk::Ev('x'),Tk::Ev('y')],);
    $m->add('command',
	-command=>[\&MyGroup::menugroupaction,$self,'newentry'],
	-label=>'New Entry',
	-underline=>0,);
    $w->bind('<Any-n>',
	[\&MyGroup::keygroupaction,$self,'newentry',
	Tk::Ev('x'),Tk::Ev('y')],);

    $m->add('separator');

    $m->add('command',
	-command=>[\&MyGroup::menumatrixaction,$self,'walkall'],
	-label=>'Refresh', # 'Walk All',
	-underline=>0,);
    $w->bind('<Any-r>',
	[\&MyGroup::keymatrixaction,$self,'walkall',
	Tk::Ev('x'),Tk::Ev('y')],);
    $m->add('command',
	-command=>[\&MyGroup::menumatrixaction,$self,'setall'],
	-label=>'Commit', # 'Set All',
	-underline=>5,);
    $w->bind('<Any-t>',
	[\&MyGroup::keymatrixaction,$self,'setall',
	Tk::Ev('x'),Tk::Ev('y')],);

    $m->add('separator');

    $m->add('command',
	-command=>[\&MyGroup::menucellaction,$self,'help'],
	-label=>'Help',
	-underline=>0,);
    $w->bind('<Any-h>',
	[\&MyGroup::keycellaction,$self,'help',
	Tk::Ev('x'),Tk::Ev('y')],);
    $w->bind('<F1>',
	[\&MyGroup::keycellaction,$self,'help',
	Tk::Ev('x'),Tk::Ev('y')],);

    $m->add('command',
	-command=>[\&MyGroup::menucellaction,$self,'info'],
	-label=>'Properties...',
	-underline=>0,
    );
    $w->bind('<Any-p>',
	[\&MyGroup::keycellaction,$self,'info',
	Tk::Ev('x'),Tk::Ev('y')],);
    return $m;
}

#package MyGroup;
sub settable {
    my ($self,$table,@args) = @_;
    $self->{'table'} = $table;
    $table->populate;
}

#package MyGroup;
sub setentry {
    my ($self,$entry,@args) = @_;
    $self->{'entry'} = $entry;
    $entry->populate;
}

#package MyGroup;
sub findvalues {
    my ($self) = @_;
    $self->{'values'} = [];
    if (@{$self->{'scalars'}}) {
	foreach my $host (@{$self->sessions}) {
	    push @{$self->{'values'}},
	    MyEntryInstanceId->new_scalar($self->tree,$host);
	}
    } elsif (@{$self->{'columns'}}) {
	foreach my $host (@{$self->sessions}) {
	    my %tags = ();
	    foreach (@{$self->{'columns'}}) {
		foreach (@{$_->value->tags($host)}) {
		    $tags{$_} = 1;
		}
	    }
	    foreach (sort { ::cmp_lexical($a,$b); } keys %tags) {
		push @{$self->{'values'}},
		MyEntryInstanceId->new_value($self->tree,$host,$self->{'entry'},$_);
	    }
	}
    } else {
	warn "no values to find";
    }
}

#package MyGroup;
sub pushscalars {
    my ($self,@scalars) = @_;
    push @{$self->{'scalars'}}, @scalars;
    return scalar @{$self->{'scalars'}};
}
#package MyGroup;
sub pushindexes {
    my ($self,@indexes) = @_;
    push @{$self->{'indexes'}}, @indexes;
    return scalar @{$self->{'indexes'}};
}
#package MyGroup;
sub pushcolumns {
    my ($self,@columns) = @_;
    foreach (@columns) {
	if ($_->{'syntax'} eq 'RowStatus') {
	    $self->{'rowstatus'} = 1;
	    last;
	}
    }
    push @{$self->{'columns'}}, @columns;
    return scalar @{$self->{'columns'}};
}
#package MyGroup;
sub findscalars {
    my ($self) = @_;
    foreach (@{$self->{'mibs'}}) {
	$self->pushscalars($_->findscalars);
    }
    return scalar @{$self->{'scalars'}};
}
#package MyGroup;
sub childnum {
    my $self = shift;
    return (@{$self->{'scalars'}} + @{$self->{'indexes'}} + @{$self->{'columns'}});
}
#package MyGroup;
sub valuenum {
    my $self = shift;
    return (@{$self->{'values'}} + 0);
}
#package MyGroup;
sub createnum {
    my $self = shift;
    return (0 + @{$self->{'creates'}});
}
#package MyGroup;
sub entrynum {
    my $self = shift;
    return (@{$self->{'values'}} + @{$self->{'creates'}});
}
#package MyGroup;
sub scalarnum {
    my $self = shift;
    return (@{$self->{'scalars'}} + 0 + 0);
}
#package MyGroup;
sub indexnum {
    my $self = shift;
    return (0 + @{$self->{'indexes'}} + 0);
}
#package MyGroup;
sub columnnum {
    my $self = shift;
    return (0 + 0 + @{$self->{'columns'}});
}
#package MyGroup;
sub children {
    my $self = shift;
    return (@{$self->{'scalars'}}, @{$self->{'indexes'}}, @{$self->{'columns'}});
}
#package MyGroup;
sub findprefix {
    my $self = shift;
    if ($self->{'table'}) {
	my $tabpre = $self->{'table'}->{'label'};
	$tabpre =~ s/Table$//;
	$self->{'tabpre'} = $tabpre;
    }
    if ($self->{'entry'}) {
	my $entpre = $self->{'entry'}->{'label'};
	$entpre =~ s/Entry$//;
	$self->{'entpre'} = $entpre;
    }
    my $prefix = undef;
    if ($self->childnum > 1) {
	foreach ($self->children) {
	    next if (ref($_) =~ /Conceptual/ && $_->{'parent'} ne $self->{'entry'});
	    $prefix = $_->{'label'} unless defined $prefix;
	    while ($prefix && (index($_->{'label'},$prefix) != 0)) {
		$prefix =~ s/.$//;
	    }
	}
    }
    $prefix = '' unless defined $prefix;
    $self->{'prefix'} = $prefix;
}
#package MyGroup;
sub lengths {
    my $self = shift;
    my $w = $self->widget;
    my $font = $w->cget('-font');
    my $llen = 0;
    my $ulen = 0;
    my $vlen = 0;
    my $hrow = 2;
    my $len;
    $self->findprefix;
    if ($self->{'table'}) {
	$len = $w->fontMeasure($font,$self->{'table'}->{'label'});
	$llen = $len if $llen < $len;
    } else {
	$len = $w->fontMeasure($font,$self->{'ancestor'}->{'label'});
	$llen = $len if $llen < $len;
    }
    if ($self->{'entry'}) {
	$len = $w->fontMeasure($font,$self->{'entry'}->{'label'});
	$ulen = $len if $ulen < $len;
    }
    foreach($self->children) {
	if (!$_->{'Label'} || ref($_) !~ /Conceptual/ || $_->{'parent'} eq $self->{'entry'}) {
	    $_->{'Label'} = $_->{'label'} || $_->{'objectID'};
	    $_->{'Label'} =~ s/^$self->{'prefix'}//;
	    $_->{'Label'} = lcfirst $_->{'Label'};
	}
	$len = $w->fontMeasure($font,$_->{'Label'});
	$llen = $len if $llen < $len;
	$_->{'Units'} = $_->{'units'} || $_->{'textualConvention'} || $_->syntaxtype;
	$len = $w->fontMeasure($font,$_->{'Units'});
	$ulen = $len if $ulen < $len;
	$_->fmsg; $_->tmsg; $_->hmsg;
	my $value = $_->value;
	$len = $value->maxlen($w,$font);
	$vlen = $len if $vlen < $len;
	$hrow += $value->maxrow;
    }
    for (my $col = 1; $col < 1 + $self->entrynum; $col++) {
	for (my $row = 1; $row < 2 + $self->childnum; $row++) {
	    my $entry = $self->entryforcell($row,$col);
	    if ($row == 1) {
		$len = $w->fontMeasure($font,$entry->hostname);
		$vlen = $len if $vlen < $len;
	    } else {
		if (my $val = $entry->val) {
		    $len = $w->fontMeasure($font,$val);
		    $vlen = $len if $vlen < $len;
		}
	    }
	}
    }
    $llen += 16;
    $ulen += 16;
    $vlen += 16;
    $llen = 80 if $llen < 80;
    $ulen = 80 if $ulen < 80;
    $vlen = 80 if $vlen < 80;
    $llen = 400 if $llen > 400;
    $ulen = 400 if $ulen > 400;
    $vlen = 400 if $vlen > 400;
    return (-$llen, -$ulen, -$vlen, $hrow);
}

#package MyGroup;
sub iidforcol {
    my ($self,$col,@args) = @_;
    my $iid = undef;
    if ($col > 0 && $col < 1 + $self->entrynum) {
	if ($col < 1 + $self->valuenum) {
	    $iid = $self->{'values'}->[$col-1];
	} else {
	    $iid = $self->{'creates'}->[$col-1-$self->valuenum];
	}
    }
    return $iid;
}

#package MyGroup;
sub hostforcol {
    my ($self,$col,@args) = @_;
    my $iid = $self->iidforcol($col);
    my $host = $iid->host if $iid;
    return $host;
}

#package MyGroup;
sub tagforcol {
    my ($self,$col,@args) = @_;
    my $iid = $self->iidforcol($col);
    my $tag = $iid->tag if $iid;
    return $tag;
}

#package MyGroup;
sub entryforcell {
    my ($self,$row,$col,@args) = @_;
    my $entry = undef;
    if (my $iid = $self->iidforcol($col)) {
	if ($row > 0 && $row < 2 + $self->childnum) {
	    if ($row == 1) {
		$entry = $iid;
	    } elsif ($row < 2 + $self->indexnum) {
		$entry = $iid->index($row-2);
	    } else {
		my $value = $self->mibforrow($row)->value;
		$entry = MyEntryInstance->locate($iid,$value);
	    }
	}
    }
    return $entry;
}

#package MyGroup;
sub motioncommand {
    my ($self,$matrix,@args) = @_;
    my $e = $matrix->XEvent || return 1;
    my ($X,$Y) = ($e->x,$e->y);
    my $index = $matrix->index("\@$X,$Y");
    my ($row,$col) = split(/,/,$index);
    my ($x,$y,$w,$h,$pos) = $matrix->bbox($index);
    return 1 if $y > $Y || $Y > $y + $h;
    return 1 if $x > $X || $X > $x + $w;
    if (defined $self->{'wasrow'} && $row != $self->{'wasrow'}) {
	return 1;
    }
    delete $self->{'wasrow'};
    return 0;
}

#package MyGroup;
sub postcommand {
    my ($self,$matrix,@args) = @_;
    my $e = $matrix->XEvent || return 0;
    my ($X,$Y) = ($e->x,$e->y);
    my $index = $matrix->index("\@$X,$Y");
    my ($row,$col) = split(/,/,$index);
    my ($x,$y,$w,$h,$pos) = $matrix->bbox($index);
    if ($col == 0) { # labels
	return 0 if $y > $Y || $Y > $y + $h;
	return 0 if $x > $X || $X > $x + $w;
	if ($X < $x + int($w/2)) {
	    $pos = ($matrix->rootx+$x-10).','.($matrix->rooty+$y+$h-10);
	    if ($row == 0) {
		if ($self->{'table'}) {
		    $self->{'balloonmsg'} = $self->{'table'}->fmsg;
		} else {
		    $self->{'balloonmsg'} = $self->{'ancestor'}->fmsg;
		}
	    } elsif ($row == 1) {
		$self->{'balloonmsg'} = <<EOF;
This column contains the labels of the various fields in
the group.
EOF
	    } elsif ($row > 1 && $row < 2 + $self->childnum) {
		my $mib = $self->mibforrow($row,$col);
		$self->{'balloonmsg'} = $mib->fmsg;
	    }
	} elsif ($X > $x + int($w/2)) {
	    $pos = ($matrix->rootx+$x+$w-10).','.($matrix->rooty+$y+$h-10);
	    if ($row == 0) {
		if ($self->{'entry'}) {
		    $self->{'balloonmsg'} = $self->{'entry'}->fmsg;
		} else {
		    return 0;
		}
	    } elsif ($row == 1) {
		$self->{'balloonmsg'} = <<EOF;
The fields in this row represent the host name for the
corresponding SNMP session.
EOF
	    } elsif ($row > 1 && $row < 2 + $self->childnum) {
		my $mib = $self->mibforrow($row);
		$self->{'balloonmsg'} = $mib->hmsg;
	    }
	} else {
	    return 0;
	}
    } elsif ($col == 1 + $self->entrynum) { # units
	return 0 if $y > $Y || $Y > $y + $h;
	return 0 if $x > $X || $X > $x + $w;
	$pos = ($matrix->rootx+$x+int($w/2)-10).','.($matrix->rooty+$y+$h-10);
	if ($row == 0) {
	    if ($self->{'entry'}) {
		$self->{'balloonmsg'} = $self->{'entry'}->fmsg;
	    }
	} elsif ($row == 1) {
	    $self->{'balloonmsg'} = <<EOF;
This column contains the units of the various fields in
the group.
EOF
	} elsif ($row > 1 && $row < 2 + $self->childnum) {
	    my $mib = $self->mibforrow($row,$col);
	    $self->{'balloonmsg'} = $mib->tmsg;
	}
	#} elsif ($col > 0 && $col < 1 + $self->entrynum) { # value
    } else {
	return 0;
    }
    return 0 unless $self->{'balloonmsg'};
    chomp $self->{'balloonmsg'};
    $self->{'balloonmsg'} =~ s/(\s|\n)*$//;
    if ($self->{'balloonmsg'} =~ /^(\s|\n)*$/) {
	return 0;
    }
    $self->{'wasrow'} = $row;
    return $pos;
    #return (($matrix->rootx+$x+$w/2-10).','.($matrix->rooty+$y+$h-10));
}

#package MyGroup;
sub browsecommand {
    my ($self,$matrix,$old,$new,@args) = @_;
    if ($old) {
	my ($row,$col) = split(/,/,$old);
	if ($col > 0 && $col < 1 + $self->entrynum) {
	    if ($row > 1 && $row < 2 + $self->childnum) {
		my $entry = $self->entryforcell($row,$col);
		if ($entry->{'haswindow'}) {
		    $entry->{'haswindow'} = 0;
		    $matrix->windowDelete($old);
		    $matrix->update;
		    $matrix->focus;
		    if ($entry->{'commit'}) {
			$entry->{'commit'} = 0;
			unless ($entry->setdiff($entry->{'ent'})) {
			    $matrix->reread;
			    #$matrix->clearCache;
			} else {
			    $matrix->set($old,$entry->val);
			}
		    } else {
			$matrix->reread;
			#$matrix->clearCache;
		    }
		}
	    }
	}
    }
    if ($new) {
	my ($row,$col) = split(/,/,$new);
	$self->{'browserow'} = $row;
	$self->{'browsecol'} = $col;
	$self->setselection($row,$col);
	if ($col > 0 && $col < 1 + $self->entrynum) {
	    if ($row > 1 && $row < 2 + $self->childnum) {
		my $entry = $self->entryforcell($row,$col);
		if (($self->isindex($row) && $self->iscreate($col)) ||
		    (!$self->isindex($row) && $entry->access !~ /ReadOnly|NoAccess|Notify/)) {
		    if (my $e = $entry->addentry($matrix,$self->iscreate($col))) {
			$entry->{'commit'} = 0;
			unless ($entry->{'haswindow'}) {
			    $entry->{'haswindow'} = $e;
			    $matrix->windowConfigure($new,
				-window=>$e,
				-sticky=>'ewns',
			    );
			    $e->bind('<Return>',[sub{
				    my ($e,$matrix,$entry) = @_;
				    $entry->{'commit'} = 1;
				    $matrix->MoveCell(1,0);
				    Tk->break;
				},$matrix,$entry],
			    );
			    $e->bind('<Escape>',[sub{
				    my ($e,$matrix,$entry) = @_;
				    $matrix->activate('0,0');
				    Tk->break;
				},$matrix,$entry],
			    );
			    $e->focus;
			    $matrix->update;
			}
		    }
		}
	    }
	}
    }
}

#package MyGroup;
sub coltagcommand {
    my ($self,$col,@args) = @_;
    if ($col == 0) {
	return 'label';
    } elsif ($col == 1 + $self->entrynum) {
	return 'units';
    } elsif ($col > 0 && $col < 1 + $self->valuenum) {
	return 'value';
    } elsif ($col > $self->valuenum && $col < 1 + $self->entrynum) {
	return 'entry';
    } else {
	return '';
    }
}

#package MyGroup;
sub rowtagcommand {
    my ($self,$row,@args) = @_;
    if ($row == 0) {
	return 'header';
    } elsif ($row == 1) {
	return 'header';
    } elsif ($row > 1 && $row < 2 + $self->childnum) {
	if ($self->isscalar($row)) {
	    return 'scalar';
	} elsif ($self->isindex($row)) {
	    return 'index';
	} else {
	    return 'column';
	}
    } else {
	return '';
    }
    return '';
}

#package MyGroup;
sub tagcells {
    my ($self,@args) = @_;
    $self->findvalues;
    my ($llen,$ulen,$vlen,$hrow) = $self->lengths;
    my ($col,$row);
    my $table = $self->widget;
    $table->clearAll;
    $table->configure(
	-cols=>2+$self->entrynum,
	-rows=>2+$self->childnum,
	-height=>$hrow,
	-maxwidth=>$self->widget->screenwidth,
	-maxheight=>$self->widget->screenheight,
    );
    $table->tagCol('title',0);
    $table->tagCol('title',1+$self->entrynum);
    $table->tagCol('label',0);
    for (my $i = 1; $i < 1 + $self->valuenum; $i++) {
	$table->tagCol('value',$i);
    }
    for (my $i = $self->valuenum; $i < 1 + $self->entrynum; $i++) {
	$table->tagCol('entry',$i);
    }
    $table->tagCol('units',1+$self->entrynum);
    $table->tagRow('header',0);
    $table->tagRow('header',1);
    for (my $i = 2; $i < 2 + $self->childnum; $i++) {
	my $mib = $self->mibforrow($i);
	$table->tagRow($mib->tagname,$i);
	$table->rowHeight($i,$mib->value->maxrow);
    }
    $table->colWidth(0,$llen+3);
    for (my $i = 1; $i < 1 + $self->entrynum; $i++) {
	$table->colWidth($i,$vlen+2);
    }
    $table->colWidth(1+$self->entrynum,$ulen+2);
    for ($col = 1; $col < 1 + $self->entrynum; $col++) {
	for ($row = 1; $row < 2 + $self->childnum; $row++) {
	    if (my $entry = $self->entryforcell($row,$col)) {
		$table->tagCell($entry->tagname,"$row,$col");
	    }
	}
    }
}

#package MyGroup;
sub accesscommand {
    my ($self,$set,$row,$col,$val,@args) = @_;
    if ($col == 0) { # labels
	if ($row == 0) {
	    if ($self->{'table'}) {
		return $self->{'table'}->{'label'};
	    } else {
		return $self->{'ancestor'}->{'label'};
	    }
	} elsif ($row == 1) {
	    return 'Label';
	} elsif ($row > 1 && $row < 2 + $self->childnum) {
	    my $mib = $self->mibforrow($row);
	    $self->widget->tagCell('label',"$row,$col");
	    return "$mib->{'Label'}: ";
	}
    } elsif ($col == 1 + $self->entrynum) { # units
	if ($row == 0) {
	    if ($self->{'entry'}) {
		return $self->{'entry'}->{'label'};
	    }
	} elsif ($row == 1) {
	    return 'Units';
	} elsif ($row > 1 && $row < 2 + $self->childnum) {
	    my $mib = $self->mibforrow($row);
	    return " $mib->{'Units'}";
	}
    } elsif ($col > 0 && $col < 1 + $self->entrynum) { # value
	my $entry = $self->entryforcell($row,$col);
	if ($row == 0) {
	    return undef;
	} elsif ($row == 1) {
	    $self->widget->tagCell($entry->tagname,"$row,$col");
	    return $entry->hostname;
	} elsif ($row > 1 && $row < 2 + $self->childnum) {
	    my $mib = $self->mibforrow($row);
	    $self->widget->tagCell($entry->tagname,"$row,$col");
	    return $entry->get unless $set;
	    if (!$entry->setdiff($val)) {
		warn "did not validate, rereading";
		$self->widget->reread;
	    }
	    $self->widget->tagCell($entry->tagname,"$row,$col");
	    return $entry->get;
	}
    }
    return undef;
}

#package MyGroup;
sub selectioncommand {
    my ($self,@args) = @_;
}

#package MyGroup;
sub validatecommand {
    my ($self,$row,$col,$old,$proposed,$index,@args) = @_;
    return 0; # refuse all changes made this way
    my $entry = $self->entryforcell($row,$col);
    return $entry->value->validateall($proposed);
    return 0;
}

#package MyGroup;
sub getcell {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    my $matrix = $self->widget;
    my $value = $mib->value;
    my $data = $value->data($tag,$host);
    my $errmsg;
    if ($mib->{'access'} !~ /NoAccess|Notify|WriteOnly/) {
	if ($host->{'sstate'} eq 'connected' && (my $snmp = $host->snmp)) {
	    my $vb = new SNMP::Varbind([$mib->{'objectID'}, $tag]);
	    $matrix->Busy(-recurse=>1);
	    my $res = $snmp->get($vb);
	    $matrix->Unbusy;
	    my $val = $vb->[$SNMP::Varbind::val_f];
	    if (defined $val && defined $res) {
		if ($val eq 'NOSUCHINSTANCE' || $res eq 'NOSUCHINSTANCE') {
		    $errmsg = $snmp->{'ErrorStr'} || 'No such object';
		    $data->nosuch;
		} else {
		    $data->valsnmp($val);
		}
	    } else {
		$errmsg = $snmp->{'ErrorStr'} || 'Unknown error';
		$data->geterr;
	    }
	} else {
	    $errmsg = 'Not connected';
	    $data->unset;
	}
    } else {
	$errmsg = 'Read access not permitted';
    }
    if (defined $errmsg) {
	$self->statusmsg('ERROR GET: '.$host->hostname.": $mib->{'label'}.$tag: $errmsg.");
	$self->toplevel->bell;
    }
    $matrix->clearCache;
}
#package MyGroup;
sub setcell {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    my $matrix = $self->widget;
    my $value = $mib->value;
    my $data = $value->data($tag,$host);
    my $errmsg;
    if ($mib->{'access'} !~ /NoAccess|Notify|ReadOnly/) {
	if ($data->{'vstate'} =~ /^(set|default|read)$/) {
	    if ($host->{'sstate'} eq 'connected' && (my $snmp = $host->snmp)) {
		my $vb = new SNMP::Varbind([$mib->{'objectID'}, $tag, $data->snmpval]);
		$matrix->Busy(-recurse=>1);
		my $res = $snmp->set($vb);
		$matrix->Unbusy;
		my $val = $vb->[$SNMP::Varbind::val_f];
		if  (!$res) {
		    if ($val ne 'NOSUCHINSTANCE') {
			$data->markread;
		    } else {
			$errmsg = 'No such object';
			$data->nosuch;
		    }
		} else {
		    $errmsg = $snmp->{'ErrorStr'} || 'Unknown error';
		    $data->seterr;
		}
	    } else {
		$errmsg = 'Not connected';
	    }
	} else {
	    $errmsg = 'Value not set by user';
	}
    } else {
	$errmsg = 'Write access not permitted';
    }
    if (defined $errmsg) {
	$self->statusmsg('ERROR SET: '.$host->hostname.": $mib->{'label'}.$tag: $errmsg.");
	$self->toplevel->bell;
    }
    $matrix->clearCache;
}

#package MyGroup;
sub getselected {
    my ($self,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    my %vlists = ();
    my %elists = ();
    my @hosts = ();
    for (my $col=1;$col<1+$self->entrynum;$col++) {
	next if $self->iscreate($col);
	my $host = $self->hostforcol($col);
	unless (defined $vlists{$host}) {
	    $vlists{$host} = new SNMP::VarList;
	    $elists{$host} = [];
	    push @hosts, $host;
	}
	my $vlist = $vlists{$host};
	my $elist = $elists{$host};
	for (my $row=2;$row<2+$self->childnum;$row++) {
	    next unless ($matrix->selectionIncludes("$row,$col"));
	    my $entry = $self->entryforcell($row,$col);
	    next if $entry->access =~ /NoAccess|Notify|WriteOnly/;
	    push @$elist, $entry;
	    push @$vlist, new SNMP::Varbind([$entry->oid, $entry->tag]);
	}
    }
    foreach my $host (@hosts) {
	my $vlist = $vlists{$host};
	my $elist = $elists{$host};
	next unless @$vlist;
	if ($host->{'sstate'} eq 'connected' && (my $snmp = $host->snmp)) {
	    $matrix->Busy(-recurse=>1,);
	    my @results = $snmp->get($vlist);
	    $matrix->Unbusy;
	    if (@results) {
		foreach (@$vlist) {
		    printf STDERR "got varbind: ".join(", ",@$_)."\n";
		}
		for (my $i=0;$i<@$vlist;$i++) {
		    my $vb = $vlist->[$i];
		    my $entry = $elist->[$i];
		    my $val = $vb->[$SNMP::Varbind::val_f];
		    my $res = $results[$i];
		    if (defined $val && defined $res) {
			if ($val eq 'NOSUCHINSTANCE' || $res eq 'NOSUCHINSTANCE') {
			    $self->statusmsg('ERROR: GET: '.$host->hostname.': '.$entry->label.$entry->tag.': No such object.');
			    $self->toplevel->bell;
			    $entry->nosuch;
			} else {
			    $entry->valsnmp($val);
			}
		    } else {
			$self->statusmsg('ERROR: GET: '.$host->hostname.': '.$entry->label.$entry->tag.': No such object.');
			$self->toplevel->bell;
			$entry->geterr;
		    }
		}
	    } else {
		my $errmsg = $snmp->{'ErrorStr'} || 'Unknown error';
		$self->statusmsg('ERROR: GET: '.$host->hostname.": $errmsg.");
		$self->toplevel->bell;
	    }
	} else {
	    my $errmsg = 'Not connected';
	    $self->statusmsg('ERROR: GET: '.$host->hostname.": $errmsg.");
	    $self->toplevel->bell;
	}
    }
    $matrix->clearCache;
}
#package MyGroup;
sub setselected {
    my ($self,$all,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    my %vlists = ();
    my %elists = ();
    my @hosts = ();
    for (my $col=1;$col<1+$self->entrynum;$col++) {
	#next if $self->iscreate($col);
	my $host = $self->hostforcol($col);
	unless (defined $vlists{$host}) {
	    $vlists{$host} = new SNMP::VarList;
	    $elists{$host} = [];
	    push @hosts, $host;
	}
	my $vlist = $vlists{$host};
	my $elist = $elists{$host};
	for (my $row=2;$row<2+$self->childnum;$row++) {
	    next unless ($all || $matrix->selectionIncludes("$row,$col"));
	    my $entry = $self->entryforcell($row,$col);
	    next if $entry->access =~ /NoAccess|Notify|ReadOnly/;
	    next if $entry->access !~ /Create/ && $entry->iscreate;
	    next unless $entry->vstate =~ /^(set|default)$/;
	    push @$elist, $entry;
	    push @$vlist, $entry->varbind;
	}
    }
    foreach my $host (@hosts) {
	my $needrebuild = 0;
	my $vlist = $vlists{$host};
	my $elist = $elists{$host};
	next unless @$vlist;
	my $errmsg;
	if ($host->{'sstate'} eq 'connected' && (my $snmp = $host->snmp)) {
	    $matrix->Busy(-recurse=>1,);
	
	    foreach (@$vlist) {
		printf STDERR "setting varbind: ".join(", ",@$_)."\n";
	    }

	    my $result = $snmp->set($vlist);

	    foreach (@$vlist) {
		printf STDERR "resulting varbind: ".join(", ",@$_)."\n";
	    }

	    $matrix->Unbusy;
	    printf STDERR "result was $result\n";
	    if ($result) {
		$matrix->Busy(-recurse=>1,);
		my @results = $snmp->get($vlist);
		$matrix->Unbusy;
		if (@results) {
		    for (my $i=0;$i<@$vlist;$i++) {
			my $vb = $vlist->[$i];
			my $entry = $elist->[$i];
			my $val = $vb->[$SNMP::Varbind::val_f];
			my $res = $results[$i];
			if (defined $val && defined $res) {
			    printf STDERR "return value was $val\n";
			    if ($val eq 'NOSUCHINSTANCE' || $res eq 'NOSUCHINSTANCE') {
				$errmsg = 'No such object';
				$entry->nosuch;
			    } else {
				$entry->valsnmp($val);
				if (UNIVERSAL::isa($entry, 'MyEntryCreate')) {
				    for (my $j = 0;$j<@{$self->{creates}};$j++) {
					if ($entry->iid eq $self->{creates}[$j]) {
					    splice @{$self->{creates}},$j,1;
					    last;
					}
				    }
				    $needrebuild = 1;
				}
			    }
			} else {
			    $errmsg = 'No such object';
			    $entry->geterr;
			    $needrebuild = 1;
			}
			if (defined $errmsg) {
			    $self->statusmsg('ERROR: GET: '.$host->hostname.': '.$entry->label.$entry->tag.': '.$errmsg.'.');
			    $self->toplevel->bell;
			    $errmsg = undef;
			    $needrebuild = 1;
			}
		    }
		} else {
		    $errmsg = $snmp->{'ErrorStr'} || 'Unknown get error';
		    $needrebuild = 1;
		}
	    } else {
		$errmsg = $snmp->{'ErrorStr'} || 'Unknown set error';
		$needrebuild = 1;
	    }
	    if ($needrebuild) {
		my $mib;
		if (($mib = $self->{'table'}) || ($mib = $self->{'ancestor'})) {
		    $matrix->activate('0,0');
		    my ($vals) = $snmp->bulkwalk(0,1000,$mib->{'objectID'});
		    unless ($snmp->{ErrorStr}) {
			$mib->removevalues($host);
			if (@{$vals}) {
			    foreach my $vb (@{$vals}) {
				my ($oid,$tag,$val,$typ,@etc) = @{$vb};
				printf STDERR "got varbind: ".join(", ",($oid,$tag,$val,$typ,@etc))."\n";
				if ($mib = MyObject->new($self->tree,$oid)) {
				    $mib->value->data($tag,$host)->valsnmp($val);
				}
			    }
			}
			$self->tagcells;
		    }
		}
	    }
	} else {
	    $errmsg = 'Not connected';
	}
	if (defined $errmsg) {
	    $self->statusmsg('ERROR: SET: '.$host->hostname.": $errmsg.");
	    $self->toplevel->bell;
	    $errmsg = undef;
	}
    }
    $matrix->clearCache;
}
#package MyGroup;
sub clearselected {
    my ($self,@args) = @_;
    my $matrix = $self->widget;
    for (my $col=1;$col<1+$self->entrynum;$col++) {
	for (my $row=2;$row<2+$self->childnum;$row++) {
	    next unless $matrix->selectionIncludes("$row,$col");
	    next if ($self->isindex($row) && !$self->iscreate($row));
	    $self->entryforcell($row,$col)->clear;
	}
    }
    $matrix->clearCache;
}
#package MyGroup;
sub resetselected {
    my ($self,@args) = @_;
    my $matrix = $self->widget;
    for (my $col=1;$col<1+$self->entrynum;$col++) {
	for (my $row=2;$row<2+$self->childnum;$row++) {
	    next unless $matrix->selectionIncludes("$row,$col");
	    next if ($self->isindex($row) && !$self->iscreate($row));
	    $self->entryforcell($row,$col)->reset;
	}
    }
    $matrix->clearCache;
}
#package MyGroup;
sub defaultselected {
    my ($self,@args) = @_;
    my $matrix = $self->widget;
    for (my $col=1;$col<1+$self->entrynum;$col++) {
	for (my $row=2;$row<2+$self->childnum;$row++) {
	    next unless $matrix->selectionIncludes("$row,$col");
	    next if ($self->isindex($row) && !$self->iscreate($row));
	    $self->entryforcell($row,$col)->default;
	}
    }
    $matrix->clearCache;
}
#package MyGroup;
sub getrow {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    if ($self->scalarnum) {
	for ($row = 2; $row < 2 + $self->scalarnum; $row++) {
	    $mib = $self->mibforrow($row);
	    $mib->get($self,$tag,$host,@args);
	    my $data = $mib->value->data($tag,$host);
	    $matrix->set("$row,$col",$data->{'val'});
	}
    } else {
	for ($row = 2 + $self->indexnum; $row < 2 + $self->childnum; $row++) {
	    $mib = $self->mibforrow($row);
	    $mib->get($self,$tag,$host,@args);
	    my $data = $mib->value->data($tag,$host);
	    $matrix->set("$row,$col",$data->{'val'});
	}
    }
}
#package MyGroup;
sub setrow {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
}
#package MyGroup;
sub editcell {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    my $index = "$row,$col";
    my $matrix = $self->widget;
    $matrix->activate($index);
}
#package MyGroup;
sub help {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    $self->top->objprops($self,$mib); # for now
}
#package MyGroup;
sub getgroup {
    my ($self,$row,$col,$mib,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    $mib->getgroup($self);
    $self->tagcells;
}
#package MyGroup;
sub setgroup {
    my ($self,$row,$col,$mib,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    $mib->setgroup($self,$row,$col,@args);
}
#package MyGroup;
sub newentry {
    my ($self,$row,$col,$mib,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    push @{$self->{'creates'}}, MyEntryInstanceId->new_create($self->tree,$self->{'entry'});
    $self->tagcells;
}
#package MyGroup;
sub walkall {
    my ($self,$row,$col,$mib,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    $self->parent->getgroups;
}
#package MyGroup;
sub setall {
    my ($self,$row,$col,$mib,@args) = @_;
    my $matrix = $self->widget;
    $matrix->activate("0,0");
    $self->parent->setgroups;
}
#package MyGroup;
sub info {
    my ($self,$row,$col,$mib,$tag,$host,@args) = @_;
    $self->top->objprops($self,$mib); # for now
}



# ---------------------------------

# ---------------------------------
package MyScalars;
use strict;
use vars qw(@ISA);
@ISA = qw(MyGroup);

#package MyScalars;
sub new {
    my ($type,$parent,$mibs,@args) = @_;
    my $self = MyGroup::new($type,$parent,$mibs,@args) || return undef;
    $self->{'rowstatus'} = 0;
    foreach (@{$mibs}) {
	unless (UNIVERSAL::isa($_,'MyObject')) {
	    warn "bad class ".ref($_)." in mibs list";
	    next;
	}
	$self->pushscalars($_->findscalars);
    }
    my $matrix = $self->SUPER::creatematrix;
    return $self;
}
sub isscalar {
    return 1;
}

sub iscreate {
    return 0;
}

sub isindex {
    return 0;
}

sub mibforrow {
    my ($self,$row,$col,@args) = @_;
    my $mib = undef;
    if ($row > 1 && $row < 2 + $self->childnum) {
	$mib = $self->{'scalars'}->[$row-2];
    } elsif ($row == 0 || $row == 1) {
	$mib = $self->{'ancestor'};
    }
    return $mib;
}

#package MyScalars;
sub construct {
    my ($parent,$data,@args) = @_;
    my $mibs = [];
    foreach (@{$data->{'mibs'}}) {
	push @{$mibs}, MyObject->new($parent->tree,$_);
    }
    my $self = MyScalars->new($parent,$mibs,@args);
    $self->reconstruct($data,@args);
    return $self;
}

# ---------------------------------

# ---------------------------------
package MyTables;
use strict;
use vars qw(@ISA);
@ISA = qw(MyGroup);

#package MyTables;
sub new {
    my ($type,$parent,$mibs,@args) = @_;
    my $self = MyGroup::new($type,$parent,$mibs,@args) || return undef;
    my ($mib) = @{$mibs};
    return undef unless ref($mib) =~ /Conceptual(Table|Entry|Column|Index)/;
    my ($class,$table,$entry,$indexes,$columns) = ref($mib);
    $self->{'rowstatus'} = 0;
    if ($class eq 'MyConceptualTable') {
	$self->settable($mib);
	$self->setentry($self->{'table'}->{'children'}->[0]);
	$self->pushindexes(@{$self->{'entry'}->{'indexes'}});
	$self->pushcolumns(@{$self->{'entry'}->{'children'}});
    } elsif ($class eq 'ConceptualEntry') {
	$self->settable($mib->{'parent'});
	$self->setentry($self->{'table'}->{'children'}->[0]);
	$self->pushindexes(@{$self->{'entry'}->{'indexes'}});
	$self->pushcolumns(@{$self->{'entry'}->{'children'}});
    } elsif ($class eq 'MyConceptualIndex') {
	$self->settable($mib->{'parent'}->{'parent'});
	$self->setentry($self->{'table'}->{'children'}->[0]);
	$self->pushindexes(@{$self->{'entry'}->{'indexes'}});
    } elsif ($class eq 'MyConceptualColumn') {
	$self->settable($mib->{'parent'}->{'parent'});
	$self->setentry($self->{'table'}->{'children'}->[0]);
	$self->pushindexes(@{$self->{'entry'}->{'indexes'}});
	foreach (@{$self->{'entry'}->{'children'}}) {
	    if ($_->{'objectID'} eq $mib->{'objectID'}) {
		$self->pushcolumns($_);
		last;
	    }
	}
    } else {
	return undef;
    }
    my $matrix = $self->SUPER::creatematrix;
    return $self;
}

#package MyTables;
sub isscalar {
    return 0;
}

#package MyTables;
sub iscreate {
    my ($self,$col,@args) = @_;
    if ($col > 0 && $col < 1 + $self->entrynum) {
	if ($col > $self->valuenum) {
	    return 1;
	}
    }
    return 0;
}

#package MyTables;
sub isindex {
    my ($self,$row,@args) = @_;
    if ($row > 1 && $row < 2 + $self->childnum) {
	if ($row < 2 + $self->indexnum) {
	    return 1;
	}
    }
    return 0;
}

#package MyTables;
sub mibforrow {
    my ($self,$row,$col,@args) = @_;
    my $mib = undef;
    if ($row > 1 && $row < 2 + $self->childnum) {
	if ($row < 2 + $self->indexnum) {
	    $mib = $self->{'indexes'}->[$row-2];
	} else {
	    $mib = $self->{'columns'}->[$row-2-$self->indexnum];
	}
    } elsif ($row == 0 || $row == 1) {
	if (defined $col && $col == 1 + $self->entrynum) {
	    $mib = $self->{'entry'};
	} else {
	    $mib = $self->{'table'};
	}
    }
    return $mib;
}

#package MyTables;
sub construct {
    my ($parent,$data,@args) = @_;
    my $mibs = [];
    foreach (@{$data->{'mibs'}}) {
	push @{$mibs}, MyObject->new($parent->tree,$_);
    }
    my $self = MyTables->new($parent,$mibs,@args);
    $self->reconstruct($data,@args);
    return $self;
}

# ---------------------------------

# ---------------------------------
package MyTree;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);

#package MyTree;
sub new {
    my ($type,$parent,@args) = @_;
    my $self = MyPersistent::new($type,$parent,@args);
    $self->{'parent'} = $parent;
    $self->{'objects'} = {};
    return $self;
}
sub statusmsg {
    my ($self,@args) = @_;
    $self->{'parent'}->statusmsg(@args);
}
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    delete $self->{'parent'};
}

#package MyTree;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $data->{'oids'} = {};
    $data->{'ents'} = {};
    foreach (keys %{$self->{'objects'}}) {
	my $obj = $self->{'objects'}->{$_};
	if (UNIVERSAL::isa($obj,'MyObject')) {
	    if (/^\./) { # only by oid
		$data->{'oids'}->{$_} = $obj->dumphash(@args);
	    }
	} elsif (UNIVERSAL::isa($obj,'MyEntity')) {
	    $data->{'ents'}->{$_} = $obj->dumphash(@args);
	} else {
	    warn "unknown object class ".ref($obj);
	    next;
	}
    }
    return $data;
}
#package MyTree;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    foreach (keys %{$data->{'oids'}}) {
	MyObject::construct($self,$data->{'oids'}->{$_},@args);
    }
    foreach (keys %{$data->{'ents'}}) {
	MyHostEntity::construct($self,$data->{'ents'}->{$_},@args);
    }
}
#package MyTree;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyTree->new($parent,@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyTree;
sub session {
    my $sessions = shift->{'parent'}->sessions;
    return undef unless scalar @{$sessions};
    return $sessions->[0];
}

#package MyTree;
sub sessions {
    shift->{'parent'}->sessions;
}

# ---------------------------------

# ---------------------------------
package MyEntity;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);
#package MyEntity;
sub new {
    my ($type,$tree,$id,@args) = @_;
    my $self = MyPersistent::new($type,$tree);
    $self->{'tree'} = $tree;
    $self->{'id'} = $id;
    $self->{'children'} = [];
    $self->{'label'} = $id;
    $tree->{'objects'}->{$id} = $self;
    return $self;
}
#package MyEntity;
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    my $tree = $self->{'tree'};
    delete $self->{'tree'};
    delete $self->{'children'};
    delete $tree->{'objects'}->{$self->{'id'}};
}
#package MyEntity;
sub id {
    shift->{'id'};
}
#package MyEntity;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    foreach (qw/state image color populated hidden label id/) {
	$data->{$_} = $self->{$_};
    }
    return $data;
}
#package MyEntity;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    foreach (qw/state image color populated hidden label/) {
	$self->{$_} = $data->{$_};
    }
    $self->populate if $self->{'state'} ne 'c';
}
#package MyEntity;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyEntity->new($parent,$data->{'id'},@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyEntity;
sub setindicator {
    my ($self,$top,$entry) = @_;
    $top->indicator('configure', $entry,
	-image=>"$self->{'state'}$self->{'image'}$self->{'color'}",
    );
}
#package MyEntity;
sub setstate {
    my ($self,$top,$entry,$state) = @_;
    $self->{'state'} = $state;
    $self->setindicator($top,$entry);
}
#package MyEntity;
sub setcolor {
    my ($self,$top,$entry,$color) = @_;
    $self->{'color'} = $color;
    $self->setindicator($top,$entry);
}
#package MyEntity;
sub setimage {
    my ($self,$top,$entry,$image) = @_;
    $self->{'image'} = $image;
    $self->setindicator($top,$entry);
}
#package MyEntity;
sub walkvalues {
    my ($self,$hlist,$entry,@args) = @_;
    my $top = $hlist->{'hlist'};
}
#package MyEntity;
sub newchild {
    my ($self,$top,$entry) = @_;
    my $e = $top->addchild($entry,
	-itemtype=>'text',
	-text=>$self->{'label'},
	-data=>$self,
    );
    $top->indicator('create', $e,
	-itemtype=>'image',
	-image=>"$self->{'state'}$self->{'image'}$self->{'color'}",
    );
    $top->itemCreate($e, 1,
	-itemtype=>'text',
    );
    $top->itemCreate($e, 2,
	-itemtype=>'text',
	-text=>$self->{'session'}->{'sstate'},
    );
    if ($self->{'hidden'} or ($self->{'parent'} && $self->{'parent'}->{'state'} eq 'c')) {
	$top->hide('entry', $e);
    } else {
	#$top->show('entry', $e);
	#$top->yview($e);
    }
    return $e;
}
#package MyEntity;
sub updatechild {
    my ($self,$top,$e) = @_;
    $top->entryconfigure($e,
	-itemtype=>'text',
	-text=>$self->{'label'},
    );
    $top->indicator('configure', $e,
	-itemtype=>'image',
	-image=>"$self->{'state'}$self->{'image'}$self->{'color'}",
    );
    unless ($top->itemExists($e, 1)) {
	$top->itemCreate($e, 1,
	    -imagetype=>'text',
	);
    }
    $top->itemConfigure($e, 1,
	-itemtype=>'text',
	-text=>'',
    );
    unless ($top->itemExists($e, 2)) {
	$top->itemCreate($e, 2,
	    -imagetype=>'text',
	);
    }
    $top->itemConfigure($e, 2,
	-itemtype=>'text',
	-text=>$self->{'session'}->{'sstate'},
    );
    if ($self->{'hidden'} or ($self->{'parent'} && $self->{'parent'}->{'state'} eq 'c')) {
	$top->hide('entry', $e);
    } else {
	$top->show('entry', $e);
    }
}

# ---------------------------------
package MyHostEntity;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntity);
#package MyHostEntity;
sub new {
    my ($type,$tree,$id,@args) = @_;
    unless (UNIVERSAL::isa($tree,'MyTree')) {
	die "not a tree";
    }
    if (defined $tree->{'objects'}->{$id}) {
	return $tree->{'objects'}->{$id};
    }
    my $self = MyEntity::new($type,$tree,$id,@args) || return undef;
    my $parent = $tree->{'parent'};
    $self->{'session'} = MySession->new($parent,@args);
    $self->{'image'} = 'host';
    $self->{'color'} = '';
    $self->{'state'} = 'c';
    $self->{'label'} = $self->{'session'}->hostname;
    return $self;
}
#package MyHostEntity;
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    $self->{'session'}->destroy;
    delete $self->{'session'};
}
#package MyHostEntity;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $data->{'session'} = $self->{'session'}->dumphash(@args);
    return $data;
}
#package MyHostEntity;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    $self->{'session'}->reconstruct($data->{'session'},@args);
}
#package MyHostEntity;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyHostEntity->new($parent,$data->{'id'},%{$data->{'session'}->{'options'}},@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyHostEntity;
sub detail {
    my ($self,$entry,$hlist,@args) = @_;
    #return $self->{'detail'} if defined $self->{'detail'};
    my $state = $self->{'state'} eq 'c' ? 'closed' : 'open';
    my $sessions = undef;
    foreach (@{$self->{'tree'}->{'parent'}->sessions}) {
	$sessions .= ",\n                  " if $sessions;
	$sessions .= $_->hostname." ".$_;
    }
    my $entities = undef;
    foreach (map { $self->{'tree'}->{'objects'}->{$_}; } keys %{$self->{'tree'}->{'objects'}}) {
	$entities .= ",\n                  " if $entities;
	$entities .= $_->id." ".$_;
    }
    my $string = '';
    $string .= "Perl:.............$self\n";
    $string .= "State:............$self\n";
    $string .= "Item:.............$entry\n" if $entry;
    $string .= "Id:...............$self->{'id'}\n";
    $string .= "Label:............$self->{'label'}\n" if $self->{'label'};
    $string .= "Sessions:.........$sessions\n" if $sessions;
    $string .= "Entities:.........$entities\n" if $entities;
    $string .= $self->{'session'}->detail(@args);
    $string .= $hlist->detail(@args) if defined $hlist;
    $self->{'detail'} = $string;
    return $string;
}
#package MyHostEntity;
sub edit {
    my ($self,$hlist,$entry,@args) = @_;
    my $answer = $self->{'session'}->dialog($hlist->toplevel);
    if ($answer eq 'OK') {
	$self->disconnect($hlist,$entry);
	$self->connect($hlist,$entry);
	$self->{'label'} = $self->{'session'}->hostname;
	my $top = $hlist->{'hlist'};
	$top->entryconfigure($$entry,
	    -text=>$self->{'session'}->hostname,
	);
    }
}
#package MyHostEntity;
sub connect {
    my ($self,$hlist,$entry) = @_;
    unless ($self->{'session'}->connected) {
	if ($self->{'session'}->connect) {
	    if ($self->{'session'}->testconnection) {
		$self->setcolor($hlist->{'hlist'},$$entry,'-grn');
	    } else {
		$self->setcolor($hlist->{'hlist'},$$entry,'-red');
	    }
	} else {
	    $self->setcolor($hlist->{'hlist'},$$entry,'-red');
	}
    }
}
#package MyHostEntity;
sub disconnect {
    my ($self,$hlist,$entry) = @_;
    if ($self->{'session'}->connected) {
	$self->{'session'}->disconnect;
	$self->setcolor($hlist->{'hlist'},$$entry,'');
    }
}
#package MyHostEntity;
sub testconnection {
    my ($self,$hlist,$entry) = @_;
    unless ($self->{'session'}->connected) {
	unless ($self->{'session'}->connect) {
	    $self->setcolor($hlist->{'hlist'},$$entry,'-red');
	    return;
	}
    }
    if ($self->{'session'}->testconnection) {
	$self->setcolor($hlist->{'hlist'},$$entry,'-grn');
    } else {
	$self->setcolor($hlist->{'hlist'},$$entry,'-red');
    }
}
# ---------------------------------

# ---------------------------------

# ---------------------------------
package MyObject;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);
#package MyObject;
sub new {
    my ($type,$tree,$oid,@args) = @_;
    return $tree->{'objects'}->{$oid} if defined $tree->{'objects'}->{$oid};
    my $mib = $SNMP::MIB{$oid} || return undef;
    my $self = MyPersistent::new($type,$tree);
    $self->{'tree'} = $tree;
    $self->{'mib'} = $mib;
    $self->{'oid'} = $mib->{'objectID'};
    $self->{'oid'} =~ s/^\.//;
    $self->{'isanindex'} = 0;
    $self->{'isindexof'} = '';
    $oid = $mib->{'objectID'};
    foreach (qw/objectID label subID moduleID type access status syntax textualConvention TCDescription units hint enums ranges description reference defaultValue/) {
	$self->{$_} = $mib->{$_} if defined $mib->{$_};
    }
    if ($self->{'syntax'} eq 'TimeInterval') { # fixup
	$self->{'units'} = 'seconds';
	$self->{'hint'} = 'd-2';
    }
    if ($self->{'syntax'} eq 'RowStatus' && !defined $self->{'defaultValue'}) {
	$self->{'defaultValue'} = 'notReady';
    }
    $self->{'indexes'} = [];
    $self->{'children'} = [];
    if ($mib->{'parent'}) {
	$self->{'parent'} = MyObject->new($tree, $mib->{'parent'}->{'objectID'});
    }
    if (defined $mib->{'indexes'} && @{$mib->{'indexes'}}) {
	bless $self, 'MyConceptualRow';
	$self->{'image'} = 'rows';
	$self->{'color'} = '';
	$self->{'state'} = 'c';
    } elsif ($self->{'parent'} && @{$mib->{'parent'}->{'indexes'}}) {
	my $found = 0;
	foreach (@{$mib->{'parent'}->{'indexes'}}) {
	    if ($self->{'label'} eq $_) {
		$found = 1;
		last;
	    }
	}
	if (!$found) {
	    bless $self, 'MyConceptualColumn';
	    $self->{'image'} = 'cols';
	    $self->{'color'} = '';
	    $self->{'state'} = 'c';
	    $self->{'value'} = MyValue->new($self);
	} else {
	    bless $self, 'MyConceptualIndex';
	    $self->{'image'} = 'inds';
	    $self->{'color'} = '';
	    $self->{'state'} = 'c';
	    $self->{'value'} = MyValue->new($self);
	}
    } elsif (defined $mib->{'children'} && @{$mib->{'children'}} && $mib->{'children'}->[0]->{'indexes'} && @{$mib->{'children'}->[0]->{'indexes'}}) {
	bless $self, 'MyConceptualTable';
	$self->{'image'} = 'docs';
	$self->{'color'} = '';
	$self->{'state'} = 'c';
    } elsif (defined $mib->{'children'} && @{$mib->{'children'}}) {
	if ($self->{'syntax'}) {
	    bless $self, 'MyObjectType';
	    $self->{'image'} = 'objs';
	    $self->{'color'} = '-blu';
	    $self->{'state'} = 'c';
	    $self->{'value'} = MyValue->new($self);
	} elsif ($self->{'description'}) {
	    if ($self->{'parent'} && $self->{'parent'}->{'moduleID'} eq $self->{'moduleID'}) {
		bless $self, 'MyObjectIdentity';
		$self->{'image'} = 'book';
		$self->{'color'} = '-blu';
		$self->{'state'} = 'c';
	    } else {
		bless $self, 'MyModuleIdentity';
		$self->{'image'} = 'book';
		$self->{'color'} = '-blu';
		$self->{'state'} = 'c';
	    }
	} else {
	    bless $self, 'MyObjectIdentifier';
	    $self->{'image'} = 'book';
	    $self->{'color'} = '';
	    $self->{'state'} = 'c';
	}
    } elsif ($self->{'type'} && $self->{'type'} eq 'NOTIF') {
	bless $self, 'MyNotification';
	$self->{'image'} = 'note';
	$self->{'color'} = '';
	$self->{'state'} = 'c';
    } elsif ($self->{'access'} && $self->{'access'} eq 'Notify') {
	bless $self, 'MyNotifyParameter';
	$self->{'image'} = 'parm';
	$self->{'color'} = '';
	$self->{'state'} = 'c';
    } elsif ($self->{'syntax'}) {
	bless $self, 'MyObjectType';
	$self->{'image'} = 'objs';
	$self->{'color'} = '';
	$self->{'state'} = 'c';
	$self->{'value'} = MyValue->new($self);
    } elsif ($self->{'description'}) {
	bless $self, 'MyObjectIdentity';
	$self->{'image'} = 'objs';
	$self->{'color'} = '-blu';
	$self->{'state'} = 'c';
    } else {
	bless $self, 'MyLeaf';
	$self->{'image'} = 'objs';
	$self->{'color'} = '';
	$self->{'state'} = 'c';
    }
    $tree->{'objects'}->{$self->{'objectID'}} = $self;
    $tree->{'objects'}->{$self->{'oid'}} = $self;
    $tree->{'objects'}->{$self->{'label'}} = $self if $self->{'label'};
    return $self;
}
#package MyObject;
sub tree {
    shift->{'tree'};
}
#package MyObject;
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    my $tree = $self->{'tree'};
    delete $self->{'tree'};
    delete $self->{'mib'};
    delete $self->{'indexes'};
    delete $self->{'children'};
    delete $self->{'parent'};
    delete $tree->{'objects'}->{$self->{'objectID'}};
    delete $tree->{'objects'}->{$self->{'oid'}};
    delete $tree->{'objects'}->{$self->{'label'}};
}
#package MyObject;
sub id {
    shift->{'objectID'};
}
#package MyObject;
sub tagname {
    shift->{'access'};
}
#package MyObject;
sub removevalues {
    my ($self,$host,@args) = @_;
    if (my $value = $self->value) {
	$value->remove($host,@args);
    }
    foreach (@{$self->{'children'}}) {
	$_->removevalues($host,@args);
    }
}
#package MyObject;
sub clearvalues {
    my ($self,$host,@args) = @_;
    if (my $value = $self->value) {
	$value->clear($host,@args);
    }
    foreach (@{$self->{'children'}}) {
	$_->clearvalues($host,@args);
    }
}
#package MyObject;
sub colorallred {
    my $self = shift;
    $self->{'color'} = '-red';
    $self->populate;
    foreach (@{$self->{'children'}}) {
	$_->colorallred;
    }
}
#package MyObject;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    foreach (qw/state image color populated hidden objectID/) {
	$data->{$_} = $self->{$_};
    }
    if ($self->value) {
	$data->{'value'} = $self->value->dumphash(@args);
    }
    return $data;
}
#package MyObject;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    foreach (qw/state image color hidden/) {
	$self->{$_} = $data->{$_} if defined $data->{$_};
    }
    $self->populate if $self->{'state'} ne 'c';
    if ($data->{'value'} && $self->{'value'}) {
	$self->{'value'}->reconstruct($data->{'value'},@args);
    }
}
#package MyObject;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyObject->new($parent,$data->{'objectID'},@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyObject;
sub detail {
    my ($self,$entry,@args) = @_;
    my $enums = undef;
    foreach (sort { $self->{'enums'}{$a} <=> $self->{'enums'}{$b}; } keys %{$self->{'enums'}}) {
	$enums .= ",\n         " if $enums;
	$enums .= "$_($self->{'enums'}{$_})";
    }
    my $ranges = undef;
    foreach (@{$self->{'ranges'}}) {
	$ranges .= ",\n         " if $ranges;
	$ranges .= "($_->{'low'}..$_->{'high'})";
    }
    my $children = undef;
    foreach (@{$self->{'children'}}) {
	$children .= ",\n         " if $children;
	$children .= $_->{'label'};
    }
    my $indexes = undef;
    foreach (@{$self->{'indexes'}}) {
	$indexes .= ",\n         " if $indexes;
	$indexes .= $_->{'label'};
    }
    my $values = undef;
    $values = $self->{'value'}->formatvalues if $self->{'value'};
    my $lead;
    my $description = $self->description;
    $description =~ s/\n/\n         /sg;
    my $tcdescription = $self->TCDescription;
    $tcdescription =~ s/\n/\n         /sg;
    my $reference = $self->reference;
    $reference =~ s/\n/\n         /sg;
    my $parent = undef;
    if ($self->{'parent'}) {
	$parent = $self->{'parent'}->{'label'} || $self->{'parent'}->{'objectID'};
	$parent .= " $self->{'parent'} ";
	$parent .= $self->{'parent'}->{'state'} eq 'c' ? ' (closed)' : ' (open)';
    }
    my $defval = $self->{'defaultValue'};
    my $state = $self->{'state'} eq 'c' ? 'closed' : 'open';
    my $string = '';
    $string .= "Perl:    $self\n";
    $string .= "State:   $state\n";
    $string .= "Source:  ".$self->type."\n";
    $string .= "Item:    $entry\n" if $entry;
    $string .= "Id:      $self->{'subID'}\n" if $self->{'subID'};
    $string .= "Object:  $self->{'objectID'}\n" if $self->{'objectID'};
    $string .= "Label:   $self->{'label'}\n" if $self->{'label'};
    $string .= "Module:  $self->{'moduleID'}\n" if $self->{'moduleID'};
    $string .= "NextNode:$self->{'nextNode'}->{'label'}\n" if $self->{'nextNode'};
    $string .= "Parent:  $parent\n" if $parent;
    $string .= "Type:    $self->{'type'}\n" if $self->{'type'};
    $string .= "Access:  $self->{'access'}\n" if $self->{'access'};
    $string .= "Status:  $self->{'status'}\n" if $self->{'status'};
    $string .= "Syntax:  $self->{'syntax'}\n" if $self->{'syntax'};
    $string .= "Ranges:  $ranges\n" if $ranges;
    $string .= "Enums:   $enums\n" if $enums;
    $string .= "Indexes: $indexes\n" if $indexes;
    $string .= "Default: $defval\n" if $defval;
    $string .= "Units:   $self->{'units'}\n" if $self->{'units'};
    $string .= "Hint:    $self->{'hint'}\n" if $self->{'hint'};
    $string .= "Augment: $self->{'augments'}\n" if $self->{'augments'};
    $string .= "Values:  $values\n" if $values;
    $string .= "Descrip: $description\n" if $description;
    $string .= "Refer:   $reference\n" if $reference;
    $string .= "TC:      $self->{'textualConvention'}\n" if $self->{'textualConvention'};
    $string .= "TC Desc: $tcdescription\n" if $tcdescription;
    $string .= "Child:   $children\n" if $children;
    $self->{'detail'} = $string;
    return $string;
}
#package MyObject;
sub strip {
    my ($self,$msg,@args) = @_;
    if (defined $msg) {
	$msg =~ s/^(\s|\n)*//s;
	$msg =~ s/(\s|\n)*$//s;
	$msg =~ s/\t/        /g;
	$msg =~ s/\n[ ]+\n/\n\n/g;
	while ($msg =~ /\n\n\n/) {
	    $msg =~ s/\n\n\n/\n/g;
	}
	my $lead = undef;
	my $match;
	while ($msg =~ /(\n[ ]+)[^\n]/g) {
	    $match = $1;
	    if (defined $lead) {
		if (length($lead) > length($match)) {
		    $lead = $match;
		}
	    } else {
		$lead = $match;
	    }
	}
	if (defined $lead) {
	    $msg =~ s/$lead/\n/g;
	}
	$msg =~ s/^(\n|\s)*$//sg;
	chomp $msg;
    } else {
	$msg = '';
    }
    return $msg;
}
#package MyObject;
sub reflow {
    my ($self,$msg,$width,@args) = @_;
    $width = 400 unless defined $width;
    my $w = $::balloonwidget;
    my $font = $w->cget('-font');
    my @lines;
    my @result = ();
    $msg =~ s/\n[ ]+\n/\n\n/sg;
    if ($msg =~ /[ ]\n[ ]*/s) {
	$msg =~ s/[ ]\n[ ]*/ /sg;
	@lines = split(/\n/,$msg);
    } elsif ($msg =~ /\n\n/s) {
	$msg =~ s/\.\n(?!\n)/. \n/sg;
	$msg =~ s/\n(?!\n)/ \n/sg;
	$msg =~ s/\n[ ]+\n/\n\n/sg;
	$msg =~ s/[ ]\n[ ]*/ /sg;
	@lines = split(/\n/,$msg);
    } else {
	$msg =~ s/\.\n/. \n/sg;
	$msg =~ s/\n[ ]*/ /sg;
	# FIXME - check for lead change
	@lines = split(/\n/,$msg);
    }
    foreach my $line (@lines) {
	my ($indent,$lead,$measure) = ('','');
	$indent = $1 if $line =~ s/^( *)//;
	$lead = $1 if $line =~ s/^(([0-9]+\.|-|)[ ]+)//;
	my $rest = $width - $w->fontMeasure($font, $indent) - $w->fontMeasure($font, $lead);
	while (($measure = $w->fontMeasure($font, $line)) > $rest) {
	    my ($pos,$where,$break) = (-1,-1,-1);
	    while (($break = index($line,' ',$pos + 1)) >= 0) {
		my $portion = $w->fontMeasure($font,substr($line,0,$break));
		last if $portion >= $rest;
		$where = $break unless $break == $pos + 1;
		$pos = $break;
	    }
	    $where = $break if $where == 0;
	    $where = length($line) if $where <= 0;
	    push(@result,$indent.$lead.substr($line,0,$where,''));
	    $line =~ s/^[ ]*//;
	    $lead =~ s/./ /g;
	    $rest = $width - $w->fontMeasure($font, $indent) - $w->fontMeasure($font, $lead);
	}
	push(@result,$indent.$lead.$line);
    }
    if (@result > 60) {
	@result = grep(!/^\s*$/,@result); # turf blank lines
    }
    $msg = join("\n",@result);
    return $msg;
}
#package MyObject;
sub rehang {
    my ($self,$msg,$width,$hang,@args) = @_;
    $width = 400 unless defined $width;
    my $w = $::balloonwidget;
    my $font = $w->cget('-font');
    $hang = '        ' unless defined $hang;
    $msg =~ s/\n[ ]+\n/\n\n/sg;
    $msg =~ s/[ ]\n[ ]*/ /sg;
    my @result = ();
    my @lines = split(/\n/,$msg);
    foreach my $line (@lines) {
	my ($indent,$lead) = ('','');
	$indent = $1 if $line =~ s/^( *)//;
	my $rest = $width - $w->fontMeasure($font,$indent) - $w->fontMeasure($font,$lead);
	while ((my $measure = $w->fontMeasure($font,$line)) > $rest) {
	    my ($pos,$where,$break) = (-1,-1,-1);
	    while (($break = index($line,' ',$pos + 1)) >= 0) {
		my $portion = $w->fontMeasure($font,substr($line,0,$break));
		last if $portion >= $rest;
		$where = $break unless $break == $pos + 1;
		$pos = $break;
	    }
	    $where = $break if $where == 0;
	    $where = length($line) if $where <= 0;
	    push(@result,$indent.$lead.substr($line,0,$where,''));
	    $line =~ s/^[ ]*//;
	    $lead = $hang;
	    $rest = $width - $w->fontMeasure($font,$indent) - $w->fontMeasure($font,$lead);
	}
	push(@result,$indent.$lead.$line);
    }
    $msg = join("\n",@result);
    return $msg;
}
#package MyObject;
sub description {
    my ($self,$width,@args) = @_;
    my $msg = $self->{'Fdesc'};
    if (defined $width) {
	unless (defined $msg) {
	    $msg = $self->strip($self->{'description'});
	    $msg = $self->reflow($msg,$width);
	    $self->{'Fdesc'} = $msg;
	}
    } else {
	$msg = $self->strip($self->{'description'});
    }
    return $msg;
}
#package MyObject;
sub TCDescription {
    my ($self,$width,@args) = @_;
    my $msg = $self->{'Ftc'};
    if (defined $width) {
	unless (defined $msg) {
	    $msg = $self->strip($self->{'TCDescription'});
	    $msg = $self->reflow($msg,$width);
	    $self->{'Ftc'} = $msg;
	}
    } else {
	$msg = $self->strip($self->{'TCDescription'});
    }
    return $msg;
}
#package MyObject;
sub reference {
    my ($self,$width,@args) = @_;
    my $msg = $self->{'Fref'};
    if (defined $width) {
	unless (defined $msg) {
	    $msg = $self->strip($self->{'reference'});
	    $msg = $self->rehang($msg,$width);
	    $self->{'Fref'} = $msg;
	}
    } else {
	$msg = $self->strip($self->{'reference'});
    }
    return $msg;
}
#package MyObject;
sub syntaxtype {
    my $self = shift;
    return $self->{'syntaxType'} if defined $self->{'syntaxType'};
    my $st = $self->{'textualConvention'} || $self->{'syntax'} || $self->{'type'};
    $st = ucfirst lc $st if ($self->{'syntax'} && $st eq $self->{'type'});
    $st = 'OCTET STRING' if ($st eq 'Octetstr');
    $st = 'OBJECT IDENTIFIER' if ($st eq 'Objectid');
    $self->{'syntaxType'} = $st;
    return $st;
}
#package MyObject;
sub constraints {
    my $self = shift;
    return $self->{'constraints'} if defined $self->{'constraints'};
    my $factor;
    my $power;
    if ($self->{'hint'} && $self->{'hint'} =~ /^d(-([0-9]*))?$/) {
	if (defined $2 && $2 > 0) {
	    $power = $2;
	    $factor = 10**$2;
	}
    }
    my $ranges = '';
    if (@{$self->{'ranges'}}) {
	foreach (@{$self->{'ranges'}}) {
	    $ranges .= '|' if $ranges;
	    my ($low,$high) = ($_->{'low'},$_->{'high'});
	    if (defined $factor) {
		$low = $low/$factor;
		$high = $high/$factor;
	    }
	    if ($low == $high) {
		if (defined $power) {
		    $ranges .= sprintf('%.'.$power.'f',$low);
		} else {
		    $ranges .= $low;
		}
	    } else {
		if (defined $power) {
		    $ranges .= sprintf('%.'.$power.'f',$low).'..'.sprintf('%.'.$power.'f',$high);
		} else {
		    $ranges .= "$low..$high";
		}
	    }
	}
	if ($ranges) {
	    $ranges = "($ranges)";
	    $ranges = "(SIZE$ranges)" if ($self->{'type'} =~ /OCTETSTR|OPAQUE|OBJECTID/);
	}
    }
    $self->{'constraints'} = $ranges;
    return $ranges;
}
#package MyObject;
sub syntaxunits {
    my $self = shift;
    return $self->{'syntaxUnits'} if defined $self->{'syntaxUnits'};
    my $su = $self->syntaxtype.$self->constraints;
    $su .= " $self->{'units'}" if $self->{'units'};
    $self->{'syntaxUnits'} = $su;
    return $su;
}
#package MyObject;
sub fmsg {
    my $self = shift;
    my $msg = $self->{'fmsg'};
    return $msg if $msg;
    my $width = 450;
    $msg = $self->{'moduleID'}."::".$self->{'label'}.":\n(".$self->{'objectID'}.")\n";
    $msg .= $self->syntaxtype."\n\n" if $self->syntaxtype;
    $msg .= $self->description($width)."\n\n" if $self->description($width);
    $msg .= $self->reference($width)."\n\n" if $self->reference($width);
    $msg =~ s/\n*$//sg;
    chomp $msg;
    $self->{'fmsg'} = $msg;
    return $msg;
}
#package MyObject;
sub hmsg {
    my $self = shift;
    my $msg = $self->{'hmsg'};
    my $w = $::balloonwidget;
    my $font = $w->cget('-font');
    return $msg if $msg;
    my $width = 450;
    my $factor;
    my $power;
    if ($self->{'hint'} && $self->{'hint'} =~ /^d(-([0-9]*))?$/) {
	if (defined $2 && $2 > 0) {
	    $power = $2;
	    $factor = 10**$2;
	}
    }
    my $defval;
    if (($defval = $self->{'defaultValue'}) && defined $factor) {
	$defval = sprintf('%.'.$power.'f',$defval/$factor);
    }
    my $values;
    my $x = $w->fontMeasure($font, "Values: ");
    if (keys %{$self->{'enums'}}) {
	foreach (map {"$_($self->{'enums'}{$_})"} sort {$self->{'enums'}{$a} <=> $self->{'enums'}{$b}} keys %{$self->{enums}}) {
	    if (defined $values) {
		if ($x + $w->fontMeasure($font,"$_, ") > $width) {
		    $values .= ",\n        ";
		    $x = $w->fontMeasure($font,'        ');
		} else {
		    $values .= ", ";
		    $x += $w->fontMeasure($font,', ');
		}
	    }
	    $values .= $_;
	    $x += $w->fontMeasure($font,$_);
	}
    }
    $msg = "Syntax: ".$self->syntaxunits."\n";
    $msg .= "Access: $self->{'access'}\n" if $self->{'access'};
    $msg .= "Format: $self->{'hint'}\n" if $self->{'hint'};
    $msg .= "Default value: $defval\n" if $defval;
    $msg .= "Values: $values\n" if $values;
    $msg .= "\n";
    $msg .= $self->description($width)."\n\n" if $self->description($width);
    $msg =~ s/\n*$//sg;
    chomp $msg;
    $self->{'hmsg'} = $msg;
    return $msg;
}
#package MyObject;
sub tmsg {
    my $self = shift;
    my $msg = $self->{'tmsg'};
    return $msg if $msg;
    my $width = 450;
    $msg = "$self->{'textualConvention'}\n\n" if $self->{'textualConvention'};
    $msg .= $self->TCDescription($width);
    $msg = $self->{'units'} unless $msg;
    $self->{'tmsg'} = $msg;
    unless ($msg) {
	my $value = $self->value;
	if (ref($value) eq 'MyOctetString') {
	    $msg = <<EOF;
A string of octets.
EOF
	} elsif (ref($value) eq 'MyOpaque') {
	    $msg = <<EOF;
A opaque string of octets.
EOF
	} elsif (ref($value) eq 'MyObjectId') {
	    $msg = <<EOF;
An object identifier.
EOF
	} elsif (ref($value) eq 'MyBits') {
	    $msg = <<EOF;
A bit string.
EOF
	} elsif (ref($value) eq 'MyInteger') {
	    $msg = <<EOF;
An integer value.
EOF
	} elsif (ref($value) eq 'MyEnumerated') {
	    $msg = <<EOF;
An enumerated type value.
EOF
	} elsif (ref($value) eq 'MyInteger32') {
	    $msg = <<EOF;
A 32-bit integer value.
EOF
	} elsif (ref($value) eq 'MyEnumerated32') {
	    $msg = <<EOF;
An enumarated type value.
EOF
	} elsif (ref($value) eq 'MyCounter64') {
	    $msg = <<EOF;
A 64-bit counter value.
EOF
	} elsif (ref($value) eq 'MyUnsigned32') {
	    $msg = <<EOF;
A 32-bit unsigned integer value.
EOF
	} elsif (ref($value) eq 'MyCounter') {
	    $msg = <<EOF;
A counter value.
EOF
	} elsif (ref($value) eq 'MyGauge') {
	    $msg = <<EOF;
A gauge value.
EOF
	} elsif (ref($value) eq 'MyTicks') {
	    $msg = <<EOF;
A time instant.
EOF
	} elsif (ref($value) eq 'MyUinteger') {
	    $msg = <<EOF;
An unsigned integer.
EOF
	} elsif (ref($value) eq 'MyIpaddr') {
	    $msg = <<EOF;
An IP address.
EOF
	} elsif (ref($value) eq 'MyNetaddr') {
	    $msg = <<EOF;
A network address.
EOF
	} elsif (ref($value) eq 'MyNull') {
	    $msg = <<EOF;
A null value.
EOF
	}
    }
    if ($msg) {
	$msg =~ s/\n*$//sg;
	chomp $msg;
    }
    return $msg;
}
#package MyObject;
sub lmsg {
    '';
}
#package MyObject;
sub umsg {
    '';
}
#package MyObject;
sub vmsg {
    '';
}
#package MyObject;
sub value {
    shift->{'value'};
}
#package MyObject;
sub sessions {
    shift->{'tree'}->sessions;
}
#package MyObject;
sub populate {
    my $self = shift;
    return 0 if $self->{'populated'};
    $self->{'populated'} = 1;
    my $mib = $self->{'mib'}; # the SNMP mib
    $self->{'indexes'} = [];
    foreach (@{$mib->{'indexes'}}) {
	my $index = MyObject->new($self->{'tree'}, $_);
	push @{$self->{'indexes'}}, $index;
	$index->{'isanindex'} = 1;
	$index->{'isindexof'} = $mib;
	$index->{'image'} = 'inds';
    }
    $self->{'children'} = [];
    my $prev = undef;
    foreach ( sort {
	    my $aoid = $a->{'objectID'};
	    $aoid =~ s/$mib->{'objectID'}.//;
	    my $boid = $b->{'objectID'};
	    $boid =~ s/$mib->{'objectID'}.//;
	    $aoid <=> $boid;
	} @{$mib->{'children'}}) {
	my $child = MyObject->new($self->{'tree'}, $_->{'objectID'});
	if ($child->{'isindexof'} eq $mib) {
	    $child->{'ismyindex'} = 1;
	    next;
	}
	push @{$self->{'children'}}, $child;
	$child->{'prevSibling'} = $prev;
	$child->{'nextSibling'} = undef;
	if ($prev) {
	    $prev->{'nextSibling'} = $child;
	}
	$prev = $child;
    }
    return 1;
}
#package MyObject;
sub buildout {
    my $self = shift;
    $self->populate;
    foreach (@{$self->{'children'}}) {
	$_->buildout;
    }
}
#package MyObject;
sub dump {
    my $self = shift;
    print <<EOF;
Object:  $self->{'objectID'}
Label:   $self->{'label'}
Module:  $self->{'moduleID'}
Type:    $self->{'type'}
Access:  $self->{'access'}
Status:  $self->{'syntax'}
Units:   $self->{'units'}
Hint:    $self->{'hint'}
Refer:   $self->reference
Description:
         $self->description
EOF
}
#package MyObject;
sub label {
    my $self = shift;
    my $label = $self->{'label'};
    $label = $self->{'oid'} unless $label;
    return $label;
}
#package MyObject;
sub smsg {
    shift->value->smsg;
}
#package MyObject;
sub setindicator {
    my ($self,$top,$entry) = @_;
    $top->indicator('configure', $entry,
	-image=>"$self->{'state'}$self->{'image'}$self->{'color'}",
    );
}
#package MyObject;
sub newchild {
    my ($self,$top,$entry) = @_;
    my $e = $top->addchild($entry,
	-itemtype=>'text',
	-text=>$self->{'label'},
	-data=>$self,
    );
    $top->indicator('create', $e,
	-itemtype=>'image',
	-image=>"$self->{'state'}$self->{'image'}$self->{'color'}",
    );
    $top->itemCreate($e, 1,
	-itemtype=>'text',
	-text=>$self->syntaxtype,
    );
    if ($self->{'hidden'} or ($self->{'parent'} && $self->{'parent'}->{'state'} eq 'c')) {
	$top->hide('entry', $e);
    } else {
	#$top->show('entry', $e);
	#$top->yview($e);
    }
    return $e;
}
#package MyObject;
sub setstate {
    my ($self,$top,$entry,$state) = @_;
    $self->{'state'} = $state;
    $self->setindicator($top,$entry);
}
#package MyObject;
sub setcolor {
    my ($self,$top,$entry,$color) = @_;
    $self->{'color'} = $color;
    $self->setindicator($top,$entry);
}
#package MyObject;
sub setimage {
    my ($self,$top,$entry,$image) = @_;
    $self->{'image'} = $image;
    $self->setindicator($top,$entry);
}
#package MyObject;
sub findobjects {
    my $self = shift;
    my @objects = ();
    $self->populate unless $self->{'populated'};
    foreach (@{$self->{'children'}}) {
	push @objects, $_->findobjects;
    }
    return @objects;
}
#package MyObject;
sub findindexes {
    my $self = shift;
    my @indexes = ();

    $self->populate unless $self->{'populated'};
    foreach (@{$self->{'children'}}) {
	push @indexes, $_->findindexes;
    }
    return @indexes;
}
#package MyObject;
sub findscalars {
    my $self = shift;
    my @scalars = ();

    $self->populate unless $self->{'populated'};
    foreach (@{$self->{'children'}}) {
	push @scalars, $_->findscalars;
    }
    return @scalars;
}
#package MyObject;
sub findtables {
    my $self = shift;
    my @tables = ();

    $self->populate unless $self->{'populated'};
    foreach (@{$self->{'children'}}) {
	push @tables, $_->findtables;
    }
    return @tables;
}
#package MyObject;
sub walkvalues {
    my ($self,$hlist,$entry) = @_;
    my $top = $hlist->{'hlist'};

    if ($self->{'state'} ne 'c') {
	if (@{$self->{'children'}}) {
	    foreach ($top->info('children',$entry)) {
		my $mib = $top->entrycget($_,-data);
		$mib->walkvalues($hlist,$_);
	    }
	}
    }
}
#package MyObject;
sub indexformat {
    my ($self,@args) = @_;
    shift->value->indexformat(@args);
}
#package MyObject;
sub indexvalue {
    my ($self,@args) = @_;
    return $self->value->indexvalue(@args);
}
#package MyObject;
sub indextag {
    my ($self,@args) = @_;
    return $self->value->indextag(@args);
}
#package MyObject;
sub statusmsg {
    my ($self,@args) = @_;
    $self->{'tree'}->statusmsg(@args);
}
#package MyObject;
sub getgroup {
    my ($self,$group,@args) = @_;
    my $values = 0;
    $group->widget->Busy(-recurse=>1,);
    foreach my $host (@{$group->sessions}) {
	next if $host->{'sstate'} ne 'connected';
	my $snmp = $host->snmp;
	unless ($snmp) {
	    $self->statusmsg('WARNING: Session '.$host->hostname.' is not connected.');
	    next;
	}
	my ($vals) = $snmp->bulkwalk(0,1000,$self->{'objectID'});
	if ($snmp->{'ErrorStr'}) {
	    $host->{'sstate'} = 'errored';
	    $self->statusmsg('ERROR: '.$host->hostname.': '.$snmp->{'ErrorStr'}.'.');
	    next;
	}
	$self->removevalues($host);
	if (@{$vals}) {
	    foreach my $vb (@{$vals}) {
		my ($oid,$tag,$val) = @{$vb};
		if (my $mib = MyObject->new($group->tree,$oid)) {
		    $mib->value->data($tag,$host)->valsnmp($val);
		}
	    }
	    $values += scalar @{$vals};
	}
    }
    $group->widget->Unbusy;
    return $values;
}
#package MyObject;
sub setgroup {
    my ($self,$group,@args) = @_;
    return $group->setselected(1,@args);
}

# ---------------------------------
package MyConceptualRow;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);
#package MyConceptualRow;
sub type {
    return 'OBJECT-TYPE (Entry)';
}
#package MyConceptualRow;
sub formatindices {
    my ($self,$tag) = @_;
    my $l = undef;
    my @elements = ();
    @elements = split(/\./,$tag) if $tag;
    my $ind = 0;
    my $lastind = $#{$self->{'indexes'}};
    foreach (@{$self->{'indexes'}}) {
	last unless $_->indexformat(\@elements,\$l,$ind == $lastind);
	$ind += 1;
    }
    return $l;
}
#package MyConceptualRow;
sub indexformats {
    my ($self,$tag) = @_;
    my @elements = ();
    @elements = split(/\./,$tag) if $tag;
    my $ind = 0;
    my $lastind = $#{$self->{'indexes'}};
    my $indexes = [];
    foreach (@{$self->{'indexes'}}) {
	my $l = undef;
	my $result = $_->indexformat(\@elements,\$l,$ind == $lastind);
	push @$indexes, $l;
	last unless $result;
	$ind += 1;
    }
    return $indexes;
}
# ---------------------------------

# ---------------------------------
package MyConceptualColumn;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);
#package MyConceptualColumn;
sub type {
    return 'OBJECT-TYPE (Field)';
}
#package MyConceptualColumn;
sub findobjects {
    shift;
}
#package MyConceptualColumn;
sub formatindices {
    my ($self,@args) = @_;
    return $self->{'parent'}->formatindices(@args);
}
#package MyConceptualColumn;
sub indexformats {
    my ($self,@args) = @_;
    return $self->{'parent'}->indexformats(@args);
}
#package MyConceptualColumn;
sub walkvalues {
    my ($self,$hlist,$entry) = @_;
    my $top = $hlist->{'hlist'};
    my $value = $self->value;

    return unless $value;
    return unless $self->getvalues($hlist);
    return unless $entry;

    $self->setstate($top,$entry,'o');
    $hlist->clearactive($top);
    $top->delete('offspring', $entry);
    if ($self->newvalues($top,$entry)) {
	$self->setcolor($top,$entry,'-grn');
    } else {
	$self->setcolor($top,$entry,'-red');
    }
}
#package MyConceptualColumn;
sub newvalues {
    my ($self,$top,$entry) = @_;
    my $value = $self->value;
    my $parent = $self->{'parent'};
    my $values = 0;
    foreach my $host (@{$self->sessions}) {
	foreach (sort { ::cmp_lexical($a,$b); } @{$value->tags($host)}) {
	    my $obj = MyEntryValue->new($self->tree,$value,$host,$parent,$_);
	    my $e = $top->addchild($entry,
		-itemtype=>'text',
		-text=>$host->hostname."::$self->{'label'}.".$self->formatindices($_),
		-data=>$obj,
	    );
	    my $val = $obj->val;
	    $val = '' unless defined $val;
	    $val =~ s/\n/, /g;
	    $top->itemCreate($e, 1,
		-itemtype=>'text',
		-text=>$val,
	    );
	    $top->itemCreate($e, 2,
		-itemtype=>'text',
		-text=>$self->{'units'},
	    ) if $self->{'units'};
	    if ($self->{'hidden'} or $self->{'state'} eq 'c') {
		$top->hide('entry', $e);
	    } else {
		#$top->yview($e);
	    }
	    $values++;
	}
    }
    return $values;
}
#package MyConceptualColumn;
sub get {
    my ($self,$group,$tag,$host,@args) = @_;
    my $errmsg = 'Failure';
    my $result = 0;
    if ($self->{'access'} !~ /NoAccess|Notify/) {
	if ($host->{'sstate'} eq 'connected' && (my $snmp = $host->snmp)) {
	    $group->widget->Busy(-recurse=>1,);
	    my $val = $snmp->get("$self->{'label'}.$tag");
	    $group->widget->Unbusy;
	    if ($snmp->{'ErrorStr'}) {
		$host->{'sstate'} = 'errored';
		$self->value->data($tag,$host)->geterr;
		$errmsg = $snmp->{'ErrorStr'};
	    } else {
		if (defined $val) {
		    if ($val eq 'NOSUCHINSTANCE') {
			$self->value->data($tag,$host)->nosuch;
			$errmsg = 'No such object';
		    } else {
			$self->value->data($tag,$host)->valsnmp($val);
			$result = 1;
		    }
		}
	    }
	} else {
	    $errmsg = 'Not connected';
	}
    } else {
	$errmsg = 'Access not permitted';
    }
    if ($result) {
	$self->{'color'} = '-grn';
    } else {
	$self->{'color'} = '-red';
	$group->statusmsg('ERROR: GET: '.$host->hostname.": $self->{'label'}.$tag: $errmsg.");
	$group->toplevel->bell;
    }
    return $result;
}
#package MyConceptualColumn;
sub getvalues {
    my ($self,$hlist) = @_;

    my $value = $self->value;
    if ($self->{'access'} =~ /NoAccess|Notify/) {
	$hlist->statusmsg("ERROR: Access to $self->{'label'} not permitted.");
	return 0;
    }
    my $values = 0;
    $self->{'color'} = '-red';
    $hlist->{'hlist'}->Busy(-recurse=>1);
    foreach my $host (@{$self->sessions}) {
	next if $host->{'sstate'} ne 'connected';
	my $snmp = $host->snmp;
	unless ($snmp) {
	    $hlist->statusmsg('Session '.$host->hostname.' is not connected.');
	    next;
	}
	my ($vals) = $snmp->bulkwalk(0, 100, $self->{'objectID'});

	if ($snmp->{'ErrorStr'}) {
	    $host->{'sstate'} = 'errored';
	    $hlist->statusmsg('ERROR: '.$host->hostname.': '.$snmp->{'ErrorStr'});
	    next;
	} else {
	    $self->removevalues($host);
	    #$self->clearvalues($host);
	    if (@{$vals}) {
		foreach my $vb ( @{$vals} ) {
		    my ($oid,$tag,$val) = @{$vb};
		    printf STDERR "got varbind: ".join(", ",($oid,$tag,$val))."\n";
		    $value->data($tag,$host)->valsnmp($val);
		    $self->{'color'} = '-grn';
		}
		$values += @{$vals};
	    }
	}
    }
    $hlist->{'hlist'}->Unbusy;
    return $values;
}
# ---------------------------------

# ---------------------------------
package MyConceptualIndex;
use strict;
use vars qw(@ISA);
@ISA = qw(MyConceptualColumn);

#package MyConceptualIndex;
sub type {
    return 'OBJECT-TYPE (Index)';
}

#package MyConceptualIndex;
sub findobjects {
    return ();
}

# ---------------------------------

# ---------------------------------
package MyConceptualTable;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);

#package MyConceptualTable;
sub type {
    return 'OBJECT-TYPE (Table)';
}

#package MyConceptualTable;
sub findtables {
    shift;
}

# ---------------------------------

# ---------------------------------
package MyObjectIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);
# ---------------------------------

#package MyObjectIdentifier;
sub type {
    return 'OBJECT IDENTIFIER';
}

# ---------------------------------
package MyModuleIdentity;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObjectIdentifier);

#package MyModuleIdentity;
sub type {
    return 'MODULE-IDENTITY';
}
# ---------------------------------

# ---------------------------------
package MyNotification;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);

#package MyNotification;
sub type {
    return 'NOTIFICATION-TYPE';
}
# ---------------------------------

# ---------------------------------
package MyNotifyParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);

#package MyNotifyParameter;
sub type {
    return 'OBJECT-TYPE (Notif)';
}
# ---------------------------------

# ---------------------------------
package MyObjectType;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);

#package MyObjectType;
sub type {
    return 'OBJECT-TYPE (Scalar)';
}

#package MyObjectType;
sub findobjects {
    shift;
}

#package MyObjectType;
sub findscalars {
    (shift);
}

#package MyObjectType;
sub formatindices {
    my ($self,$tag) = @_;
    return $tag;
}

#package MyObjectType;
sub setvalue {
}

#package MyObjectType;
sub walkvalues {
    my ($self,$hlist,$entry) = @_;
    my $top = $hlist->{'hlist'};
    my $value = $self->value;

    return unless $value;
    return unless $self->getvalues($hlist);
    return unless $entry;

    $self->setstate($top,$entry,'o');
    $hlist->clearactive($top);
    $top->delete('offsprings', $entry);
    if ($self->newvalues($top,$entry)) {
	$self->setcolor($top,$entry,'-grn');
    } else {
	$self->setcolor($top,$entry,'-red');
    }
}

#package MyObjectType;
sub newvalues {
    my ($self,$top,$entry) = @_;
    my $value = $self->value;
    my $values = 0;
    foreach my $host (@{$self->sessions}) {
	my $obj = MyEntryScalar->new($self->tree,$value,$host);
	my $e = $top->addchild($entry,
	    -itemtype=>'text',
	    -text=>$host->hostname."::$self->{'label'}.0",
	    -data=>$obj,
	);
	my $val = $obj->val;
	$val = '' unless defined $val;
	$val =~ s/\n/, /g;
	$top->itemCreate($e, 1,
	    -itemtype=>'text',
	    -text=>$val,
	);
	$top->itemCreate($e, 2,
	    -itemtype=>'text',
	    -text=>$self->{'units'},
	) if $self->{'units'};
	if ($self->{'hidden'} or $self->{'state'} eq 'c') {
	    $top->hide('entry', $e);
	} else {
	    #$top->yview($e);
	}
	$values++;
    }
    return $values;
}

#package MyObjectType;
sub get {
    my ($self,$group,$tag,$host,@args) = @_;
    my $errmsg = 'Failure';
    my $result = 0;
    if ($self->{'access'} !~ /NoAccess|Notify/) {
	if ($host->{'sstate'} eq 'connected' && (my $snmp = $host->snmp)) {
	    $group->widget->Busy(-recurse=>1,);
	    my $val = $snmp->get("$self->{'label'}.$tag");
	    $group->widget->Unbusy;
	    if ($snmp->{'ErrorStr'}) {
		$host->{'sstate'} = 'errored';
		$self->value->data($tag,$host)->geterr;
		$errmsg = $snmp->{'ErrorStr'};
	    } else {
		if (defined $val) {
		    if ($val eq 'NOSUCHINSTANCE') {
			$self->value->data($tag,$host)->nosuch;
			$errmsg = 'No such object';
		    } else {
			$self->value->data($tag,$host)->valsnmp($val);
			$result = 1;
		    }
		}
	    }
	} else {
	    $errmsg = 'Not connected';
	}
    } else {
	$errmsg = 'Access not permitted';
    }
    if ($result) {
	$self->{'color'} = '-grn';
    } else {
	$self->{'color'} = '-red';
	$group->statusmsg('ERROR: GET: '.$host->hostname.": $self->{'label'}.$tag: $errmsg.");
	$group->toplevel->bell;
    }
    return $result;
}

#package MyObjectType;
sub getvalues {
    my ($self,$hlist) = @_;

    my $value = $self->value;
    if ($self->{'access'} =~ /NoAccess|Notify/) {
	$hlist->statusmsg("ERROR: Access to $self->{'label'} not permitted.");
	return 0;
    }
    my $values = 0;
    $self->{'color'} = '-red';
    $hlist->{'hlist'}->Busy(-recurse=>1,);
    foreach my $host (@{$self->sessions}) {
	next if $host->{'sstate'} ne 'connected';
	my $snmp = $host->snmp;
	unless ($snmp) {
	    $hlist->statusmsg('ERROR: Session '.$host->hostname.' not connected.');
	    next;
	}
	my $val = $snmp->get("$self->{'label'}.0");
	if ($snmp->{'ErrorStr'}) {
	    $host->{'sstate'} = 'errored';
	    $hlist->statusmsg('ERROR: GET: '.$host->hostname.": $self->{'label'}.0: $snmp->{'ErrorStr'}");
	    $value->data(0,$host)->geterr;
	    next;
	} else {
	    if (defined $val) {
		if ($val eq 'NOSUCHINSTANCE') {
		    $hlist->statusmsg('ERROR: GET: '.$host->hostname.": $self->{'label'}.0: No such object.");
		    $value->data(0,$host)->nosuch;
		    next;
		} else {
		    $value->data(0,$host)->valsnmp($val);
		    $self->{'color'} = '-grn';
		    $values++;
		}
	    }
	}
    }
    $hlist->{'hlist'}->Unbusy;
    return $values;
}

# ---------------------------------

# ---------------------------------
package MyObjectIdentity;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);

#package MyObjectIdentity;
sub type {
    return 'OBJECT-IDENTITY';
}
# ---------------------------------

# ---------------------------------
package MyLeaf;
use strict;
use vars qw(@ISA);
@ISA = qw(MyObject);

#package MyLeaf;
sub type {
    return 'OBJECT IDENTIFIER';
}
# ---------------------------------

# ---------------------------------
package MyEntry;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);
#package MyEntry;
sub new {
    my ($type,$tree,$id,@args) = @_;
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    $self = MyPersistent::new($type,$tree);
    $self->{'tree'} = $tree;
    $self->{'id'} = $id;
    $self->{'children'} = [];
    $self->{'label'} = $id;
    $tree->{'objects'}->{$id} = $self;
    $self;
}
sub id {
    shift->{'id'};
}
sub move {
    my ($self,$id) = @_;
    my $tree = $self->{'tree'};
    my $old = $self->{'id'};
    delete $tree->{'objects'}->{$old};
    $tree->{'objects'}->{$id} = $self;
    $self->{'id'} = $id;
    $self->{'label'} = $id;
}
# ---------------------------------

# ---------------------------------
# This is an entry object for hosts.
# ---------------------------------
package MyEntryHost;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntry);
#package MyEntryHost;
sub new {
    my ($type,$tree,$id,$host,@args) = @_;
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    $self = MyEntry::new($type,$tree,$id,@args);
    my $data = $self->{'data'};
    $host = $tree->sessions->[0] unless $host;
    $self->{'host'} = $host;
    return $self;
}
#package MyEntryHost;
sub tagname {
    shift->host->tagname;
}
#package MyEntryHost;
sub hostname {
    shift->host->hostname;
}
#package MyEntryHost;
sub host {
    shift->{'host'};
}
# ---------------------------------

# ---------------------------------
# This is an entry object that has a value;
# ---------------------------------
package MyEntryItem;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntry);
#package MyEntryItem;
sub new {
    my ($type,$tree,$id,$value,@args) = @_;
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    $self = MyEntry::new($type,$tree,$id,@args);
    my $data = $self->{'data'};
    $self->{'haswindow'} = 0;
    $self->{'value'} = $value;
    $self->{'val'} = $data->{'val'} = undef;
    $self->{'old'} = $data->{'old'} = undef;
    $self->{'ent'} = $data->{'ent'} = undef;
    $self->{'vstate'} = $data->{'vstate'} = 'unset';
    $self->{'ostate'} = $data->{'ostate'} = 'unset';
    $self->{'estate'} = $data->{'estate'} = 'unset';
    return $self;
}
#package MyEntryItem;
sub detail {
    my ($self,$entry,@args) = @_;
    return $self->{'datum'}->detail($entry) if $self->{'datum'};
    return $self->{'detail'} if defined $self->{'detail'};
    my $host = $self->id;
    $host =~ s/:.*$//;
    my $oid = $self->oid;
    my $id = $self->id;
    my $val = $self->val;
    my $string = '';
    $string .= "Item:     $entry\n" if $entry;
    $string .= "Id:       $id\n";
    $string .= "Object:   $oid\n";
    $string .= "Instance: $oid.$id\n";
    $string .= "Host:     $host\n";
    $string .= "Value:    $val\n";
    $self->{'detail'} = $string;
    return $string;
}
#package MyEntryItem;
sub datum {
    my $self = shift;
    if ($self->{'datum'}) {
	return $self->{'datum'};
    }
    return $self;
}
#package MyEntryItem;
sub mib {
    shift->value->{'mib'};
}
#package MyEntryItem;
sub oid {
    shift->mib->{'objectID'};
}
#package MyEntryItem;
sub isindex {
    0;
}
#package MyEntryItem;
sub label {
    shift->mib->{'label'};
}
#package MyEntryItem;
sub access {
    shift->mib->{'access'};
}
#package MyEntryItem;
sub setdatum {
    my ($self,$datum) = @_;
    $self->{'datum'} = $datum;
}
#package MyEntryItem;
sub tagname {
    shift->datum->{'vstate'};
}
#package MyEntryItem;
sub value {
    shift->{'value'};
}
#package MyEntryItem;
sub addentry {
    my ($self,$parent,$force,@args) = @_;
    $self->setdefault;
    $self->{'ent'} = $self->val;
    $self->{'estate'} = $self->vstate;
    $self->value->addentry($parent,$self,$force,@args);
}
#package MyEntryItem;
sub force {
    my ($self,$value) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'set';
    $datum->{'val'} = $data->{'val'} = $value;
}
#package MyEntryItem;
sub set {
    my ($self,$val,@args) = @_;
    my $datum = $self->datum;
    my $value = $self->value;
    $value->reformat(\$val);
    if ($value->validate($val,@args)) {
	$datum->force($val,@args);
	return 1;
    }
    warn "value '$val' did not validate";
    return 0;
}
#package MyEntryItem;
sub setdiff {
    my ($self,$val,@args) = @_;
    my $old = $self->val;
    if ((defined $old && !defined $val) ||
	(!defined $old && defined $val) ||
	(defined $val && $old ne $val)) {
	warn "setting val $val, old was $old";
	return $self->set($val);
    }
    return 1;
}
#package MyEntryItem;
sub markread {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'ostate'} = $data->{'ostate'} = 
    $datum->{'vstate'} = $data->{'vstate'} = 'read';
    $datum->{'old'} = $data->{'old'} = $datum->{'val'};
}
#package MyEntryItem;
sub markset {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'set';
    $datum->{'val'};
}
#package MyEntryItem;
sub markdefault {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'default';
    $datum->{'val'};
}
#package MyEntryItem;
sub default {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $value = $self->value;
    my $val = $value->getdefault;
    if ($value->validate($val,@args)) {
	$datum->{'data'}->{'val'} = $datum->{'val'} = $val;
	$self->markdefault;
    } else {
	warn "value $val did not validate";
    }
    $datum->{'val'};
}
#package MyEntryItem;
sub setdefault {
    my ($self,$val,@args) = @_;
    my $datum = $self->datum;
    if ($datum->{'vstate'} eq 'unset') {
	my $data = $datum->{'data'};
	my $value = $self->value;
	$val = $value->getdefault unless defined $val;
	if ($value->validate($val,@args)) {
	    $data->{'val'} = $datum->{'val'} = $val;
	    $self->markdefault;
	} else {
	    warn "value $val did not validate";
	}
    }
    $datum->{'val'};
}
#package MyEntryItem;
sub snmpval {
    my ($self) = @_;
    my $datum = $self->datum;
    $self->value->snmpval($datum);
}
#package MyEntryItem;
sub varbind {
    my ($self) = @_;
    my $datum = $self->datum;
    my $value = $self->value;
    $self->value->varbind($datum);
}
#package MyEntryItem;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'val'} = $data->{'val'} = $self->value->valsnmp($val,@args);
    $self->markread;
}
#package MyEntryItem;
sub val {
    shift->datum->{'val'};
}
#package MyEntryItem;
sub vstate {
    shift->datum->{'vstate'};
}
#package MyEntryItem;
sub get {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    if ($datum->{'vstate'} =~ /^(set|read|default)$/) {
	return $datum->{'val'};
    }
    return undef;
}
#package MyEntryItem;
sub reset {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = $datum->{'ostate'};
    $datum->{'val'} = $data->{'val'} = $datum->{'old'};
}
#package MyEntryItem;
sub clear {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'ostate'} = $data->{'ostate'} = 
    $datum->{'vstate'} = $data->{'vstate'} = 'unset';
    $datum->{'old'} = $data->{'old'} =
    $datum->{'val'} = $data->{'val'} = undef;
}
#package MyEntryItem;
sub unset {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'unset';
    $datum->{'val'} = $data->{'val'} = undef;
}
#package MyEntryItem;
sub nosuch {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'nosuch';
    $datum->{'val'} = $data->{'val'} = undef;
}
#package MyEntryItem;
sub geterr {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'geterr';
    $datum->{'val'} = $data->{'val'} = undef;
}
#package MyEntryItem;
sub seterr {
    my ($self,@args) = @_;
    my $datum = $self->datum;
    my $data = $datum->{'data'};
    $datum->{'vstate'} = $data->{'vstate'} = 'seterr';
    $datum->{'val'} = $data->{'val'} = undef;
}
#package MyEntryItem;
sub validate {
    my ($self,$proposed,@args) = @_;
    my $datum = $self->datum;
    $self->value->validate($proposed,@args);
}
# ---------------------------------

# ---------------------------------
# This is an entry object for indexes.
# ---------------------------------
package MyEntryIndex;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntryItem);
#package MyEntryIndex;
sub new {
    my ($type,$tree,$id,$entry,$value,$create,$elements,$last,@args) = @_;
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    $self = MyEntryItem::new($type,$tree,$id,$value,@args);
    my $data = $self->{'data'};
    $self->{'create'} = $create;
    $self->{'entry'} = $entry;
    $self->{'last'} = $last;
    $self->{'tag'} = $self->value->indextag($elements,$last,@args);
    $self->recalc_format;
    $self->recalc_val;
    $self;
}
sub recalc_format {
    my $self = shift;
    my $data = $self->{'data'};
    my $last = $self->{'last'};
    my @e = split(/\./,$self->{'tag'});
    my $l = undef;
    if ($self->value->indexformat(\@e,\$l,$last)) {
	$self->{'format'} = $data->{'format'} = $l;
    }
}
sub recalc_val {
    my $self = shift;
    my $data = $self->{'data'};
    my $last = $self->{'last'};
    my @e = split(/\./,$self->{'tag'});
    $self->force($self->value->indexvalue(\@e,$last));
    if ($self->iscreate) {
	$self->markdefault;
    } else {
	$self->markread;
    }
}
sub tag {
    # have to convert the value to a canonical tag
    my $self = shift;
    my $datum = $self->datum;
    $self->{'tag'} = $self->value->snmptag($datum);
    return $self->{'tag'};
}
#package MyEntryIndex;
sub isindex {
    1;
}
#package MyEntryIndex;
sub iscreate {
    shift->{'create'};
}
#package MyEntryIndex;
sub tagname {
    shift->iscreate ? 'create' : 'index';
}
# ---------------------------------

# ---------------------------------
# This is an entry object for instances.  It contains one host entry, a
# (possibly empty) set of indexes, and a value.
# ---------------------------------
package MyEntryInstanceId;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntryHost);
#package MyEntryInstanceId;
sub new {
    my ($type,$tree,$id,$host,$entry,$tag,$num,@args) = @_;
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    $self = MyEntryHost::new('MyEntryInstanceId',$tree,$id,$host,@args);
    my $data = $self->{'data'};
    $self->{'type'} = $data->{'type'} = $type;
    $self->{'tag'} = $data->{'tag'} = $tag;
    $self->{'num'} = $data->{'num'} = $num;
    $self->{'entry'} = $entry;
    $self->{'indexes'} = [];
    $self->{'create'} = ($type eq 'MyEntryCreate') ? 1 : 0;
    my $entrynum = 0;
    if (defined $entry) {
	my @elements = split(/\./,$tag);
	my $ind = 0;
	my $lastind = $#{$self->{'indexes'}};
	foreach (@{$entry->{'indexes'}}) {
	    my $eid = $id.'.0.'.$entrynum++;
	    push @{$self->{'indexes'}},
	    MyEntryIndex->new($tree,$eid,$entry,$_->value,$self->{'create'},\@elements,$ind == $lastind,@args);
	    $ind++;
	}
    }
    $self;
}
#package MyEntryInstanceId;
sub new_scalar {
    my ($type,$tree,$host,@args) = @_;
    my $entry = undef;
    my $tag = '0';
    my $id = $host->name.":$tag";
    MyEntryInstanceId::new('MyEntryScalar',$tree,$id,$host,$entry,$tag,0,@args);
}
#package MyEntryInstanceId;
sub new_value {
    my ($type,$tree,$host,$entry,$tag,@args) = @_;
    my $id = $host->name.":$entry->{'objectID'}.0.$tag";
    MyEntryInstanceId::new('MyEntryValue',$tree,$id,$host,$entry,$tag,0,@args);
}
#package MyEntryInstanceId;
$MyEntryInstanceId::instancenum = 0;
#package MyEntryInstanceId;
sub new_create {
    my ($type,$tree,$entry,@args) = @_;
    my $num = $MyEntryInstanceId::instancenum++;
    my $id = "host:$entry->{'objectID'}.0.$type.".$num;
    my $tag;
    for (my $i=0;$i<@{$entry->{'indexes'}};$i++) {
	$tag .= '.' if defined $tag;
	$tag .= '0';
    }
    MyEntryInstanceId::new('MyEntryCreate',$tree,$id,undef,$entry,$tag,$num,@args);
}
#package MyEntryInstanceId;
sub index {
    my ($self,$num) = @_;
    return $self->{'indexes'}->[$num];
}
#package MyEntryInstanceId;
sub num {
    shift->{'num'};
}
#package MyEntryInstanceId;
sub type {
    shift->{'type'};
}
#package MyEntryInstanceId;
sub entry {
    shift->{'entry'};
}
#package MyEntryInstanceId;
sub tree {
    shift->{'tree'};
}
#package MyEntryInstanceId;
sub iscreate {
    shift->{'create'};
}
#package MyEntryInstanceId;
sub tag {
    my $self = shift;
    my $tag = '0';
    if (@{$self->{'indexes'}}) {
	$tag = undef;
	foreach (@{$self->{'indexes'}}) {
	    $tag .= '.' if defined $tag;
	    $tag .= $_->tag;
	}
    }
    $tag;
}
#package MyEntryInstanceId;
sub idforvalue {
    my ($self,$value,$type) = @_;
    $type = $self->type unless defined $type;
    $self->{'type'} = $type;
    my $id = undef;
    if ($type eq 'MyEntryScalar') {
	$id = $self->host->name.":$value->{'mib'}->{'objectID'}.0";
    } elsif ($type eq 'MyEntryValue') {
	$id = $self->host->name.":$value->{'mib'}->{'objectID'}.".$self->tag;
    } elsif ($type eq 'MyEntryCreate') {
	$id = "host:$value->{'mib'}->{'objectID'}.$type.$self->num";
    }
    return $id;
}
#package MyEntryInstanceId;
sub datumforvalue {
    my ($self,$value) = @_;
    my $type = $self->type;
    my $datum = undef;
    if ($type ne 'MyEntryCreate') {
	$datum = $value->data($self->tag,$self->host);
    }
    return $datum;
}
# ---------------------------------

# ---------------------------------
package MyEntryInstance;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntryItem);
#package MyEntryInstance;
sub new {
    my ($type,$tree,$id,$value,$iid,$datum,@args) = @_;
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    $self = MyEntryItem::new($type,$tree,$id,$value,@args) || return undef;
    $self->{'iid'} = $iid;
    $self->setdatum($datum);
    $self;
}
sub locate {
    my ($type,$iid,$value,@args) = @_;
    my $id = $iid->idforvalue($value);
    my $datum = $iid->datumforvalue($value);
    MyEntryInstance::new($iid->type,$iid->tree,$id,$value,$iid,$datum,@args);
}
sub iid {
    shift->{'iid'};
}
sub tag {
    shift->iid->tag;
}
sub entry {
    shift->iid->entry;
}
sub host {
    shift->iid->host;
}
sub iscreate {
    shift->iid->iscreate;
}
# ---------------------------------

# ---------------------------------
package MyEntryScalar;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntryInstance);
#package MyEntryScalar;
sub new {
    my ($type,$tree,$value,$host,@args) = @_;
    my $id = $host->name.":$value->{'mib'}->{'objectID'}.0";
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    my $iid = MyEntryInstanceId->new_scalar($tree,$host,@args);
    my $datum = $value->data('0',$host);
    MyEntryInstance::new($type,$tree,$id,$value,$iid,$datum,@args);
}
# ---------------------------------

# ---------------------------------
package MyEntryValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntryInstance);
#package MyEntryValue;
sub new {
    my ($type,$tree,$value,$host,$entry,$tag,@args) = @_;
    my $id = $host->name.":$value->{'mib'}->{'objectID'}.$tag";
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    my $iid = MyEntryInstanceId->new_value($tree,$host,$entry,$tag,@args);
    my $datum = $value->data($tag,$host);
    MyEntryInstance::new($type,$tree,$id,$value,$iid,$datum,@args);
}
# ---------------------------------

# ---------------------------------
package MyEntryCreate;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEntryInstance);
#package MyEntryCreate;
sub new {
    my ($type,$tree,$value,$entry,$num,@args) = @_;
    my $id = "host:$value->{'mib'}->{'objectID'}.$type.$num";
    my $self = $tree->{'objects'}->{$id};
    return $self if $self;
    my $iid = MyEntryInstanceId->new_create($tree,$entry,@args);
    my $datum = undef;
    MyEntryInstance::new($type,$tree,$id,$value,$iid,$datum,@args);
}
# ---------------------------------

# ---------------------------------
# This object represents instance data for a specific mib object-type value.
# ---------------------------------
package MyData;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);
#package MyData;
sub new {
    my ($type,$value,$tag,$val,@args) = @_;
    my $self = MyPersistent::new($type,$value);
    $self->{'parent'} = $value;
    my $mib = $value->{'mib'};
    my $oid = $mib->{'objectID'};
    my $data = $self->{'data'};
    $self->{'oid'} = $oid;
    $self->{'tag'} = $data->{'tag'} = $tag; # e.g. '.0'
    $self->{'val'} = $data->{'val'} = $val;
    $self->{'old'} = $data->{'old'} = $val;
    $self->{'state'} = 'o';
    $self->{'image'} = 'obj';
    $self->{'color'} = '-grn';
    if (defined $val) {
	$self->{'vstate'} = $data->{'vstate'} = 'set';
	$self->{'ostate'} = $data->{'ostate'} = 'set';
    } else {
	$self->{'vstate'} = $data->{'vstate'} = 'unset';
	$self->{'ostate'} = $data->{'ostate'} = 'unset';
    }
    $self->{'elements'} = [ split(/\./,$tag) ];
    $self->{'index'} = $mib->formatindices($tag); # pretty index, e.g. "pfmod"
    return $self;
}
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    delete $self->{'parent'};
}
#package MyData;
sub id {
    my ($self,@args) = @_;
    return "$self->{'oid'}.$self->{'tag'}";
}
#package MyData;
sub tag {
    shift->{'tag'};
}
#package MyData;
sub label {
    shift->{'parent'}->{'mib'}->{'label'};
}
#package MyData;
sub tagname {
    shift->{'vstate'};
}
#package MyData;
sub setindicator {
    my ($self,$top,$entry) = @_;
#    $top->indicator('configure', $entry,
#	-image=>"$self->{'state'}$self->{'image'}$self->{'color'}",
#    );
}
#package MyData;
sub setstate {
    my ($self,$top,$entry,$state) = @_;
    $self->{'state'} = $state;
    $self->setindicator($top,$entry);
}
#package MyData;
sub setcolor {
    my ($self,$top,$entry,$color) = @_;
    $self->{'color'} = $color;
    $self->setindicator($top,$entry);
}
#package MyData;
sub setimage {
    my ($self,$top,$entry,$image) = @_;
    $self->{'image'} = $image;
    $self->setindicator($top,$entry);
}
#package MyData;
sub populate {
    my $self = shift;
    return 0 if $self->{'populated'};
    $self->{'populated'} = 1;
    return 1;
}
#package MyData;
sub value {
    shift->{'parent'};
}
#package MyData;
sub force {
    my ($self,$value,@args) = @_;
    my $data = $self->{'data'};
    $self->{'val'} = $data->{'val'} = $value;
    $self->{'vstate'} = $data->{'vstate'} = 'set';
    return $value;
}
#package MyData;
sub set {
    my ($self,$val,@args) = @_;
    my $data = $self->{'data'};
    my $value = $self->{'parent'};
    $value->reformat(\$val);
    if ($value->validate($val,@args)) {
	$self->force($val,@args);
	return 1;
    }
    warn "value '$val' did not validate";
    return 0;
}
#package MyData;
sub markread {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    $self->{'old'} = $data->{'old'} = $self->{'val'};
    $self->{'ostate'} = $data->{'ostate'} = 
    $self->{'vstate'} = $data->{'vstate'} = 'read';
    $self->{'val'};
}
#package MyData;
sub markset {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    $self->{'vstate'} = $data->{'vstate'} = 'set';
    return $self->{'val'};
}
#package MyData;
sub default {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    my $value = $self->{'parent'};
    my $val = $value->getdefault;
    if ($value->validate($val,@args)) {
	$data->{'val'} = $self->{'val'} = $val;
	$data->{'vstate'} = $self->{'vstate'} = 'default';
    } else {
	warn "value '$val' did not validate";
    }
    $self->{'val'};
}
#package MyData;
sub setdefault {
    my ($self,$val,@args) = @_;
    if ($self->{'vstate'} eq 'unset') {
	my $data = $self->{'data'};
	my $value = $self->{'parent'};
	$val = $value->getdefault unless defined $val;
	if ($value->validate($val,@args)) {
	    $data->{'val'} = $self->{'val'} = $val;
	    $data->{'vstate'} = $self->{'vstate'} = 'default';
	} else {
	    warn "value '$val' did not validate";
	}
    }
    return $self->{'val'};
}
#package MyData;
sub snmpval {
    my ($self,@args) = @_;
    $self->{'parent'}->snmpval($self);
}
#package MyData;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $data = $self->{'data'};
    $self->{'ostate'} = $data->{'ostate'} =
    $self->{'vstate'} = $data->{'vstate'} = 'read';
    $self->{'old'} = $data->{'old'} =
    $self->{'val'} = $data->{'val'} = $self->{'parent'}->valsnmp($val);
}
#package MyData;
sub get {
    my ($self,@args) = @_;
    if ($self->{'vstate'} =~ /^(set|read|default)$/) {
	return $self->{'val'};
    }
    return undef;
}
#package MyData;
sub reset {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    $self->{'vstate'} = $data->{'vstate'} = $self->{'ostate'};
    $self->{'val'} = $data->{'val'} = $self->{'old'};
    $self->{'val'};
}
#package MyData;
sub clear {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    $self->{'old'} = $data->{'old'} =
    $self->{'val'} = $data->{'val'} = undef;
    $self->{'ostate'} = $data->{'ostate'} = 
    $self->{'vstate'} = $data->{'vstate'} = 'unset';
}
#package MyData;
sub unset {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    if ($self->{'vstate'} ne 'unset') {
	$self->{'val'} = $data->{'val'} = undef;
	$self->{'vstate'} = $data->{'vstate'} = 'unset';
    }
}
#package MyData;
sub nosuch {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    if ($self->{'vstate'} ne 'nosuch') {
	$self->{'val'} = $data->{'val'} = undef;
	$self->{'vstate'} = $data->{'vstate'} = 'nosuch';
    }
}
#package MyData;
sub geterr {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    if ($self->{'vstate'} ne 'geterr') {
	$self->{'val'} = $data->{'val'} = undef;
	$self->{'vstate'} = $data->{'vstate'} = 'geterr';
    }
}
#package MyData;
sub seterr {
    my ($self,@args) = @_;
    my $data = $self->{'data'};
    if ($self->{'vstate'} ne 'seterr') {
	$self->{'val'} = $data->{'val'} = undef;
	$self->{'vstate'} = $data->{'vstate'} = 'seterr';
    }
}
#package MyData;
sub validate {
    my ($self,$proposed,@args) = @_;
    return $self->{'parent'}->validate($proposed,@args);
}
#package MyData;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    return $data;
}
#package MyData;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    $self->{'val'} = $data->{'val'};
    my $value = $self->{'parent'};
}
#package MyData;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyData->new($parent,$data->{'tag'},$data->{'val'},@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyData;
sub detail {
    my ($self,$entry,@args) = @_;
    return $self->{'detail'} if defined $self->{'detail'};
    my $string = '';
    $string .= "Item:     $entry\n" if $entry;
    $string .= "Id:       $self->{'tag'}\n";
    $string .= "Object:   $self->{'oid'}\n";
    $string .= "Instance: $self->{'oid'}.$self->{'tag'}\n";
    $string .= "Index:    $self->{'index'}\n";
    $string .= "Value:    $self->{'val'}\n";
    $self->{'detail'} = $string;
    return $string;
}
#package MyData;
sub newvalue {
    my ($self,$top,$mib,$entry,$host) = @_;
    return undef if $self->{'vstate'} !~ /^(set|read|default)$/;
    my $e = $top->addchild($entry,
	-itemtype=>'text',
	-text=>$host->hostname."::$mib->{'label'}.$self->{'index'}",
	-data=>$self,
    );
    my $val = $self->{'val'};
    $val =~ s/\n/, /g;
    $top->itemCreate($e, 1,
	-itemtype=>'text',
	-text=>$val,
    );
    $top->itemCreate($e, 2,
	-itemtype=>'text',
	-text=>$mib->{'units'},
    ) if $mib->{'units'};
    if ($self->{'hidden'} or $mib->{'state'} eq 'c') {
	$top->hide('entry', $e);
    } else {
	#$top->yview($e);
    }
    return $e;
}

# ---------------------------------

# ---------------------------------
package MyValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPersistent);
#package MyValue;
sub new {
    my ($type,$mib,@args) = @_;
    my $self = MyPersistent::new($type,$mib);
    $self->{'mib'} = $mib;
    $self->{'state'} = 'c';
    $self->{'image'} = 'val';
    $self->{'color'} = '';
    my $oid = $self->{'oid'} = $mib->{'objectID'};
    foreach my $session (@{$mib->sessions}) {
	$session->{'vdata'}->{$oid} = {} unless defined $session->{'vdata'}->{$oid};
    }
    if ($mib->{'type'} eq 'OCTETSTR') {
	$self->{'default'} = '';
	bless $self, 'MyOctetString';
    } elsif ($mib->{'type'} eq 'OPAQUE') {
	$self->{'default'} = '';
	bless $self, 'MyOpaque';
    } elsif ($mib->{'type'} eq 'OBJECTID') {
	$self->{'default'} = '0.0';
	bless $self, 'MyObjectId';
    } elsif ($mib->{'type'} eq 'BITS') {
	$self->{'default'} = '';
	bless $self, 'MyBits';
    } elsif ($mib->{'type'} eq 'INTEGER32') {
	if (keys %{$mib->{'enums'}}) {
	    $self->{'default'} = '';
	    bless $self, 'MyEnumerated32';
	} else {
	    $self->{'default'} = 0;
	    bless $self, 'MyInteger32';
	}
    } elsif ($mib->{'type'} eq 'INTEGER') {
	if (keys %{$mib->{'enums'}}) {
	    $self->{'default'} = '';
	    bless $self, 'MyEnumerated';
	} else {
	    $self->{'default'} = 0;
	    bless $self, 'MyInteger';
	}
    } elsif ($mib->{'type'} eq 'COUNTER64') {
	$self->{'default'} = 0;
	bless $self, 'MyCounter64';
    } elsif ($mib->{'type'} eq 'UNSIGNED32') {
	$self->{'default'} = 0;
	bless $self, 'MyUnsigned32';
    } elsif ($mib->{'type'} eq 'COUNTER') {
	$self->{'default'} = 0;
	bless $self, 'MyCounter';
    } elsif ($mib->{'type'} eq 'GAUGE') {
	$self->{'default'} = 0;
	bless $self, 'MyGauge';
    } elsif ($mib->{'type'} eq 'TICKS') {
	$self->{'default'} = 0;
	bless $self, 'MyTicks';
    } elsif ($mib->{'type'} eq 'UINTEGER') {
	$self->{'default'} = 0;
	bless $self, 'MyUinteger';
    } elsif ($mib->{'type'} eq 'IPADDR') {
	$self->{'default'} = '0.0.0.0';
	bless $self, 'MyIpaddr';
    } elsif ($mib->{'type'} eq 'NETADDR') {
	$self->{'default'} = 'inet:0.0.0.0';
	bless $self, 'MyNetaddr';
    } elsif ($mib->{'type'} eq 'NULL') {
	$self->{'default'} = 'NULL';
	bless $self, 'MyNull';
    }
    return $self;
}
sub destroy {
    my ($self,@args) = @_;
    $self->SUPER::destroy(@args);
    delete $self->{'mib'};
}
#package MyValue;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    return $data;
}
#package MyValue;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
}
#package MyValue;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyValue->new($parent,@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyValue;
sub sessions {
    shift->{'mib'}->sessions;
}
#package MyValue;
sub idata {
    my ($self,$session,@args) = @_;
    die "no session" unless $session;
    my $vdata = $session->{'vdata'};
    $vdata->{$self->{'oid'}} = {} unless $vdata->{$self->{'oid'}};
    return $vdata->{$self->{'oid'}};
}
#package MyValue;
sub remove {
    my ($self,$host,@args) = @_;
    my $idata = $host->{'vdata'}->{$self->{'oid'}};
    $host->{'vdata'}->{$self->{'oid'}} = {};
    foreach (map { $idata->{$_}; } keys %{$idata}) {
	$_->destroy;
    }
}
#package MyValue;
sub data {
    my ($self,$tag,$host,@args) = @_;
    warn "no host for tag $tag" unless $host;
    my $idata = $self->idata($host,@args);
    unless (defined $idata->{$tag}) {
	$idata->{$tag} = MyData->new($self,$tag,undef);
    }
    return $idata->{$tag};
}
#package MyValue;
sub tags {
    my ($self,$host,@args) = @_;
    warn "no host" unless $host;
    my $idata = $self->idata($host,@args);
    return [keys %{$idata}];
}
#package MyValue;
sub clear {
    my ($self,$host,@args) = @_;
    warn "no host" unless $host;
    my $idata = $self->idata($host);
    foreach (map {$idata->{$_};} keys %{$idata}) {
	$_->clear;
    }
}
#package MyValue;
sub formatvalues {
    my ($self,@args) = @_;
    my $values = undef;
    foreach my $host (@{$self->sessions}) {
	unless (UNIVERSAL::isa($host,'MySession')) {
	    warn "\$host is not a session, class is ".ref($host);
	    if (ref($host) eq 'HASH') {
		warn "hash contents are: ".%{$host};
	    }
	    next;
	}
	my $idata = $self->idata($host);
	foreach (map {$idata->{$_};} sort { ::cmp_lexical($a,$b); } keys %{$idata}) {
	    next if $_->{'vstate'} !~ /^(set|read|default)$/;
	    $values .= ",\n         " if $values;
	    $values .= $host->hostname."::\t$_->{'index'}:\t$_->{'val'}";
	}
    }
    return $values;
}
#package MyValue;
sub indexformat {
    my ($self,$elements,$l,$last,@args) = @_;
    while ($_ = shift @$elements) {
	$$l .= '.' if defined $$l;
	$$l .= $_;
    }
    return 0;
}
#package MyValue;
sub indexvalue {
    my ($self,$elements,$last,@args) = @_;
    my $val = undef;
    while ($_ = shift @$elements) {
	$val .= '.' if defined $val;
	$val .= $_;
    }
    return $val;
}
#package MyValue;
sub indextag {
    my ($self,$elements,$last,@args) = @_;
    my $len = $self->indextaglen($elements,$last,@args);
    return join('.',splice @$elements, 0, $len);
}
#package MyValue;
sub indextaglen {
    my ($self,$elements,$last,@args) = @_;
    my $shift;
    my $len = 0;
    $shift = $len = shift @$elements if @$elements; # try to detect implicit strings
    if ($len > @$elements || ($last && $len != @$elements)) {
	unshift @$elements, $shift if defined $shift;
	$len = @$elements;
    } else {
	unshift @$elements, $shift if defined $shift;
	$len += 1;
    }
    return $len;
}
#package MyValue;
sub indexlen {
    my ($self,$elements,$last,@args) = @_;
    my $len = 0;
    $len = shift @$elements if scalar @$elements; # try to detect implicit strings
    if ($len > scalar @$elements || ($last && $len != scalar @$elements)) {
	unshift @$elements, $len;
	$len = scalar @$elements;
    }
    return $len;
}
#package MyValue;
sub maxlen {
    my ($self,$w,$font,@args) = @_;
    return 0;
}
#package MyValue;
sub maxrow {
    1;
}
#package MyValue;
sub fmsg {
    shift->{'mib'}->fmsg;
}
#package MyValue;
sub hmsg {
    shift->{'mib'}->hmsg;
}
#package MyValue;
sub tmsg {
    shift->{'mib'}->tmsg;
}
#package MyValue;
sub smsg {
    return 'Make an entry.';
}
#package MyValue;
sub reformat {
    my ($self,$ref,@args) = @_;
    return;
}
#package MyValue;
sub validate {
    my ($self,$value,@args) = @_;
    return $value;
}
#package MyValue;
sub entrystate {
    my ($self,$force,@args) = @_;
    my $state = 'normal';
    unless ($force) {
	if ($self->{'mib'}->{'access'} =~ /NoAccess|Notify/) {
	    $state = 'disabled';
	}
	if ($self->{'mib'}->{'access'} =~ /ReadOnly/) {
	    $state = 'readonly';
	}
    }
    return $state;
}
#package MyValue;
sub menustate {
    my ($self,$force,@args) = @_;
    my $state = 'normal';
    unless ($force) {
	if ($self->{'mib'}->{'access'} =~ /NoAccess|Notify|ReadOnly/) {
	    $state = 'disabled';
	}
    }
    return $state;
}
#package MyValue;
sub entryvalidate {
    my ($self,$force,@args) = @_;
    my $validate = 'focusout';
    unless ($force) {
	if ($self->{'mib'}->{'access'} =~ /NoAccess|Notify|ReadOnly/) {
	    $validate = 'none';
	}
    }
    return $validate;
}
#package MyValue;
sub entrybell {
    my ($self,$force,@args) = @_;
    my $bell = 1;
    unless ($force) {
	if ($self->{'mib'}->{'access'} =~ /NoAccess|Notify|ReadOnly/) {
	    $bell = 0;
	}
    }
    return $bell;
}
#package MyValue;
sub entrybuttons {
    my ($self,$force,@args) = @_;
    my $buttons = 1;
    unless ($force) {
	if ($self->{'mib'}->{'access'} =~ /NoAccess|Notify|ReadOnly/) {
	    $buttons = 0;
	}
    }
    return $buttons;
}
#package MyValue;
sub varbind {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $vb = new SNMP::Varbind([$mib->{'objectID'},$data->tag,$self->snmpval($data),$self->snmptype]);
}
#package MyValue;
sub snmpval {
    my ($self,$data,@args) = @_;
    return $data->{'val'};
}
#package MyValue;
sub valsnmp {
    my ($self,$val,@args) = @_;
    return $val;
}
#package MyValue;
sub getdefault {
    my ($self,@args) = @_;
    my $val = $self->{'mib'}->{'defaultValue'} || $self->{'default'};
    return $self->valsnmp($val);
}
# ---------------------------------

# ---------------------------------
package MyOctetString;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

##package MyOctetString;
sub snmptype {
    return 'OCTETSTR';
}
##package MyOctetString;
sub maxlen {
    my ($self,$w,$font,@args) = @_;
    my $len = 0;
    return $len;
}
#package MyOctetString;
sub stringvalidate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};

    if ($proposed =~ /^'(([0-9a-fA-F][0-9a-fA-F])*)'X$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = length($1)/2;
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'X$/) {
	return 0;
    } elsif ($proposed =~ /^\s*'(([01][01][01][01][01][01][01][01])*)'B\s*$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = length($1)/8;
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'B$/) {
	return 0;
    } elsif ($proposed =~ /^'(\p{IsPrint}*)'$/) {
	my $string = $1;
	$string =~ s/''/./g;
	if ($string =~ /'/) {
	    return 0;
	}
	if (@{$mib->{'ranges'}}) {
	    my $size = length($string);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'$/) {
	return 0;
    } elsif ($proposed =~ /^'/) {
	return 0;
    } elsif ($proposed =~ /^"(\p{IsPrint}*)"$/) {
	my $string = $1;
	$string =~ s/\\\\/./g;
	$string =~ s/\\x[0-9a-fA-F]{1,4}/./g;
	if ($string =~ /\\x/) {
	    return 0;
	}
	$string =~ s/\\0[0-7]{1,6}/./g;
	if ($string =~ /\\0/) {
	    return 0;
	}
	$string =~ s/""/./g;
	$string =~ s/\\"/./g;
	if ($string =~ /"/) {
	    return 0;
	}
	if (@{$mib->{'ranges'}}) {
	    my $size = length($string);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^".*"$/) {
	return 0;
    } elsif ($proposed =~ /^\p{IsPrint}*$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = length($proposed);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } else {
	return 0;
    }
}

#package MyOctetString;
sub octetvalidate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};
    if ($proposed =~ /^'(([0-9a-fA-F][0-9a-fA-F])*)'X$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = length($1)/2;
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'X$/) {
	return 0;
    } elsif ($proposed =~ /^\s*'(([01][01][01][01][01][01][01][01])*)'B\s*$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = length($1)/8;
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'B$/) {
	return 0;
    } elsif ($proposed =~ /^'(.*)'$/) {
	my $string = $1;
	$string =~ s/''/./g;
	if ($string =~ /'/) {
	    return 0;
	}
	if (@{$mib->{'ranges'}}) {
	    my $size = length($string);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'$/) {
	return 0;
    } elsif ($proposed =~ /^'/) {
	return 0;
    } elsif ($proposed =~ /^"(.*)"$/) {
	my $string = $1;
	$string =~ s/\\\\/./g;
	$string =~ s/\\x[0-9a-fA-F]{1,4}/./g;
	if ($string =~ /\\x/) {
	    return 0;
	}
	$string =~ s/\\0[0-7]{1,6}/./g;
	if ($string =~ /\\0/) {
	    return 0;
	}
	$string =~ s/""//g;
	$string =~ s/\\"//g;
	if ($string =~ /"/) {
	    return 0;
	}
	if (@{$mib->{'ranges'}}) {
	    my $size = length($string);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^.*$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = length($proposed);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } else {
	return 0;
    }
}

#package MyOctetString;
sub validate {
    my ($self,$proposed,@args) = @_;
    my $size = 0;
    my $mib = $self->{'mib'};
    my $max = 256; # $entry->isindex ? 128 : 256;
    if (@{$mib->{'ranges'}}) {
	my $rmax = $mib->{'ranges'}[-1]{'high'};
	$max = $rmax < $max ? $rmax : $max;
    }
    if ($proposed eq '') { # null string
	$size = 0;
    } elsif ($proposed =~ /^'([01]*)'B$/) {  # 'bb'B form
	$size = int((length($1)+7)/8);
    } elsif ($proposed =~ /^'([0-9a-fA-F]*)'X$/) {  # 'xx'X form
	$size = int((length($1)+1)/2);
    } elsif ($proposed =~ /^"([0-9a-fA-F]*) "$/) { # "xx " form
	$size = int((length($1)+1)/2);
    } elsif ($proposed =~ /^'(\p{IsPrint}*)'$/) { # 'tt' form
	$size = length($1);
    } elsif ($proposed =~ /^"(\p{IsPrint}*)"?$/) { # "tt" form
	$size = length($1);
    } else {
	my $hint;
	if (!($hint = $mib->{'hint'}) || $hint =~ /^\d*[at]$/) {
	    if ($proposed =~ /^(\p{IsPrint}*)$/) { # tt form
		$size = length($1);
	    } else {
		warn "validation of `$proposed' failed";
		return 0;
	    }
	} else {
	    my @octetspecs;
	    while ($hint =~ s/^(\*?)([0-9]{1,})([xdoat])([^0-9*]?)([^0-9*]?)//) {
		push @octetspecs, { 'repeat'=>$1, 'length'=>$2, 'format'=>$3, 'sepchr'=>"\Q$4\E", 'trmchr'=>"\Q$5\E" };
	    }
	    my $string = $proposed;
	    my $ospec = '';
	    for (my $n=0;$n<@octetspecs;$n++) {
		my $o = $octetspecs[$n];
		#printf STDERR "ospec is ".join(', ',map { "$_=>'$o->{$_}'"; } keys %{$o})."\n";
		if ($o->{'format'} eq 'd') {
		    if ($o->{'length'} == 1) {
			$ospec = '-?0*[0-9]{1,3}';
		    } elsif ($o->{'length'} == 2) {
			$ospec = '-?0*[0-9]{1,5}';
		    } elsif ($o->{'length'} == 3) {
			$ospec = '-?0*[0-9]{1,8}';
		    } elsif ($o->{'length'} == 4) {
			$ospec = '-?0*[0-9]{1,10}';
		    } else {
			$ospec = '-?0*[0-9]{1,}';
		    }
		} elsif ($o->{'format'} eq 'o') {
		    $ospec = '-?0*[0-7]{1,'.(int((($o->{'length'}*8)+2)/3)).'}';
		} elsif ($o->{'format'} eq 'x') {
		    $ospec = '-?0*[0-9a-fA-F]{1,'.($o->{'length'}*2).'}';
		} elsif ($o->{'format'} eq 'a') {
		    $ospec = '\p{IsPrint}{1,'.$o->{'length'}.'}';
		} elsif ($o->{'format'} eq 't') {
		    $ospec = '\p{IsPrint}{1,'.$o->{'length'}.'}';
		}
		if ($o->{'repeat'}) {
		    if ($o->{'trmchr'}) {
			$ospec = '(('.$ospec.'('.$o->{'sepchr'}.'('.$ospec.')){0,254})?('.$o->{'trmchr'}.'|$))';
			#printf STDERR "applying octet spec `$ospec' to `$string'\n";
			last unless $string =~ s/^$ospec//;
			#printf STDERR "succeeded\n";
			$size += ($o->{'length'} * scalar(split(/$o->{'sepchr'}/,$&)));
		    } elsif ($o->{'sepchr'}) {
			$ospec = '(('.$ospec.'('.$o->{'sepchr'}.'('.$ospec.')){0,254})?('.$o->{'sepchr'}.'|$))';
			#printf STDERR "applying octet spec `$ospec' to `$string'\n";
			last unless $string =~ s/^$ospec//;
			#printf STDERR "succeeded\n";
			$size += ($o->{'length'} * scalar(split(/$o->{'sepchr'}/,$&)));
		    } else {
			$ospec = '(('.$ospec.'){0,255})';
			#printf STDERR "applying octet spec `$ospec' to `$string'\n";
			last unless $string =~ s/^$ospec//;
			#printf STDERR "succeeded\n";
			$size += ($o->{'length'} * (scalar(split(/$ospec/,$&) - 1)));
		    }
		} else {
		    if ($o->{'sepchr'}) {
			$ospec = '('.$ospec.'('.$o->{'sepchr'}.'|$))';
		    } else {
			$ospec = '('.$ospec.')';
		    }
		    #printf STDERR "applying octet spec `$ospec' to `$string'\n";
		    last unless $string =~ s/^$ospec//;
		    #printf STDERR "succeeded\n";
		    $size += $o->{'length'};
		}
		last unless length($string);
		#printf STDERR "string is now `$string'\n";
		last if $size > $max;
		$n-- if $n == $#octetspecs;
	    }
	    if (length($string) || $size > $max) {
		warn "string was `$string'";
		warn "octet spec was `$ospec'";
		warn "validation of `$proposed' failed";
		return 0;
	    }
	}
    }
    if (@{$mib->{'ranges'}}) {
	my $ok = 0;
	foreach (@{$mib->{'ranges'}}) {
	    if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		$ok = 1;
		last;
	    }
	}
	return 1 if $ok;
    } else {
	return 1 if $size <= $max;
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyOctetString;
sub smsg {
    shift->{'smsg'};
}

#package MyOctetString;
sub validateall {
    my ($self,$proposed,@args) = @_;
    my $mib = $self->{'mib'};
    my $max = 256; # $entry->isindex ? 128 : 256;
    if (@{$mib->{'ranges'}}) {
	my $rmax = $mib->{'ranges'}[-1]{'high'};
	$max = $rmax < $max ? $rmax : $max;
    }
    if ($proposed eq '') { # null string
	return 1;
    } elsif ($proposed =~ /^'([01]*)('B?)?$/) {  # 'bb'B form
	my $string = $1; $max *= 8;
	return 1 if $string =~ /^.{0,$max}$/;
    } elsif ($proposed =~ /^'([0-9a-fA-F]*)('X?)?$/) {  # 'xx'X form
	my $string = $1; $max *= 2;
	return 1 if $string =~ /^.{0,$max}$/;
    } elsif ($proposed =~ /^"([0-9a-fA-F]*)( "?)?$/) { # "xx " form
	my $string = $1; $max *= 2;
	return 1 if $string =~ /^.{0,$max}$/;
    } elsif ($proposed =~ /^'(\p{IsPrint}*)'?$/) { # 'tt' form
	my $string = $1;
	return 1 if $string =~ /^.{0,$max}$/;
    } elsif ($proposed =~ /^"(\p{IsPrint}*)"?$/) { # "tt" form
	my $string = $1;
	return 1 if $string =~ /^.{0,$max}$/;
    }
    my $hint;
    if (!($hint = $mib->{'hint'}) || $hint =~ /^\d*[at]$/) {
	if ($proposed =~ /^(\p{IsPrint}*)$/) { # tt form
	    my $string = $1;
	    return 1 if $string =~ /^.{0,$max}$/;
	}
    } else {
	my @octetspecs;
	while ($hint =~ s/^(\*?)([0-9]{1,})([xdoat])([^0-9*]?)([^0-9*]?)//) {
	    push @octetspecs, { 'repeat'=>$1, 'length'=>$2, 'format'=>$3, 'sepchr'=>"\Q$4\E", 'trmchr'=>"\Q$5\E" };
	}
	my $size = 0;
	my $string = $proposed;
	my $ospec = '';
	for (my $n=0;$n<@octetspecs;$n++) {
	    my $o = $octetspecs[$n];
	    #printf STDERR "ospec is ".join(', ',map { "$_=>'$o->{$_}'"; } keys %{$o})."\n";
	    if ($o->{'format'} eq 'd') {
		if ($o->{'length'} == 1) {
		    $ospec = '-?0*[0-9]{1,3}';
		} elsif ($o->{'length'} == 2) {
		    $ospec = '-?0*[0-9]{1,5}';
		} elsif ($o->{'length'} == 3) {
		    $ospec = '-?0*[0-9]{1,8}';
		} elsif ($o->{'length'} == 4) {
		    $ospec = '-?0*[0-9]{1,10}';
		} else {
		    $ospec = '-?0*[0-9]{1,}';
		}
	    } elsif ($o->{'format'} eq 'o') {
		$ospec = '-?0*[0-7]{1,'.(int((($o->{'length'}*8)+2)/3)).'}';
	    } elsif ($o->{'format'} eq 'x') {
		$ospec = '-?0*[0-9a-fA-F]{1,'.($o->{'length'}*2).'}';
	    } elsif ($o->{'format'} eq 'a') {
		$ospec = '\p{IsPrint}{1,'.$o->{'length'}.'}';
	    } elsif ($o->{'format'} eq 't') {
		$ospec = '\p{IsPrint}{1,'.$o->{'length'}.'}';
	    }
	    if ($o->{'repeat'}) {
		if ($o->{'trmchr'}) {
		    $ospec = '(('.$ospec.'('.$o->{'sepchr'}.'('.$ospec.')){0,254})?('.$o->{'trmchr'}.'|$))';
		    #printf STDERR "applying octet spec `$ospec' to `$string'\n";
		    last unless $string =~ s/^$ospec//;
		    #printf STDERR "succeeded\n";
		    $size += ($o->{'length'} * scalar(split(/$o->{'sepchr'}/,$&)));
		} elsif ($o->{'sepchr'}) {
		    $ospec = '(('.$ospec.'('.$o->{'sepchr'}.'('.$ospec.')){0,254})?('.$o->{'sepchr'}.'|$))';
		    #printf STDERR "applying octet spec `$ospec' to `$string'\n";
		    last unless $string =~ s/^$ospec//;
		    #printf STDERR "succeeded\n";
		    $size += ($o->{'length'} * scalar(split(/$o->{'sepchr'}/,$&)));
		} else {
		    $ospec = '(('.$ospec.'){0,255})';
		    #printf STDERR "applying octet spec `$ospec' to `$string'\n";
		    last unless $string =~ s/^$ospec//;
		    #printf STDERR "succeeded\n";
		    $size += ($o->{'length'} * (scalar(split(/$ospec/,$&) - 1)));
		}
	    } else {
		if ($o->{'sepchr'}) {
		    $ospec = '('.$ospec.'('.$o->{'sepchr'}.'|$))';
		} else {
		    $ospec = '('.$ospec.')';
		}
		#printf STDERR "applying octet spec `$ospec' to `$string'\n";
		last unless $string =~ s/^$ospec//;
		#printf STDERR "succeeded\n";
		$size += $o->{'length'};
	    }
	    last unless length($string);
	    #printf STDERR "string is now `$string'\n";
	    last if $size > $max;
	    $n-- if $n == $#octetspecs;
	}
	if ($size <= $max) {
	    return 1 unless length($string);
	}
	warn "string was `$string'";
	warn "octet spec was `$ospec'";
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyOctetString;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $init = $entry->{'ent'};
    my $e = $parent->Entry(
	-takefocus=>1,
	-exportselection=>1,
	-justify=>'left',
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyOctetString::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter a string.';
    return $e;
}

#package MyOctetString;
sub indexformat {
    my ($self,$elements,$l,$last,@args) = @_;
    my $mib = $self->{'mib'};
    my $len = 0;
    $len = shift @$elements if scalar @$elements; # try to detect implicit strings
    if ($len > scalar @$elements || ($last && $len != scalar @$elements)) {
	unshift @$elements, $len;
	$len = scalar @$elements;
    }
    $$l .= '.' if (defined $$l);
    if (defined $mib->{'textualConvention'} && $mib->{'textualConvention'} =~ /^(SnmpAdminString|SimpleNameType|CommonLanguageName|StreamsModuleName)$/) {
	$$l .= '"';
	$$l .= pack("C*", splice(@$elements,0,$len));
	$$l .= '"';
    } else {
	my $isstring = 1;
	for (my $i = 0; $i < $len; $i++) {
	    $isstring = 0 if ($elements->[$i] < 32 || $elements->[$i] > 126);
	}
	$$l .= '"';
	if ($isstring) {
	    for (my $i = 0; $i < $len; $i++) {
		$$l .= chr(shift @$elements);
	    }
	} else {
	    for (my $i = 0; $i < $len; $i++) {
		$$l .= sprintf('%02X ', shift @$elements);
	    }
	}
	$$l .= '"';
    }
    return 1;
}
#package MyOctetString;
sub indexvalue {
    my ($self,$elements,$last,@args) = @_;
    my $len = $self->indexlen($elements,$last,@args);
    my $val = pack('C*', splice(@$elements,0,$len));
    $val = $self->valsnmp($val);
    return $val;
}

#package MyOctetString;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    $ret = [ unpack('C*',$ret) ];
    my $len = @$ret;
    $ret = join('.',($len,@$ret));
    return $ret;
}

#package MyOctetString;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    my $string = $val;
    my $result;
    if (my $hint = $mib->{'hint'}) {
	if ($hint =~ /^\d*[at]$/) {
	    return $val;
	}
	my @octetspecs;
	while ($hint =~ s/^(\*?)([0-9]{1,})([xdoat])([^0-9*]?)([^0-9*]?)//) {
	    push @octetspecs, { repeat=>$1, length=>$2, format=>$3, sepchr=>$4, trmchr=>$5 };
	}
	foreach my $ospec (@octetspecs) {
	    my $maxlen;
	    my $digits;
	    my $convert;
	    if ($ospec->{'format'} eq 'x') {
		$maxlen = $ospec->{'length'}*2;
		$maxlen = "{0,$maxlen}?";
		$digits = '-?[0-9a-fA-F]'.$maxlen;
		$convert = sub {
		    my $val = shift;
		    $val = '0'.$val;
		    my $len = int(length($val)/2)*2;
		    $val = substr($val,-$len,$len);
		    pack('x*',$val);
		};
	    } elsif ($ospec->{'format'} eq 'd') {
		if ($ospec->{'length'} == 1) {
		    $maxlen = '{0,3}?';
		    $convert = sub {
			my $val = shift;
			pack('C1',$val);
		    };
		} elsif ($ospec->{'length'} == 2) {
		    $maxlen = '{0,5}?';
		    $convert = sub {
			my $val = shift;
			pack('C2',$val,$val>>8);
		    };
		} elsif ($ospec->{'length'} == 3) {
		    $maxlen = '{0,8}?';
		    $convert = sub {
			my $val = shift;
			pack('C3',$val,$val>>8,$val>>16);
		    };
		} elsif ($ospec->{'length'} == 4) {
		    $maxlen = '{0,10}?';
		    $convert = sub {
			my $val = shift;
			pack('C4',$val,$val>>8,$val>>16,$val>>24);
		    };
		} else {
		    $maxlen = '{0,}?';
		    $convert = sub {
			my $val = shift;
			pack('C4',$val,$val>>8,$val>>16,$val>>24);
		    };
		}
		$digits = '-?[0-9]'.$maxlen;
	    } elsif ($ospec->{'format'} eq 'o') {
		$maxlen = (($ospec->{'length'}*8) + 2)/3;
		$maxlen = "{0,$maxlen}?";
		$digits = '-?[0-7]'.$maxlen;
		$convert = sub {
		    my $val = shift;
		    my @vals = ('000','001','010','011','100','101','110','111');
		    my $ret = '';
		    while ($val =~ s/^.//) {
			$ret .= $vals[$&];
		    }
		    $ret = '0000000'.$ret;
		    my $len = int(length($ret)/8)*8;
		    $ret = substr($ret,-$len,$len);
		    pack('b*',$ret);
		};
	    } elsif ($ospec->{'format'} eq 'a') {
		$maxlen = $ospec->{'length'};
		$maxlen = "{0,$maxlen}?";
		$digits = '\p{IsPrint}'.$maxlen;
		$convert = sub {
		    pack('C*',$_);
		};
	    } elsif ($ospec->{'format'} eq 't') {
		$maxlen = $ospec->{'length'};
		$maxlen = "{0,$maxlen}?";
		$digits = '\p{IsPrint}'.$maxlen;
		$convert = sub {
		    pack('C*',$_);
		};
	    }
	    if ($ospec->{'repeat'}) {
		my $r = 0;
		my $pattern;
		if ($ospec->{'trmchr'}) {
		    for (my $repeat = 255; $repeat > 0; $repeat--) {
			if ($string !~ s/^($digits)($ospec->{'sepchr'}|$ospec->{'trmchr'}|$)//) {
			    last;
			}
			$pattern .= $convert->($1);
			$r++;
			last unless $string;
		    }
		} elsif ($ospec->{'sepchr'}) {
		    for (my $repeat = 255; $repeat > 0; $repeat--) {
			if ($string !~ s/^($digits)($ospec->{'sepchr'}|$)//) {
			    last;
			}
			$pattern .= $convert->($1);
			$r++;
			last unless $string;
		    }
		} else {
		    for (my $repeat = 255; $repeat > 0; $repeat--) {
			if ($string !~ s/^($digits)//) {
			    last;
			}
			$pattern .= $convert->($1);
			$r++;
			last unless $string;
		    }
		}
		$pattern = pack('a1',$r).$pattern;
		$result .= $pattern;
		last unless $string;
	    } else {
		if ($ospec->{'sepchr'}) {
		    if ($string !~ s/^($digits)($ospec->{'sepchr'}|$)//) {
			last;
		    }
		    $result .= $convert->($1);
		} else {
		    if ($string !~ s/^($digits)//) {
			last;
		    }
		    $result .= $convert->($1);
		}
		last unless $string;
	    }
	}
    }
    return $result unless $string;
    if ($val =~ /^'[0-9a-fA-F]*'X$/) {
	$ret =~ s/^'//;
	$ret =~ s/'X$//;
	$ret = pack('H*',$ret);
    } elsif ($val =~ /^'[01]*'B$/) {
	$ret =~ s/^'//;
	$ret =~ s/'B$//;
	$ret = pack('B*',$ret);
    } elsif ($val =~ /^'\p{IsPrint}*'$/) {
	$ret =~ s/^'//;
	$ret =~ s/'$//;
    } elsif ($val =~ /^"([0-9a-fA-F][0-9a-fA-F] )*"$/) {
	$ret =~ s/^"//;
	$ret =~ s/ "$//;
	$ret =~ s/ //g;
	$ret = pack('H*',$ret);
    } elsif ($val =~ /^"\p{IsPrint}*"$/) {
	$ret =~ s/^"//;
	$ret =~ s/"$//;
    } elsif ($val =~ /^\p{IsPrint}*$/) {
    } else {
	warn "value format not recognized";
    }
    return $ret;
}

#package MyOctetString;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	my $mib = $self->{'mib'};
	if ($val =~ /^\s*'[0-9a-fA-F]*'X\s*$/) {
	    $val =~ s/^\s*'//;
	    $val =~ s/'X\s*$//;
	    $val = pack('H*',$val);
	    $ret = uc "'".unpack('H*',$val)."'X";
	} elsif ($val =~ /^\s*'[0-1]*'B\s*$/) {
	    $val =~ s/^\s*'//;
	    $val =~ s/'B\s*$//;
	    $val = pack('B*',$val);
	    $ret = uc "'".unpack('H*',$val)."'X";
	} elsif ($val =~ /^\s*'\p{IsPrint}*'\s*$/) {
	    $val =~ s/^\s*'//;
	    $val =~ s/'\s*$//;
	    $ret = $val;
	} elsif ($val =~ /^\s*"\p{IsPrint}*"\s*$/) {
	    $val =~ s/^\s*"//;
	    $val =~ s/"\s*$//;
	    $ret = $val;
	} elsif ($val =~ /^\p{IsPrint}*$/) {
	    $ret = $val;
	} else {
	    $ret = uc "'".unpack('H*',$val)."'X";
	}
	if ($mib->{'hint'}) {
	    my $hint = $mib->{'hint'};
	    my @charspecs;
	    while ($hint =~ s/^([*])?([0-9][0-9]*)([xdoat])([^0-9*])?([^0-9*])?//) {
		push @charspecs, { repeat=>$1, length=>$2, format=>$3, sepchr=>$4, trmchr=>$5 };
	    }
	    my @octets = ( unpack('C*', $val) );
	    my $str = undef;
	    while (scalar @octets > 0) {
		my ($r,$cspec);
		if (scalar @charspecs > 1) { $cspec = shift @charspecs; } else { $cspec = $charspecs[0]; }
		if ($cspec->{'repeat'}) { $r = shift @octets; } else { $r = 1; }
		for (;$r > 0 && scalar @octets > 0; $r--) {
		    if ($cspec->{'format'} =~ /[xdo]/) {
			my $v = 0;
			for (my $i = 0; $i < $cspec->{'length'} && scalar @octets > 0; $i++) {
			    $v <<= 8;
			    $v += shift @octets;
			}
			if ($cspec->{'format'} eq 'x') {
			    $str .= sprintf('%02X', $v);
			} elsif ($cspec->{'format'} eq 'o') {
			    $str .= sprintf('%03o', $v);
			} else {
			    $str .= sprintf('%d', $v);
			}
		    } else {
			for (my $i = 0; $i < $cspec->{'length'} && scalar @octets > 0; $i++) {
			    my $c = shift @octets;
			    if ($c < 32 || $c > 126) {
				$c = '?';
			    } else {
				$c = chr($c);
			    }
			    $str .= $c;
			}
		    }
		    if ($cspec->{'sepchr'} && scalar @octets > 0) {
			$str .= $cspec->{'sepchr'};
		    }
		}
		if ($cspec->{'repeat'} && $cspec->{'trmchr'} && scalar @octets > 0) {
		    substr($str,-1,1,$cspec->{'trmchr'});
		}
	    }
	    $ret = $str;
	}
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyOpaque;
use strict;
use vars qw(@ISA);
@ISA = qw(MyOctetString);

sub snmptype {
    return 'OPAQUE';
}
#package MyOpaque;
sub smsg {
    shift->{'smsg'};
}

#package MyOpaque;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $init = $entry->{'ent'};
    my $e = $parent->Entry(
	-takefocus=>1,
	-exportselection=>1,
	-justify=>'left',
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyOctetString::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $self->{'smsg'}='Enter an opaque octet string.';
    $entry->{'ent'} = $init;
    $e->validate;
    return $e;
}

# ---------------------------------

# ---------------------------------
package MyObjectId;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'OBJECTID';
}
#package MyObjectId;
sub validate {
    my ($value,$proposed,@args) = @_;

    return 1 if defined SNMP::translateObj($proposed);
    $proposed =~ s/^\.//; # leading dot is always optional and accepted
    return 1 if defined SNMP::translateObj($proposed);
    if ($proposed =~ /^[0-9][0-9]*(\.[0-9][0-9]*)*$/) {
	return 1;
    } elsif ($proposed =~ /^([0-9][0-9]*|[a-z][a-zA-Z0-9-]*)(\.([0-9][0-9]*|[a-z][a-zA-Z0-9-]*))*$/) {
	return 1 if defined SNMP::translateObj($proposed);
    } elsif ($proposed =~ /^([0-9][0-9]*|[a-z][a-zA-Z0-9-]*(\([0-9][0-9]*\))?)(\.([0-9][0-9]*|[a-z][a-zA-Z0-9-]*(\([0-9][0-9]*\))?))*$/) {
	return 1 if defined SNMP::translateObj($proposed);
	my @components = split(/\./,$proposed);
	for (my $i = 0; $i < scalar @components; $i++) {
	    $components[$i] =~ s/^[a-z].*\(//;
	    $components[$i] =~ s/\)//;
	}
	$proposed = join('.', @components);
	return 1 if defined SNMP::translateObj($proposed);
    } else {
	return 1 if defined SNMP::translateObj($proposed);
    }
    return 0;
}

#package MyObjectId;
sub smsg {
    shift->{'smsg'};
}

#package MyObjectId;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if defined SNMP::translateObj($proposed);
    return 1 if $proposed =~ /^(\.?([0-9][0-9]*|[a-z][a-zA-Z0-9-]*(\([0-9][0-9]*\))?)(\.([0-9][0-9]*|[a-z][a-zA-Z0-9-]*(\([0-9][0-9]*\))?))*\.?)?$/;
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyObjectId;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $init = $entry->{'ent'};
    my $e = $parent->Entry(
	-takefocus=>1,
	-exportselection=>1,
	-justify=>'left',
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyObjectId::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter (or drag) an object id.';
    $e->DropSite(
	-droptypes=>[qw/XDND Sun Local/],
	-dropcommand=>[\&MyObjectId::dropcommand,$self,$parent,$entry],
    );
    return $e;
}

#package MyObjectId;
sub dropcommand {
    my ($self,$parent,$entry,$seln,$action,$targets,$xo,$yo,@args) = @_;
    my $tl = $parent->toplevel;
    my $oid = undef;
    if ($::dragobj || $action eq 'LocalDrop') {
	if (UNIVERSAL::isa($::dragobj, 'MyObject')) {
	    $oid = $::dragobj->{'objectID'};
	} elsif (UNIVERSAL::isa($::dragobj, 'MyData')) {
	    $oid = "$::dragobj->{'oid'}.$::dragobj->{'tag'}";
	} elsif (UNIVERSAL::isa($::dragobj, 'MyEntry')) {
	    $oid = $::dragobj->id;
	    $oid = ~s/^.*://;
	} elsif (UNIVERSAL::isa($::dragobj, 'MyEntry')) {
	    $oid = $::dragobj->oid.".".$::dragobj->id;
	}
    } else {
	if ($oid = $tl->SelectionGet(-selection=>$seln)) {
	    chomp $oid;
	    $oid =~ s/(\s|\n)*$//;
	} else {
	    warn "MyObjectId::dropcommand: no oid";
	}
    }
    if (defined $oid && $self->validate($oid)) {
	if (my $w = $entry->{'haswindow'}) {
	    $w->delete(0,'end');
	    $w->insert('end',$self->valsnmp($oid));
	}
	return;
    }
    $tl->bell;
}

#package MyObjectId;
sub indexformat {
    my ($self,$elements,$l,$last,@args) = @_;
    my $len = 0;
    $len = shift @$elements if scalar @$elements;
    if ($len > scalar @$elements || ($last && $len != scalar @$elements)) {
	unshift(@$elements, $len);
	$len = scalar @$elements;
    }
    my $o = undef;
    for (my $i = 0; $i < $len; $i++) {
	$o .= '.' if (defined $o);
	$o .= shift @$elements;
    }
    $$l .= '.' if (defined $$l);
    $$l .= SNMP::translateObj($o);
    return 1;
}
#package MyObjectId;
sub indexvalue {
    my ($self,$elements,$last,@args) = @_;
    my $len = $self->indexlen($elements,$last,@args);
    return $self->valsnmp(join('.',splice @$elements, 0, $len));
}

#package MyObjectId;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $val = $data->{'val'};
    my $ret = $val;
    if ($ret =~ /^\s*{\s+.*}\s*$/) {
	$ret =~ s/^\s*{\s*//;
	$ret =~ s/\s*}\s*$//;
	$ret =~ s/\s*:\s*/:/g;
	$ret =~ s/\s+/./g;
    }
    unless ($ret =~ /^\.?[0-9][0-9]*(\.[0-9][0-9]*)*$/) {
	if (my $newval = SNMP::translateObj($ret)) {
	    $ret = $newval;
	}
    }
    $ret =~ s/^\.//;
    $ret = [ split(/\./,$ret) ];
    my $len = @$ret;
    $ret = join('.',($len,@$ret));
    return $ret;

}

#package MyObjectId;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $val = $data->{'val'};
    my $ret = $val;
    if ($ret =~ /^\s*{\s+.*}\s*$/) {
	$ret =~ s/^\s*{\s*//;
	$ret =~ s/\s*}\s*$//;
	$ret =~ s/\s*:\s*/:/g;
	$ret =~ s/\s+/./g;
    }
    unless ($ret =~ /^\.?[0-9][0-9]*(\.[0-9][0-9]*)*$/) {
	if (my $newval = SNMP::translateObj($ret)) {
	    $ret = $newval;
	}
    }
    return $ret;
}

#package MyObjectId;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	my $mib = $self->{'mib'};
	$ret = $val;
	if ($ret =~ /^\s*{\s+.*}\s*$/) {
	    $ret =~ s/^\s*{\s*//;
	    $ret =~ s/\s*}\s*$//;
	    $ret =~ s/\s*:\s*/:/g;
	    $ret =~ s/\s+/./g;
	}
	unless ($ret =~ /^\.?[0-9][0-9]*(\.[0-9][0-9]*)*$/) {
	    if (my $newval = SNMP::translateObj($ret)) {
		$ret = $newval;
	    }
	}
	if ($ret =~ /^\.?[0-9][0-9]*(\.[0-9][0-9]*)*$/) {
	    if (my $newval = SNMP::translateObj($ret,0,1)) {
		$ret = $newval;
	    }
	}
	if ($ret =~ /^$mib->{'moduleID'}:/) {
	    $ret =~ s/^.*://;
	}
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyBits;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);
sub snmptype {
    return 'BITS';
}
#package MyBits;
sub maxlen {
    my ($self,$w,$font,@args) = @_;
    my $len = 0;
    my $mib = $self->{'mib'};
    if ($mib->{'enums'}) {
	foreach my $l (keys %{$mib->{'enums'}}) {
	    my $ll = $w->fontMeasure($font,$l);
	    $len = $ll if $ll > $len;
	}
    }
    return $len;
}
#package MyBits;
sub maxrow {
    my $self = shift;
    my $mib = $self->{'mib'};
    my $rows = 1;
    if ($mib->{'enums'}) {
	$rows = scalar keys %{$mib->{'enums'}};
    }
    return $rows + 1;
}
#package MyBits;
sub reformat {
    my ($self,$ref,@args) = @_;
    $$ref =~ s/(\s*,\s*|\s+)/\n/sg;
}
#package MyBits;
sub validate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};

    if ($proposed eq '') {
	return 1;
    } elsif ($proposed =~ /^'(([0-9a-fA-F][0-9a-fA-F])*)'X$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = int((length($1)+1)/2);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'X$/) {
	return 0;
    } elsif ($proposed =~ /^\s*'(([01][01][01][01][01][01][01][01])*)'B\s*$/) {
	if (@{$mib->{'ranges'}}) {
	    my $size = int((length($1)+7)/8);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif ($proposed =~ /^'.*'B$/) {
	return 0;
    } elsif ($proposed =~ /^'/) {
	return 0;
    } elsif ($proposed =~ /^"(.*)"$/) {
	my $string = $1;
	$string =~ s/\\\\/./g;
	$string =~ s/\\x[0-9a-fA-F]{1,4}/./g;
	if ($string =~ /\\x/) {
	    return 0;
	}
	$string =~ s/\\0[0-7]{1,6}/./g;
	if ($string =~ /\\0/) {
	    return 0;
	}
	$string =~ s/""//g;
	$string =~ s/\\"//g;
	if ($string =~ /"/) {
	    return 0;
	}
	if (@{$mib->{'ranges'}}) {
	    my $size = length($string);
	    my $ok = 0;
	    foreach (@{$mib->{'ranges'}}) {
		if ($size >= $_->{'low'} && $size <= $_->{'high'}) {
		    $ok = 1;
		    last;
		}
	    }
	    return 0 if !$ok;
	}
	return 1;
    } elsif (%{$mib->{'enums'}}) {
	my @elements = split("\n",$proposed);
	foreach (@elements) {
	    unless (exists $mib->{'enums'}{$_}) {
		return 0;
	    }
	}
	return 1;
    } else {
	return 0;
    }
}
#package MyBits;
sub indexformat {
    my ($self,$elements,$l,$last,@args) = @_;
    my $len = 0;
    $len = shift @$elements if scalar @$elements;
    if ($len > scalar @$elements || ($last && $len != scalar @$elements)) {
	unshift @$elements, $len;
	$len = scalar @$elements;
    }
    $$l .= '.' if (defined $$l);
    $$l .= '"';
    for (my $i = 0; $i < $len; $i++) {
	$$l .= chr(shift @$elements);
    }
    $$l .= '"';
    return 1;
}
#package MyBits;
sub indexvalue {
    my ($self,$elements,$l,$last,@args) = @_;
    my $len = $self->indexlen($elements,$last,@args);
    my $val = pack('C*',splice @$elements, 0, $len);
    $val = '"'.unpack('H*',$val).' "';
    return $self->valsnmp($val);
}
#package MyBits;
sub smsg {
    shift->{'smsg'};
}
#package MyBits;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if $proposed =~ /^'[01]*('B?)?$/;  # 'bb'B form
    return 1 if $proposed =~ /^'[0-9a-fA-F]*('X?)?$/;  # 'xx'X form
    return 1 if $proposed =~ /^"([0-9a-fA-F][0-9a-fA-F] )*[0-9a-fA-F]?[0-9a-fA-F]? ?"$/; # "xx " form
    my $mib = $self->{'mib'};
    if ($mib->{'enums'} && %{$mib->{'enums'}}) {
	if ($proposed =~ s/^{\s*//) {
	    $proposed =~ s/\s*}$//;
	}
	$proposed =~ s/[,\n\t]/ /g;
	$proposed =~ s/^\s+//;
	$proposed =~ s/\s+$//;
	my @elements = split(/\s+/,$proposed);
	return 1 unless @elements;
	my @keys = sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys %{$mib->{enums}};
	my @nums = map {$mib->{'enums'}{$_}} @keys;
	my $ok = 0;
	foreach my $element (@elements) {
	    $ok = 0;
	    if ($element =~ /^\d+$/) {
		$element =~ s/^0+//; # leading zeros optional
		unless ($ok) {
		    foreach (@nums) {
			if ($_ == $element) {
			    $ok = 1;
			    last;
			}
		    }
		}
		unless ($ok) {
		    foreach (@nums) {
			if (index($_,$element) == 0) {
			    $ok = 1;
			    last;
			}
		    }
		}
	    }
	    unless ($ok) {
		foreach (@keys) {
		    if (index($_,$element) == 0) {
			$ok =1;
			last;
		    }
		}
	    }
	    last unless $ok;
	}
	return 1 if $ok;
    }
    warn "validation of `$proposed' failed";
    return 0;
}
#package MyBits;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $mib = $self->{'mib'};
    my $e;
    my $init = $entry->{'ent'};
    if (%{$mib->{'enums'}}) {
	my $opts = [];
	foreach (sort { $mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}; } keys %{$mib->{'enums'}}) {
	    push @$opts, $_;
	}
	$entry->{'lst'} = [ split(/\n/,$entry->{'ent'}) ];
	$e = $parent->Listbox(
	    -font=>$parent->cget('-font'),
	    -takefocus=>1,
	    -exportselection=>1,
	    -height=>scalar @$opts, #-width=>0,
	    -selectmode=>'extended',
	    -listvariable=>$opts,
	    -state=>$self->entrystate($force,@args),
	);
	$e->OnDestroy([sub{
		my ($e,$self,$opts,$entry) = @_;
		if ($entry->{'commit'}) {
		    $entry->{'ent'} = join("\n",map {$opts->[$_]} $e->curselection);
		}
	    },$e,$self,$opts,$entry],
	);
	$e->bind(ref($e),'<Escape>',undef);
	my %vals = ();
	$e->focus;
	foreach (@{$entry->{'lst'}}) {
	    $vals{$_} = 1;
	}
	$e->selectionClear(0,'end');
	foreach (my $i=0;$i<@$opts;$i++) {
	    if ($vals{$opts->[$i]}) {
		$e->selectionSet($i);
	    }
	}
	$self->{'smsg'}='Select bits from the list.';
    } else {
	$e = $parent->Entry(
	    -takefocus=>1,
	    -exportselection=>1,
	    -justify=>'left',
	    -textvariable=>\$entry->{'ent'},
	    -state=>$self->entrystate($force,@args),
	);
	$e->configure(
	    -validate=>'all',
	    -validatecommand=>[\&MyBits::validateall,$self],
	    -invalidcommand=>[sub{shift->toplevel->bell;},$e],
	);
	$entry->{'ent'} = $init;
	$e->validate;
	$self->{'smsg'}='Enter a bit string.';
    }
    return $e;
}
#package MyBits;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    if ($ret =~ /^'([0-1]*)'B/) {
    } elsif ($ret =~ /^'([0-9a-fA-F]*)'X/) {
	$ret = pack('B*',$1);
    } elsif ($ret =~ /^"([0-9a-fA-F]*) "/) {
	$ret = pack('X*',$1);
    } elsif ($ret =~ /^(\d+)$/) {
	$ret = pack('N',$1);
    }
    $ret = [ unpack('C*',$ret) ];
    my $len = @$ret;
    $ret = join('.',($len,@$ret));
    return $ret;
}
#package MyBits;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    if ($ret =~ /^((\w+\b)(\n?\w+\b)*)?$/) {
	printf STDERR "found line feed array\n";
	my @elements = split(/\n/,$ret);
	my @bvalues = ();
	foreach (map { $mib->{'enums'}{$_}; } keys %{$mib->{'enums'}}) {
	    $bvalues[$_] = 0;
	}
	foreach (@elements) {
	    if (defined $mib->{'enums'}{$_}) {
		$bvalues[$mib->{'enums'}{$_}] = 1;
	    } elsif (/^\d+$/) {
		$bvalues[$_] = 1;
	    }
	}
	my $bits = '';
	for (my $i=0;$i<@bvalues;$i++) {
	    $bits .= $bvalues[$i] ? '1' : '0';
	}
	$bits .= '0000000';
	$bits = substr($bits,0,8*int(length($bits)/8));
	printf STDERR "bit string is $bits\n";
	$ret = pack('B*',$bits);
	printf STDERR "packed string is ".unpack('B*',$ret)."\n";
	printf STDERR "packed string is ".unpack('H*',$ret)."\n";
    } elsif ($ret =~ /^\s*{\s*((\w+\b)(\s*[,]?\s*\w+\b)*)?\s*}\s*$/) {
	$ret =~ s/^\s*{\s*//;
	$ret =~ s/\s*}\s*$//;
	my @elements = split(/\b\s*[,]?\s*/,$ret);
	my @bvalues = ();
	foreach (map { $mib->{'enums'}{$_}; } keys %{$mib->{'enums'}}) {
	    $bvalues[$_] = 0;
	}
	foreach (@elements) {
	    if (defined $mib->{'enums'}{$_}) {
		$bvalues[$mib->{'enums'}{$_}] = 1;
	    } elsif (/^\d+$/) {
		$bvalues[$_] = 1;
	    }
	}
	my $bits = '';
	for (my $i=0;$i<@bvalues;$i++) {
	    $bits .= $bvalues[$i] ? '1' : '0';
	}
	$ret = pack('B*',$bits);
    } elsif ($ret =~ /^"([0-9a-fA-F][0-9a-fA-F])* "$/) {
	$ret =~ s/^"//;
	$ret =~ s/ "$//;
	$ret = pack('H*',$ret);
    } elsif ($ret =~ /^[0-9]+$/) {
	$ret = pack('N',$ret);
    }
    #$ret = unpack('H*',$ret);
    #$ret =~ s/(..)/$1 /g;
    #$ret = '"'.$ret.'"';
    print STDERR "returned value is $ret\n";
    return $ret;
}
#package MyBits;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	my $mib = $self->{'mib'};
	if ($val =~ /^\s*{\s*((\w+\b)(\s*[,]?\s*\w+\b)*)?\s*}\s*$/) {
	    $ret = $val;
	    $ret =~ s/^\s*{\s*//;
	    $ret =~ s/\s*}\s*$//;
	    $ret = join("\n",split(/\b\s*[,]?\s*/,$ret));
	    return $ret;
	} elsif ($val =~ /^"([0-9a-fA-F][0-9a-fA-F] )*"$/) {
	    $ret = $val;
	    $ret =~ s/^"//;
	    $ret =~ s/ "$//;
	    $ret =~ s/ //g;
	    $ret = pack("H*",$ret);
	} elsif ($val =~ /^[0-9]+$/) {
	    $ret = pack('N',$val);
	} else {
	    $ret = $val;
	}
	my $bits = unpack('B*',$ret);
	$ret = "'".$bits."'B";
	if ($mib->{'enums'}) {
	    my @bvals = ();
	    foreach (sort { $mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}; } keys %{$mib->{'enums'}}) {
		unless (length($bits) < $mib->{'enums'}{$_}) {
		    if (substr($bits,$mib->{'enums'}{$_},1) eq '1') {
			push @bvals, $_;
		    }
		}
	    }
	    $ret = join("\n",@bvals);
	}
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyInteger;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'INTEGER';
}
#package MyInteger;
sub validate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};

    my $power = 0;
    if ($mib->{'hint'} && $mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	$power = $2 if (defined $2 && $2 > 0);
    }
    return 0 if $power != 0 && $proposed !~ /^-?[0-9][0-9]*(\.[0-9]*)?$/; # not decimal number
    return 0 if $power == 0 && $proposed !~ /^-?[0-9][0-9]*$/; # not a number
    my $factor = 10**$power;
    if (@{$mib->{'ranges'}}) {
	my $ok = 0;
	foreach (@{$mib->{'ranges'}}) {
	    if ($proposed >= $_->{'low'}/$factor && $proposed <= $_->{'high'}/$factor) {
		$ok = 1;
		last;
	    }
	}
	return 0 if !$ok;
    } elsif ($mib->{'type'} =~ /^(INTEGER|INTEGER32)$/) {
	return 0 if ($proposed < -2147482647/$factor or $proposed > 2147482648/$factor);
    } elsif ($mib->{'type'} =~ /^(UNSIGNED32|COUNTER|GAUGE|TICKS|UINTEGER)$/) {
	return 0 if ($proposed < 0/$factor or $proposed > 4294967295/$factor);
    } elsif ($mib->{'type'} eq 'COUNTER64') {
	return 0 if ($proposed < 0 or $proposed > 18446744073709551615/$factor);
    }
    return 1;
}

#package MyInteger;
sub smsg {
    shift->{'smsg'};
}

#package MyInteger;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if ($proposed eq '');
    my $mib = $self->{'mib'};
    if ($mib->{'hint'}) {
	if ($mib->{'hint'} eq 'b') {
	    return 1 if $proposed =~ /^-?[0-1]+$/;
	} elsif ($mib->{'hint'} eq 'o') {
	    return 1 if $proposed =~ /^-?[0-7]+$/;
	} elsif ($mib->{'hint'} eq 'x') {
	    return 1 if $proposed =~ /^-?[0-9a-fA-F]+$/;
	} elsif ($mib->{'hint'} eq 'd') {
	    return 1 if $proposed =~ /^-?[0-9]+$/;
	} elsif ($mib->{'hint'} =~ /^d-([0-9]+)$/) {
	    return 1 if $proposed =~ /^-?\d*(\.\d{0,$1})?$/;
	}
    } else {
	return 1 if $proposed =~ /^-?[0-9]+$/;
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyInteger;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $mib = $self->{'mib'};
    my $e;

# FIXME handle hints, both in entry and in validation
    my $increment = 1;
    if ($mib->{'hint'} && $mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	$increment = $increment/(10**$2) if (defined $2 && $2 > 0);
    }
    my ($min,$max);
    if (@{$mib->{'ranges'}}) {
	$min = $mib->{'ranges'}[0]{'low'} * $increment;
	$max = $mib->{'ranges'}[-1]{'high'} * $increment;
    } else {
	$min = -2147482647 * $increment;
	$max =  2147482648 * $increment;
    }
    my $init = $entry->{'ent'};
    $e = $parent->Spinbox(
	-takefocus=>1,
	-increment=>$increment,
	-from=>$min,
	-to=>$max,
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyInteger::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter a signed number.';
    return $e;
}

#package MyInteger;
sub indexformat {
    my ($self,$elements,$l,$last,@args) = @_;
    $$l .= '.' if (defined $$l);
    my $i = 0;
    $i = shift @$elements if scalar @$elements;
    $$l .= $i;
    return 1;
}
#package MyInteger;
sub indextaglen {
    my ($self,$elements,$last,@args) = @_;
    return 1;
}
#package MyInteger;
sub indexvalue {
    my ($self,$elements,$last,@args) = @_;
    return $self->valsnmp(shift @$elements);
}

#package MyInteger;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    return $val;
}

#package MyInteger;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    $val = 0 unless defined $val;
    my $ret = $val;
    if (defined $mib->{'hint'}) {
	if ($mib->{'hint'} eq 'b') {
	    my $sign = ($ret =~ s/^-//) ? '-' : '';
	    $ret = '000000000000000000000000000000000000'.$ret;
	    $ret = substr($ret,-32,32);
	    $ret = pack('b*',$ret);
	    $ret = unpack('n',$ret);
	    $ret = $sign ? -$ret : $ret;
	} elsif ($mib->{'hint'} eq 'o') {
	    my $sign = ($ret =~ s/^-//) ? '-' : '';
	    my @values = ('000', '001', '010', '011', '100', '101', '110', '111');
	    my $bits = '';
	    while ($ret =~ s/^.//) {
		$bits .= $values[$&];
	    }
	    $ret = '000000000000000000000000000000000000'.$bits;
	    $ret = substr($ret,-32,32);
	    $ret = pack('b*',$ret);
	    $ret = unpack('n',$ret);
	    $ret = $sign ? -$ret : $ret;
	} elsif ($mib->{'hint'} eq 'x') {
	    my $sign = ($ret =~ s/^-//) ? '-' : '';
	    $ret = '00000000'.$ret;
	    $ret = substr($ret,-8,8);
	    $ret = pack('x*',$ret);
	    $ret = unpack('n',$ret);
	    $ret = $sign ? -$ret : $ret;
	} elsif ($mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	    if (defined $2 && $2 > 0) {
		$ret = $val * (10**$2);
	    }
	}
    }
    return $ret;
}

#package MyInteger;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	my $mib = $self->{'mib'};
	$ret = $val;
	if (defined $mib->{'hint'}) {
	    if ($mib->{'hint'} eq 'b') {
		$ret = ($val < 0) ? -$val : $val;
		$ret = pack('N',$ret);
		$ret = unpack('B*',$ret);
		$ret =~ s/^[0]*//;
		if ($val < 0) { $ret = "-".$ret; }
	    } elsif ($mib->{'hint'} eq 'o') {
		my $sign = ($val < 0) ? '-' : '';
		$ret = ($val < 0) ? -$val : $val;
		$ret = sprintf($sign.'%o', $ret);
	    } elsif ($mib->{'hint'} eq 'x') {
		my $sign = ($val < 0) ? '-' : '';
		$ret = ($val < 0) ? -$val : $val;
		$ret = sprintf($sign.'%x', $ret);
	    } elsif ($mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
		if (defined $2 && $2 > 0) {
		    $ret = $val/(10**$2);
		    $ret = sprintf('%.'.$2.'f',$ret);
		} else {
		    $ret = sprintf('%d', $val);
		}
	    } elsif ($mib->{'hint'} =~ /^d/) {
		$ret = sprintf('%d', $val);
	    }
	}
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyEnumerated;
use strict;
use vars qw(@ISA);
@ISA = qw(MyInteger);

sub snmptype {
    return 'INTEGER';
}
#package MyEnumerated;
sub maxlen {
    my ($self,$w,$font,@args) = @_;
    my $len = 0;
    my $mib = $self->{'mib'};
    foreach my $l (keys %{$mib->{'enums'}}) {
	my $ll = $w->fontMeasure($font,$l);
	$len = $ll if $ll > $len;
    }
    return $len;
}

#package MyEnumerated;
sub validate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};

    foreach (keys %{$mib->{'enums'}}) {
	if ($proposed eq $_) {
	    return 1;
	}
    }
    if ($proposed =~ /^\d+$/) {
	foreach (keys %{$mib->{'enums'}}) {
	    if ($proposed == $mib->{'enums'}{$_}) {
		return 1;
	    }
	}
    }
    return 0;
}

#package MyEnumerated;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if $proposed eq '';
    my $mib = $self->{'mib'};
    my @keys = sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys %{$mib->{enums}};
    if ($proposed =~ /^\d+$/) {
	my @nums = map {$mib->{'enums'}{$_}} @keys;
	foreach (@nums) {
	    return 1 if $_ == $proposed;
	}
	foreach (@nums) {
	    return 1 if (index($_,$proposed) == 0);
	}
    }
    foreach (@keys) {
	return 1 if (index($_,$proposed) == 0);
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyEnumerated;
sub complete {
    my ($self,$entry,@args) = @_;
    my $mib = $self->{mib};
    my $proposed = $entry->{'ent'};
    my $estate = 'set';
    my @keys = sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys %{$mib->{'enums'}};
    if ($proposed eq '') {
	$estate = 'default';
	$proposed = $self->getdefault;
	$proposed = $keys[0] if $proposed eq '';
    } else {
	if ($entry->{'ent'} =~ /^\d+$/) {
	    $proposed =~ s/^0+//;
	    my @nums = map {$mib->{'enums'}{$_}} @keys;
	    foreach (@nums) {
		if ($_ == $proposed) {
		    $entry->{'ent'} = $_;
		    $entry->{'estate'} = $estate;
		    return 1;
		}
	    }
	    foreach (@nums) {
		if (index($_,$proposed) == 0) {
		    $entry->{'ent'} = $_;
		    $entry->{'estate'} = $estate;
		    return 1;
		}
	    }
	}
	foreach (sort keys %{$mib->{enums}}) {
	    if (index($_,$proposed) == 0) {
		$entry->{'ent'} = $_;
		$entry->{'estate'} = $estate;
		return 1;
	    }
	}
    }
    warn "completion failed";
    return (0);
}

#package MyEnumerated;
sub smsg {
    shift->{'smsg'};
}

#package MyEnumerated;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $mib = $self->{'mib'};
    my $e;

    my $opts = [];
    foreach (sort { $mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}; } keys %{$mib->{'enums'}}) {
	push @{$opts}, $_;
    }
    my $init = $entry->{'ent'};
    $e = $parent->Spinbox(
	-values=>$opts,
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyEnumerated::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $e->bind('<Key-Tab>', [sub {
	    my ($w,$parent,$entry) = @_;
	    $w->icursor('end') if $entry->value->complete($entry);
	    Tk->break;
	},$parent,$entry],
    );
    $self->{'smsg'}='Select a value.';
    return $e;
}

#package MyEnumerated;
sub indexformat {
    my ($self,$elements,$l,$last) = @_;
    my $mib = $self->{'mib'};
    $$l .= '.' if (defined $$l);
    my $i = 0;
    $i = shift @$elements if scalar @$elements;
    if (defined $mib->{'enums'}{$i}) {
	$i = "$i($mib->{'enums'}{$i})";
    } else {
	foreach ( keys %{$mib->{'enums'}} ) {
	    if ($mib->{'enums'}{$_} == $i) {
		$i = "$_($i)";
		last;
	    }
	}
    }
    $$l .= $i;
    return 1;
}
#package MyEnumerated;
sub indextaglen {
    my ($self,$elements,$l,$last) = @_;
    return 1;
}
#package MyEnumerated;
sub indexvalue {
    my ($self,$elements,$l,$last) = @_;
    return $self->valsnmp(shift @$elements);
}

#package MyEnumerated;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    $ret = $mib->{'enums'}{$ret};
    return $ret;
}

#package MyEnumerated;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    if (defined $mib->{'enums'}{$ret}) {
	$ret = $mib->{'enums'}{$ret};
    }
    return $ret;
}

#package MyEnumerated;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	my $mib = $self->{'mib'};
	if ($val eq '') {
	    foreach (sort { $mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}; } keys %{$mib->{'enums'}}) {
		$val = $_;
		last;
	    }
	} else {
	    if (defined $mib->{'enums'}{$val}) {
		$ret = $val;
	    } else {
		my $found = 0;
		my $first = undef;
		foreach (sort { $mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}; } keys %{$mib->{'enums'}}) {
		    $first = $_ unless defined $first;
		    if ($mib->{'enums'}{$_} == $val) {
			$ret = $_;
			$found = 1;
			last;
		    }
		}
		unless ($found) {
		    if (defined $first) {
			$ret = $first;
		    } else {
			$ret = undef;
		    }
		}
	    }
	}
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyInteger32;
use strict;
use vars qw(@ISA);
@ISA = qw(MyInteger);
sub snmptype {
    return 'INTEGER';
}
# ---------------------------------

# ---------------------------------
package MyEnumerated32;
use strict;
use vars qw(@ISA);
@ISA = qw(MyEnumerated);
sub snmptype {
    return 'INTEGER';
}
# ---------------------------------

# ---------------------------------
package MyCounter64;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'COUNTER64';
}
#package MyCounter64;
sub smsg {
    shift->{'smsg'};
}

#package MyCounter64;
sub validate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};

    return 0 if $proposed !~ /^-?[0-9][0-9]*$/; # not a number
    if (@{$mib->{'ranges'}}) {
	my $ok = 0;
	foreach (@{$mib->{'ranges'}}) {
	    if ($proposed >= $_->{'low'} && $proposed <= $_->{'high'}) {
		$ok = 1;
		last;
	    }
	}
	return 0 if !$ok;
    } else {
	return 0 if $proposed < 0 or $proposed > 18446744073709551615;
    }
    return 1;
}
#package MyCounter64;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if ($proposed eq '');
    my $mib = $self->{'mib'};
    if ($mib->{'hint'}) {
	if ($mib->{'hint'} eq 'b') {
	    return 1 if $proposed =~ /^[0-1]+$/;
	} elsif ($mib->{'hint'} eq 'o') {
	    return 1 if $proposed =~ /^[0-7]+$/;
	} elsif ($mib->{'hint'} eq 'x') {
	    return 1 if $proposed =~ /^[0-9a-fA-F]+$/;
	} elsif ($mib->{'hint'} eq 'd') {
	    return 1 if $proposed =~ /^[0-9]+$/;
	} elsif ($mib->{'hint'} =~ /^d-([0-9]+)$/) {
	    return 1 if $proposed =~ /^\d*(\.\d{0,$1})?$/;
	}
    } else {
	return 1 if $proposed =~ /^[0-9]+$/;
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyCounter64;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $mib = $self->{'mib'};

# FIXME handle hints
    my $increment = 1;
    if ($mib->{'hint'} && $mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	$increment = $increment/(10**$2) if (defined $2 && $2 > 0);
    }
    my ($min,$max);
    if (@{$mib->{'ranges'}}) {
	$min = $mib->{'ranges'}->[0]->{'low'} * $increment;
	$max = $mib->{'ranges'}->[-1]->{'high'} * $increment;
    } else {
	$min = 0 * $increment;
	$max = 18446744073709551615 * $increment;
    }
    my $init = $entry->{'ent'};
    my $e = $parent->Spinbox(
	-takefocus=>1,
	-increment=>$increment,
	-from=>$min,
	-to=>$max,
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyCounter64::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter an unsigned number.';
    return $e;
}

#package MyCounter64;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    return $ret;
}

#package MyCounter64;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    return $ret;
}

#package MyCounter64;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	$ret = $val;
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyUnsigned32;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'UNSIGNED32';
}
#package MyUnsigned32;
sub smsg {
    shift->{'smsg'};
}

#package MyUnsigned32;
sub validate {
    my ($value,$proposed,@args) = @_;
    my $mib = $value->{'mib'};

    my $power = 0;
    if ($mib->{'hint'} && $mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	$power = $2 if (defined $2 && $2 > 0);
    }
    if ($power != 0 && $proposed !~ /^[0-9][0-9]*(\.[0-9]*)?$/) {
	warn "not a decimal number";
	return 0; # not decimal number
    }
    if ($power == 0 && $proposed !~ /^[0-9][0-9]*$/) {
	warn "not an integral number";
	return 0; # not a number
    }
    my $factor = 10**$power;
    if (@{$mib->{'ranges'}}) {
	my $ok = 0;
	foreach (@{$mib->{'ranges'}}) {
	    my ($low,$high) = ($_->{'low'}/$factor,$_->{'high'}/$factor);
	    if ($proposed >= $low && $proposed <= $high) {
		$ok = 1;
		last;
	    } else {
		warn "$proposed not in range from $low to $high";
	    }
	}
	unless ($ok) {
	    warn "$proposed not in valid range";
	    return 0;
	}
    } else {
	my ($low,$high) = (0/$factor,4294967295/$factor);
	if ($proposed < $low || $proposed > $high) {
	    warn "$proposed not in range from $low to $high";
	    return 0; # out of range
	}
    }
    return 1;
}

#package MyUnsigned32;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if ($proposed eq '');
    my $mib = $self->{'mib'};
    if ($mib->{'hint'}) {
	if ($mib->{'hint'} eq 'b') {
	    return 1 if $proposed =~ /^[0-1]+$/;
	} elsif ($mib->{'hint'} eq 'o') {
	    return 1 if $proposed =~ /^[0-7]+$/;
	} elsif ($mib->{'hint'} eq 'x') {
	    return 1 if $proposed =~ /^[0-9a-fA-F]+$/;
	} elsif ($mib->{'hint'} eq 'd') {
	    return 1 if $proposed =~ /^[0-9]+$/;
	} elsif ($mib->{'hint'} =~ /^d-([0-9]+)$/) {
	    return 1 if $proposed =~ /^\d*(\.\d{0,$1})?$/;
	}
    } else {
	return 1 if $proposed =~ /^[0-9]+$/;
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyUnsigned32;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $mib = $self->{'mib'};

    my $increment = 1;
    if ($mib->{'hint'} && $mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	$increment = $increment/(10**$2) if (defined $2 && $2 > 0);
    }
    my ($min,$max);
    if (@{$mib->{'ranges'}}) {
	$min = $mib->{'ranges'}->[0]->{'low'} * $increment;
	$max = $mib->{'ranges'}->[-1]->{'high'} * $increment;
    } else {
	$min = 0 * $increment;
	$max = 4294967295 * $increment;
    }
    my $init = $entry->{'ent'};
    my $e = $parent->Spinbox(
	-takefocus=>1,
	-increment=>$increment,
	-from=>$min,
	-to=>$max,
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyUnsigned32::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter an unsigned number.';
    return $e;
}

#package MyUnsigned32;
sub indexformat {
    my ($self,$elements,$l,$last) = @_;
    my $mib = $self->{'mib'};

    $$l .= '.' if (defined $$l);
    my $i = 0;
    $i = shift @$elements if scalar @$elements;
    $i = 0 unless defined $i;
    if ($mib->{'enums'}) {
	if (defined $mib->{'enums'}{$i}) {
	    $i = "$i($mib->{'enums'}{$i})";
	} else {
	    foreach ( keys %{$mib->{'enums'}} ) {
		if ($mib->{'enums'}{$_} == $i) {
		    $i = "$_($i)";
		    last;
		}
	    }
	}
    }
    $$l .= $i;
    return 1;
}

#package MyUnsigned32;
sub indextaglen {
    my ($self,$elements,$last) = @_;
    return 1;
}

#package MyUnsigned32;
sub indexvalue {
    my ($self,$elements,$last) = @_;
    return $self->valsnmp(shift @$elements);
}

#package MyUnsigned32;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    return $ret;
}

#package MyUnsigned32;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    if (defined $mib->{'hint'}) {
	if ($mib->{'hint'} eq 'b') {
	    $ret = '000000000000000000000000000000000000'.$ret;
	    $ret = substr($ret,-32,32);
	    $ret = pack('b*',$ret);
	    $ret = unpack('n',$ret);
	} elsif ($mib->{'hint'} eq 'o') {
	    my @values = ('000', '001', '010', '011', '100', '101', '110', '111');
	    my $bits = '';
	    while ($ret =~ s/^.//) {
		$bits .= $values[$&];
	    }
	    $ret = '000000000000000000000000000000000000'.$bits;
	    $ret = substr($ret,-32,32);
	    $ret = pack('b*',$ret);
	    $ret = unpack('n',$ret);
	} elsif ($mib->{'hint'} eq 'x') {
	    $ret = '00000000'.$ret;
	    $ret = substr($ret,-8,8);
	    $ret = pack('x*',$ret);
	    $ret = unpack('n',$ret);
	} elsif ($mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
	    if (defined $2 && $2 > 0) {
		$ret = $val * (10**$2);
	    }
	}
    }
    return $ret;
}

#package MyUnsigned32;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	my $mib = $self->{'mib'};
	$ret = $val;
	if (defined $mib->{'hint'}) {
	    if ($mib->{'hint'} eq 'b') {
		$ret = pack('N',$val);
		$ret = unpack('B*',$ret);
		$ret =~ s/^[0]*//;
	    } elsif ($mib->{'hint'} eq 'o') {
		$ret = sprintf('%o', $val);
	    } elsif ($mib->{'hint'} eq 'x') {
		$ret = sprintf('%x', $val);
	    } elsif ($mib->{'hint'} =~ /^d(-([0-9]*))?$/) {
		if ((my $ord = $2) > 0) {
		    $ret = $val/(10**$ord);
		    $ret = sprintf('%.'.$ord.'f',$ret);
		} else {
		    $ret = sprintf('%u', $val);
		}
	    } elsif ($mib->{'hint'} =~ /^d/) {
		$ret = sprintf('%u', $val);
	    }
	}
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyCounter;
use strict;
use vars qw(@ISA);
@ISA = qw(MyUnsigned32);
# ---------------------------------
sub snmptype {
    return 'COUNTER';
}

# ---------------------------------
package MyGauge;
use strict;
use vars qw(@ISA);
@ISA = qw(MyUnsigned32);
# ---------------------------------
sub snmptype {
    return 'GAUGE';
}

# ---------------------------------
package MyTicks;
use strict;
use vars qw(@ISA);
@ISA = qw(MyUnsigned32);
# ---------------------------------
sub snmptype {
    return 'TICKS';
}

# ---------------------------------
package MyUinteger;
use strict;
use vars qw(@ISA);
@ISA = qw(MyUnsigned32);
# ---------------------------------
sub snmptype {
    return 'UINTEGER';
}

# ---------------------------------
package MyIpaddr;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'IPADDR';
}
#package MyIpaddr;
sub validate {
    my ($value,$proposed,@args) = @_;
    return 0 if $proposed !~ /^([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)$/;
    return 0 if $1 > 255 or $2 > 255 or $3 > 255 or $4 > 255;
    return 1;
}

#package MyIpaddr;
sub smsg {
    shift->{'smsg'};
}

#package MyIpaddr;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if $proposed eq '';
    my @elements = split(/\./,$proposed);
    if (@elements <= 4) {
	my $ok = 1;
	foreach (@elements) {
	    next if ($_ eq '' || ($_ =~ /^\d+$/ && $_ >= 0 && $_ < 256));
	    $ok = 0;
	    last;
	}
	return 1 if $ok;
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyIpaddr;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $init = $entry->{'ent'};
    my $e = $parent->Entry(
	-takefocus=>1,
	-exportselection=>1,
	-justify=>'left',
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyIpaddr::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter an IP address.';
    return $e;
}

#package MyIpaddr;
sub indexformat {
    my ($self,$elements,$l,$last) = @_;

    for (my $i = 0; $i < 4; $i++) {
	$$l .= '.' if (defined $$l);
	if (scalar @$elements) {
	    $$l .= shift @$elements;
	} else {
	    $$l .= '0';
	}
    }
    return 1;
}
#package MyIpaddr;
sub indextaglen {
    my ($self,$elements,$l,$last) = @_;
    return 4;
}
#package MyIpaddr;
sub indexvalue {
    my ($self,$elements,$l,$last) = @_;
    my $val = undef;
    for (my $i = 0; $i < 4; $i++) {
	$val .= '.' if defined $val;
	if (scalar @$elements) {
	    $val .= shift @$elements;
	} else {
	    $val .= '0';
	}
    }
    return $val;
}

#package MyIpaddr;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    return $ret;
}

#package MyIpaddr;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    return $ret;
}

#package MyIpaddr;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	$ret = $val;
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyNetaddr;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'NETADDR';
}
#package MyNetaddr;
sub validate {
    my ($self,$proposed,@args) = @_;
    if ($proposed =~ /^(inet:)?([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)$/) {
	return 1 if ($1 < 256 && $2 < 256 && $3 < 256 && $4 < 256);
    }
    return 0;
}

#package MyNetaddr;
sub smsg {
    shift->{'smsg'};
}

#package MyNetaddr;
sub validateall {
    my ($self,$proposed,@args) = @_;
    return 1 if $proposed eq '';
    $proposed =~ s/^i?n?e?t?:?//; # optional leader
    return 1 if $proposed eq '';
    my @elements = split(/\./,$proposed);
    if (@elements <= 4) {
	my $ok = 1;
	foreach (@elements) {
	    next if ($_ eq '' || ($_ =~ /^\d+$/ && $_ >= 0 && $_ < 256));
	    $ok = 0;
	    last;
	}
	return 1 if $ok;
    }
    warn "validation of `$proposed' failed";
    return 0;
}

#package MyNetaddr;
sub addentry {
    my ($self,$parent,$entry,$force,@args) = @_;
    my $init = $entry->{'ent'};
    my $e = $parent->Entry(
	-takefocus=>1,
	-exportselection=>1,
	-justify=>'left',
	-textvariable=>\$entry->{'ent'},
	-state=>$self->entrystate($force,@args),
    );
    $e->configure(
	-validate=>'all',
	-validatecommand=>[\&MyNetaddr::validateall,$self],
	-invalidcommand=>[sub{shift->toplevel->bell;},$e],
    );
    $entry->{'ent'} = $init;
    $e->validate;
    $self->{'smsg'}='Enter an network address.';
    return $e;
}

#package MyNetaddr;
sub indexformat {
    my ($self,$elements,$l,$last) = @_;
    shift @$elements if scalar @$elements;
    for (my $i = 0; $i < 4; $i++) {
	$$l .= '.' if (defined $$l);
	if (scalar @$elements) {
	    $$l .= shift @$elements;
	} else {
	    $$l .= '0';
	}
    }
    return 1;
}
#package MyNetaddr;
sub indextaglen {
    my ($self,$elements,$last) = @_;
    return 5;
}
#package MyNetaddr;
sub indexvalue {
    my ($self,$elements,$last) = @_;
    shift @$elements if scalar @$elements;
    my $val = undef;
    for (my $i = 0; $i < 4; $i++) {
	$val .= '.' if defined $val;
	if (scalar @$elements) {
	    $val .= shift @$elements;
	} else {
	    $val .= '0';
	}
    }
    return $val;
}

#package MyNetaddr;
sub snmptag {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    $ret = 's/^i?n?e?t?:?//';
    return $ret;
}

#package MyNetaddr;
sub snmpval {
    my ($self,$data,@args) = @_;
    my $mib = $self->{'mib'};
    my $val = $data->{'val'};
    my $ret = $val;
    $ret =~ s/^inet://;
    return $ret;
}

#package MyNetaddr;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	$ret = $val;
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
package MyNull;
use strict;
use vars qw(@ISA);
@ISA = qw(MyValue);

sub snmptype {
    return 'NULL';
}
#package MyNull;
sub snmptag {
    return '';
}

#package MyNull;
sub snmpval {
    return '';
}

#package MyNull;
sub indextaglen {
    return 0;
}

#package MyNull;
sub valsnmp {
    my ($self,$val,@args) = @_;
    my $ret = undef;
    if (defined $val && $val ne 'NOSUCHINSTANCE') {
	$ret = 'NULL';
    }
    return $ret;
}
# ---------------------------------

# ---------------------------------
# This is an Hlist proxy object.  The object represents an Tk::HList window, of
# which there can be multiples.
# ---------------------------------
package MyHList;
use strict;
use vars qw(@ISA);
@ISA = qw(MyPage);

#package MyHList;
sub new {
    my ($type,$parent,$page,$label,$width,@args) = @_;
    my $self = MyPage::new($type,$parent,$page,$label,@args) || return undef;
    $self->{'data'}->{'txtwidth'} = $width;
    return $self;
}
#package MyHList;
sub createcmd {
    my ($self,$frame,@args) = @_;
    return if $self->{'created'};
    my $width = $self->{'data'}->{'txtwidth'};
    $width = 60 unless $width;
    my $top = $frame->Scrolled('HList',
	-scrollbars=>'onow',
	-columns=>3,
	-browsecmd=>[\&MyHList::browsehlist,$self],
	-command=>[\&MyHList::selecthlist,$self],
	-drawbranch=>1,
	-header=>1,
	-indent=>19,  # cannot be less that width of image
	-indicator=>1,
	-indicatorcmd=>[\&MyHList::indicatorhlist,$self],
	-selectmode=>'browse',
	-separator=>'.',
	-width=>$width,
	-exportselection=>1,
    )->pack(
	-expand=>1, -fill=>'both', -side=>'left', -anchor=>'w',
#    )->place(
#	-x=>0,-y=>0,-relwidth=>1.0,-relheight=>1.0,
    );
    $self->{'scroll'} = $top;
    $self->{'contained'} = $top;
    $top = $top->Subwidget('scrolled');
    $self->{'hlist'} = $top;
    $top->header('create', 0,
	-itemtype=>'text',
	-text=>'Name',
    );
    $top->header('create', 1,
	-itemtype=>'text',
	-text=>'Syntax/Value',
    );
    $top->header('create', 2,
	-itemtype=>'text',
	-text=>'Units',
    );
    $top->bind('<Button-3>', [\&MyHList::button3, $self, Tk::Ev('y')]);
    $top->bind('<F1>', [\&MyHList::f1, $self, Tk::Ev('y')]);
    $self->{'anchors'} = []; # this is the anchor stack
    $self->{'created'} = 1;
    if ($self->{'needreconstruct'}) {
	$self->reconstruct($self->{'data'});
    }
    return $self;
}
#package MyHList;
sub raisecmd {
    my ($self,$frame,@args) = @_;
}
#package MyHList;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    $self->createcmd($self->widget);
    $data->{'anchors'} = $self->{'anchors'};
    $data->{'base'} = $self->{'base'};
    $data->{'root'} = [];
    $data->{'hwidth'} = $self->{'hlist'}->cget('-width');
    foreach (@{$self->{'root'}}) {
	push @{$data->{'root'}}, $_->dumphash(@args);
    }
    my $entry = $self->{'hlist'}->info('selection');
    if ($entry) {
	my $obj = $self->{'hlist'}->entrycget($entry,'-data');
	if ($obj && UNIVERSAL::isa($obj,'MyObject')) {
	    $data->{'selection'} = $obj->id;
	}
    }
    return $data;
}
#package MyHList;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    unless ($self->{'created'}) {
	$self->{'needreconstruct'} = 1;
	return;
    }
    if ($data->{'selection'}) {
	$self->{'selection'} = $self->createobject($data->{'selection'});
    }
}
#package MyHList;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyHList->new($parent,$data->{'page'},$data->{'label'},$data->{'hwidth'},@args);
    $self->reconstruct($data,@args);
    return $self;
}
#package MyHList;
sub detail {
    my ($self,@args) = @_;
    my $parent = $self->{'hlist'};
    my $w;
    my $string = '';
    $string .= "\n";
    $string .= "Family:...........";
    $string .= join("\nFamily:...........", sort $parent->fontFamilies);
    $string .= "\n";
    while (($w = $parent)) {
	$parent = $w->parent;
	$string .= "\n";
	$string .= "Widget:...........".ref($w)."\n";
	$string .= "Geometry:.........".$w->geometry."\n";
	foreach ($w->configure) {
	    $string .= "Option:...........".join(', ',@$_)."\n";
	}
    }
    return $string;
}
#package MyHList;
sub browsehlist {
    warn "MyHList browsehlist called @_";
    my ($self,$new,@args) = @_;
    my $top = $self->{'hlist'};
    my $obj = $top->entrycget($new, -data);
    $self->setselectionhlist($new);
    if (my $clipboard = $obj->id) {
	my $tl = $top->toplevel;
	$tl->clipboardClear;
	$tl->clipboardAppend('--',$clipboard);
    }
    if (my $text = $self->rotext) {
	$text->filltext($obj,$new,$self);
    }
    return;
}
#package MyHList;
sub clearactive {
    my ($self,$top) = @_;
    my $old = $self->{'active'};
    return unless defined $old;
    delete $self->{'active'};
    if ($top->info('exists', $old)) {
	my $obj = $top->entrycget($old,-data);
	if (UNIVERSAL::isa($obj,'MyData')) {
	    my $val = $obj->{'val'};
	    $val = '' unless defined $val;
	    $val =~ s/\n/, /g;
	    $top->itemDelete($old,1) if $top->itemExists($old, 1);
	    $top->itemCreate($old,1,
		-itemtype=>'text',
		-text=>$val,
	    );
	} elsif (UNIVERSAL::isa($obj,'MyEntry')) {
	    my $val = $obj->val;
	    $val = '' unless defined $val;
	    $val =~ s/\n/, /g;
	    $top->itemDelete($old,1) if $top->itemExists($old, 1);
	    $top->itemCreate($old,1,
		-itemtype=>'text',
		-text=>$val,
	    );
	}
    }
}
#package MyHList;
sub setactive {
    my ($self,$top,$new) = @_;
    $self->clearactive($top) if defined $self->{'active'};
    if ($top->info('exists', $new)) {
	$top->selectionClear;
	$top->selectionSet($new);
	my $obj = $top->entrycget($new,-data);
	if (UNIVERSAL::isa($obj,'MyData')) {
	    my $val = $obj->{'val'};
	    $val = '' unless defined $val;
	    $val =~ s/\n/, /g;
	    my $w = $top->Entry(
		-takefocus=>0,
		-exportselection=>1,
		-justify=>'left',
		-textvariable=>\$val,
		-state=>$obj->value->entrystate(0),
	    );
	    $top->itemDelete($new,1) if $top->itemExists($new, 1);
	    $top->itemCreate($new,1,
		-itemtype=>'window',
		-window=>$w,
	    );
	} elsif (UNIVERSAL::isa($obj,'MyEntry')) {
	    if (my $w = $obj->addentry($top,0)) {
		$obj->{'commit'} = 0;
		unless ($obj->{'haswindow'}) {
		    $obj->{'haswindow'} = $w;
		    $top->itemDelete($new,1) if $top->itemExists($new, 1);
		    $top->itemCreate($new,1,
			-itemtype=>'window',
			-window=>$w,
		    );
		    $w->bind('<Return>',[sub{
			    my ($w,$self,$top,$obj) = @_;
			    $obj->{'commit'} = 1;
			    $self->clearactive($top);
			    Tk->break;
			},$self,$top,$obj],
		    );
		    $w->bind('<Escape>',[sub{
			    my ($w,$self,$top,$obj) = @_;
			    $self->clearactive($top);
			    Tk->break;
			},$self,$top,$obj],
		    );
		    $w->focus;
		    $top->update;
		}
	    }
	}
	$self->{'active'} = $new;
    }
}
#package MyHList;
sub selecthlist {
    warn "MyHlist selecthlist called with @_";
    my ($self,$entry,@args) = @_;
    my $top = $self->{'hlist'};
    my $obj = $top->entrycget($entry, -data);
    $self->setselectionhlist($entry);
    $self->setactive($top,$entry);
    return;
}
#package MyHList;
sub indicatorhlist {
    warn "MyHList indicatorhist called with @_";
    my ($self,$entry,$action,@args) = @_;

    if ($action eq '<Activate>') {
	my $top = $self->{'hlist'};
	delete $top->{'armed'};
	my $obj = $top->entrycget($entry, -data);
	my $o;
	if (exists $obj->{'state'} && $obj->{'state'} eq 'c') {
	    $self->populate($entry,$obj);
	    $self->getvalues($entry,$obj);
	    if ($top->info('children', $entry)) {
		my @children = $top->info('children', $entry);
		foreach (@children) {
		    $o = $top->entrycget($_, -data);
		    $top->show('entry', $_) unless $o->{'hidden'};
		}
	    }
	    $obj->setstate($top,$entry,'o');
	} else {
	    if ($top->info('children', $entry)) {
		my @children = $top->info('children', $entry);
		foreach (@children) {
		    $top->hide('entry', $_);
		}
	    }
	    $obj->setstate($top,$entry,'c');
	}
	return 1;
    } elsif ($action eq '<Arm>') {
	my $top = $self->{'hlist'};
	$top->{'armed'} = $entry;
    } elsif ($action eq '<Disarm>') {
	my $top = $self->{'hlist'};
	delete $top->{'armed'};
    }
}
#package MyHList;
sub button3 {
    my ($top,$self,$y,@args) = @_;
    my $entry = $top->nearest($y);
    my $menu = $self->setselectionhlist($entry);
    $menu->Popup(
	-popanchor=>'nw',
	-popover=>'cursor',
    );
    return;
}
#package MyHList;
sub f1 {
    my ($top,$self,$y,@args) = @_;
}
#package MyHList;
sub menuanyaction {
    my ($self,$cmd,@args) = @_;
    my $top = $self->{'hlist'};
    $self->$cmd($top);
}
#package MyHList;
sub keyanyaction {
    my ($top,$self,$cmd,@args) = @_;
    $self->menuanyaction($cmd,@args);
}
#package MyHList;
sub menuitemaction {
    my ($self,$cmd,$entry,@args) = @_;
    return unless defined($entry) && defined ($$entry);
    my $top = $self->{'hlist'};
    my $obj = $top->entrycget($$entry, -data);
    return unless defined $obj;
    $self->$cmd($top,$$entry,$obj);
}
#package MyHList;
sub keyitemaction {
    my ($top,$self,$cmd,$y,@args) = @_;
    my $entry = $top->nearest($y);
    $self->menuitemaction($cmd,\$entry,@args);
}
#package MyHList;
sub copyobj {
    my ($self,$top,$entry,$obj,@args) = @_;
    if (my $clipboard = $obj->id) {
	my $tl = $top->toplevel;
	$tl->clipboardClear;
	$tl->clipboardAppend('--',$clipboard);
    }
}
#package MyHList;
sub pasteobj {
    my ($self,$top,$entry,$obj,@args) = @_;
}
#package MyHList;
sub hideobj {
    my ($self,$top,$entry,$obj,@args) = @_;
    $obj->{'hidden'} = 1;
    $obj->{'parent'}->{'hiddenchildren'}++ if $obj->{'parent'};
    $self->{'hlist'}->hide('entry', $entry);
    return;
}
#package MyHList;
sub unhideobj {
    my ($self,$top,$entry,$obj,@args) = @_;
    my $par = $top->entrycget($entry,-data);
    if ($top->info('children', $entry)) {
	my @children = $top->info('children', $entry);
	foreach (@children) {
	    my $obj = $top->entrycget($_, -data);
	    if ($obj->{'hidden'}) {
		$obj->{'hidden'} = undef;
		$par->{'hiddenchildren'}--;
		$top->show('entry', $_);
	    }
	}
    }
}
#package MyHList;
sub deleteoffsprings {
    my ($self,$top,$entry) = @_;
    if ($top->info('children',$entry)) {
	my @children = $top->info('children', $entry);
	foreach (@children) {
	    $self->deleteoffsprings($top,$_);
	}
    }
    my $obj = $top->entrycget($entry,-data);
    $top->entryconfigure($entry,-data=>undef);
    $top->delete('entry',$entry);
    for (my $i = 0; $i < @{$self->{'root'}}; $i++) {
	if ($self->{'root'}->[$i] eq $obj) {
	    splice @{$self->{'base'}}, $i, 1;
	    splice @{$self->{'root'}}, $i, 1;
	}
    }
    $obj->destroy;
}
#package MyHList;
sub deleteall {
    my ($self) = @_;
    my $top = $self->{'hlist'};
    if ($top->info('children',undef)) {
	my @children = $top->info('children', undef);
	foreach (@children) {
	    $self->deleteoffsprings($top,$_);
	}
    }
}
#package MyHList;
sub rebuildfind {
    my ($self,$look,$parent,@objs) = @_;
    my $found = $self->rebuild($look,$parent,@objs);
    if (defined $found) {
	$self->setselectionhlist($found);
	$self->{'hlist'}->xview($found);
    }
    return $found;
}
#package MyHList;
sub anchorobj {
    my ($self,$top,$entry,$obj,@args) = @_;
    push @{$self->{'anchors'}}, $self->{'base'};
    $top->delete('all'); # toast entire tree
    $self->{'base'} = [ $obj->id ];
    $self->{'root'} = [ $obj ] ;
    $self->updatelabel($obj->{'label'});
    $self->rebuildfind($obj,undef,@{$self->{'root'}});
}
#package MyHList;
sub anchorparent {
    my ($self,$top,$entry,$obj,@args) = @_;
    return unless @{$self->{'anchors'}};
    return unless $self->{'base'}->[0] =~ /\./;
    $top->delete('all'); # toast entire tree
    $self->{'base'}->[0] =~ s/\.[^\.]*$//;
    $self->{'root'} = [ MyObject->new($self->tree, $self->{'base'}->[0]) ];
    $self->updatelabel($obj->{'label'});
    $top->selectionClear;
    $self->rebuildfind($obj,undef,@{$self->{'root'}});
}
#package MyHList;
sub unanchorobj {
    my ($self,$top,$entry,$mib,@args) = @_;
    return unless @{$self->{'anchors'}};
    $top->delete('all'); # toast entire tree
    $self->{'base'} = pop @{$self->{'anchors'}};
    $self->{'root'} = [];
    foreach (@{$self->{'base'}}) {
	push @{$self->{'root'}}, $self->createobject($_);
    }
    $self->updatelabel($self->{'root'}->[0]->{'label'});
    $top->selectionClear;
    $self->rebuildfind($mib,undef,@{$self->{'root'}});
}
#package MyHList;
sub expandall {
    my ($self,$top,$entry,$obj,@args) = @_;
    $top->Busy(-recurse=>1);
    $self->expandallsubtree($entry,1);
    $top->Unbusy;
    return;
}
#package MyHList;
sub expandallsubtree {
    my ($self,$entry,$walk,@args) = @_;
    my $top = $self->{'hlist'};
    my $obj = $top->entrycget($entry, -data);
    my $o;
    if (exists $obj->{'state'} && $obj->{'state'} eq 'c') {
	$self->populate($entry,$obj);
	$self->getvalues($entry,$obj) if $walk;
	#$top->yview($entry);
	if ($top->info('children', $entry)) {
	    my @children = $top->info('children', $entry);
	    foreach (@children) {
		$o = $top->entrycget($_, -data);
		$top->show('entry', $_) unless $o->{'hidden'};
		#$top->yview($_);
	    }
	}
	$obj->setstate($top,$entry,'o');
    }
    if ($top->info('children', $entry)) {
	my @children = $top->info('children', $entry);
	foreach (@children) {
	    $self->expandallsubtree($_,$walk);
	}
    }
}
#package MyHList;
sub collapseall {
    my ($self,$top,$entry,$obj,@args) = @_;
    $top->Busy(-recurse=>1,);
    $self->collapseallsubtree($entry);
    $top->Unbusy;
    return;
}
#package MyHList;
sub collapseallsubtree {
    my ($self,$entry,@args) = @_;
    my $top = $self->{'hlist'};
    my $obj = $top->entrycget($entry, -data);
    if (exists $obj->{'state'} && $obj->{'state'} eq 'o') {
	if ($top->info('children', $entry)) {
	    my @children = $top->info('children', $entry);
	    foreach (@children) {
		$top->hide('entry', $_);
		$self->collapseallsubtree($_);
	    }
	}
	$obj->setstate($top,$entry,'c');
    }
}
#package MyHList;
sub attachballoon {
    my ($self,$widget,%args) = @_;
    $args{'-balloonmsg'} =~ s/[ ]\n[ ]*//sg;
    return $self->{'Balloon'}->attach($widget,%args) if $self->{'Balloon'};
}
#package MyHList;
sub objproperties {
    my ($self,$top,$entry,$obj,@args) = @_;
    return $self->top->objprops($self,$obj);
}

# ---------------------------------

# ---------------------------------
package MyHostList;
use strict;
use vars qw(@ISA);
@ISA = qw(MyHList);

#package MyHostList;
sub new {
    my ($type,$parent,$page,$label,$width,@args) = @_;
    $label = 'Hosts' unless defined $label;
    $width = 20 unless $width;
    my $self = MyHList::new($type,$parent,$page,$label,$width,@args) || return undef;
    return $self;
}
#package MyHostList;
sub createcmd {
    my ($self,$frame,@args) = @_;
    return if $self->{'created'};
    $self->SUPER::createcmd($frame,@args);
    my $top = $self->{'hlist'};
    $top->header('configure', 0, -text=>'Host/Object',);
    $top->header('configure', 1, -text=>'Detail',);
    $top->header('configure', 2, -text=>'State',);
    $self->{'dragdrop'} = $top->DragDrop(
	-sitetypes=>[qw/XDND Sun Local/],
	-startcommand=>[ sub {
	    return 1 if ($::dragobj);
	    my ($token,$e) = @_;
	    my $top = $token->parent;
	    my $entry = $top->nearest($e->y);
	    my $obj = $top->entrycget($entry, -data);
	    if (UNIVERSAL::isa($obj,'MyEntity')) {
		$token->configure(
		    -text=>$obj->{'label'},
		    -image=>$top->indicator('cget',$entry,'-image'),
		);
	    } else {
		return 1;
	    }
	    $::dragobj = $obj;
	    return 0;
	} ],
	-endcommand=>[ sub {
	    $::dragobj = undef;
	} ],
	#-predropcommand=>[ sub { my ($seln,$site) = @_; return 1; } ],
	#-postdropcommand=>[ sub { my ($seln) = @_; return; } ],
	-delta=>8,
	-cursor=>'question_arrow',
	#-handlers=>
	#-selection=>'PRIMARY', #-selection=>'XdndSelection',
	#-event=>'<B1-Motion>',
    );
    $self->{'base'} = [];
    $self->{'root'} = [];
    $self->{'hostnum'} = 0;
    $self->newsession($self->{'hlist'},DestHost=>'localhost');
    $self->{'created'} = 1;
    if ($self->{'needreconstruct'}) {
	$self->reconstruct($self->{'data'});
    }
    return $self;
}
#package MyHostList;
sub raisecmd {
    my ($self,$frame,@args) = @_;
    $self->SUPER::raisecmd($frame,@args);
    my $top = $self->{'hlist'};
    $self->refresh($top);
}
#package MyHostList;
sub refresh {
    my ($self,$top,$entry,@args) = @_;
    if (defined $entry && (my $obj = $top->entrycget($entry, '-data'))) {
	$obj->updatechild($top,$entry);
    }
    if ($top->info('children', $entry)) {
	my @children = $top->info('children', $entry);
	foreach (@children) {
	    $self->refresh($top,$_,@args);
	}
    }
}
#package MyHostList;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    unless ($self->{'created'}) {
	$self->{'needreconstruct'} = 1;
	return;
    }
    $self->{'hlist'}->delete('all'); # toast entire tree
    $self->{'base'} = $data->{'base'};
    $self->{'root'} = [];
    foreach (@{$data->{'root'}}) {
	push @{$self->{'root'}}, MyHostEntity::construct($self->tree,$_,@args);
    }
    $self->setlabel($data->{'label'});
    $self->{'anchors'} = $data->{'anchors'};
    $self->{'selection'} = $self->{'root'}->[0];
    if ($data->{'selection'}) {
	$self->{'selection'} = $self->{'tree'}->{'objects'}->{$data->{'selection'}};
	$self->{'selection'} = $self->{'root'}->[0] unless $self->{'selection'};
    }
    $self->rebuildfind($self->{'selection'},undef,@{$self->{'root'}});
}

#package MyHostList;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyHostList->new($parent,$data->{'page'},$data->{'label'},$data->{'width'},@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyHostList;
sub createobject {
    my ($self,$id,@args) = @_;
    return MyHostEntity->new($self->tree, $id);
}

#package MyHostList;
sub getvalues {
    my ($self,$entry,$obj) = @_;
}
#package MyHostList;
sub populate {
    my ($self,$entry,$obj) = @_;
}
#package MyHostList;
sub setselectionhlist {
    my ($self,$entry,@args) = @_;
    my $top = $self->{'hlist'};
    $self->clearactive($top);
    my $m = $self->getpopup;
    if ($top->info('exists', $entry)) {
	$self->{'selected'} = $entry;
	$m->entryconfigure('Disconnect',-state=>'normal',);
	$m->entryconfigure('Connect',-state=>'normal',);
	$m->entryconfigure('Test',-state=>'normal',);
	$m->entryconfigure('Edit',-state=>'normal',);
	$m->entryconfigure('Delete',-state=>'normal',);
	if ((my $obj = $top->entrycget($entry, '-data'))) {
	    $obj->updatechild($top,$entry);
	}
    } else {
	$m->entryconfigure('Disconnect',-state=>'disabled',);
	$m->entryconfigure('Connect',-state=>'disabled',);
	$m->entryconfigure('Test',-state=>'disabled',);
	$m->entryconfigure('Edit',-state=>'disabled',);
	$m->entryconfigure('Delete',-state=>'disabled',);
    }
    $m->entryconfigure('New...',-state=>'normal',);
    return $m;
}
#package MyHostList;
sub disconnect {
    my ($self,$top,$entry,$obj,@args) = @_;
    $obj->disconnect($self,\$entry);
    $obj->updatechild($top,$entry);
}
#package MyHostList;
sub connect {
    my ($self,$top,$entry,$obj,@args) = @_;
    $obj->connect($self,\$entry);
    $obj->updatechild($top,$entry);
}
#package MyHostList;
sub testconnection {
    my ($self,$top,$entry,$obj,@args) = @_;
    $obj->testconnection($self,\$entry);
    $obj->updatechild($top,$entry);
}
#package MyHostList;
sub editsession {
    my ($self,$top,$entry,$obj,@args) = @_;
    $obj->edit($self,\$entry);
    $obj->updatechild($top,$entry);
}
#package MyHostList;
sub delsession {
    my ($self,$top,$entry,$obj,@args) = @_;
    for (my $i = 0; $i < @{$self->{'root'}}; $i++) {
	if ($self->{'root'}->[$i] eq $obj) {
	    splice @{$self->{'base'}}, $i, 1;
	    splice @{$self->{'root'}}, $i, 1;
	}
    }
    $top->entryconfigure($entry,-data=>undef);
    $top->delete('entry',$entry);
    $obj->destroy;
}
#package MyHostList;
sub newsession {
    my ($self,$top,@args) = @_;
    my $id = "host$self->{'hostnum'}";
    $self->{'hostnum'}++;
    my $obj = MyHostEntity->new($self->tree,$id,@args);
    push @{$self->{'base'}}, $obj->id;
    push @{$self->{'root'}}, $obj;
    $obj->newchild($top,undef);
}
#package MyHostList;
sub getpopup {
    my ($self,@args) = @_;
    return $self->{'popup'} if $self->{'popup'};
    my $w = $self->{'hlist'};
    my $m = $w->toplevel->Menu(
	-tearoff=>1,
	-title=>"Session Entry",
	-type=>'normal',
    );
    $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'disconnect',\$self->{'selected'}],
	-label=>'Disconnect',
	-underline=>3,);
    $w->bind('<Key-s>',[\&MyHList::keyitemaction,$self,'disconnect',Tk::Ev('y')]);
    $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'connect',\$self->{'selected'}],
	-label=>'Connect',
	-underline=>0,);
    $w->bind('<Key-c>',[\&MyHList::keyitemaction,$self,'connect',Tk::Ev('y')]);
    $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'testconnection',\$self->{'selected'}],
	-label=>'Test',
	-underline=>0,);
    $w->bind('<Key-t>',[\&MyHList::keyitemaction,$self,'testconnection',Tk::Ev('y')]);
    $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'editsession',\$self->{'selected'}],
	-label=>'Edit',
	-underline=>0,);
    $w->bind('<Key-e>',[\&MyHList::keyitemaction,$self,'editsession',Tk::Ev('y')]);
    $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'delsession',\$self->{'selected'}],
	-label=>'Delete',
	-underline=>0,);
    $w->bind('<Key-d>',[\&MyHList::keyitemaction,$self,'delsession',Tk::Ev('y')]);
    $m->add('command',
	-command=>[\&MyHList::menuanyaction,$self,'newsession'],
	-label=>'New...',
	-underline=>0,);
    $w->bind('<Key-n>',[\&MyHList::keyanyaction,$self,'newsession']);
    $self->{'popup'} = $m;
    return $self->{'popup'};
}
#package MyHostList;
sub rebuild {
    my ($self,$look,$parent,@objs) = @_;
    my $top = $self->{'hlist'};
    my $found = undef;

    foreach my $obj (@objs) {
	my $entry = $obj->newchild($top,$parent);
	$found = $entry if $obj eq $look;
	foreach (@{$obj->{'children'}}) {
	    my $e = $self->rebuild($look,$entry,$_);
	    $found = $e unless defined $found;
	}
    }
    return $found;
}
#package MyHostList;
sub addentities {
    my ($self,$top,$entry,$mib,@args) = @_;
    return unless UNIVERSAL::isa($mib, 'MyEntity');
}

# ---------------------------------

# ---------------------------------
package MyMibList;
use strict;
use vars qw(@ISA);
@ISA = qw(MyHList);

#package MyMibList;
sub new {
    my ($type,$parent,$page,$label,$width,@args) = @_;
    $label = 'Browser' unless defined $label;
    $width = 40 unless $width;
    my $self = MyHList::new($type,$parent,$page,$label,$width,@args) || return undef;
    return $self;
}
#package MyMibList;
sub createcmd {
    my ($self,$frame,@args) = @_;
    return if $self->{'created'};
    $self->SUPER::createcmd($frame,@args);
    my $top = $self->{'hlist'};
    $top->header('configure', 0, -text=>'Name',);
    $top->header('configure', 1, -text=>'Syntax/Value',);
    $top->header('configure', 2, -text=>'Units',);
    $self->{'dragdrop'} = $top->DragDrop(
	-sitetypes=>[qw/XDND Sun Local/],
	-startcommand=>[ sub {
	    return 1 if ($::dragobj);
	    my ($token,$e) = @_;
	    my $top = $token->parent;
	    return 1 unless $top->{'armed'};
	    delete $top->{'armed'};
	    my $entry = $top->nearest($e->y);
	    my $obj = $top->entrycget($entry, -data);
	    if (UNIVERSAL::isa($obj,'MyObject')) {
		$token->configure(
		    -text=>$obj->{'label'},
		    -image=>$top->indicator('cget',$entry,'-image'),
		);
	    } elsif (UNIVERSAL::isa($obj, 'MyData')) {
		my $oid = $obj->id;
		$oid =~ s/^.*://;
		$token->configure(
		    -text=>$oid,
		    -image=>undef,
		);
	    } elsif (UNIVERSAL::isa($obj, 'MyEntry')) {
		my $oid = $obj->id;
		$oid =~ s/^.*://;
		$token->configure(
		    -text=>$oid,
		    -image=>undef,
		);
	    } else {
		return 1;
	    }
	    $::dragobj = $obj;
	    return 0;
	} ],
	-endcommand=>[ sub {
	    $::dragobj = undef;
	} ],
	#-predropcommand=>[ sub { my ($seln,$site) = @_; return 1; } ],
	#-postdropcommand=>[ sub { my ($seln) = @_; return; } ],
	-delta=>8,
	-cursor=>'question_arrow',
	#-handlers=>
	#-selection=>'PRIMARY', #-selection=>'XdndSelection',
	#-event=>'<B1-Motion>',
    );
    $self->{'base'} = [ '.1' ];	# the oid subtree to map
    $self->{'root'} = [ MyObject->new($self->tree, $self->{'base'}->[0]) ];
    $self->updatelabel('iso');
    $self->{'root'}->[0]->newchild($top,undef);
    $self->{'created'} = 1;
    if ($self->{'needreconstruct'}) {
	$self->reconstruct($self->{'data'});
    }
    return $self;
}
#package MyMibList;
sub raisecmd {
    my ($self,$frame,@args) = @_;
    $self->SUPER::raisecmd($frame,@args);
}
#package MyMibList;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    unless ($self->{'created'}) {
	$self->{'needreconstruct'} = 1;
	return;
    }
    $self->{'hlist'}->delete('all'); # toast entire tree
    $self->{'base'} = $data->{'base'};
    $self->{'root'} = [];
    foreach (@{$data->{'root'}}) {
	push @{$self->{'root'}}, MyObject::construct($self->tree,$_,@args);
    }
    $self->updatelabel($self->{'root'}->[0]->{'label'});
    $self->{'anchors'} = $data->{'anchors'};
    $self->{'selection'} = $self->{'root'}->[0];
    if ($data->{'selection'}) {
	$self->{'selection'} = $self->{'tree'}->{'objects'}->{$data->{'selection'}};
	$self->{'selection'} = $self->{'root'}->[0] unless $self->{'selection'};
    }
    $self->rebuildfind($self->{'selection'},undef,@{$self->{'root'}});
}

#package MyMibList;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyMibList->new($parent,$data->{'page'},$data->{'label'},$data->{'width'},@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyMibList;
sub createobject {
    my ($self,$oid,@args) = @_;
    return MyObject->new($self->tree,$oid);
}

#package MyMibList;
sub setselectionhlist {
    my ($self,$entry) = @_;
    my $top = $self->{'hlist'};
    $self->clearactive($top);
    my $mib = $top->entrycget($entry, -data);
    $self->{'selected'} = $entry;
    my $m = $self->getpopup;
    if (@{$self->{'anchors'}}) {
	$m->entryconfigure('Unanchor',
	    -state=>'normal',);
	$m->entryconfigure('Anchor Parent',
	    -state=>'normal',);
    } else {
	$m->entryconfigure('Unanchor',
	    -state=>'disabled',);
	$m->entryconfigure('Anchor Parent',
	    -state=>'disabled',);
    }
    if (UNIVERSAL::isa($mib, 'MyObject')) {
	if ($entry !~ /\./) {
	    $m->entryconfigure('Hide',
		-state=>'disabled',);
	    $m->entryconfigure('Anchor',
		-state=>'disabled',);
	} else {
	    $m->entryconfigure('Anchor',
		-state=>'normal',);
	    $m->entryconfigure('Hide',
		-state=>'normal',);
	}
	if (@{$mib->{'mib'}->{'children'}}) { # might not be populated
	    $m->entryconfigure('Expand All',
		-state=>'normal',);
	    $m->entryconfigure('Collapse All',
		-state=>'normal',);
	    $m->entryconfigure('Edit',
		-state=>'disabled',);
	    $m->entryconfigure('Get',
		-state=>'disabled',);
	    $m->entryconfigure('Table Edit',
		-state=>'normal',);
	    $m->entryconfigure('Scalars Edit',
		-state=>'normal',);
	    $m->entryconfigure('Walk',
		-state=>'normal',);
	    $m->entryconfigure('Add Scalars',
		-state=>'normal',);
	    $m->entryconfigure('Add Tables',
		-state=>'normal',);
	    $m->entryconfigure('Add Objects',
		-state=>'normal',);
	    if ($mib->{'hiddenchildren'}) {
		$m->entryconfigure('Unhide',
		    -state=>'normal',);
	    } else {
		$m->entryconfigure('Unhide',
		    -state=>'disabled',);
	    }
	} else {
	    $m->entryconfigure('Unhide',
		-state=>'disabled',);
	    $m->entryconfigure('Expand All',
		-state=>'disabled',);
	    $m->entryconfigure('Collapse All',
		-state=>'disabled',);
	    $m->entryconfigure('Table Edit',
		-state=>'disabled',);
	    $m->entryconfigure('Scalars Edit',
		-state=>'disabled',);
	    $m->entryconfigure('Add Scalars',
		-state=>'disabled',);
	    $m->entryconfigure('Add Tables',
		-state=>'disabled',);
	    $m->entryconfigure('Add Objects',
		-state=>'disabled',);
	    if (!$mib->{'access'} or $mib->{'access'} =~ /NoAccess|Notify/) {
		$m->entryconfigure('Edit',
		    -state=>'disabled',);
		$m->entryconfigure('Get',
		    -state=>'disabled',);
		$m->entryconfigure('Walk',
		    -state=>'disabled',);
	    } elsif ($mib->{'access'} eq 'ReadOnly') {
		$m->entryconfigure('Edit',
		    -state=>'disabled',);
		$m->entryconfigure('Get',
		    -state=>'normal',);
		$m->entryconfigure('Walk',
		    -state=>'normal',);
	    } else {
		$m->entryconfigure('Edit',
		    -state=>'normal',);
		$m->entryconfigure('Get',
		    -state=>'normal',);
		$m->entryconfigure('Walk',
		    -state=>'normal',);
	    }
	}
	if (
	    UNIVERSAL::isa($mib,'MyConceptualTable') ||
	    UNIVERSAL::isa($mib,'MyConceptualRow')||
	    UNIVERSAL::isa($mib,'MyConceptualIndex')||
	    UNIVERSAL::isa($mib,'MyConceptualColumn')
	) {
	    $m->entryconfigure('Add Scalars',
		-state=>'disabled',);
	    $m->entryconfigure('Scalars Edit',
		-state=>'disabled',);
	}
	unless (UNIVERSAL::isa($mib,'MyConceptualTable')) {
	    $m->entryconfigure('Table Edit',
		-state=>'disabled',);
	}
    } else {
	$m->entryconfigure('Anchor',
	    -state=>'disabled',);
	$m->entryconfigure('Expand All',
	    -state=>'disabled',);
	$m->entryconfigure('Collapse All',
	    -state=>'disabled',);
	$m->entryconfigure('Edit',
	    -state=>'normal',);
	$m->entryconfigure('Get',
	    -state=>'normal',);
	$m->entryconfigure('Walk',
	    -state=>'disabled',);
	$m->entryconfigure('Table Edit',
	    -state=>'disabled',);
	$m->entryconfigure('Scalars Edit',
	    -state=>'disabled',);
	$m->entryconfigure('Add Scalars',
	    -state=>'disabled',);
	$m->entryconfigure('Add Tables',
	    -state=>'disabled',);
	$m->entryconfigure('Add Objects',
	    -state=>'disabled',);
    }
    $m->entryconfigure('Properties...',
	-state=>'normal',);
    return $m;
}
#package MyMibList;
sub getvalues {
    my ($self,$entry,$mib) = @_;
    my $top = $self->{'hlist'};
    return if UNIVERSAL::isa($mib,'MyData');
    return if UNIVERSAL::isa($mib,'MyEntry');
    return if UNIVERSAL::isa($mib,'MyConceptualIndex');
    my $value = $mib->value;
    return unless $value;
    $self->clearactive($top);
    $top->delete('offspring', $entry);
    if ($mib->newvalues($top,$entry)) {
	$mib->setcolor($top,$entry,'-grn');
    } else {
	$mib->setcolor($top,$entry,'-red');
    }
}
#package MyMibList;
sub populate {
    my ($self,$entry,$mib,@args) = @_;
    my $top = $self->{'hlist'};

    return unless $mib->populate;

    my $e;
    foreach (@{$mib->{'indexes'}},@{$mib->{'children'}}) {
	next unless $_;
	$_->newchild($top,$entry);
    }
}
#package MyMibList;
sub getpopup {
    my ($self,@args) = @_;
    return $self->{'popup'} if $self->{'popup'};
    my $w = $self->{'hlist'};
    my $mb;
    my $m = $w->toplevel->Menu(
	-tearoff=>1,
	-title=>"MIB Entry",
	-type=>'normal',
    );
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'copyobj',\$self->{'selected'}],
	-label=>'Copy',
	-underline=>3,);
    $self->attachballoon($mb,
	-balloonmsg=>'Copy the selection.',
    );
    $w->bind('<Control-c>',[\&MyHList::keyitemaction,$self,'copyobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'pasteobj',\$self->{'selected'}],
	-label=>'Paste',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Paste to the selection.',
    );
    $w->bind('<Control-v>',[\&MyHList::keyitemaction,$self,'pasteobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'findobj',\$self->{'selected'}],
	-label=>'Find...',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Find a mib in the MIB tree.',
    );
    $w->bind('<Key-f>',[\&MyHList::keyitemaction,$self,'findobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'hideobj',\$self->{'selected'}],
	-label=>'Hide',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Hide the selected arc.',
    );
    $w->bind('<Key-h>',[\&MyHList::keyitemaction,$self,'hideobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'unhideobj',\$self->{'selected'}],
	-label=>'Unhide',
	-underline=>4,);
    $self->attachballoon($mb,
	-balloonmsg=>'Unhide all hidden subtending arcs.',
    );
    $w->bind('<Key-d>',[\&MyHList::keyitemaction,$self,'unhideobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'anchorobj',\$self->{'selected'}],
	-label=>'Anchor',
	-underline=>1,);
    $self->attachballoon($mb,
	-balloonmsg=>'Anchor the tree at the current selection.',
    );
    $w->bind('<Key-n>',[\&MyHList::keyitemaction,$self,'anchorobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'anchorparent',\$self->{'selected'}],
	-label=>'Anchor Parent',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Anchor to the parent of the current anchor.',
    );
    $w->bind('<Key-p>',[\&MyHList::keyitemaction,$self,'anchorparent',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'unanchorobj',\$self->{'selected'}],
	-label=>'Unanchor',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Pop current anchor.',
    );
    $w->bind('<Key-u>',[\&MyHList::keyitemaction,$self,'unanchorobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'expandall',\$self->{'selected'}],
	-label=>'Expand All',
	-underline=>1,);
    $self->attachballoon($mb,
	-balloonmsg=>'Expand all subtending arcs.',
    );
    $w->bind('<Key-x>',[\&MyHList::keyitemaction,$self,'expandall',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'collapseall',\$self->{'selected'}],
	-label=>'Collapse All',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Collapse all subtending arcs.',
    );
    $w->bind('<Key-c>',[\&MyHList::keyitemaction,$self,'collapseall',Tk::Ev('y')]);
    $m->add('separator');
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'editobj',\$self->{'selected'}],
	-label=>'Edit',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Edit the selected MIB.',
    );
    $w->bind('<Key-e>',[\&MyHList::keyitemaction,$self,'editobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'getobj',\$self->{'selected'}],
	-label=>'Get',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Get the selected MIB.',
    );
    $w->bind('<Key-g>',[\&MyHList::keyitemaction,$self,'getobj',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'walktree',\$self->{'selected'}],
	-label=>'Walk',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Walk the MIB tree from the selected MIB.',
    );
    $w->bind('<Key-w>',[\&MyHList::keyitemaction,$self,'walktree',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'edittable',\$self->{'selected'}],
	-label=>'Table Edit',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Edit the table corresponding to the selected MIB.',
    );
    $w->bind('<Key-s>',[\&MyHList::keyitemaction,$self,'edittable',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'editscalars',\$self->{'selected'}],
	-label=>'Scalars Edit',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Edit scalar objects corresponding to the selected MIB.',
    );
    $w->bind('<Key-s>',[\&MyHList::keyitemaction,$self,'editscalars',Tk::Ev('y')]);
    $m->add('separator');
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'addscalars',\$self->{'selected'}],
	-label=>'Add Scalars',
	-underline=>4,);
    $self->attachballoon($mb,
	-balloonmsg=>'Add scalars to a newly formed editor page.',
    );
    $w->bind('<Key-s>',[\&MyHList::keyitemaction,$self,'addscalars',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'addtables',\$self->{'selected'}],
	-label=>'Add Tables',
	-underline=>0,);
    $self->attachballoon($mb,
	-balloonmsg=>'Add tables to a newly formed editor page.',
    );
    $w->bind('<Key-a>',[\&MyHList::keyitemaction,$self,'addtables',Tk::Ev('y')]);
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'addobjects',\$self->{'selected'}],
	-label=>'Add Objects',
	-underline=>4,);
    $self->attachballoon($mb,
	-balloonmsg=>'Add objects to a newly formed editor page.',
    );
    $w->bind('<Key-o>',[\&MyHList::keyitemaction,$self,'addobjects',Tk::Ev('y')]);
    $m->add('separator');
    $mb = $m->add('command',
	-command=>[\&MyHList::menuitemaction,$self,'objproperties',\$self->{'selected'}],
	-label=>'Properties...',
	-underline=>0,);
    $w->bind('<Key-p>',[\&MyHList::keyitemaction,$self,'objproperties',Tk::Ev('y')]);
    $self->attachballoon($mb,
	-balloonmsg=>'Display object propoerties.',
    );
    $self->{'popup'} = $m;
    return $self->{'popup'};
}
#package MyMibList;
sub rebuild {
    my ($self,$look,$parent,@objs) = @_;
    my $top = $self->{'hlist'};
    my $found = undef;

    foreach my $obj (@objs) {
	next if UNIVERSAL::isa($obj,'MyData');
	next if UNIVERSAL::isa($obj,'MyEntry');
	my $entry = $obj->newchild($top,$parent);
	$found = $entry if $obj eq $look;
	if (my $value = $obj->value) {
	    next if UNIVERSAL::isa($obj,'MyConceptualIndex');
	    if ($obj->newvalues($top,$entry)) {
		$obj->setcolor($top,$entry,'-grn');
	    } else {
		$obj->setcolor($top,$entry,'-red');
	    }
	} else {
	    foreach (@{$obj->{'indexes'}},@{$obj->{'children'}}) {
		my $e = $self->rebuild($look,$entry,$_);
		$found = $e unless defined $found;
	    }
	}
    }
    return $found;
}

#package MyMibList;
sub edittable {
    my ($self,$top,$entry,$mib,@args) = @_;
    return unless UNIVERSAL::isa($mib, 'MyConceptualTable');
}
#package MyMibList;
sub editscalars {
    my ($self,$top,$entry,$mib,@args) = @_;
    return unless UNIVERSAL::isa($mib, 'MyObject');
    return if (
	UNIVERSAL::isa($mib, 'MyConceptualTable') ||
	UNIVERSAL::isa($mib, 'MyConceptualRow') ||
	UNIVERSAL::isa($mib, 'MyConceptualIndex') ||
	UNIVERSAL::isa($mib, 'MyConceptualColumn')
    );
}
#package MyMibList;
sub createrow {
    my ($self,$top,$entry,$mib,@args) = @_;
    return unless UNIVERSAL::isa($mib, 'MyConceptualRow');
}
#package MyMibList;
sub editobj {
    my ($self,$top,$entry,$obj,@args) = @_;
    return unless UNIVERSAL::isa($obj,'MyObject');
}
#package MyMibList;
sub getobj {
    my ($self,$top,$entry,$obj,@args) = @_;
    return unless UNIVERSAL::isa($obj,'MyObject');
    #FIXME -- need more general method
    $obj->walkvalues($self,$entry);
}
#package MyMibList;
sub walktree {
    my ($self,$top,$entry,$obj,@args) = @_;
    return unless UNIVERSAL::isa($obj,'MyObject');
    #FIXME -- need more general method
    $obj->walkvalues($self,$entry);
}
#package MyMibList;
sub findobj {
    my ($self,$top,$entry,$mib,@args) = @_;
    my $dialog = $self->{'finddialog'};
    my $value = \$self->{'finddialogvalue'};
    unless ($dialog) {
	$dialog = $top->toplevel->DialogBox(
	    -title=>'Search for MIB Object Dialog',
	    -buttons=>[qw/OK Cancel/],
	    -default_button=>'OK',
	);
	$dialog->Label(
	    -text=>"MIB Object Name or OID:",
	)->grid(
	    -row=>0,
	    -column=>0,
	    -sticky=>'ew',
	);
	$dialog->Entry(
	    -textvariable=>$value,
	    -exportselection=>1,
	)->grid(
	    -row=>0,
	    -column=>1,
	    -sticky=>'ew',
	);
	$self->{'finddialog'} = $dialog;
    }
    while (1) {
	if ($dialog->Show eq 'OK') {
	    if ($$value ne '') {
		unless (defined SNMP::translateObj($$value)) {
		    $self->statusmsg("Cannot translate value '$$value'.");
		    $top->toplevel->bell;
		    next;
		}
		unless ($$value =~ /^\./) {
		    $$value = SNMP::translateObj($$value);
		}
		$$value = SNMP::translateObj($$value);
		unless (($mib = $SNMP::MIB{$$value}) ||
		    ($mib = $SNMP::MIB{SNMP::translateObj($$value)})) {
		    $self->statusmsg("Cannot find '$$value' in any MIB.");
		    $top->toplevel->bell;
		    next;
		}
		unless ($mib = MyObject->new($self->tree,$$value)) {
		    $self->statusmsg("Cannot create '$$value' from MIB.");
		    $top->toplevel->bell;
		    next;
		}
		my $parent = $mib;
		my $found;
		while ($parent = $parent->{'parent'}) {
		    $entry =~ s/\.[^\.]*$//; # cut a dot.
		    $parent->populate;
		    if ($parent->{'state'} eq 'c') {
			my @children = $top->info('children', $entry);
			foreach (@children) {
			    my $o = $top->entrycget($_,-data);
			    $top->show('entry',$_) unless $o->{'hidden'};
			    $found = $_ if $o eq $mib;
			}
			$parent->setstate($top,$entry,'o');
			$top->show('entry',$entry);
		    }
		    if ($parent->{'hidden'}) {
			$parent->{'hidden'} = 0;
			$top->show('entry',$entry);
		    }
		}
		return;
	    }
	} else {
	    last;
	}
    }
}

#---------------------------------

#---------------------------------
package MyTop;
use strict;
use vars qw(@ISA);
@ISA = qw(MyMainWindow);

@MyTop::myapps = ();
$MyTop::appnum = 0;

#package MyTop;
sub new {
    my ($type,$filename,$number,@args) = @_;
    my $title = 'OpenSS7 Network Manager';
    $title .= ": $filename" if defined $filename;
    my $appno = defined $number ? $number : $MyTop::appnum;
    my $self = MyMainWindow::new($type,$title,$filename,$appno,@args);
    my $data = $self->{'data'};
    $data->{'recent'} = [];
    $self->{'dirty'} = 'no';
    $data->{'directory'} = '/usr/share/snmp/mibs';
    $data->{'number'} = $appno;
    $data->{'filename'} = $ENV{'HOME'}.'/.snmp/.mibbrowser'.sprintf('%02d',$appno);
    $data->{'filename'} = $filename if defined $filename;
    $self->{'sessions'} = [];
    $self->createmenubar;
    $self->createstatusbar->pack(
	-expand=>0,
	-fill=>'x',
	-side=>'bottom',
	-anchor=>'sw',
    );
    $self->createballoon;
    $self->createbooks;
    push @MyTop::myapps, $self;
    $MyTop::appnum = $appno if $appno > $MyTop::appnum;
    return $self;
}


#package MyTop;
sub dumphash {
    my ($self,@args) = @_;
    my $data = $self->SUPER::dumphash(@args);
    my $w = $self->widget;
    $self->SUPER::dumphash(@args);
    $data->{'books'} = [];
    foreach (@{$self->{'books'}}) {
	push @{$data->{'books'}}, $_->dumphash(@args);
    }
    return $data;
}

#package MyTop;
sub reconstruct {
    my ($self,$data,@args) = @_;
    $self->SUPER::reconstruct($data,@args);
    my $w = $self->widget;
    for (my $i = 0; $i < @{$data->{'books'}}; $i++) {
	if ($self->{'books'}->[$i]) {
	    $self->{'books'}->[$i]->reconstruct($data->{'books'}->[$i],@args);
	}
    }
}

#package MyTop;
sub construct {
    my ($parent,$data,@args) = @_;
    my $self = MyTop::new($data->{'class'},@args);
    $self->reconstruct($data,@args);
    return $self;
}

#package MyTop;
sub addsession {
    my ($self,$session,@args) = @_;
    push @{$self->{'sessions'}}, $session;
}

#package MyTop;
sub delsession {
    my ($self,$session,@args) = @_;
    my $count = @{$self->{'sessions'}};
    for (my $i = 0; $i < $count; $i++) {
	if ($self->{'sessions'}->[$i] eq $session) {
	    splice @{$self->{'sessions'}}, $i, 1;
	    return 1;
	}
    }
    return 0;
}

#package MyTop;
sub loadrecent {
    my ($self,$file) = @_;
}

#package MyTop;
sub storefile {
    my $self = shift;
    my $data = $self->{'data'};
    while ($self->{'dirty'} eq 'yes') {
	my $d = $self->widget->Dialog(
	    -title=>'Are you sure?',
	    -text=>'Changes will be lost: are you sure?',
	    -default_button=>'Cancel',
	    -buttons=>[ 'Discard', 'Cancel', 'Save' ],
	);
	my $answer = $d->Show;
	$d->destroy;
	if ($answer eq 'Cancel') {
	    return 'Cancel';
	} elsif ($answer eq 'Save') {
	    $self->save;
	    next;
	} elsif ($answer eq 'Discard') {
	    return 'Discard';
	} else {
	    return 'Discard';
	}
    }
    return 'Saved';
}

#package MyTop;
sub somedialog {
    shift->{'Dialog'}->Show;
}

#package MyTop;
sub destroyed {
    my ($self,$mw,@args) = @_;
    $self->SUPER::destroyed($mw,@args);
    if (UNIVERSAL::isa($mw, 'Tk::MainWindow')) {
	for (my $i; $i < @MyTop::myapps; $i++) {
	    if ($MyTop::myapps[$i] eq $self) {
		splice @MyTop::myapps, $i, 1;
		last;
	    }
	}
    }
}

#package MyTop;
sub prefsok {
    my ($self,$nb) = @_;
    $nb->destroy;
    return;
}

#package MyTop;
sub prefsaccept {
    my ($self,$nb) = @_;
    $nb->destroy;
    return;
}

#package MyTop;
sub prefscancel {
    my ($self,$nb) = @_;
    $nb->destroy;
    return;
}

sub createmenubar {
    my $self = shift;
    my $w = $self->widget;
    my ($mb,$mi,$mc);
    $mb = $self->{'MenuBar'} = $w->Menu(
	-type=>'menubar',
    );
    $w->configure(-menu=>$mb);
    $self->{'Dialog'} = $self->toplevel->Dialog(
	-buttons=>[qw/Ok Cancel Help/],
	-default_button=>'Cancel',
	-text=>'Please input the MIB to load.',
	-title=>'MIB Selection',
    );
    $mi = $self->{'FileMenu'} = $mb->Menu(
	-tearoff=>1,
	-title=>'File Menu',
	-type=>'normal',
    );
    $mi->add('command',
	-label=>'New',
	-underline=>0,
	-command=>[\&MyTop::menuFileNew,$self],
    );
    $mi->add('command',
	-label=>'Read...',
	-underline=>0,
	-command=>[\&MyTop::menuFileRead,$self],
    );
    $mi->add('command',
	-label=>'Open...',
	-underline=>0,
	-command=>[\&MyTop::menuFileOpen,$self],
    );
    $mi->add('command',
	-label=>'Save',
	-underline=>0,
	-command=>[\&MyTop::menuFileSave,$self],
    );
    $mi->add('command',
	-label=>'Save As...',
	-underline=>5,
	-command=>[\&MyTop::menuFileSaveAs,$self],
    );
    $mi->add('command',
	-label=>'Close',
	-underline=>0,
	-command=>[\&MyTop::menuFileClose,$self],
    );
    $mi->add('separator');
    $mi->add('command',
	-label=>'Properties...',
	-underline=>0,
	-command=>[\&MyTop::menuFileProperties,$self],
    );
    $mi->add('separator');
    $mi->add('command',
	-label=>'Load MIB',
	-underline=>0,
	-command=>[\&MyTop::menuFileLoadMib,$self],
    );
    $mi->add('command',
	-label=>'Unload MIB',
	-underline=>0,
	-command=>[\&MyTop::menuFileUnloadMib,$self],
    );
    $mc = $mi->Menu(
	-tearoff=>1,
	-title=>'Recent Files',
    );
    $mi->add('cascade',
	-menu=>$mc,
	-label=>'Recent MIBs...',
	-underline=>0,
	-state=>'disabled',
    );
    $self->{'RecentMenu'} = $mc;
    $mi->add('separator');
    $mi->add('command',
	-label=>'Exit All',
	-underline=>1,
	-command=>[\&MyTop::menuFileExitAll,$self],
    );
    $mi->add('command',
	-label=>'Debug Dump',
	-underline=>1,
	-command=>[sub { 
	    my $parent = shift->{'FileMenu'};
	    my $w;
	    while ($w = $parent) {
		$parent = $w->parent;
		print $w;
		foreach (@{$w->configure}) {
		    print "Option: ".join(', ',@$_);
		}
	    }
	}, $self],
    );
    $mb->add('cascade',
	-menu=>$mi,
	-label=>'File',
	-underline=>0,
    );
    $self->{'FileMenu'} = $mi;

    $mi = $mb->Menu(
	-tearoff=>1,
	-title=>'Edit Menu',
    );
    $mi->add('command',
	-label=>'Undo',
	-underline=>0,
	-state=>'disabled',
	-command=>[\&MyTop::menuEditUndo,$self],
    );
    $mi->bind('all', '<Control-u>', sub { return; });
    $mi->add('command',
	-label=>'Redo',
	-underline=>0,
	-state=>'disabled',
	-command=>[\&MyTop::menuEditRedo,$self],
    );
    $mi->bind('all', '<Control-r>', sub { return; });
    $mi->add('separator');
    $mi->add('command',
	-label=>'Cut',
	-underline=>0,
	-state=>'normal',
	-command=>[\&MyTop::menuEditCut,$self],
    );
    $mi->bind('all', '<Control-x>', sub { return; });
    $mi->add('command',
	-label=>'Copy',
	-underline=>3,
	-state=>'normal',
	-command=>[\&MyTop::menuEditCopy,$self],
    );
    $mi->bind('all', '<Control-c>', sub { return; });
    $mi->add('command',
	-label=>'Paste',
	-underline=>0,
	-state=>'disabled',
	-command=>[\&MyTop::menuEditPaste,$self],
    );
    $mi->bind('all', '<Control-v>', sub { return; });
    $mi->add('separator');
    $mi->add('command',
	-label=>'Delete',
	-underline=>0,
	-state=>'normal',
	-command=>[\&MyTop::menuEditDelete,$self],
    );
    $mi->bind('all', '<Delete>', sub { return; });
    $mi->add('separator');
    $mi->add('command',
	-label=>'Preferences...',
	-underline=>1,
	-state=>'normal',
	-command=>[\&MyTop::menuEditPreferences,$self],
    );
    $mb->add('cascade',
	-label=>'Edit',
	-menu=>$mi,
	-underline=>0,
    );
    $self->{'EditMenu'} = $mi;

    $mi = $mb->Menu(
	-tearoff=>1,
	-title=>'View Menu',
    );
    $mi->add('command',
	-label=>'Expand All',
	-underline=>0,
	-state=>'disabled',
	-command=>[\&MyTop::menuViewExpandAll,$self],
    );
    $mi->add('command',
	-label=>'Collapse All',
	-underline=>0,
	-state=>'disabled',
	-command=>[\&MyTop::menuViewCollapseAll,$self],
    );
    $mb->add('cascade',
	-label=>'View',
	-menu=>$mi,
	-underline=>0,
    );
    $self->{'ViewMenu'} = $mi;

    $mi = $mb->Menu(
	-tearoff=>1,
	-title=>'Mib Menu',
    );
    $mi->add('command',
	-label=>'Add MIB Directory',
	-underline=>0,
	-command=>[\&MyTop::menuMibAddDirectory,$self],
    );
    $mi->add('command',
	-label=>'Load MIB Module',
	-underline=>0,
	-command=>[\&MyTop::menuMibLoadModule,$self],
    );
    $mi->add('command',
	-label=>'Load MIB File',
	-underline=>9,
	-command=>[\&MyTop::menuMibLoadFile,$self],
    );
    $mi->add('separator');
    $mc = $mi->Menu(
	-tearoff=>1,
	-title=>'MIB Directories',
    );
    $mi->add('cascade',
	-label=>'MIB Directories',
	-menu=>$mc,
	-state=>'disabled',
	-underline=>4,
    );
    $self->{'MibDirs'} = $mc;
    $mc = $mi->Menu(
	-tearoff=>1,
	-title=>'MIB Modules',
    );
    $mi->add('cascade',
	-label=>'MIB Modules',
	-menu=>$mc,
	-state=>'disabled',
	-underline=>4,
    );
    $self->{'MibMods'} = $mc;
    $mc = $mi->Menu(
	-tearoff=>1,
	-title=>'MIB Files',
    );
    $mi->add('cascade',
	-label=>'MIB Files',
	-menu=>$mc,
	-state=>'disabled',
	-underline=>4,
    );
    $self->{'MibFiles'} = $mc;
    $mb->add('cascade',
	-label=>'MIBs',
	-menu=>$mi,
	-underline=>0,
    );
    $self->{'MibMenu'} = $mi;

    $mi = $mb->Menu(
	-tearoff=>1,
	-title=>'About',
	-type=>'normal',
    );
    $mi->add('command',
	-label=>'Version',
	-underline=>0,
	-command=>[\&MyTop::menuAboutVersion,$self],
    );
    $mi->add('command',
	-label=>'Usage',
	-underline=>0,
	-command=>[\&MyTop::menuAboutUsage,$self],
    );
    $mi->add('command',
	-label=>'Copying',
	-underline=>0,
	-command=>[\&MyTop::menuAboutCopying,$self],
    );
    $mi->add('command',
	-label=>'Help',
	-underline=>0,
	-command=>[\&MyTop::menuAboutHelp,$self],
    );
    $mb->add('separator');
    $mb->add('cascade',
	-menu=>$mi,
	-label=>'About',
	-underline=>0,
    );
    $self->{'About'} = $mi;
    $self->{'Menu'} = $mb;
    return $mb;
}

sub createstatusbar {
    my $self = shift;
    my $sb = $self->toplevel->Message(
	-text=>"Status bar.",
	-justify=>'left',
	-width=>400,
	-anchor=>'w',
    );
    $self->{'Message'} = $sb;
    return $sb;
}

sub createballoon {
    my $self = shift;
    $_ = $self->{'Balloon'} = $self->toplevel->Balloon(
	#-initwait=>1000,
	-statusbar=>$self->{'Message'},
    );
    $::balloonwidget = $_;
    return $_;
}

sub createbook {
    my ($self,$width,@args) = @_;
    my $book = MyNoteBook->new($self,$width,@args);
    if (@{$self->{'books'}}) {
	my $prev = $self->{'books'}->[-1]->frame;
	$self->widget->Adjuster(
	    -side=>'left',
	    -widget=>$prev,
	    -restore=>0,
	)->pack(
	    -expand=>0,
	    -fill=>'y',
	    -side=>'left',
	    -anchor=>'w',
	);
	$book->frame->pack(
	    -expand=>1,
	    -fill=>'both',
	    -side=>'left',
	    -anchor=>'e',
	);
    } else {
	$book->frame->pack(
	    -expand=>1,
	    -fill=>'both',
	    -side=>'left',
	    -anchor=>'center',
	);
    }
    push @{$self->{'books'}}, $book;
    return $book;
}

sub createbooks {
    my $self = shift;
    $self->{'books'} = [];
    my $book1 = $self->createbook(200);
    my $book2 = $self->createbook(300);
    my $book3 = $self->createbook(524);
    $book1->newpage(undef,'MyHostList',undef,16);
    $book2->newpage(undef,'MyMibList',undef,45);
    $book3->newpage(undef,'MyROText',undef,80);
}

#package MyTop;
sub attachballoon {
    my ($self,@args) = @_;
    return $self->{'Balloon'}->attach(@args) if $self->{'Balloon'};
}

#package MyTop;
sub statusmsg {
    my ($self,$msg) = @_;
    $self->{'Message'}->configure(-text=>$msg) if $self->{'Message'};
    printf STDERR "$msg\n";
}

#package MyTop;
sub addscalars {
    my ($self,@args) = @_;
    return $self->{'books'}->[-1]->addscalars(@args);
}

#package MyTop;
sub addtables {
    my ($self,@args) = @_;
    return $self->{'books'}->[-1]->addtables(@args);
}

#package MyTop;
sub addobjects {
    my ($self,@args) = @_;
    return $self->{'books'}->[1]->addobjects(@args);
}

#package MyTop;
sub rotext {
    my ($self,@args) = @_;
    my $rotext;
    for (my $i = -1; defined $self->{'books'}->[$i]; $i--) {
	$rotext = $self->{'books'}->[$i]->rotext(@args);
	return $rotext if $rotext;
    }
    return $rotext;
}

#package MyTop;
sub menuFileNew {
    MyTop->new;
}

#package MyTop;
sub menuFileOpen {
    my $self = shift;
    my $data = $self->{'data'};
    my $file = $ENV{'HOME'}.'/.snmp/.mibbrowser'.sprintf('%02d',$MyTop::appnum);
    my $idir = $file; $idir =~ s/\/[^\/]*$//;
    my $ifil = $file; $ifil =~ s/^.*\///;
    $file = $self->widget->getOpenFile(
	-defaultextension=>'.dat',
	-initialdir=>$idir,
	-initialfile=>$ifil,
	-title=>'Open Dialog',
    );
    return unless $file;
    my $base = $file; $base =~ s/^.*\///;
    if (-r $file) {
	my $hash;
	if ($hash = Storable::lock_retrieve($file)) {
	    my $app = MyTop->new($file);
	    my $appdata = $app->{'data'};
	    $app->reconstruct($hash);
	    $appdata->{'filename'} = $file;
	    $app->{'data'} = $appdata;
	    $app->{'dirty'} = 'no';
	    return;
	} else {
	    my $d = $self->widget->Dialog(
		-title=>'Could not read file.',
		-text=>"File $base could not be read!",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	}
    } else {
	if (-e $file) {
	    my $d = $self->widget->Dialog(
		-title=>'Permission denied.',
		-text=>"File $base is not readable for you!",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	} else {
	    my $d = $self->widget->Dialog(
		-title=>'File does not exist?',
		-text=>"File $base does not exist!",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	}
    }
}

#package MyTop;
sub menuFileRead {
    my $self = shift;
    my $data = $self->{'data'};
    my $result = $self->storefile;
    return if $result eq 'Cancel';
    my $file = $data->{'filename'} ||
    $ENV{'HOME'}.'/.snmp/.mibbrowser'.$data->{'number'};
    my $idir = $file; $idir =~ s/\/[^\/]*$//;
    my $ifil = $file; $ifil =~ s/^.*\///;
    $file = $self->widget->getOpenFile(
	-defaultextension=>'.dat',
	-initialdir=>$idir,
	-initialfile=>$ifil,
	-title=>'Read Dialog',
    );
    return unless $file;
    my $base = $file; $base =~ s/^.*\///;
    if (-r $file) {
	my $hash;
	if ($hash = Storable::lock_retrieve($file)) {
	    $self->reconstruct($hash);
	    $data->{'filename'} = $file;
	    $self->{'data'} = $data;
	    $self->{'dirty'} = 'no';
	    return;
	} else {
	    my $d = $self->widget->Dialog(
		-title=>'Could not read file.',
		-text=>"File $base could not be read!",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	}
    } else {
	if (-e $file) {
	    my $d = $self->widget->Dialog(
		-title=>'Permission denied.',
		-text=>"File $base is not readable for you!",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	} else {
	    my $d = $self->widget->Dialog(
		-title=>'File does not exist?',
		-text=>"File $base does not exist!",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	}
    }
}

#package MyTop;
sub menuFileSave {
    my $self = shift;
    my $data = $self->{'data'};
    my $file = $data->{'filename'};
    return $self->menuFileSaveAs unless $file;
    my $base = $file; $base =~ s/^.*\///;
    if (-e $file) {
	my $d = $self->widget->Dialog(
	    -title=>'Are you sure?',
	    -text=>"File $base already exists: are you sure that you want to overwrite it?",
	    -default_button=>'Cancel',
	    -buttons=>[ qw/Save Cancel Help/ ],
	);
	my $answer = $d->Show;
	$d->destroy;
	return unless $answer eq 'Save';
	if (not -w $file) {
	    $d = $self->widget->Dialog(
		-title=>'Permission denied.',
		-text=>"You do not have permission to write to $base.",
		-default_button=>'Ok',
		-buttons=>[ 'Ok' ],
	    );
	    $d->Show;
	    $d->destroy;
	    return $self->menuFileSaveAs;
	}
    }
    my $hash = $self->dumphash;
    #print $xml->XMLout($hash);

    if (Storable::lock_nstore($hash, $file)) {
	$self->{'dirty'} = 'no';
    } else {
	my $d = $self->widget->Dialog(
	    -title=>'Write failed.',
	    -text=>"Could not write to $base.",
	    -default_button=>'Ok',
	    -buttons=>[ 'Ok' ],
	);
	$d->Show;
	$d->destroy;
    }
}

#package MyTop;
sub menuFileSaveAs {
    my $self = shift;
    my $data = $self->{'data'};
    my $file = $self->{'data'}->{'filename'} || $ENV{'HOME'}.'/.snmp/.mibbrowser';
    my $idir = $file;
    $idir =~ s/\/[^\/]*$//;
    my $ifil = $file;
    $ifil =~ s/^.*\///;
    $file = $self->widget->getSaveFile(
	-defaultextension=>'.dat',
	-initialdir=>$idir,
	-initialfile=>$ifil,
	-title=>'Save As Dialog',
    );
    if ($file) {
	my $base = $file; $base =~ s/^.*\///;
	if (-e $file) {
	    my $d = $self->widget->Dialog(
		-title=>'Are you sure?',
		-text=>"File $base already exists: are you sure that you want to overwrite it?",
		-default_button=>'Cancel',
		-buttons=>[ qw/Save Cancel Help/ ],
	    );
	    my $answer = $d->Show;
	    $d->destroy;
	    return unless $answer eq 'Save';
	    if (not -w $file) {
		$d = $self->widget->Dialog(
		    -title=>'Permission denied.',
		    -text=>"You do not have permission to write to $base.",
		    -default_button=>'Ok',
		    -buttons=>[ 'Ok' ],
		);
		$d->Show;
		$d->destroy;
		return $self->menuFileSaveAs;
	    }
	}
	my $hash = $self->dumphash;
	#print $xml->XMLout($hash);

	if (Storable::lock_nstore($hash, $file)) {
	    $data->{'filename'} = $file;
	    $self->{'dirty'} = 'no';
	} else {
		my $d = $self->widget->Dialog(
		    -title=>'Write failed.',
		    -text=>"Could not write to $base.",
		    -default_button=>'Ok',
		    -buttons=>[ 'Ok' ],
		);
		$d->Show;
		$d->destroy;
	}
    }
}

#package MyTop;
sub menuFileClose {
    my $self = shift;
    my $data = $self->{'data'};
    my $result = $self->storefile;
    return if $result eq 'Cancel';
    if (scalar(@MyTop::myapps) > 1) {
	$self->widget->destroy;
    } else {
	$data->{'recent'} = [];
	$data->{'filename'} = undef;
	$data->{'directory'} = '/usr/share/snmp/mibs';
	$self->{'dirty'} = 'no';
    }
}

#package MyTop;
sub menuFileProperties {
    my $self = shift;
}

#package MyTop;
sub menuFileLoadMib {
    my $self = shift;
    my $data = $self->{'data'};
    my @temp = ();
    my $file = $self->widget->getOpenFile(
	-defaultextension=>'.mib',
	-initialdir=>'/home/brian/.snmp/mibs',
	-initialfile=>$data->{'filename'},
	-title=>'Load MIB Dialog',
	-type=>'open',
    );
    if ($file) {
	$data->{'directory'} = $file;
	$data->{'directory'} =~ s/\/[^\/]*$//;
	foreach my $f ( @{$data->{'recent'}} ) {
	    push @temp, $f unless $f eq $file;
	}
	push @temp, $file;
	$data->{'recent'} = [ @temp ];
	$self->{'RecentMenu'}->delete(0, 'last');
	while (my $f = pop @temp) {
	    $self->{'RecentMenu'}->add('command',
		-command=>[ \&loadrecent, $self, $f ],
		-label=>$f,
	    );
	}
	$self->{'FileMenu'}->entryconfigure('Recent MIBs...',
	    -state=>'normal',
	);
    }
    return;
}

#package MyTop;
sub menuFileUnloadMib {
    my $self = shift;
}

#package MyTop;
sub menuFileExitAll {
    my $self = shift;
    foreach my $s (@MyTop::myapps) {
	$s->widget->destroy;
    }
}

#package MyTop;
sub menuEditUndo {
    my $self = shift;
}

#package MyTop;
sub menuEditRedo {
    my $self = shift;
}

#package MyTop;
sub menuEditCut {
    my $self = shift;
}

#package MyTop;
sub menuEditCopy {
    my $self = shift;
}

#package MyTop;
sub menuEditPaste {
    my $self = shift;
}

#package MyTop;
sub menuEditDelete {
    my $self = shift;
}

#package MyTop;
sub menuViewExpandAll {
    my $self = shift;
}

#package MyTop;
sub menuViewCollapseAll {
    my $self = shift;
}

#package MyTop;
sub menuEditPreferences {
    my $self = shift;
    my $data = $self->{'data'};
    my $tl = $self->widget->Toplevel;
    $tl->title('Preferences');
    my $nb = $tl->NoteBook(
	-dynamicgeometry=>1,
	-backpagecolor=>'white',
	-focuscolor=>'black',
    )->pack(
	-side=>'top',
	-fill=>'x',
	-expand=>0,
    );
    my $f = $tl->Frame(
    )->pack(
	-side=>'top',
	-fill=>'x',
	-expand=>0,
    );
    my $b = $f->Button(
	-text=>'OK',
	-default=>'active', 
	-command=>[ \&prefsok, $self, $tl ],
    )->grid(
	-row=>0,
	-column=>0,
    );
    $b = $f->Button(
	-text=>'Accept',
	-command=>[ \&prefsaccept, $self, $tl ],
    )->grid(
	-row=>0,
	-column=>1,
    );
    $b = $f->Button(
	-text=>'Cancel',
	-command=>[ \&prefscancel, $self, $tl ],
    )->grid(
	-row=>0,
	-column=>2,
    );
}

#package MyTop;
sub menuMibAddDirectory {
    my $self = shift;
    my $dir = $self->widget->chooseDirectory(
	-initialdir=>'/home/brian/.snmp/mibs',
	-parent=>$self->widget,
	-title=>'Add MIB Directory',
	#-mustexist=>1,
    );
    if ($dir) {
	if ($dir ne '') {
	    SNMP::addMibDirs($dir);
	    $self->{'needupdate'} = 1;
	}
    }
}

#package MyTop;
sub menuMibLoadModule {
    my $self = shift;
    my $dialog = $self->widget->DialogBox(
	-title=>'Load MIB Module Dialog',
	-buttons=>[qw/OK Cancel/],
	-default_button=>'OK',
    );
    my $value = '';
    $dialog->Label(
	-text=>"MIB Module Name:",
    )->grid(
	-row=>0,
	-column=>0,
	-sticky=>'ew',
    );
    $dialog->Entry(
	-textvariable=>\$value,
	-exportselection=>1,
    )->grid(
	-row=>0,
	-column=>1,
	-sticky=>'ew',
    );
    if ($dialog->Show eq 'OK') {
	if ($value ne '') {
	    SNMP::loadModules($value);
	    $self->{'needupdate'} = 1;
	}
    }
}

#package MyTop;
sub menuMibLoadFile {
    my $self = shift;
    my $filename = $self->widget->getOpenFile(
	-defaultextension=>'.mib',
	-initialdir=>'/home/brian/.snmp/mibs',
	-title=>'Load MIB Dialog',
    );
    if ($filename) {
	SNMP::addMibFiles($filename);
	$self->{'needupdate'} = 1;
    }
}

#package MyTop;
sub menuAboutVersion {
    my $self = shift;
    my $dialog = $self->widget->DialogBox(
	-title=>'Program Version',
	-default_button=>'Dismiss',
	-buttons=>[qw/Dismiss/],
    );
    $dialog->resizable(0,0);
    $dialog->iconimage('icon');
    $dialog->iconname($title);
    $dialog->Label(
	-image=>'icon',
	-text=>$Title,
	-compound=>'left',
	-justify=>'left',
    )->pack(
	-side=>'top',
	-fill=>'x',
	-expand=>0,
    );
    my $lines = $Version;
    $lines =~ s/[^\n]//g;
    $lines = length($lines) + 1;
    my $text = $dialog->Scrolled('ROText',
	-scrollbars=>'onow',
	-wrap=>'word',
	-height=>$lines,
    )->pack(
	-side=>'top',
	-fill=>'both',
	-expand=>1,
    );
    $text->insert('0.0', $Version);
    $dialog->Show;
}

#package MyTop;
sub menuAboutUsage {
    my $self = shift;
    my $dialog = $self->widget->DialogBox(
	-title=>'Program Copying Conditions',
	-default_button=>'Accept',
	-buttons=>[qw/Accept Refuse/],
    );
    $dialog->resizable(0,0);
    $dialog->iconimage('icon');
    $dialog->iconname($title);
    $dialog->Label(
	-image=>'icon',
	-text=>$Title,
	-compound=>'left',
	-justify=>'left',
    )->pack(
	-side=>'top',
	-fill=>'x',
	-expand=>0,
    );
    my $lines = $Usage;
    $lines =~ s/[^\n]//g;
    $lines = length($lines) + 1;
    my $tx = $dialog->Scrolled('ROText',
	-scrollbars=>'onow',
	-wrap=>'word',
	-height=>$lines,
    )->pack(
	-side=>'top',
	-fill=>'both',
	-expand=>1,
    );
    $tx->insert('0.0', $Usage);
    exit 0 if ($dialog->Show eq 'Refuse');
}

#package MyTop;
sub menuAboutCopying {
    my $self = shift;
    my $dialog = $self->widget->DialogBox(
	-title=>'Program Copying Conditions',
	-default_button=>'Accept',
	-buttons=>[qw/Accept Refuse/],
    );
    $dialog->resizable(0,0);
    $dialog->iconimage('icon');
    $dialog->iconname($title);
    $dialog->Label(
	-image=>'icon',
	-text=>$Title,
	-compound=>'left',
	-justify=>'left',
    )->pack(
	-side=>'top',
	-fill=>'x',
	-expand=>0,
    );
    my $lines = $Copying;
    $lines =~ s/[^\n]//g;
    $lines = length($lines) + 1 + 15;
    my $tx = $dialog->Scrolled('ROText',
	-scrollbars=>'onow',
	-wrap=>'word',
	-height=>$lines,
    )->pack(
	-side=>'top',
	-fill=>'both',
	-expand=>1,
    );
    $tx->insert('0.0', $Copying);
    exit 0 if ($dialog->Show eq 'Refuse');
}

#package MyTop;
sub menuAboutHelp {
    my $self = shift;
    my $dialog = $self->widget->DialogBox(
	-title=>'Help',
	-default_button=>'Dismiss',
	-buttons=>[qw/Dismiss/],
    );
    $dialog->resizable(0,0);
    $dialog->iconimage('icon');
    $dialog->iconname($title);
    $dialog->Label(
	-image=>'icon',
	-text=>$Title,
	-compound=>'left',
	-justify=>'left',
    )->pack(
	-side=>'top',
	-fill=>'x',
	-expand=>0,
    );
    my $lines = $Help;
    $lines =~ s/[^\n]//g;
    $lines = length($lines) + 1 + 5;
    my $tx = $dialog->Scrolled('ROText',
	-scrollbars=>'onow',
	-wrap=>'word',
	-height=>$lines,
    )->pack(
	-side=>'top',
	-fill=>'both',
	-expand=>1,
    );
    $tx->insert('0.0', $Help);
    $dialog->Show;
}

#package MyTop;
sub objprops {
    my ($self,$place,$obj,$entry,@args) = @_;
    my ($mib,$extra);
    if (UNIVERSAL::isa($obj,'MyData')) {
	$mib = $obj->{'parent'}->{'mib'};
	$extra = 'values of ';
    } elsif (UNIVERSAL::isa($obj,'MyEntry')) {
	$mib = $obj->value->{'mib'};
	$extra = 'values of ';
    } elsif (UNIVERSAL::isa($obj,'MyObject')) {
	$mib = $obj;
	$extra = '';
    } else {
	warn "ERROR: properties requested for unknown class ".ref($obj);
	return;
    }
    my $widget = $place->widget;
    my $e = $widget->XEvent;
    my $tl = $place->widget->Toplevel(
	-title=>'Properties of '.$extra.$mib->{'label'},
    );
    $tl->MoveToplevelWindow($e->X+3,$e->Y+3) if $e;
    $tl->resizable(0,0);
    $tl->iconimage('icon');
    $tl->iconname($title);
    my $tx = $tl->Scrolled('ROText',
	-scrollbars=>'onow',
	-width=>80,
	-wrap=>'none',
    )->pack(
	-expand=>1,
	-fill=>'both',
	-side=>'top',
    );
    $tx->{_private} = {};
    my $w = $tx->Subwidget('scrolled');
    my $dropsite = $w->DropSite(
	-droptypes=>[qw/XDND Sun Local/],
	-dropcommand=>[sub {
	    my ($self,$tx,$seln,$action,$targets,$xo,$yo,@args) = @_;
	    if ($action eq 'LocalDrop' || $::dragobj) {
		$tx->delete('0.0', 'end');
		$tx->insert('end', $::dragobj->detail);
	    } else {
		if (my $oid = $tx->toplevel->SelectionGet(-selection=>$seln)) {
		    chomp $oid;
		    $oid =~ s/(\s|\n)*$//;
		    if (my $mib = MyObject->new($self->tree, $oid)) {
			$tx->delete('0.0', 'end');
			$tx->insert('end', $mib->detail);
		    }
		}
	    }
	}, $self, $tx],
    );
    $tx->{_private}->{'dropsite'} = $dropsite;
    my $bt = $tl->Button(
	-text=>'Dismiss',
	-default=>'active',
	-command=>[ sub {
	    my $w = shift;
	    $w->destroy;
	    return;
	}, $tl ],
    )->pack(
	-expand=>0,
	-fill=>'none',
	-side=>'bottom',
    );
    $tx->delete('0.0', 'end');
    $tx->insert('end', $obj->detail($entry));
    $tl->MapWindow;
    return;
}

package main;
use strict;

my $gotone = 0;
my $appno;
for ($appno=0;$appno<10;$appno++) {
    my $file = $ENV{'HOME'}.'/.snmp/.mibbrowser'.sprintf('%02d',$appno);
    if (-r $file) {
	if ((my $hash = Storable::lock_retrieve($file))) {
	    my $app = MyTop->new($file,$appno);
	    my $appdata = $app->{'data'};
	    $app->reconstruct($hash);
	    $appdata->{'filename'} = $file;
	    $app->{'dirty'} = 'no';
	    $gotone = 1;
	}
    }
}

MyTop->new unless $gotone;

Tk::MainLoop;

exit;

1;

# vim: ft=perl sw=4
